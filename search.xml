<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大家好</title>
    <url>/zh-CN/2018/12/22/%E5%A4%A7%E5%AE%B6%E5%A5%BD/</url>
    <content><![CDATA[<div align="right">Language:
    <a href="/2018/12/22/hello-world"><kbd>English</kbd></a>
    <a href="/zh-CN/2018/12/22/大家好"><kbd>中文</kbd></a>
</div>

<hr>
<p><strong>大家好！这里是我的第一篇博文！</strong>我猜你会看到这里的唯一原因是你太闲了😉</p><div><sub><sub><sup><sup>也可能是除了这个我啥也没写</sup></sup></sub></sub></div><p></p>
<hr>
<p>OK，我终于独立于那些恶心的C*DN等中文博客网站建立了自己可爱的博客。完美。</p>
<p>我建立博客1️⃣是为了<strong>记录我的学习心得</strong>（我发现在博客立Flag能强迫我继续学下去不然我可能就摸了。）也可能看心情写点随笔。在当今这个知识碎片满天飞的时代这真的是一种很好的整理方式。另一个很重要的原因是2️⃣我想安利一些我觉得很nb的东西。安利使我快乐。</p>
<p>希望日后的我能谨记初衷。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历</title>
    <url>/zh-CN/2018/12/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p><strong>前言</strong> ：博主是个不怎么懂软件的菜鸟，前几天为了学习Soft Robotics企图装一个带SoftRobots插件的SOFA，但我搜了半天也没有较新的安装教程（连下载方式都变了好吗）。虽然有官网的安装教程但我在安装过程中还是出了很多意外。感慨于在身边诸多大佬们的帮助下我这个对软件一窍不通的人才安装成功，我以一个不怎么接触编程的人的角度写下这篇博客帮助也想学习Soft Robotics的各位。(博主为了写这篇教程忍痛把安好的SOFA删了又下了一遍）</p>
<a id="more"></a>
<p><strong>P.S.</strong> 由于我并不是软件相关专业的有很多理解和做法可能并不准确，仅供参考，也欢迎指教。</p>
<p><strong><em>教程仍然是跟着<a href="https://project.inria.fr/softrobot/" target="_blank" rel="noopener">SOFT ROBOTS Plugins for SOFA官网</a>来的，顺序有些许调整，要更详细一些。</em></strong></p>
<p>官网教程是<a href="https://project.inria.fr/softrobot/install-get-started-2/download/" target="_blank" rel="noopener">这个</a>，<a href="https://project.inria.fr/softrobot/install-get-started-2/building-on-windows/" target="_blank" rel="noopener">这个</a>和<a href="https://www.sofa-framework.org/community/doc/getting-started/build/windows/" target="_blank" rel="noopener">这个</a></p>
<p>实际上开发SoftRobots插件的项目组也考虑到要装这个软件太麻烦了，提供了<a href="https://softroboticstoolkit.com/sofa/plugin" target="_blank" rel="noopener">一个已经嵌入了SOFA的Ubuntu虚拟机映像</a>,但这个下载链接无效了。不过据说给项目组发邮件的话回复很快。此处为了运行速度和想安在Windows系统下偏向虎山行。</p>
<h1 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h1><p>要下一个SOFA，首先你得下一堆东西…</p>
<p><code>建议各位看完每一个小节下的内容再操作，有的提供不止一种方法</code></p>
<h2 id="Visual-Studio2015或以上版本"><a href="#Visual-Studio2015或以上版本" class="headerlink" title="Visual Studio2015或以上版本"></a>Visual Studio2015或以上版本</h2><blockquote>
<p>利用其中的<strong>MSVC编译器</strong>来编译本软件，只需要用到基础功能。</p>
</blockquote>
<p>建议安装<strong>VS2017 community</strong>版，安装可以参考<a href="https://blog.csdn.net/qq_36556893/article/details/79430133" target="_blank" rel="noopener">这个</a></p>
<h3 id="pthread库"><a href="#pthread库" class="headerlink" title="pthread库"></a><span id="pthread">pthread库</span></h3><blockquote>
<p>博主在Cmake时曾因缺少这个库报错。这是<strong>一个实行了POSIX线程标准的线程库</strong>，Windows下的pthreads-win32是从类Unix系统移植来的。</p>
</blockquote>
<p>或许你可以先跳过这一步，如果你也遇到了这个报错再安装也不迟。安装参考<a href="https://blog.csdn.net/cry1994/article/details/79115394?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">这个</a>。单纯安装后博主也遇到了左边链接中提到的 <strong>“timespec”:“struct”类型重定义</strong> 问题，因此建议加上那个宏定义。</p>
<h2 id="Qt-版本-gt-5-5-0"><a href="#Qt-版本-gt-5-5-0" class="headerlink" title="Qt (版本>= 5.5.0)"></a>Qt (版本&gt;= 5.5.0)</h2><blockquote>
<p>我猜这个是用来绘制SOFA的图形界面的</p>
</blockquote>
<p>官网提供的下载链接是<a href="http://download.qt.io/official_releases/online_installers/" target="_blank" rel="noopener">这个</a>,选择<em>qt-unified-windows-x86-online.exe<em>，是在线安装包。你也可以安装<a href="https://download.qt.io/official_releases/qt/5.11/5.11.1/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">离线安装包</a>,选择</em>qt-opensource-windows-x86-5.11.1.exe</em>.
安装可以参考<a href="https://www.cnblogs.com/chenmingjun/p/8392713.html" target="_blank" rel="noopener">这个</a></p>
<p>但实际上，只是为了安装SOFA的话，
<img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/qt.jpg" alt="Qt组件">
只需要如上图这个<strong>MSVC 2017 64-bit</strong>组件(博主当初不知道，把Qt5.11.1和Tools下所有东西都装了，下死我了)</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><blockquote>
<p>接下来下载SOFA源代码，SoftRobots插件源代码，vcpkg等都要用到这个高级百*云</p>
</blockquote>
<p>安装和使用教程可以参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">廖雪峰老师的Git教程</a></p>
<h2 id="Boost-版本-gt-1-54-0"><a href="#Boost-版本-gt-1-54-0" class="headerlink" title="Boost (版本>= 1.54.0)"></a>Boost (版本&gt;= 1.54.0)</h2><blockquote>
<p>Boost是一个影响甚大，应用广泛的C++库（SOFA基于C++）</p>
</blockquote>
<p>在大佬的推荐下博主并没有直接安装Boost，而是安装了<strong>一个面向VS的开源C++库集成器<em>Vcpkg</em></strong>,通过Vcpkg傻瓜式安装了Boost。Vcpkg的安装和使用教程参考<a href="https://blog.csdn.net/cjmqas/article/details/79282847" target="_blank" rel="noopener">这个</a>。</p>
<p>然后Boost的安装就很轻松愉快了：在Vcpkg.exe所在文件夹shift+右键点击<strong>在此处打开powershell</strong>，在powershell中</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#x64平台的电脑输入</span></span><br><span class="line">.\vcpkg.exe install Boost:x64-windows</span><br><span class="line"><span class="comment">#x86平台的电脑输入</span></span><br><span class="line">.\vcpkg.exe install Boost:x86-windows</span><br></pre></td></tr></tbody></table></figure>

<p>截至写博客时，通过这种方法下载下来的是Boost1.68.0</p>
<p><strong>P.S.</strong>当然你也可以直接安装Boost。实际上这样可能更容易让Cmake找到Boost，博主通过Vcpkg安装的Boost需要手动让Cmake找到，<a href="#Boost">见编译部分</a>。</p>
<h2 id="Python-2-7"><a href="#Python-2-7" class="headerlink" title="Python 2.7"></a>Python 2.7</h2><blockquote>
<p>我们所必须的SoftRobots插件很大程度上依赖于SofaPython插件，另外有了SoftPython插件SOFA才可以识别“.py”,”.pyscn”扩展名的文件。SofaPython插件是默认安装的，前提是你有Python2.7。</p>
</blockquote>
<p><code>注意，要成功安装SofaPython插件必须用Python2.7，不能使用Python3，否则生成Makefile时会出错。(血泪亲测)</code></p>
<p>因为博主之前为Python这个博主唯一接触过一点的语言下了<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a>,于是博主试图用在Anaconda中激活的一个Python2.7环境来满足条件，但博主尝试了许久也无法让Cmake找到我这个2.7的Python，他只找到了在我Anaconda根目录的Python3.5…</p>
<p>因此我为了安装SOFA专门下了一个<a href="https://www.python.org/downloads/release/python-2715/" target="_blank" rel="noopener">Python2.7.15</a>(截至写博客时最新版Python2.7.x)。x64平台电脑下载<strong>Windows x86-64 MSI installer</strong>，x86平台电脑下载<strong>Windows x86 MSI installer</strong>。如果图省事一路默认选项安装即可（是的博主甚至安到了C盘）</p>
<br>

<p><strong>好的，有了以上这些我们可以开始下载SOFA了</strong></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="SOFA源代码下载"><a href="#SOFA源代码下载" class="headerlink" title="SOFA源代码下载"></a>SOFA源代码下载</h2><p>SOFA官网提供稳定版（v18.06）和不稳定版。一开始博主下了稳定版，一秒下载两秒安装，那叫一个爽。但不幸的是<span style="color:red;">要安装SoftRobots插件的话只能安装不稳定版</span>。刺激。</p>
<p>找一个你认为适合安装SOFA的文件夹（博主安装在了D盘根目录），此处打开powershell，输入</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/sofa-framework/sofa.git sofa/src/</span><br></pre></td></tr></tbody></table></figure>

<p>然后你可以去看一集番。因为Github的鬼屎速度303.37MiB左右博主下了二十几分钟。</p>
<p>下好之后在<strong>sofa/</strong>文件夹下新建一个<strong>build</strong>文件夹一会放runsofa.sln和编译好的软件用。</p>
<h2 id="补充的库下载"><a href="#补充的库下载" class="headerlink" title="补充的库下载"></a>补充的库下载</h2><p>需要额外下载四个库<strong>libPNG, libJPEG, libTIFF, Zlib, Glew</strong>.VS2015用户下载<a href="https://www.sofa-framework.org/download/WinDepPack/VS-2015/latest" target="_blank" rel="noopener">这个</a>，VS2017用户下载<a href="https://www.sofa-framework.org/download/WinDepPack/VS-2017/latest" target="_blank" rel="noopener">这个</a>。直接将解压出来的<strong>include，lib，licenses</strong>三个文件夹放到 <strong>sofa/src/</strong> 文件夹下就可以了。</p>
<h2 id="SoftRobots插件源代码下载"><a href="#SoftRobots插件源代码下载" class="headerlink" title="SoftRobots插件源代码下载"></a>SoftRobots插件源代码下载</h2><p>进入<strong>sofa/src/applications/plugins</strong>文件夹，此处打开powershell，输入</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/SofaDefrost/SoftRobots</span><br></pre></td></tr></tbody></table></figure>

<p>这一次17.52MiB博主下了十分钟。(What?!)</p>
<p>实际上除了SoftRobots，项目组还提供了一个插件<a href="https://project.inria.fr/softrobot/install-get-started-2/download/" target="_blank" rel="noopener">SoftRobots.Inverse</a>,但这个插件目前不向公众开发。有兴趣的话各位可以发邮件给项目组，下载来试试。</p>
<p><em>别忘记将刚下的<strong>HIDAPI</strong>放进去</em></p>
<h1 id="生成runsofa-sln"><a href="#生成runsofa-sln" class="headerlink" title="生成runsofa.sln"></a>生成runsofa.sln</h1><p>然后就可以点开CMake图形界面了，做好多次报错的心理准备。</p>
<blockquote>
<p>博主推荐先修改一下设定，打开<code>Options</code>下的<strong>Warning Messages…</strong>,像下面这样勾选抑制警告的两项，关掉可能很多条，干扰视线而不影响Cmake的Warning提示，有利于稍后更容易地找出报错原因。</p>
</blockquote>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/warning.jpg" alt="Warning设置"></p>
<p>首先在<em>where is the source code</em>一栏填上你的<strong>sofa/src</strong>的地址，在<em>where to build the binaries</em>一栏填上你的<strong>sofa/build</strong>的地址，然后点击<code>Configure</code>。
<img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/cmake.jpg" alt="CMake地址"></p>
<p>然后为项目选择你将要使用的编译器，向下面这样选择。
<img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/compiler.jpg" alt="选择编译器"></p>
<p>P.S.虽然官网教程有提及可以使用<strong>Ninja</strong>来代替此处的选择，但我没研究出怎么使用，此处仍然选择VS的<strong>MSVC</strong>编译器。</p>
<blockquote>
<p>第一次Configure用时较长，，尤其是可能在<strong>Cloning into ‘SofaHighOrder’…</strong>一行停留许久。你可以稍微歇息一下</p>
</blockquote>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/error.jpg" alt="报错"></p>
<p>然后是频繁出现地报错。</p>
<p>但不用担心，Configure这个操作本来就是要多次进行来逐渐更正错误，甚至可以在此期间调整要安装的插件。经过我的观察Generate多次也没有问题，只会在原本的基础上改动，不会出现重复的文件。因此放心大胆地来，每次你觉得修正了几个问题了就可以运行一次Configure。经过博主摸索发现了两种找报错原因的方式</p>
<ul>
<li>直接看<code>Configure</code>和<code>Generate</code>两个按键下面的信息框里的报错信息</li>
<li><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/checkerror.jpg" alt="看报错信息方式1"></li>
<li>打开在<strong>sofa/src/build/CMakeFiles/</strong>下的<em>CMakeError.log</em>（错误日志）。这个日志会记录你在Cmake过程中所有的报错 (包括每一次Configure的报错)。我的经验是错误原因通常在”<strong>生成失败。</strong>“这句话附近。如果有多个错误，一个一个耐心解决。</li>
</ul>
<h2 id="SOFA本体Configure过程中遇到的一些报错及解决"><a href="#SOFA本体Configure过程中遇到的一些报错及解决" class="headerlink" title="SOFA本体Configure过程中遇到的一些报错及解决"></a>SOFA本体Configure过程中遇到的一些报错及解决</h2><p>以下是博主在Cmake过程中遇到的一些报错及博主的解决方式。</p>
<h3 id="fatal-error-C1083-无法打开包括文件-“pthread-h”-No-such-file-or-directory"><a href="#fatal-error-C1083-无法打开包括文件-“pthread-h”-No-such-file-or-directory" class="headerlink" title="fatal error C1083: 无法打开包括文件: “pthread.h”: No such file or directory"></a>fatal error C1083: 无法打开包括文件: “pthread.h”: No such file or directory</h3><p>好的，如果你出了这个报错说明你刚刚没有安装<a href="#pthread">推荐你安的pthread库</a>，让你懒哈哈哈哈哈</p>
<p>不过即便安装pthread库后在<em>CMakeError.log</em>中仍然会有pthread相关报错。但不会影响SOFA的安装，可以忽略。</p>
<h3 id="Unable-to-find-the-Boost-header-files"><a href="#Unable-to-find-the-Boost-header-files" class="headerlink" title="Unable to find the Boost header files"></a><span id="Boost">Unable to find the Boost header files</span></h3><p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/Boosterror.png" alt="Boost报错"></p>
<p>如果你得到了类似这样的报错信息那你大概是像博主一样利用Vcpkg安装的Boost，Cmake没能找到你的Boost。(我错了，下次还犯)但用Vcpkg安装Boost真的很容易。Cmake给出了提示：</p>
<h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/addEntry.png" alt="添加Entry"></p>
<p>点击<code>Add Entry</code>按键添加一个下面这样的Entry。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Boost_ROOT</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td><strong>path</strong></td>
</tr>
<tr>
<td>Value</td>
<td><strong>你安装Vcpkg的文件夹/vcpkg/installed/x64-windows/include</strong>(比如博主的是<em>D:\vcpkg\installed\x64-windows\include</em>)</td>
</tr>
<tr>
<td>Description</td>
<td>空</td>
</tr>
</tbody></table>
<br>
注意Value不能填<b>你安装Vcpkg的文件夹/vcpkg/installed/x64-windows/include/boost</b>,需要填包含Boost文件夹的文件夹的路径，否则仍然会像上图那样报错。

<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>在环境变量中添加一个下面这样的系统变量</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>Boost_ROOT</td>
<td><strong>你安装Vcpkg的文件夹/vcpkg/installed/x64-windows/include</strong>(比如博主的是<em>D:\vcpkg\installed\x64-windows\include</em>)</td>
</tr>
</tbody></table>
<h3 id="sofa-src-applications-plugins-SofaHighOrder-ExternalProjectConfig-cmake-in-does-not-exist"><a href="#sofa-src-applications-plugins-SofaHighOrder-ExternalProjectConfig-cmake-in-does-not-exist" class="headerlink" title="sofa/src/applications/plugins/SofaHighOrder/ExternalProjectConfig.cmake.in does not exist."></a>sofa/src/applications/plugins/SofaHighOrder/ExternalProjectConfig.cmake.in does not exist.</h3><p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/lackCMake.png" alt="缺少CMake.in文件"></p>
<p>有可能当添加SofaHighOrder的子目录EXTERNAL的时候会发生这样的报错，有时候又不会发生。我怀疑<em>ExternalProjectConfig.cmake.in</em>这个文件特别容易丢包。但解决很容易，博主在前面下载SOFA源码的Github仓库里找到了这个<a href="https://github.com/sofa-framework/sofa/tree/master/applications/plugins/SofaHighOrder" target="_blank" rel="noopener">ExternalProjectConfig.cmake.in</a>你说神不神奇。把这个文件下载下来放到<b>sofa/src/applications/plugins/SofaHighOrder/</b>文件夹下即可。(其实博主不知道怎么下这个文件，就在sofa/src/applications/plugins/SofaHighOrder/文件夹下新建了一个ExternalProjectConfig.cmake.in并把Github上该文件里的内容复制粘贴了进去)</p>
<p>在运行到SofaHighOrder这部分的时候你可能会碰到像下面这样的乱码，但不要紧，再Configure几次就没有了。</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/messycode.png" alt="乱码"></p>
<h3 id="找不到Python"><a href="#找不到Python" class="headerlink" title="找不到Python"></a>找不到Python</h3><p>博主为此专门下了一个Python2.7。</p>
<p><code>你需要在搜索框中搜索Python以确保你确实添加上了SofaPython插件</code>。即便你单独下好了Python2.7你也可能需要手动勾选SofaPython选项（勾选前Enter列表中<strong>SofaPython_DIR</strong>显示找不到SofaPython，但你手动添加这个插件的话其实他找得到）</p>
<h3 id="找不到Qt"><a href="#找不到Qt" class="headerlink" title="找不到Qt"></a>找不到Qt</h3><p>类似找不到Boost的解决办法，点击<code>Add Entry</code>,添加一个下面这样的Entry</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>CMAKE_PREFIX_PATH</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td><strong>path</strong></td>
</tr>
<tr>
<td>Value</td>
<td><strong>你安装Qt的文件夹/Qt/5.11.1/msvc2017_64</strong>(比如博主的是<em>D:/Qt/5.11.1/msvc2017_64</em>)</td>
</tr>
<tr>
<td>Description</td>
<td>空</td>
</tr>
</tbody></table>
<p>再次运行Configure后刚添加的这个叫CMAKE_PREFIX_PATH的Entry会消失，取而代之的是一帮Qt的Entry</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/QtEntry.png" alt="那堆Qt的Entry"></p>
<p><strong>以上便是博主安装SOFA本体过程中遇到过的报错，如果你遇到了别的无法解决的报错也欢迎讨论</strong></p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/noError.png" alt="无误反馈信息">
这是博主在加装SoftRobots插件前得到的无误的反馈信息。并且你会发现本来一片红色的Entry列表此时全都是白/灰这种看起来就很OK的颜色。(如果还有红色的请再Configure一次。这之后如果还有，忽略)</p>
<p>在此之前，在搜索框里输入python并确保你的<strong>PLUGIN_SOFAPYTHON</strong>打了勾，<strong>SofaPython_DIR</strong>不是not found</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/checkPython.png" alt="确认SofaPython"></p>
<p>这样SOFA软件本体的安装就没有问题了，接下来添加SoftRobots插件(现在你在搜索框查找SoftRobots是什么也查不到的)。</p>
<h2 id="添加SoftRobots插件"><a href="#添加SoftRobots插件" class="headerlink" title="添加SoftRobots插件"></a>添加SoftRobots插件</h2><blockquote>
<p>博主一开始没看到正规添加SoftRobots插件的方法，手足无措下自行修改了SOFA的CMakeList.txt文件安上的…(狗屎英语教程)</p>
</blockquote>
<p>正规方法是在搜索框搜索<strong>SOFA_EXTERNAL_DIRECTORIES</strong>，找到这个Entry并将Value填为<strong>你安装SOFA的文件夹/sofa/src/applications/plugins/SoftRobots</strong>(比如博主的是<em>D:/sofa/src/applications/plugins/SoftRobots</em>)，</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/softRobotEntrry.jpg" alt="SoftRobots相关Entry"></p>
<p>再次Configure，你就得到了与SoftRobots相关的几个Entry。不勾选这几个可选组件orz博主研究了很久也没能成功安装他们。根据名字和需要的库博主猜测<strong>SOFTROBOTS_GAMETRAKCONTROLLER</strong>是一个实现可以通过usb设备或蓝牙和外设交互的组件，<strong>SOFTROBOTS_COMMUNICATIONCONTROLLER</strong>似乎是实现利用网络通信和外设交互的组件，而<strong>SOFTROBOTS_ROBOTINOCONTROLLER</strong>猜测需要配合<strong>Robotino</strong>使用。<strong>Robotino</strong>是一款商业化的移动机器人系统，明显买不起。博主暂时不需要这个插件。</p>
<p>再次Configure。</p>
<p>完美。</p>
<p>这是博主最终的无误版<strong>Configure</strong>的反馈信息。</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/reaction.png" alt="最终版反馈信息"></p>
<p>现在安装已经接近尾声了(步骤方面，时间方面还得要一会)，你可以选择性的再安装几个部件。(报错了的话就放弃吧哈哈哈哈哈)给出官网上<a href="https://www.sofa-framework.org/community/doc/getting-started/build/build-options/" target="_blank" rel="noopener">相关网页</a>以供参考。</p>
<p>当你对Configure的结果感到满意后，<code>Generate</code>，点击！</p>
<p><code>注意，编译完成之前暂时先不要关闭CMake界面，否则可能编译失败</code></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><blockquote>
<p>你可以睡前来做这个</p>
</blockquote>
<p>进入<strong>sofa/build/</strong>,用VS打开<em>Sofa.sln</em>,经过一段令人尴尬的等待，</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/howtocompile.png" alt="编译操作顺序"></p>
<p>进入界面后先将解决方案配置调为<strong>Release</strong>，然后确保解决方案平台确实是你电脑的平台(博主的电脑是x64平台)，等待左下角显示<strong>就绪</strong>后，点击<strong>本地Windows调试器</strong>开始编译。</p>
<p>然后你就可以去睡觉了。(即便你想用电脑做点别的应该也很难，不知道是我人品太差还是SOFA的编译真的很考验电脑，我的电脑呈现出了这样的尴尬局面 )</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/mess.png" alt="编译车祸现场"></p>
<p>第二天(博主的电脑编译了两个多小时)，你会看到一个无法打开ALL_BUILD的报错，这是正常现象，无须在意。</p>
<p><code>如果你没有看到其他报错，恭喜你编译成功了!</code></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>现在就可以来测试一下软件是否真的安装成功了。进入<strong>sofa/build/bin/release/</strong>，运行<em>rensofa.exe</em>,会进入这个蛇绕柱子的Demo。</p>
<p><img src="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/demo.jpg" alt="Demo"></p>
<p>你可以通过打开在SoftRobots下的几个Example来进一步测试。可以参考官网给出的<a href="https://project.inria.fr/softrobot/install-get-started-2/tutorial/" target="_blank" rel="noopener">样例教程</a>。或者你也可以探索SOFA官网上的<a href="https://www.sofa-framework.org/community/doc/getting-started/tutorials/" target="_blank" rel="noopener">入门教程</a>。</p>
<br>

<p><strong>至此，本次在Win10下安装SOFA仿真软件并加装SoftRobots插件的任务便完成了。</strong></p>
<p><strong>恭喜你能坚持安装完成，也祝你接下来的研究顺利。</strong></p>
<br>
<br>

<blockquote>
<p>顺带一提，电子科大微软学生俱乐部真是个好地方，里面人才又多，说话又好听</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>配置VSCode中调试C/C++环境</title>
    <url>/zh-CN/2018/12/30/%E9%85%8D%E7%BD%AEVSCode%E4%B8%AD%E8%B0%83%E8%AF%95C-C-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<div align="right">Language:
<a href="/2018/12/30/Configure-C-C-environment-in-VSCode"><kbd>English</kbd></a>
<a href="/zh-CN/2018/12/30/配置VSCode中调试C-C-环境"><kbd>中文</kbd></a>
</div>

<p>这里是为我在VSCode插件市场发布的
<a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.ccpp-extension-pack" target="_blank" rel="noopener">C/C++扩展包</a>
写的Windows下VSCode中C/C++配置教程<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span></p>
<a id="more"></a>

<p>实际上在<a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank" rel="noopener">VSCode的说明文档中C++部分</a>
对如何配置环境有十分详细的说明, 本文仅是对其的部分整理和解读<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span> 因此如果你的能力足够看官方文档当然是更好的选择<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8">👍</span></p>
<p>P.S.其实只要右键翻译成中文我觉得不难懂…</p>
<ol>
<li><a href="#准备工作">准备工作</a><ol>
<li><a href="#编译器">编译器</a><ol>
<li><a href="#安装">安装</a></li>
<li><a href="#添加至Path">添加至Path</a></li>
<li><a href="#测试">测试</a></li>
</ol>
</li>
<li><a href="#VSCode插件">VSCode插件</a></li>
</ol>
</li>
<li><a href="#配置文件">配置文件</a><ol>
<li><a href="#配置IntelliSense">配置IntelliSense</a></li>
<li><a href="#配置编译配置文件">配置编译配置文件</a><ol>
<li><a href="#合起来">合起来!</a></li>
</ol>
</li>
<li><a href="#配置调试配置文件">配置调试配置文件</a><ol>
<li><a href="#调试对象">调试对象</a></li>
<li><a href="#Debugger路径及选项">Debugger路径及选项</a></li>
<li><a href="#启动前编译">启动前编译</a></li>
<li><a href="#合起来-1">合起来!</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#Enjoy">Enjoy</a></li>
</ol>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>VSCode本身只是一个编辑器, 也就是一个记事本, 是不包含编译器的. 即便我们安装了cpptools
这个扩展, 他也并没有为我们安装编译器 (如果你想看看cpptools这个扩展里都有什么可以前往自己电脑的 <strong>%HOMEPATH%\.vscode\extensions</strong>, 找到<strong>ms-vscode.cpptools</strong> 去看看)</p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>因此第一步我们需要安装编译器. 编译器不止一家, 在VSCode官方文档中推荐的是:</p>
<ul>
<li><p>Windows平台: <a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="noopener">MinGW-w64</a></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 要注意另有一个叫MinGW的东西, 虽然功能差不多, 但那个已经很久没更新了,
安装没MinGW-w64容易, 还不是官宣, 因此不推荐. 后面所说的MinGW实际指的是MinGW-w64, 我只是懒得打那么多字了</p>
</li>
<li><p>macOS: <a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">clang</a></p>
</li>
<li><p>Linux: <a href="https://gcc.gnu.org/" target="_blank" rel="noopener">gcc</a></p>
</li>
</ul>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>因为我没钱买Mac, 暂时也没需求在Linux配置VSCode, 本文仅针对<strong>Windows</strong>
平台, 当然也可以作为其他平台的参考. 甚至<a href="https://pimylifeup.com/raspberry-pi-visual-studio-code/" target="_blank" rel="noopener">有人在树莓派安装VSCode</a>.</p>
<p>P.S. 实际上编译器的选择并不是个令人头疼的事, 我们随时可以轻易的更换VSCode使用的编译器</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>将MinGW-w64下载下来之后点击安装, 以下几点要注意, 其余选项默认即可:</p>
<ul>
<li><p>安装向导第一页有一项是选择<code>Architecture</code> (即电脑的架构, 此处i386代指32位电脑,
x86_64代指64位电脑), 此处选择<strong>x86_64</strong>. (当然如果你的电脑竟然是32位的话不用变)</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 如何查看自己电脑是32位还是64位?</p>
<p>Windows10的话, 前往 <strong>设置</strong> &gt; <strong>系统</strong> &gt; <strong>关于</strong> &gt; <strong>设备规格</strong> &gt; <strong>系统类型</strong></p>
<p>其他Windows的话上网搜索一下好啦 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8">😉</span></p>
</li>
<li><p>安装在哪里都可以, 但一定要是你找得到的地方, 因为安装完成后还要手动将MinGW加入<strong>Path</strong>.</p>
</li>
</ul>
<h3 id="添加至Path"><a href="#添加至Path" class="headerlink" title="添加至Path"></a>添加至Path</h3><p>安装完毕后我们需要将MinGW添加至<strong>Path</strong>, 这样我们通过命令行就可以调用它啦 (VSCode编译/调试
C/C++程序实际上就是在内置命令行中调用MinGW)</p>
<p>要将什么路径添加到<strong>Path</strong>呢? 因为添加到Path的路径是要调用的程序的exe文件所在的文件夹比如我将MinGW安装到了 <strong>D:\Softwares\mingw-w64\x86_64-8.1.0-posix-seh-rt_v6-rev0</strong>
这个文件夹下, 那么我将
<strong>D:\Softwares\mingw-w64\x86_64-8.1.0-posix-seh-rt_v6-rev0\mingw64\bin</strong>加入环境变量.
你会看到我们将要调用的<code>gcc</code>和<code>gdb</code>两个程序正在其中.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> 关于如何添加系统变量, <a href="https://jingyan.baidu.com/article/ca41422f17107a1eaf99ed64.html" target="_blank" rel="noopener">这篇百度知道</a>应该就够了</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这之后! 我们测试一下, 在命令行输入<code>gcc</code></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 你看到的应当是:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\LeoJh&gt;gcc</span><br><span class="line">gcc: fatal error: no input files</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></tbody></table></figure>

<p>这是说gcc被成功唤起,我们已经成功完成编译器的配置了, 但你没告诉它要编译的文件路径, 所以他就报错了.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span>而如果你看到的是:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\LeoJh&gt;gcc</span><br><span class="line">'gcc' 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br></pre></td></tr></tbody></table></figure>

<p>这是说无法从命令行调用gcc. 一种情况是没有把正确的路径加入<strong>Path</strong>, 另一种情况是该换电脑了
<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span></p>
<h2 id="VSCode插件"><a href="#VSCode插件" class="headerlink" title="VSCode插件"></a>VSCode插件</h2><p>搞定了编译器我们就离完成不远了! 实际上你现在已经可以开始开发C/C++了, 只不过是硬核一些.
不信你可以搓一段hello world放进一个.c文件, 比如<strong>test.c</strong>, 在该文件所在文件夹空白处按住<code>shift</code>同时按右键, 在此打开powershell, 输入<code>gcc test.c</code>, 然后你就会发现文件夹里多了一个<strong>a.exe</strong>. 这便是编译好的可执行文件了!</p>
<p>但这样无论是编辑还是编译还是调试体验都太差了, 于是我们安装一些好用的扩展提高效率.</p>
<p>因为我并不常在VSCode中编写C/C++, 因此<a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.ccpp-extension-pack" target="_blank" rel="noopener">我的扩展包</a>
中并没有几个插件. 但我认为这几个很不错的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<p>当然你看不上我的扩展包也没事<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>只需要安装了<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">官方C/C++支持扩展</a>
就能体验到很强大的支持了.</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>在有些教程中, 要在VSCode中开发C/C++需要配置<code>c_cpp_properties.json</code>, <code>tasks.json</code>,
<code>launch.json</code>三样, 但现在不是这样了! 🎉 现在<code>c_cpp_properties.json</code>已经完全被
<code>settings.json</code>取代了, 也就是说在设置中就可以进行原来在<code>c_cpp_properties.json</code>中进行的配置! 这样的好处是我们可以针对不同的工作区进行不同的设置等. 另外, 稍后你也会看到随着VSC的更新<code>tasks.json</code>和<code>launch.json</code>的生成也变得十分简单!</p>
<p>🔗 关于设置取代了<code>c_cpp_properties.json</code>的说明参见<a href="https://github.com/Microsoft/vscode-cpptools/blob/master/Documentation/LanguageServer/Customizing%20Default%20Settings.md" target="_blank" rel="noopener">这里</a>,
另外给出对原本可以在<code>c_cpp_properties.json</code>中配置的内容的描述的<a href="https://github.com/Microsoft/vscode-cpptools/blob/master/Documentation/LanguageServer/c_cpp_properties.json.md" target="_blank" rel="noopener">链接</a></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 以下配置文件内容都以我的配置文件为例</p>
<h2 id="配置IntelliSense"><a href="#配置IntelliSense" class="headerlink" title="配置IntelliSense"></a>配置IntelliSense</h2><p>正如前面所说, 我们不需要VSCode就可以编译/调试C/C++, 因此能够提供智能补全功能的
IntelliSence是<strong>cpptools</strong>这个插件很重要的一部分, 通过在<code>settings.json</code> (原本是
<code>c_cpp_properties.json</code>)中进行设置来设定IntelliSense的模式. 主要设置以下几个:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"C_Cpp.autocomplete": "Default",</span><br><span class="line">"C_Cpp.clang_format_style": "{ BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Allman, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 0, AccessModifierOffset: -4 }",</span><br><span class="line">"C_Cpp.clang_format_fallbackStyle": "{ BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Allman, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 0, AccessModifierOffset: -4 }",</span><br><span class="line">"C_Cpp.default.compilerPath": "D:\\Softwares\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin\\gcc.exe",</span><br><span class="line">"C_Cpp.default.cStandard": "c99",</span><br><span class="line">"C_Cpp.default.cppStandard": "c++11",</span><br><span class="line">"C_Cpp.default.intelliSenseMode": "gcc-x64",</span><br><span class="line">"C_Cpp.intelliSenseEngine": "Default",</span><br><span class="line">"C_Cpp.errorSquiggles": "Enabled",</span><br></pre></td></tr></tbody></table></figure>

<p>💡 其中<strong>C_Cpp.clang_format_style</strong>, <strong>C_Cpp.clang_format_fallbackStyle</strong>是VSC格式化C/C++代码的风格.
上面的配置是近似于<strong>Visual Studio</strong>格式化C/C++代码的风格.
我偏爱VS风格, 而如果你喜欢Google风格, 可以用下面这个值:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"C_Cpp.clang_format_style": "{BasedOnStyleStyle: Google, IndentWidth: 4}",</span><br><span class="line">"C_Cpp.clang_format_fallbackStyle": "{BasedOnStyleStyle: Google, IndentWidth: 4}",</span><br></pre></td></tr></tbody></table></figure>

<p>随着VSC的更新, VSC提供了一些<code>tasks.json</code>和<code>launch.json</code>的模板, 这让生成这两个文件变得十分容易!
下面这个gif👇 是一个生成<code>tasks.json</code>和<code>launch.json</code>的示例.</p>
<p><img src="%E9%85%8D%E7%BD%AEVSCode%E4%B8%AD%E8%B0%83%E8%AF%95C-C-%E7%8E%AF%E5%A2%83/example.gif" alt=""></p>
<p>💡 这个gif是在Linux系统 (Ubuntu) 下录制的.</p>
<p>下面则是对这两个文件内容的一些解释.</p>
<h2 id="配置编译配置文件"><a href="#配置编译配置文件" class="headerlink" title="配置编译配置文件"></a>配置编译配置文件</h2><p>然后配置编译用的<code>tasks.json</code>.</p>
<p>✔️ 这个文件和之后配置的<code>launch.json</code>都是针对特定程序的,
如何生成这两个文件请参见VSCode官方文档. 但你可以将满意的<code>tasks.json</code>和<code>launch.json</code>放在一个包含许多工程的目录中, 那么这些工程都将使用这两个配置文件. 如果你想给这之中某个工程配置不同的配置你可以在这个工程的根目录另外生成<code>tasks.json</code>和<code>launch.json</code>, 会覆盖上一层的配置.</p>
<p>当你跟随VSCode官方文档创建了一个 <code>tasks.json</code> 之后, 将下面这个任务添加到tasks的列表,
至于自带的label为 <strong>echo</strong> 的任务你可以删掉或者不管他.</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="attr">"label"</span>: <span class="string">"Compile"</span>,</span><br><span class="line">   <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">   <span class="attr">"command"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">   <span class="attr">"args"</span>: [</span><br><span class="line">         <span class="string">"${file}"</span>,</span><br><span class="line">         <span class="string">"-o"</span>,</span><br><span class="line">         <span class="string">"${fileDirname}/${fileBasenameNoExtension}.exe"</span>,</span><br><span class="line">         <span class="string">"-g"</span>,</span><br><span class="line">         <span class="string">"-Wall"</span>,</span><br><span class="line">         <span class="string">"-std=c++17"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"group"</span>: {</span><br><span class="line">         <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">         <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>label</code>的意思是给这个任务取名为<strong>Compile</strong>, <a href="#启动前编译">稍后</a>会用到.</p>
<p>从中我们可以看出实际上当我们调用这个叫<strong>Compile</strong>的task的时候会在shell中输入:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gcc ${file} -o ${fileDirname}/${fileBasenameNoExtension}.exe -g -Wall -std=c++17</span><br></pre></td></tr></tbody></table></figure>

<p>其中<strong>${file}</strong>等是<a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener">VSCode中定义的变量</a></p>
<p><code>-o</code>选项使我们可以<a href="http://www.runoob.com/note/28613" target="_blank" rel="noopener">指定生成文件的名字</a></p>
<p>其他几个选项可以上网查查.</p>
<p><code>group</code>这里的配置是我们能通过快捷键 <code>Ctrl+shift+B</code>来执行该任务.
参见<a href="https://code.visualstudio.com/docs/editor/tasks#_typescript-hello-world" target="_blank" rel="noopener">这里</a></p>
<h3 id="合起来"><a href="#合起来" class="headerlink" title="合起来!"></a>合起来!</h3><p>因此我的 <code>tashs.json</code> 长这样:</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Compile"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"${file}"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"${fileDirname}/${fileBasenameNoExtension}.exe"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"-Wall"</span>,</span><br><span class="line">                <span class="string">"-std=c++17"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: {</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置调试配置文件"><a href="#配置调试配置文件" class="headerlink" title="配置调试配置文件"></a>配置调试配置文件</h2><p>最后配置的这个是<code>launch.json</code>. 实际上这很简单, 因为VSCode已经提供了很多种模板, 需要改动的非常少.</p>
<p>通常我们选择 <strong>(gdb) Launch</strong> 这种模板. Launch指的是要调试的程序是在开始调试时才开始运行,
Attach指的是开始调试时程序已经在运行了 (比如在服务器上的程序)</p>
<p>需要改动/添加的非常少:</p>
<h3 id="调试对象"><a href="#调试对象" class="headerlink" title="调试对象"></a>调试对象</h3><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"program": "${workspaceFolder}/a.exe"</span><br></pre></td></tr></tbody></table></figure>

<p><code>program</code>指的是要调试的程序. 如果不特别指出的话大多数编译器默认将编译出来的可执行文件命名为 <strong>a.exe</strong>. 而如果你的<code>tasks.json</code>也像我一样加了
“-o ${fileDirname}/${fileBasenameNoExtension}.exe” 这个选项的话, 将会生成和源文件同名的可执行文件, 因此要用:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"program": "${workspaceFolder}/${fileBasenameNoExtension}.exe"</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Debugger路径及选项"><a href="#Debugger路径及选项" class="headerlink" title="Debugger路径及选项"></a>Debugger路径及选项</h3><p>如果你在命令行输入 <code>gdb</code> 你会发现首先映入眼帘的是一串废话, 因此我们可以加上<code>-q</code>这个选项来让它少说废话.</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"miDebuggerPath": "gdb.exe",</span><br><span class="line">"miDebuggerArgs": "-q"</span><br></pre></td></tr></tbody></table></figure>

<h3 id="启动前编译"><a href="#启动前编译" class="headerlink" title="启动前编译"></a>启动前编译</h3><p>如果你担心自己忘记每次调试前先编译一遍已更改的代码 (不然你会哭出声响), 可以添加一个
<strong>preLaunchTask</strong>, 这个task指定为刚配置的那个<strong>Compile</strong>任务.
这样每次调试前程序都会被先编译一遍<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8">👍</span></p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"preLaunchTask": "Compile"</span><br></pre></td></tr></tbody></table></figure>

<h3 id="合起来-1"><a href="#合起来-1" class="headerlink" title="合起来!"></a>合起来!</h3><p>因此我的<code>launch.json</code>长这样:</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/${fileBasenameNoExtension}.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerPath"</span>: <span class="string">"gdb.exe"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerArgs"</span>: <span class="string">"-q"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                }</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"Compile"</span></span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy"></a>Enjoy</h1><p>这下我们可以轻松愉快的开发C/C++了! 祝各位水平日益提高<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>关于我的NexT主题博客的个性化配置以及遇到的一些问题</title>
    <url>/zh-CN/2019/01/07/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<div align="right">Language:
<a href="/2018/12/24/About-My-Custom-Settings-of-My-Next-Theme-Blog-and-Problem-Killing"><kbd>English</kbd></a>
<a href="/zh-CN/2019/01/07/关于我的NexT主题博客的个性化配置以及遇到的一些问题"><kbd>中文</kbd></a>
</div>

<a id="more"></a>

<!-- TODO -->

<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="更改配置后页面未出现变化"><a href="#更改配置后页面未出现变化" class="headerlink" title="更改配置后页面未出现变化"></a>更改配置后页面未出现变化</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">priority</a></p>
<h3 id="markdown中文换行导致的空格问题"><a href="#markdown中文换行导致的空格问题" class="headerlink" title="markdown中文换行导致的空格问题"></a>markdown中文换行导致的空格问题</h3><p>请看<a href="https://codehut.me/posts/Y3Vyc29yOjg=" target="_blank" rel="noopener">这里</a>，它完美解决了问题。我在<strong>themes/next/scripts/</strong>下放了一个<code>fuck_chinese_space.js</code>,里面正是上面这位老兄博文里写的：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">hexo.extend.filter.register(<span class="string">'after_render:html'</span>, fix);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fix</span>(<span class="params">str</span>) </span>{ <span class="keyword">return</span> str.replace(<span class="regexp">/([¡«·»¿;·՚-՟։׀׃׆׳-״؉-؊،-؍؛؞-؟٪-٭۔܀-܍߷-߹।-॥॰෴๏๚-๛༄-༒྅࿐-࿔၊-၏჻፡-፨᙭-᙮᛫-᛭᜵-᜶។-៖៘-៚᠀-᠅᠇-᠊᥄-᥅᧞-᧟᨞-᨟᭚-᭠᰻-᰿᱾-᱿\u2000-\u206e⳹-⳼⳾-⳿⸀-\u2e7e⺀-\u2efe\u3000-〾・㇀-\u31ee㈀-㋾㌀-㏾㐀-\u4dbe一-\u9ffe꘍-꘏꙳꙾꡴-꡷꣎-꣏꤮-꤯꥟꩜-꩟豈-\ufafe︐-︖︙︰-﹎﹐-﹒﹔-﹗﹟-﹡﹨﹪-﹫！-＃％-＇＊，．-／：-；？-＠＼｡､-･]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud800[\udd00-\udd01\udf9f\udfd0]|\ud802[\udd1f\udd3f\ude50-\ude58]|\ud809[\udc00-\udc7e]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e])\n\s*/g</span>, <span class="string">'$1'</span>); }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Google站点地图报错"><a href="#Google站点地图报错" class="headerlink" title="Google站点地图报错"></a>Google站点地图报错</h3><p><a href="https://alanlee.fun/2017/12/30/google-sitemap/" target="_blank" rel="noopener">这里</a></p>
<h3 id="如何建立多级分类"><a href="#如何建立多级分类" class="headerlink" title="如何建立多级分类"></a>如何建立多级分类</h3><p>参见<a href="http://aiellochan.com/2018/02/13/hexo/Hexo-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA-categories/" target="_blank" rel="noopener">这里</a></p>
<h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><h3 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h3><p><a href="https://www.ieclipse.cn/2016/06/02/other/tech-hexo-i18n/index.html" target="_blank" rel="noopener">参考1</a>
<a href="https://bambooom.github.io/2018/03/08/hexo-multi-lang/" target="_blank" rel="noopener">参考2</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Web</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>几个提高效率的小技巧</title>
    <url>/zh-CN/2019/01/18/%E5%87%A0%E4%B8%AA%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>记录和分享一些我觉得提高了自己效率的技巧。</p>
<a id="more"></a>

<h1 id="虚拟桌面分割任务"><a href="#虚拟桌面分割任务" class="headerlink" title="虚拟桌面分割任务"></a>虚拟桌面分割任务</h1><p>Windows有一个我觉得蛮有意思的功能, <strong>虚拟桌面</strong>. 按 <code>Windows+Tab</code> 或者点击任务栏上有个长得有点奇怪的图标可以打开<strong>任务视图</strong>, 然后可以新建桌面, 管理桌面. 通过把应用界面分别放到不同桌面可以让任务栏不会堆积很多页面. 有时候同时写多个项目的时候会用浏览器搜好几个主题 (是的我就是浏览器选手) 如果都放到一起太乱太多了, 因此放到不同桌面是个非常不错的选择. 我经常将娱乐的玩意, 什么网易云, 百度云之类放一个桌面, 然后一个项目放一个桌面, 心情愉悦让效率大大提高<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<h1 id="更改输入法符号"><a href="#更改输入法符号" class="headerlink" title="更改输入法符号"></a>更改输入法符号</h1><p>有时, 比如写中文文档时, 我们需要频繁切换中英文输入法, 而代码中打符号的时候我总是忘记切换成英文输入法, 打出万恶的中文字符, 比如；什么的. 而我发现快捷键 <code>Ctrl+.</code>可以只切换符号的中英文! 也就是说你可以在中文输入法下打出英文标点 (比如我的句号是英文句号). 这样就解决了中英文标点易混淆的烦恼<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<!-- TODO -->
<!-- chrom --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>当VSCode成为一种生活方式</title>
    <url>/zh-CN/2019/01/07/%E5%BD%93VSCode%E6%88%90%E4%B8%BA%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<div align="right">Language:
<a href="/2018/12/25/When-VSCode-Becomes-A-Lifestyle"><kbd>English</kbd></a>
<a href="/zh-CN/2019/01/07/当VSCode成为一种生活方式"><kbd>中文</kbd></a>
</div>

<!-- TODO -->

<p>VSCode是一款很强大的编辑器, 因为我现在的电脑性能不太好, 开规模很大的那些2IDE特别慢, 我很喜欢用VSCode. 而且用VSCode在某些方面确实能获得很不错的体验<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span> 本文算是VSCode
安利和我个人的使用技巧.</p>
<a id="more"></a>

<h1 id="Why-VSCode"><a href="#Why-VSCode" class="headerlink" title="Why VSCode"></a>Why VSCode</h1><h2 id="写Markdown"><a href="#写Markdown" class="headerlink" title="写Markdown"></a>写Markdown</h2><h2 id="写前端"><a href="#写前端" class="headerlink" title="写前端"></a>写前端</h2><h2 id="写小段代码"><a href="#写小段代码" class="headerlink" title="写小段代码"></a>写小段代码</h2><h3 id="写Python"><a href="#写Python" class="headerlink" title="写Python"></a>写Python</h3><h3 id="写C-C"><a href="#写C-C" class="headerlink" title="写C/C++"></a>写C/C++</h3><h2 id="写LaTeX"><a href="#写LaTeX" class="headerlink" title="写LaTeX"></a>写LaTeX</h2><h1 id="插件安利"><a href="#插件安利" class="headerlink" title="插件安利"></a>插件安利</h1><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 要注意的是最好不要在一个项目中使用过多插件, 这会让VSCode最开始的加载非常慢,
这是得不偿失的. 我们仍要记得VSCode只是一个编辑器. 而我们通常面临的尴尬情况是:有很多日常会用到的插件, 但并不是在每个项目中都需要用到全部的插件, 很多本工作区用不到的插件放在那里只会浪费资源. 而通过将一些插件设为<strong>禁用(工作区)</strong>可以仅在这个项目中禁用这个插件! 这样能大大缩短VSCode启动时间<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<h1 id="VSCode-个性化设置"><a href="#VSCode-个性化设置" class="headerlink" title="VSCode 个性化设置"></a>VSCode 个性化设置</h1><h2 id="改编辑器选项卡关闭按钮位置至左边"><a href="#改编辑器选项卡关闭按钮位置至左边" class="headerlink" title="改编辑器选项卡关闭按钮位置至左边"></a>改编辑器选项卡关闭按钮位置至左边</h2><p>在这之前有一件让我很恼火的事: 我经常由于文件标题过长而选项卡关闭按钮在右侧而不能轻松地关闭一个选项卡, 因为关闭按钮没能显示出来! 而我将关闭按钮改至左侧后, <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span>爽到!</p>
<p>:heavy_check_mark: 更改方法: 在设置中搜索 <code>workbench.editor.tabCloseButton</code>, 设置为<strong>left</strong></p>
<h2 id="在一定数量的等宽字符后显示垂直标尺"><a href="#在一定数量的等宽字符后显示垂直标尺" class="headerlink" title="在一定数量的等宽字符后显示垂直标尺"></a>在一定数量的等宽字符后显示垂直标尺</h2><p>VSCode有许多很好用的功能!<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span> 这是其中之一. 你可以设置任意多个标尺来作为字数的参考线!</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>editor.rulers</code>, 选择后在数组中填入要画线处的字数.</p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>统一用 <code>Alt+shift+F</code> 作为代码格式化快捷键</p>
<h2 id="查看键盘快捷方式"><a href="#查看键盘快捷方式" class="headerlink" title="查看键盘快捷方式"></a>查看键盘快捷方式</h2><p>如果你新安装了一个插件, 其中几个快捷键不知道为什么不好用或者效果不对, 你应当到
<strong>键盘快捷方式</strong>查看一下这个快捷键在该情况下是不是对应了不止一个命令.</p>
<h2 id="关闭Enter键接受建议"><a href="#关闭Enter键接受建议" class="headerlink" title="关闭Enter键接受建议"></a>关闭Enter键接受建议</h2><p>很多时候原本想换行的, 但是按Enter却接受了VSCode的沙雕建议, 令人郁闷, 通过关掉Enter接受建议能让心情好很多<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span> 虽然习惯Enter接受建议突然改成只能用Tab接受建议会有点不适应,
但再适应一下就会觉得非常舒服了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8">👏</span></p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>editor.acceptSuggestionOnEnter</code>, 改为
<strong>off</strong></p>
<h2 id="设置git-commit成功即上传"><a href="#设置git-commit成功即上传" class="headerlink" title="设置git commit成功即上传"></a>设置git commit成功即上传</h2><p>在使用个人repository时我认为commit和push是没必要分开进行的, 因为只有自己用, 在本地存着和在云端存着没什么区别. 甚至有可能发生代码忘记上传云端就把电脑格式化了因而损失大段代码的惨案<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span> 因此git有一项选项特别适合我: commit成功即push</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>git.postCommitCommand</code>, 设置为<strong>push</strong></p>
<h2 id="打开用户设置的同时打开默认设置"><a href="#打开用户设置的同时打开默认设置" class="headerlink" title="打开用户设置的同时打开默认设置"></a>打开用户设置的同时打开默认设置</h2><p>虽然打开<strong>settings.json</strong>时同时打开默认设置的json文件应当是默认设置, 但我有一次安装
VSCode之后发现这个选项没被勾上.</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>workbench.settings.openDefaultSettings</code>,
设置为<strong>true</strong>.</p>
<h2 id="允许编辑器中水平滚动"><a href="#允许编辑器中水平滚动" class="headerlink" title="允许编辑器中水平滚动"></a>允许编辑器中水平滚动</h2><p>触摸板和一些鼠标 (比如我的Microsooft Arch) 是支持水平滚动界面的, 但VSCode默认禁止水平滚动, 只能滑动底下的滑条来左右滑, 但这个选项可以打开.</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>workbench.tree.horizontalScrolling</code>,
设置为<strong>true</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>搓一个Python/C++的简易卡尔曼滤波器</title>
    <url>/zh-CN/2019/01/07/%E6%90%93%E4%B8%80%E4%B8%AAPython-C-%E7%9A%84%E7%AE%80%E6%98%93%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<div align="right">Language:
<a href="/Struggling-a-Simple-Kalman-Filter-by-Python-C"><code>English</code></a>
<a href="/zh-CN/搓一个Python-C-的简易卡尔曼滤波器"><code>中文</code></a>
</div>

<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>滤波</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派杂记</title>
    <url>/zh-CN/2019/01/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>因为我是一个记性很差并且接触东西很杂的人, 很多很基础的命令根本记不住,但每次都去查一遍很浪费时间, 于是整理一下. 这是树莓派相关的.</p>
<a id="more"></a>

<p>首先不得不说<a href="https://www.raspberrypi.org/documentation" target="_blank" rel="noopener">树莓派官方文档</a>实在是文档范本! 即便是初学者也能得到<strong>友好全面</strong>的帮助! 文档里包含了使用树莓派的绝大多数完整, 深入的教程, 而且方法都十分清爽 😆</p>
<p><img src="%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9D%82%E8%AE%B0/15826242887468.jpg?50" alt="img"></p>
<blockquote>
<p>放一张树莓派4B布局图</p>
</blockquote>
<h2 id="关于树莓派4"><a href="#关于树莓派4" class="headerlink" title="关于树莓派4"></a>关于树莓派4</h2><p>我买了一个4GB的DDR4内存的树莓派4B, 性能确实比树莓派3B+强大很多! 运行图像识别的python程序完全不成问题, 通过VNC的虚拟桌面, 用网页看b站高清视频只有40%的内存在被使用, 温度也并不高. 属实牛皮.</p>
<p>而我觉得最神奇的是树莓派4B的UART. 在树莓派3上使用UART一直是个麻烦事, 因为一共只内置两个UART, 其中一共是阉割版, 仅有的一个PL011 UART (硬件UART) 还默认被蓝牙模块占用了. 而树莓派4就很🐮🍺了. 他内置<strong>六个</strong>UART, 5个PL011 UART, 1个阉割UART. 开始看树莓派4引脚分配表时还以为我理解错了, 直到我看到这句话</p>
<blockquote>
<p>11.1. Overview</p>
<p>The  BCM2711  device  has  six  UARTs.  One  mini  UART  (UART1)  and  five  PL011  UARTs  (UART0,  UART2,UART3,  UART4  &amp;  UART5).  This  section  describes  the  PL011  UARTs</p>
</blockquote>
<p>🔗 参见<a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/rpi_DATA_2711_1p0.pdf" target="_blank" rel="noopener">树莓派4片上系统datasheet</a></p>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>🔗 <a href="https://www.raspberrypi.org/documentation/usage/gpio/" target="_blank" rel="noopener">树莓派官方GPIO部分文档</a></p>
<blockquote>
<p>放两张好看的树莓派引脚对照表 (实际上两张都不完善)</p>
</blockquote>
<p><img src="%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9D%82%E8%AE%B0/175605x4nx4ryrywnn7hyw.jpg?50" alt="img"></p>
<p><img src="%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9D%82%E8%AE%B0/GPIO-Pi4-1587126749653.png?50" alt="Raspberry Pi 4 Model B GPIO Pinout Diagram | element14 | Raspberry Pi"></p>
<p>🔗 这个<a href="http://pinout.xyz/" target="_blank" rel="noopener">交互式引脚排布图</a>很棒.</p>
<p>运行<code>gpio readall</code>可以打印一张包含引脚真实输入/输出值的引脚表. 对于树莓派4需要手动操作一下更新<strong>wiringPi</strong>至版本<code>2.52</code>, 否则无法识别. 操作参考<a href="http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/" target="_blank" rel="noopener">wiringPi updated to 2.52 for the Raspberry Pi 4B</a></p>
<p><img src="%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9D%82%E8%AE%B0/image-20200417205537326.png?80" alt="image-20200417205537326"></p>
<p>但<code>gpio readall</code>无法打印出每个引脚所有可用功能, 而运行<code>raspi-gpio funcs</code>可用打印所有gpio的上拉/下拉, 所有可用功能.</p>
<p>树莓派官方文档列出了几个很好用的gpio库, 其中这个<a href="https://gpiozero.readthedocs.io/" target="_blank" rel="noopener">GPIO Zero</a>将GPIO分类封装成了一些很简洁的类, 看起来很值得一试.</p>
<h3 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h3><p>如前面提到的, 树莓派4内置6个UART. 关于如何同时使用多个UART可用看看<a href="https://www.raspberrypi.org/forums/viewtopic.php?f=107&amp;t=244827&amp;sid=478967f5e58d920a422de08085f343d8" target="_blank" rel="noopener">这个讨论</a>. 截止目前树莓派还没有就此更新官方文档.</p>
<p>至于PL011 UART与mini UART的区别根据树莓派官方文档总结下来就是:</p>
<ul>
<li>mini UART的FIFO更小而没有流控制功能, 因此在高波特率下更容易丢帧</li>
<li>mini UART的时钟参考源是系统时钟, 因此很可能一直在变化, 因此波特率是不稳定的</li>
<li>mini UART没有断线检测</li>
<li>mini UART没有没有帧错误检测</li>
<li>mini UART没有奇偶校验位</li>
<li>mini UART没有接收超时中断</li>
<li>mini UART没有DCD，DSR，DTR或RI信号</li>
</ul>
<p>emmm看起来就是个废物呢. 不过问题不大, 树莓派开发人员给它的定位只是一个控制台 (应该就是用来ssh的意思吧)</p>
<p>关于如何在树莓派3B+等设备上禁用蓝牙并启动PL011 UART的操作可以看<a href="https://www.raspberrypi.org/documentation/configuration/uart.md" target="_blank" rel="noopener">官方教程</a></p>
<h2 id="固件警告图标"><a href="#固件警告图标" class="headerlink" title="固件警告图标"></a>固件警告图标</h2><p>有时候屏幕右上角会有表示异常状态图标出现 (如果你有显示屏的话), 图标及对应含义如下:</p>
<ul>
<li>⚡ 闪电 : 电源电压不足</li>
<li>🌡 温度计: 温度过高</li>
</ul>
<p>🔗 <a href="https://www.raspberrypi.org/documentation/configuration/warning-icons.md" target="_blank" rel="noopener">对应官方文档</a></p>
<p>(以前还有种表示电源电流不足的彩虹图标, 看文档现在似乎没有这个了)</p>
<h2 id="VNC使用"><a href="#VNC使用" class="headerlink" title="VNC使用"></a>VNC使用</h2><p><a href="https://www.raspberrypi.org/documentation/remote-access/vnc/README.md" target="_blank" rel="noopener">VNC使用的官方文档</a>已经把大多数东西都说清了. 值得一提的是如果树莓派没有连接显示器, (这特么不是废话吗, 如果有屏幕谁还需要VNC😅) 直接用RealVNC访问树莓派ip很可能看到的不是树莓派界面, 而是看到<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=216737" target="_blank" rel="noopener">Cannot currently show the dekstop</a>这样的字样. 树莓派官方对这种情况给出的办法是使用虚拟桌面, 每次需要手动启动. 而上面这个链接里提到其实只需在<code>raspi-config</code>中手动指定一个分辨率就能正常使用了, 亲测有效.</p>
<p>💡 我觉得VNC也就是偷懒用的, 虽然ssh无法看到画面但大多数需要看到画面的需求都可以用别的方式满足. 比如使用<a href="https://www.raspberrypi.org/documentation/remote-access/ssh/sshfs.md" target="_blank" rel="noopener">sshfs</a>来将树莓派文件当做本地文件编辑, 比如通过创建RTSP (实时视频流)或者使用<a href="https://elinux.org/RPi-Cam-Web-Interface#Remote_access_to_website_with_User.2FPass_and_changing_port" target="_blank" rel="noopener">RPi-Cam-Web-Interface</a>这样成熟的工具实现远程查看摄像头输出/自定义视频流.</p>
<p>当然如果你想玩树莓派自带的那些推荐软件那当我没说 😁</p>
<h3 id="开启VNC的server与viewer的剪贴板共享"><a href="#开启VNC的server与viewer的剪贴板共享" class="headerlink" title="开启VNC的server与viewer的剪贴板共享"></a>开启VNC的server与viewer的剪贴板共享</h3><p>在linux中执行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vncconfig -nowin&amp;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="屏幕调节"><a href="#屏幕调节" class="headerlink" title="屏幕调节"></a>屏幕调节</h2><h3 id="禁止息屏"><a href="#禁止息屏" class="headerlink" title="禁止息屏"></a>禁止息屏</h3><p>最近买了一块7寸触摸显示屏😁 (不我没有在炫耀), 发现系统默认开启了息屏功能, 但我的应用场景要求屏幕常亮. 问题不大, 这个可以禁用. 在网上看到了两种方法:</p>
<h4 id="通过Raspbian默认桌面显示管理器lightdm"><a href="#通过Raspbian默认桌面显示管理器lightdm" class="headerlink" title="通过Raspbian默认桌面显示管理器lightdm"></a>通过Raspbian默认桌面显示管理器lightdm</h4><p>进入 <code>/etc/lightdm/lightdm.cfg</code>, 找到 <strong>[Seat:*]</strong> 字段, 取消<code>xserver-command</code>
的注释, 设置为:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">xserver-command=X -s 0 -dpms</span><br></pre></td></tr></tbody></table></figure>

<p>⚠️ 需要重启树莓派</p>
<p>其中:</p>
<ul>
<li><code>-s</code> 设置屏幕保护不启用</li>
<li><code>-dpms</code> 关闭电源节能管理, 我猜这是 <strong>D</strong>isplay <strong>P</strong>ower <strong>M</strong>anagemant
<strong>S</strong>ystem的缩写</li>
</ul>
<h4 id="使用Screen-sh"><a href="#使用Screen-sh" class="headerlink" title="使用Screen.sh"></a>使用<code>Screen.sh</code></h4><p>在 <code>/etc/profile.d/</code>下新建<code>Screen.sh</code>, 写入:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">xsetdpms 0 0 0</span><br><span class="line">xsets off</span><br></pre></td></tr></tbody></table></figure>

<p>⚠️ 需要重启树莓派</p>
<p>列出一些相关指令及其含义</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xset s off</td>
<td>禁用屏幕保护</td>
</tr>
<tr>
<td>xset s 3600 3600</td>
<td>设置空闲时间为1小时</td>
</tr>
<tr>
<td>xset -dpms</td>
<td>关闭 DPMS</td>
</tr>
<tr>
<td>xset s off -dpms</td>
<td>禁用 DPMS 并阻止屏幕进入空闲</td>
</tr>
<tr>
<td>xset dpms force off</td>
<td>立即关闭屏幕</td>
</tr>
<tr>
<td>xset dpms force standby</td>
<td>强制屏幕进入待命状态</td>
</tr>
<tr>
<td>xset dpms force suspend</td>
<td>强制屏幕进入暂停状态</td>
</tr>
</tbody></table>
<h3 id="屏幕亮度调节"><a href="#屏幕亮度调节" class="headerlink" title="屏幕亮度调节"></a>屏幕亮度调节</h3><p>调节范围为0-255</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo [value] &gt; /sys/class/backlight/rpi-backlight/brightness</span><br></pre></td></tr></tbody></table></figure>

<h3 id="关闭背光"><a href="#关闭背光" class="headerlink" title="关闭背光"></a>关闭背光</h3><p>看网上说法关闭背光和关闭显示屏的区别在于只关闭背光的话屏幕其实仍在工作, 如果自己拿光照还是能看到画面的. 也就是说关闭背光应该和将屏幕亮度调至0效果一样.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo 0 &gt; /sys/class/backlight/rpi_backlight/bl_power</span><br></pre></td></tr></tbody></table></figure>

<p>0为开启背光，1为关闭背光. (我总觉得这和通常对01的理解不同)</p>
<h2 id="查看CPU温度"><a href="#查看CPU温度" class="headerlink" title="查看CPU温度"></a>查看CPU温度</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /sys/class/thermal/thermal_zone0/temp</span><br></pre></td></tr></tbody></table></figure>

<p>这个返回值除1000就是一个<strong>摄氏度</strong>单位的CPU温度值了</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>麦语言速成</title>
    <url>/zh-CN/2019/01/17/%E9%BA%A6%E8%AF%AD%E8%A8%80%E9%80%9F%E6%88%90/</url>
    <content><![CDATA[<blockquote>
<p>因为父亲经常炒期货，我速成一下<a href="https://www.wenhua.com.cn/myy/" target="_blank" rel="noopener">麦语言</a>来减轻一下他的工作量吧。</p>
</blockquote>
<a id="more"></a>

<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 我体验下来觉得期货风险真的特别大, 能看盘时还是盯着点比较好.</p>
<p>随着我逐渐了解才发现量化交易并没有我想象中那么简单…单说
<a href="https://www.zhihu.com/question/25404359" target="_blank" rel="noopener">这些业内人士使用的语言</a>就五花八门…<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span>
<a href="https://zhuanlan.zhihu.com/p/33839493" target="_blank" rel="noopener">这位仁兄</a>则让我大概了解了局面.
站在一个接触编程有一段时间的人的角度，我是觉得用C#编写模型比用麦语言看着NB多了，但我明显没那水平和精力,更何况我觉得知乎这个提问里的回答都说的很有道理,<a href="https://www.zhihu.com/question/36803590" target="_blank" rel="noopener">能赚钱的工具就是好工具</a>
。还是老老实实研究一下传说中用<strong>易语言</strong>编写的麦语言<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span></p>
<blockquote>
<p>看资料过程中<a href="http://www.tradeblazer.net/" target="_blank" rel="noopener">交易开拓者</a>(简称<strong>TB</strong>)和
<a href="https://www.multicharts.cn/" target="_blank" rel="noopener">MultiCharts</a>(简称<strong>MC</strong>)也经常被提及。</p>
</blockquote>
<h2 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h2><p>我觉得最蛋疼的是这玩意好像没法debug啊!!<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f627.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f627.png?v8">😧</span></p>
<ul>
<li><a href="麦语言速成/教程.zip">网上找到的一套PPT教程</a>，并附上对应视频教程的<a href="https://pan.baidu.com/s/1foE6ORfqdGHyTQ-ZW9NPVg" target="_blank" rel="noopener">百度云链接</a></li>
<li><a href="http://www.wenhua.com.cn/guide/wh8/index.htm" target="_blank" rel="noopener">智赢wh8使用说明书</a></li>
<li><a href="http://www.wenhua.com.cn/guide/views41a3.htm" target="_blank" rel="noopener">wh8趋势跟踪模型语法参考</a></li>
<li><a href="http://www.wenhua.com.cn/guide/wh8_zjyfhs2.htm" target="_blank" rel="noopener">wh8算法交易模型语法参考</a></li>
</ul>
<p>这套PPT有文华财经的水印，大概是官方教程吧。而且我觉得讲得很浅显也比较详细了,好评<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<h2 id="麦语言语法简记"><a href="#麦语言语法简记" class="headerlink" title="麦语言语法简记"></a>麦语言语法简记</h2><h3 id="算法交易模型与趋势跟踪模型"><a href="#算法交易模型与趋势跟踪模型" class="headerlink" title="算法交易模型与趋势跟踪模型"></a>算法交易模型与趋势跟踪模型</h3><p>打开wh8后我发现可以用来交易的分两种模型 (即代码), 分
<a href="http://www.wenhua.com.cn/new_guide/Wh8/view4_6.html" target="_blank" rel="noopener">算法交易模型和趋势跟踪模型</a>,
普通的趋势交易策略使用趋势模型编写，加载到程序化平台运行实现自动交易；与趋势无关的盘口高频交易模型，需要用算法模型编写. 一开始我并没有理解这两种模型的区别,
(实际这两个模型的名字非常直白的指出了两者的应用领域)
看到算法交易模型使用的是类C语法就果断开始写这个, 后来我才发现其中区别:</p>
<ul>
<li>趋势跟踪模型中可以调用很多常用分析指标, 比如布林通道, 比如指数加权移动平均, 更注重对目标的<strong>趋势</strong>的分析</li>
<li>算法跟踪模型更多的是能调用未经处理的精确数据, 甚至不提供EMA等很常用的分析指标
(如果需要只能自己写), 这类模型更注重于对<strong>实时行情</strong> (即<strong>盘口</strong>) 的处理.</li>
<li>算法交易模型的回测只提供一日的tick数据, 不支持更久的回测.</li>
</ul>
<p>看了wh8说明书中<a href="http://www.wenhua.com.cn/new_guide/Wh8/view4_5.html" target="_blank" rel="noopener">相关章节</a>
个人觉得算法交易模型更多应当与趋势跟踪模型配合使用, 说明书有句话说得好</p>
<blockquote>
<p>利用趋势模型可以有效捕捉趋势行情的交易方向，当交易方向确定，下一步便是寻找入场点。一个精准的入场点位是交易成功的起点，使用盘口的高频报价辅助判断无疑是最合适的方案</p>
</blockquote>
<p>也即是说由<strong>趋势模型</strong>判断是做多还是做空, 由<strong>算法模型</strong>判断买, 卖精确时间是比较科学的运用方式.</p>
<p>由于我需要写的模型并不要求高频交易, 主要的是做小时线, 因此只建立趋势模型. (趋势模型语法太低级也只好忍了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>)</p>
<h3 id="一开一平信号过滤模型·加减仓模型等"><a href="#一开一平信号过滤模型·加减仓模型等" class="headerlink" title="一开一平信号过滤模型·加减仓模型等"></a>一开一平信号过滤模型·加减仓模型等</h3><p>以上是一种分类方式, 另外按交易行为分类可以分为一开一平信号过滤模型, 加减仓模型等模型.
<strong>一开一平模型</strong>限定了必须一平跟随一开或者一开跟随一平, 如果是简单模型还是很方便, 但无法特定开仓手数, 只能在开始运行模型时指定整个模型开仓手数, 也无法加仓. 而<strong>加减仓模型</strong>打破了前述弊端, 但需要自己设置开闭仓信号滤波器, 费点脑子.
<a href="http://www.wenhua.com.cn/popwin/cxhmingci.htm" target="_blank" rel="noopener">模型列表</a></p>
<h3 id="算法交易模型与C的比较"><a href="#算法交易模型与C的比较" class="headerlink" title="算法交易模型与C的比较"></a>算法交易模型与C的比较</h3><p>因为也体验了一会算法模型的语法, 稍作整理. 使用下来感觉与C语言语法区别主要如下:</p>
<ul>
<li>不需要引用头文件</li>
<li>变量可以用<strong>GLOBAL_VAR</strong>或<strong>VAR</strong>关键字来声明, 变量是动态数据类型, 似乎也可以使用
<strong>WriteGlobal</strong>, <strong>WriteGlobalF</strong> 等来定义整型, 浮点等变量. (文华给出的所有示例中定义变量竟然全部定义的全局变量也是很迷了)</li>
<li>函数类型可以是<strong>VOID</strong>或<strong>VAR</strong>, 当然如果需要返回值需要定义为<strong>VAR</strong>型</li>
<li>函数, 变量可以先引用后声明</li>
<li>麦语言的函数是可以有返回值的! 但是要把要返回的值括起来. (参考<a href="http://www.wenhua.com.cn/guide/wh8_zjyfhs2.htm" target="_blank" rel="noopener">这里</a>)</li>
</ul>
<h3 id="趋势跟踪模型语法简记"><a href="#趋势跟踪模型语法简记" class="headerlink" title="趋势跟踪模型语法简记"></a>趋势跟踪模型语法简记</h3><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 常用语句:</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td><strong>等于</strong>操作符 :warning:趋势模型中赋值操作符为<code>:=</code>. 应注意等于操作符<strong>只有一个</strong>=</td>
</tr>
<tr>
<td>:</td>
<td>定义变量并且加载模型时显示图线. 冒号前为变量名.</td>
</tr>
<tr>
<td>:=</td>
<td>定义变量并且不显示图线</td>
</tr>
<tr>
<td>#IMPORT [PERIOD,N,FORMULA] AS VAR</td>
<td><a href="#跨周期编写">见下</a></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>IF, THEN</td>
<td>参见<a href="http://www.wenhua.com.cn/guide/views41a3.htm" target="_blank" rel="noopener">这里</a></td>
</tr>
</tbody></table>
<h3 id="模组"><a href="#模组" class="headerlink" title="模组"></a>模组</h3><p>算法交易模型中可以调用的一大串函数有类似<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8">👇</span>这样的函数说明.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">注：</span><br><span class="line">该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。</span><br></pre></td></tr></tbody></table></figure>

<p>开始我以为模组也是模型的意思, 后来看到示例里的用法似乎模组类似于<strong>类</strong>, 每个模组对应一个实例, 可以调用里面的各种函数来处理这个合约的数据, 而且每个模型也可以是一个模组一个模型可以调用另一个模型的函数, 就很像类. <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8">🤔</span>我是这样理解的</p>
<h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><p>看过wh8给出的示例后我发现官方风格写法里趋势模型基本没有用过IF, ELSE什么的, 普遍是一句话浓缩一串条件搞定. 主要这玩意语法就让人懒得写IF, ELSE…而算法模型中运用IF, ELSE较多.</p>
<p>很有意思的是趋势模型中可以将一串判断条件赋值给一个变量作为布林变量. 然后通常是以下面这样的形式来调用</p>
<p><code>[布林变量], [交易指令]</code></p>
<p>另外趋势模型中逻辑运算操作符只有逻辑与和逻辑或, 如果需要其他运算, 我是使用的<code>NOT()</code>函数</p>
<h3 id="跨周期编写"><a href="#跨周期编写" class="headerlink" title="跨周期编写"></a>跨周期编写</h3><p>跨周期模型函数: #IMPORT [PERIOD,N,FORMULA]</p>
<p>举例: <code>#IMPORT[DAY,2,WHBXSF] AS VAR1</code><br>调取自定义2日线周期上WHBXSF指标中的数据. 需要先编写被引用的指标 (只有一串变量的模型似乎称为<strong>指标</strong>)</p>
<p>具体可以参考<a href="http://www.2818668.com/369.html" target="_blank" rel="noopener">这个</a></p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li>到现在我也不确定这些模型是循环运行还是怎么在执行, 如果是循环运行一次运行时间是多长</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>搜索过程中看到的<a href="https://zhuanlan.zhihu.com/p/52867020" target="_blank" rel="noopener">十六套经典策略</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>量化交易</category>
        <category>语言</category>
        <category>麦语言</category>
      </categories>
  </entry>
  <entry>
    <title>Bug List</title>
    <url>/zh-CN/2019/02/05/Bug-List/</url>
    <content><![CDATA[<p>我想记录一下我遇到过的各种bug, 不论大小. 原本我从一开始学编程的时候就在这么做了, 但我也忘了我什么时候竟然怠慢了这件事! 我会想到记录这些是上大学前的暑假看到
<a href="https://zhuanlan.zhihu.com/p/22266788" target="_blank" rel="noopener">这篇让人深受启发的教诲</a>而想要养成的习惯之一.
我认为这绝对不是浪费时间. 正如初高中学习时的错题本 (虽然我那时的错题本一共也没能记几笔)
只要我偶尔能想起来记几笔, 我想总是能为以后节省一些时间的.</p>
<a id="more"></a>

<h1 id="有时候等号两侧不能加空格"><a href="#有时候等号两侧不能加空格" class="headerlink" title="有时候等号两侧不能加空格"></a>有时候等号两侧不能加空格</h1><ul>
<li>在bash中赋值时等号两侧不能有空格</li>
<li>在swift中等号两侧要不都加等号, 要不都不加, 不可只有单侧有等号</li>
</ul>
<h1 id="此python非彼python"><a href="#此python非彼python" class="headerlink" title="此python非彼python"></a>此python非彼python</h1><p>有时会遇到明明刚安装了一个包但调用的时候报错未找到该包, 再次安装显示已安装最新版的神奇情况</p>
<p>有以下几种可能 (总体来说是安装包的python环境和调用包的python环境不一样):</p>
<ol>
<li><p>如果你是用命令行安装的 (或者你安装了Anaconda,用conda安装的), 在IDE中调用的, 那你应当检查一下你的IDE调用的pytohn interpreter和cmd调用的是不是一个了. 比如Anaconda自带的Spyder默认的是python2.7, 但我设置的cmd调用的是一个3.6.4的python</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> Anaconda中切换Spyder环境可以参考
<a href="https://www.zhihu.com/question/49144687" target="_blank" rel="noopener">这里</a></p>
</li>
<li><p>如果环境中同时有python2和python3, 有可能将包安装到了python2的环境中但你的程序是
python3的程序, 可以将<code>pip install</code> 换为 <code>pip3 install</code> 试试</p>
</li>
</ol>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 如果安装了conda那么安装python库最好使用conda, 尽量不要混用conda和pip,
<strong>conda和pip的包格式不同, 两者是不兼容的, 甚至有的库在conda和pip中名字不同</strong>.
有关在conda中没有某库但pip中有的情况可以参考<a href="https://www.zhihu.com/question/49144687" target="_blank" rel="noopener">这里</a>, 而关于混用conda与pip的危害可以参考<a href="http://onoz000.hatenablog.com/entry/2018/02/11/142347" target="_blank" rel="noopener">这位日本兄弟的文章</a></p>
<h1 id="谨防数据溢出"><a href="#谨防数据溢出" class="headerlink" title="谨防数据溢出"></a>谨防数据溢出</h1><p>这个例子是我在尝试细化图像的时候遇到的</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Xihua</span><span class="params">(image, array, num=<span class="number">1</span>)</span>:</span></span><br><span class="line">    iXihua = np.zeros(image.shape, np.uint8)</span><br><span class="line">    iXihua = image.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        VThin(iXihua, array)</span><br><span class="line">    <span class="keyword">return</span> iXihua</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VThin</span><span class="params">(image, array)</span>:</span></span><br><span class="line">    h = height</span><br><span class="line">    w = width</span><br><span class="line">    NEXT = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            <span class="keyword">if</span> NEXT == <span class="number">0</span>:</span><br><span class="line">                NEXT = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                M = (image[i, j<span class="number">-1</span>] + image[i, j] + image[i, j+<span class="number">1</span>]) <span class="keyword">if</span> <span class="number">0</span>&lt;j&lt;w<span class="number">-1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> image[i, j] == <span class="number">0</span> <span class="keyword">and</span> M != <span class="number">0</span>:</span><br><span class="line">                    a = [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">-1</span>&lt;(i<span class="number">-1</span>+k)&lt;h <span class="keyword">and</span> <span class="number">-1</span> &lt;(j<span class="number">-1</span>+l)&lt;w <span class="keyword">and</span> image[i<span class="number">-1</span>+k, j<span class="number">-1</span>+l]==<span class="number">255</span>:</span><br><span class="line">                                a[k*<span class="number">3</span>+l] = <span class="number">1</span></span><br><span class="line">                    sum = a[<span class="number">0</span>]*<span class="number">1</span>+a[<span class="number">1</span>]*<span class="number">2</span>+a[<span class="number">2</span>]*<span class="number">4</span>+a[<span class="number">3</span>]*<span class="number">8</span>+a[<span class="number">5</span>]*<span class="number">16</span>+a[<span class="number">6</span>]*<span class="number">32</span>+a[<span class="number">7</span>]*<span class="number">64</span>+a[<span class="number">8</span>]*<span class="number">128</span></span><br><span class="line">                    image[i, j] = array[sum] * <span class="number">255</span></span><br><span class="line">                    <span class="keyword">if</span> array[sum] == <span class="number">1</span>:</span><br><span class="line">                        NEXT = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure>

<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p><img src="Bug-List/%E5%9B%BE%E5%83%8F%E7%BB%86%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%A5%E9%94%99.png" alt="报错信息"></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>M默认与image[i, j]同数据类型，而image[i, j]设定的是ubyte类型，范围-255~256，M极有可能数据溢出。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>将18行改为下面代码, 将M数据类型强制转为int</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">M = (int(image[i, j<span class="number">-1</span>]) + int(image[i, j]) + int(image[i, j+<span class="number">1</span>])) <span class="keyword">if</span> <span class="number">0</span>&lt;j&lt;w<span class="number">-1</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="迭代中的计数器记得归零"><a href="#迭代中的计数器记得归零" class="headerlink" title="迭代中的计数器记得归零"></a>迭代中的计数器记得归零</h1><p>在迭代中的迭代中的计数器 (简称迭中迭) 要记得在一次迭代后归零, 或者应当将一次迭代的代码分割出来封装成一个函数, 在函数中给计数器设定初值. 这样每次调用都会是从零开始而不是累积的.</p>
<h1 id="python中赋值的坑"><a href="#python中赋值的坑" class="headerlink" title="python中赋值的坑"></a>python中赋值的坑</h1><p>一次我得到一个list, 想要将其从小到大重新排序, 但不影响原来的list. 因此我试图将这个<code>list</code>
复制到<code>listSort</code>中, 对listSort排序:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">listSort = list</span><br><span class="line">listSort.sort()</span><br></pre></td></tr></tbody></table></figure>

<p>但我发现这样完全没有达到我的目的! list会随着listSort的改变而改变, 与我想保持list不变的目的完全相悖. 随后我才知道在python中<strong>赋值是将变量名指向对象</strong>, 与C语言中变量不止是个名字, 也是字节集合并真实存在于内存某个位置上的情况是不同的.</p>
<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><h3 id="可变对象与不可变对象"><a href="#可变对象与不可变对象" class="headerlink" title="可变对象与不可变对象"></a>可变对象与不可变对象</h3><p>python中的不可变对象有:</p>
<ul>
<li>int</li>
<li>float</li>
<li>bool</li>
<li>string</li>
<li>tuple</li>
</ul>
<p>python中的可变对象有:</p>
<ul>
<li>list</li>
<li>dict</li>
<li>set</li>
</ul>
<p>:exclamation: 要注意python中对一个可变对象重新赋值对象重新赋值对象地址不会变化, 而对一个不可变对象重新赋值其地址会发生改变 (可以用<code>id(var)</code>语句来查看变量的地址).</p>
<p>另外python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响外层该变量,
而不可变对象不会. 在向类传递参数时也是如此.</p>
<p>可变对象有时是一种很方便的特性, 但很多时候是<strong>很危险的</strong>.</p>
<h4 id="函数默认参数一定要设定为不可变对象"><a href="#函数默认参数一定要设定为不可变对象" class="headerlink" title="函数默认参数一定要设定为不可变对象"></a>函数默认参数一定要设定为<strong>不可变对象</strong></h4><p>否则可能会引发一些错误, 我们来看下面一个例子:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(l=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>    l.append(<span class="string">'add'</span>)</span><br><span class="line"><span class="meta">... </span>    print(l)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'add'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'add'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码是正常运行的, 我们来看下面这些:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc()</span><br><span class="line">[<span class="string">'add'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc()</span><br><span class="line">[<span class="string">'add'</span>, <span class="string">'add'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc()</span><br><span class="line">[<span class="string">'add'</span>, <span class="string">'add'</span>, <span class="string">'add'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>按理说应该每次都是<code>['add']</code>, 但是现在出现了意想不到的错误.</p>
<p>这是因为<code>l = []</code>是在<strong>函数定义时就确定下来了的</strong>, 所以之后每次调用这个函数, 使用的<strong>l</strong>都是同一个, 如果不指定这个参数的新值, 就会出现上面这个问题.</p>
<p>上面这个<strong>l</strong>可以默认设置为<strong>None</strong>, 这就是一个不可变对象.</p>
<h4 id="类的属性通常是可变对象"><a href="#类的属性通常是可变对象" class="headerlink" title="类的属性通常是可变对象"></a>类的属性通常是可变对象</h4><p>有意思的是类的属性通常都是可以访问和修改的, 也就是说属性都是可变对象. 主要有两种方法使我们可以创建不可变的属性:</p>
<ul>
<li>设置<code>__setattr__</code>直接抛出异常, 即只要想设置属性值, 就会抛出异常</li>
<li>设置<code>__slot__</code>限制属性的访问, 如果属性都不能访问了, 那就肯定不能修改</li>
</ul>
<h2 id="复制列表的正确操作"><a href="#复制列表的正确操作" class="headerlink" title="复制列表的正确操作"></a>复制列表的正确操作</h2><p>:link: 这个<a href="https://www.cnblogs.com/ifantastic/p/3811145.html" target="_blank" rel="noopener">链接</a>说明了我的错误原因并列出了五种复制列表的方法的比较, 但实际上还有一种
<a href="https://www.programiz.com/python-programming/methods/list/copy" target="_blank" rel="noopener">我很喜欢的方法</a>
他没有列出. 从中可以看出<code>copy.deepcopy()</code>是最保险的方法.</p>
<h2 id="赋值-浅拷贝与深拷贝"><a href="#赋值-浅拷贝与深拷贝" class="headerlink" title="赋值, 浅拷贝与深拷贝"></a>赋值, 浅拷贝与深拷贝</h2><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> 请参考<a href="https://www.jianshu.com/p/1059318d38e0" target="_blank" rel="noopener">这里</a></p>
<h1 id="python写入中文字符串变乱码"><a href="#python写入中文字符串变乱码" class="headerlink" title="python写入中文字符串变乱码"></a>python写入中文字符串变乱码</h1><p>🔗 <a href="https://ericfu.me/python-2-str-and-unicode/" target="_blank" rel="noopener">Python 2 字符串编码踩坑小结</a></p>
<p>虽然我并不怎么写python2的代码但👆这篇文章确实对python中编码问题很有启发.</p>
<p>🔗 <a href="https://www.nltk.org/book/ch03.html" target="_blank" rel="noopener">Processing Raw Text</a></p>
<p>而在网上搜图的时候我搜到了这段讲python中处理文本的各种方法的话.</p>
<p>其中提到了如下图这样的方式防止出现乱码.</p>
<p><img src="Bug-List/Unicode_Decoding_and_Encoding.png" alt="Unicode Decoding and Encoding"></p>
<p>正如 “Python 2 字符串编码踩坑小结” 中提到的, 在python3中<code>str</code>类型数据都以Unicode码点格式储存. 实际上我们<a href="https://zh.wikipedia.org/wiki/Unicode#%E8%BE%93%E5%85%A5%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">可以直接输入Unicode码点</a>.</p>
<h1 id="Verilog中要写完整控制语句"><a href="#Verilog中要写完整控制语句" class="headerlink" title="Verilog中要写完整控制语句"></a>Verilog中要写完整控制语句</h1><p>Verilog中如果不写完整if-else结构和case结构会产生latch, 会将毛刺传给下一级电路的那种latch.</p>
<p>参见我的另一篇博客 <a href="https://leojhonsong.github.io/zh-CN/Verilog%E6%9D%82%E8%AE%B0/#%E5%85%B3%E4%BA%8E%20default">Verilog 杂记-有关default</a></p>
<h1 id="Verilog中因不同条件触发的变量应在不同always块中描述"><a href="#Verilog中因不同条件触发的变量应在不同always块中描述" class="headerlink" title="Verilog中因不同条件触发的变量应在不同always块中描述"></a>Verilog中因不同条件触发的变量应在不同always块中描述</h1><p>参见我的另一篇博客 <a href="https://leojhonsong.github.io/zh-CN/Verilog%E6%9D%82%E8%AE%B0/#%E6%9C%89%E5%85%B3%20always">Verilog 杂记-有关always</a></p>
<h1 id="C-字符串赋值坑"><a href="#C-字符串赋值坑" class="headerlink" title="C++字符串赋值坑"></a>C++字符串赋值坑</h1><p>在写一段C++代码时我遇到了这样的问题: 用如下代码给一个string类型的变量<code>str</code>赋值为
“\xfe\xfe\x03\x00\x00\x3e\xfd”, 也就是一个16进制表示的ASCII编码值为 fe fe 03 00 00 3e fd 的字符串,但这样做始终只能让<code>str</code>的值变为”\xfe\xfe\x03”!</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"\xfe\xfe\x03\x00\x00\x3e\xfd"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>但同时我发现用<code>assign()</code>来指定长度赋值就不会出现这种问题:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">str.assign(<span class="string">"\xfe\xfe\x03\x00\x00\x3e\xfd"</span>, <span class="number">7</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>⚠️要注意的是传给<code>assign()</code>的字符串长度不能用<code>length()</code>, <code>size()</code>等函数来给出, 他们同样会把\0视为字符串末尾… 我的方法是手动给出, 反正我的程序里字符串是定长的.</p>
<p>我拿这个问题问我的C++大佬同学, 他说应该是因为\0让C++认为字符串到头了, 于是只有前三个字符.</p>
<p>我说: ? 我这字符串里哪有\0? 你别骗我读书少.</p>
<p>然后他发了一张图来:</p>
<p><img src="Bug-List/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9D%9F%E7%AC%A6.jpg" alt="C++字符串结束符"></p>
<p>…我是真的吃了读书少的亏, 竟然特么\0和\x00是一个意思🤦‍</p>
<p>然后在string类型变量里写入\0的方法似乎只有用<code>assign()</code>和指定字符串长度的构造函数
. 其实用<code>=</code>赋值在变量声明和定义同时出现时是只有字符串值这个参数的构造函数, 否则就是只有字符串值这个参数的<code>assign()</code>函数.</p>
<h1 id="socket的Address-already-in-use问题"><a href="#socket的Address-already-in-use问题" class="headerlink" title="socket的Address already in use问题"></a>socket的Address already in use问题</h1><p>前几天写了一段socket服务器端的代码, 运行了一遍没毛病, 再运行第二遍竟然在创建业务
socket时报错了. 过了一会运行第三遍竟然又没问题了🤦‍ 我记得报错似乎是这个<strong>Error:
Address already in use</strong>, 我的服务器端监听的端口处于 <strong>TIME_WAIT</strong> 状态. 后来我发现<a href="https://stackoverflow.com/questions/15198834/bind-failed-address-already-in-use/15199016#15199016" target="_blank" rel="noopener">这个描述</a>
符合我的情况 (虽然我是在创建业务socket时出错的). 没想到是因为socket关得太慢了我重新启动程序时上次程序的socket还在占用端口…虽然我觉得这有点神奇但设置
<strong>SO_REUSEADDR</strong> 确实解决了我的问题. 解决方法很简单,紧跟着创建了监听socket代码的那一行后面加两句:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">setsocketopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br></pre></td></tr></tbody></table></figure>

<p>或者更严谨一点:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(enable)) &lt; <span class="number">0</span>)</span><br><span class="line">    error(<span class="string">"setsockopt(SO_REUSEADDR) failed"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h1 id="make编译提示Clock-skew-detected"><a href="#make编译提示Clock-skew-detected" class="headerlink" title="make编译提示Clock skew detected"></a>make编译提示Clock skew detected</h1><p>有次在用make编译时给出如下warning:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make: warning: Clock skew detected. Your build may be incomplete.</span><br></pre></td></tr></tbody></table></figure>

<p>💡 Clock skew 可以翻译时钟错误</p>
<p>我当时都懵了, 这编译咋还和时间扯上关系了…查了一下说这个warning是说<strong>某个文件的时间戳大于系统的当前时间</strong>. 而之所以说编译可能不完全是因为<strong>make完全依赖各个文件的时间戳来确定哪个文件最近被修改了, 随后决定哪个文件需要重新生成</strong>, 因此文件时间戳出问题了的话, make对需要编译哪些文件的判断可能出错. 虽然此处只是文件时间大于系统时间, 看起来并没有顺序问题. 但是因为时间戳问题通常出现于<strong>NFS</strong> (网络文件系统)
中, 因为不同设备的时间不同步而导致, 而这<strong>很可能导致最新的代码无法被应</strong>用, 算是很严重的问题, 因此make还是会给出给出warning.</p>
<p>但是! 我一直是在本地运行的, 通常来说是不会出现这种问题的啊…</p>
<p>后来我发现是因为<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#Linux%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%92%8CWindows%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%B7%AE8%E5%B0%8F%E6%97%B6">我Linux系统时间比Windows系统时间多八个小时</a>,
而虽然我的Linux系统能够自动进行网络校时, 但我这次关闭Windows系统 (Windows系统校准过时间) 再打开Linux系统使用过程中并没有联网… <strong>这使得Linux系统时间比实际时间少了8个小时</strong>. 那么如果距我上次对Makefile的修改没到八个小时就会遇到这个warning 😁</p>
<p>💡 这个问题解决起来很简单, 只需要<code>touch</code>每一个文件来更新时间戳即可. 找到当前目录下每个文件并touch的命令如下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">find . -type f -exec touch {} +</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Bug List</category>
      </categories>
  </entry>
  <entry>
    <title>Git杂记</title>
    <url>/zh-CN/2019/02/27/Git%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>先有git, 许久后才有了GitHub等代码托管平台. git是一个软件而GitHub是一个网站. 他们的关系是你可以通过git将你的代码托管给GitHub (就是把你的代码存到GitHub的服务器上). 不过随着发展, 这些代码托管平台现在提供极为丰富的服务, 我认为其中生态做得最好的还得是github. 从github自带的github pages, github action到应用市场的各种应用, 应有尽有.</p>
<a id="more"></a>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git是一个<strong>分布式版本控制</strong>软件. 与它齐名的另一个版本控制软件是<strong>SVN</strong>.</p>
<p>🔗 <a href="https://blog.csdn.net/xiaoqiangyonghu/article/details/78400313" target="_blank" rel="noopener">为什么要版本控制及分布式版本控制原理</a></p>
<h3 id="图形化软件"><a href="#图形化软件" class="headerlink" title="图形化软件"></a>图形化软件</h3><p>虽然有人仍喜欢用纯命令行, 并且有的命令确实只能在命令行输入 (很多命令图形界面无法提供), 但我平时更喜欢使用图形化软件来操作git. 此处推荐三款软件.</p>
<h4 id="GitHub-Desktop"><a href="#GitHub-Desktop" class="headerlink" title="GitHub Desktop"></a>GitHub Desktop</h4><p>🔗 <a href="https://desktop.github.com/" target="_blank" rel="noopener">下载地址</a></p>
<p>GitHub官方客户端. 这是一个对新手很友好的客户端, 我自己也在用. 它的缺点是<strong>只能管理托管在GitHub的git仓库</strong>. 它很有用的一点是<strong>能在一个面板上看到你每个仓库的更新情况</strong>. (我经常忘记哪个仓库有没有上传)</p>
<p>❗️ 要打开软件等它检测一会才会显示出来状态.</p>
<p><img src="Git%E6%9D%82%E8%AE%B0/image-20200227141011525.png" alt="image-20200227141011525"></p>
<blockquote>
<p>仓库名字后有蓝色点表示有本地更改未提交, 有向上箭头表示有本地提交未上传, 有向下箭头表示有远程端有比本地更新的提交需要拉取.</p>
</blockquote>
<p>🔗 <a href="https://help.github.com/cn/desktop/contributing-to-projects" target="_blank" rel="noopener">GitHub Desktop使用帮助</a></p>
<h4 id="Tower"><a href="#Tower" class="headerlink" title="Tower"></a>Tower</h4><p>🔗 <a href="https://www.git-tower.com/" target="_blank" rel="noopener">下载地址</a></p>
<p>这个软件看起来比GitHub Desktop功能强大些, 并且不像后者只能管理托管在GitHub的git仓库. 这个软件只能免费试用, 但申请了这个<a href="https://education.github.com/pack" target="_blank" rel="noopener">GitHub学生大礼包</a>的话可以免费用一年.</p>
<h4 id="开发工具集成的git管理"><a href="#开发工具集成的git管理" class="headerlink" title="开发工具集成的git管理"></a>开发工具集成的git管理</h4><p>🌟 实际上这是我最常使用的方式</p>
<p><img src="Git%E6%9D%82%E8%AE%B0/image-202002271546.png" alt="img"></p>
<p>这是装了<strong>GitLens</strong>插件的<strong>Visual Studio Code</strong>的源代码控制面板和编辑窗口截图. 可以看到左下角显示了当前分支及同步状态, 编辑窗口里有颜色条标示文件更改情况, 右上角有可以对文件进行的一些git操作, etc…</p>
<h3 id="登陆git"><a href="#登陆git" class="headerlink" title="登陆git"></a>登陆git</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config --global user.name "Your Name"</span><br><span class="line">git config --global user.email "email@example.com"</span><br></pre></td></tr></tbody></table></figure>

<p>⚠ 建议每台设备使用不同的<code>user.name</code>, 这样才能区分它们. 为了方便记忆可以统一使用<strong>昵称-设备型号</strong>的命名方式.</p>
<p>值得一提的是git的配置文件分三级: 系统级(所有用户的), 全局级(当前用户的), 仓库级. 在配置时分别使用<code>--system</code>, <code>--global</code>, <code>--local</code>参数来访问. 如果想直接进入配置文件而不是一个参数一个参数地设置可以使用:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config -e</span><br></pre></td></tr></tbody></table></figure>

<p>要注意默认情况下<code>git config -e</code>访问<strong>仓库级配置文件</strong>.</p>
<h3 id="http连接与ssh连接"><a href="#http连接与ssh连接" class="headerlink" title="http连接与ssh连接"></a>http连接与ssh连接</h3><p>最常用的连接git远程仓库的方式是通过http, ssh这两种协议.</p>
<p><strong>我建议使用http连接</strong>, 一方面http连接无论从远程端下载还是上传到远程端都会比用ssh<strong>快许多</strong> (原因我不清楚, 但确实是这样), 另一方面对于普通用户来说http连接<strong>麻烦事少一些</strong>. 这里的麻烦事指的是如果想通过ssh连接远程端那么需要在本地生成ssh秘钥对并把生成的公钥添加到远程端.</p>
<p>💡 也许有人说通过http连接每次push都需要输入账号密码, 但其实可以设置git记住账号密码:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></tbody></table></figure>

<p>另外在github的<a href="https://help.github.com/en/github/using-git/which-remote-url-should-i-use" target="_blank" rel="noopener">在克隆仓库时使用什么协议</a>中也是推荐使用http协议😏</p>
<h4 id="有关SSH"><a href="#有关SSH" class="headerlink" title="有关SSH"></a>有关SSH</h4><h5 id="获取SSH-Key"><a href="#获取SSH-Key" class="headerlink" title="获取SSH Key"></a>获取SSH Key</h5><p>首先查看有没有<code>~/.ssh</code>这个文件夹以及文件夹下有没有类似<code>id_rsa</code>和<code>id_rsa.pub</code>的文件.
如果有, 那就不用生成了.</p>
<p>这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥可以放心地告诉任何人. 比如加入GitHub的SSH Key.</p>
<h6 id="生成key"><a href="#生成key" class="headerlink" title="生成key"></a>生成key</h6><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果没有特别需求(比如甚至想设置密码), 直接连敲三次回车.</p>
<p>💡 其实在输入命令后第一个选项是指定生成的秘钥文件名, 可以指定为<code>id_rsa_github</code>,
<code>id_rsa_gitee</code>这样, 加上远程端的名字, 这样有多个远程端时也不会混乱.</p>
<h5 id="同时上传到多个远程端"><a href="#同时上传到多个远程端" class="headerlink" title="同时上传到多个远程端"></a>同时上传到多个远程端</h5><p>新建<code>~/.ssh/config</code>, 如果远程端是github和gitee, github和gitee的ssh key是像上面说的这样命名的, 那么内容如下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitee</span><br></pre></td></tr></tbody></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="克隆一个repository"><a href="#克隆一个repository" class="headerlink" title="克隆一个repository"></a>克隆一个repository</h4><p>💡 <strong>克隆与下载的区别</strong>: 如果下载一个仓库的压缩包, 你获得的只是这个仓库<strong>当前版本</strong>的代码, 而如果克隆一个仓库则首先得到的是记录了该仓库所有版本的版本库, 然后git从中释放出了当前版本. 这个版本库就是仓库根目录的<code>.git</code>文件夹. 因此经常出现到开发后期.git文件夹大小比当前版本的代码大很多的情况.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></tbody></table></figure>

<p>🔗 <a href="https://help.github.com/cn/github/creating-cloning-and-archiving-repositories/cloning-a-repository" target="_blank" rel="noopener">GitHub中文帮助文档-如何从GitHub克隆仓库</a></p>
<h5 id="让克隆更快"><a href="#让克隆更快" class="headerlink" title="让克隆更快"></a>让克隆更快</h5><h6 id="克隆特定分支"><a href="#克隆特定分支" class="headerlink" title="克隆特定分支"></a>克隆特定分支</h6><p>一个社区活跃的项目通常会有许多分支, 其中会有很多是你不需要关注的, 别人正在开发feature或者修bug等的分支, 可以通过只克隆指定分支来减少不必要的下载时间.</p>
<p>❗️ 这样的坏处是在本地看不到其他分支.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone -b &lt;branch&gt; --single-branch &lt;url&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>❗️ 如果不带<code>--single-branch</code>这个参数那效果仅仅是在完成克隆后切换到你指定的这个分支, 克隆的仍是<strong>完整的, 有多个分支的仓库</strong> (如果你的仓库有多个分支的话)</p>
<p>当你想要从远程端再弄下来一个分支<code>B</code>, 但仍不想要其他分支:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git remote set-branches --add origin B</span><br><span class="line">git fetch</span><br><span class="line">git checkout B</span><br></pre></td></tr></tbody></table></figure>

<p>当你强迫症犯了想要把所有分支都下下来时:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"</span><br><span class="line">git fetch</span><br></pre></td></tr></tbody></table></figure>

<h6 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h6><p>随着时间推移版本库的迭代次数可能越来越多, 多到对你来说并不是所有版本都是有意义的了. 比如涉及到某个文件的提交次数可能有100次, 但可能只有后20次对你是有意义, 你可能会查看的, 那么此时可以通过指定克隆深度来减少不必要的下载时间.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone --depth &lt;depth&gt; &lt;url&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>克隆 <a href="https://github.com/LeoJhonSong/vimrc" target="_blank" rel="noopener">https://github.com/LeoJhonSong/vimrc</a> 这个仓库master分支最新一次提交到用户主目录下的<code>.vimrc</code>文件夹:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone -b master --single-branch --depth 1 https://github.com/LeoJhonSong/vimrc ~/.vimrc</span><br></pre></td></tr></tbody></table></figure>

<p>当你发现你克隆的提交次数少了, 你需要看更往前的提交但仍不想把所有提交都克隆下来的时候, 你可以:</p>
<ol>
<li>再往前多下几个提交 <code>git fetch --deepen=&lt;depth&gt;</code></li>
<li>把直到一个指定日期的提交都下下来 <code>git fetch --shallow-since=15/11/2012</code></li>
</ol>
<p>而当你又犯强迫症了😏想要将这个浅克隆转为一个完整深度的克隆时, 输入:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git fetch --unshallow</span><br></pre></td></tr></tbody></table></figure>

<h6 id="利用代理"><a href="#利用代理" class="headerlink" title="利用代理"></a>利用代理</h6><p>很多人的代码托管在GitHub (这意味着服务器在美国), 因此可能下载/上传速度很慢. 如果你知道你的翻墙工具的代理端口那么你可以设置git使用这个端口, 速度会好很多. (如果你的翻墙工具是直接全局代理了所有流量那么不需要这一步)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比如我知道自己VPN的http代理端口为: 127.0.0.1:1234,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> socks代理端口为: 127.0.0.1:5678</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置git使用http代理端口</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1234</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置git使用socks代理端口</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:5678</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消git使用代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></tbody></table></figure>

<h6 id="利用gitee"><a href="#利用gitee" class="headerlink" title="利用gitee"></a>利用gitee</h6><p>如果你没有翻墙工具或者你的翻墙工具失效了😏, 那么还有一种曲折一点的方式可以快速克隆下来.</p>
<p>正如上面所说, 之所以从github克隆仓库速度很慢是因为它的服务器离我们太远了, 因此如果你习惯了直连github克隆仓库的破速度再体验从国内服务器克隆仓库的MB级速度你一定会感动得泪流满面👍</p>
<p>而我要说的就是利用一个国内的很棒的代码托管平台<strong>gitee</strong>提供的一个很贴心的功能: <strong>从github/gitlab导入仓库</strong>! (推荐大家也体验一下gitee, 它还提供了一些很贴心的github所没有的小功能)</p>
<p>利用gitee可以从github导入仓库, 我们可以轻松将一个仓库从遥不可及的服务器移到国内服务器来🎉 gitee导入仓库的时间可以忽略不计, 然后与从github克隆仓库一样的流程急速将仓库克隆到本地! 但一般网烂到这种程度我们还选择克隆仓库而不是下载压缩包是因为要加入开发, 因此从gitee克隆下来仓库后需要<strong>更改远程端的地址为github的仓库地址</strong>.</p>
<p>打开仓库根目录下<code>.git/config</code>文件, 你会看到类似下面这样的字段:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[remote "origin"]</span><br><span class="line">    url = https://gitee.com/someone/something.git</span><br></pre></td></tr></tbody></table></figure>

<p>你只需要把url中的<code>gitee</code>改为<code>github</code>就可以了😏神不神奇</p>
<h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure>

<h4 id="暂存所有更改"><a href="#暂存所有更改" class="headerlink" title="暂存所有更改"></a>暂存所有更改</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></tbody></table></figure>

<h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></tbody></table></figure>

<h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></tbody></table></figure>

<p>⚠️ 个人仓库的话提交之后一定不要忘记上传! 我在格式化电脑前忘记将本地commit上传, 失去了好几篇博文啊😢 (但应该一般没有我这么蠢的)</p>
<p>💡 在VSC中可以通过设置<code>git.enableSmartCommit</code>, <code>git.postCommitCommand</code>两项来实现<strong>暂存所有更改, 提交, 推送的一键三连</strong>😏 不过我只在自己随意写的版本库中这样用, <strong>在正规开发流程中十分不推荐提交后立即推送</strong>, 因为传到了远程端再想更改提交的内容会很麻烦. 应当完成一个阶段后再进行推送. (另外可能还需要<code>git rebase</code>等)</p>
<h3 id="git仓库瘦身"><a href="#git仓库瘦身" class="headerlink" title="git仓库瘦身"></a>git仓库瘦身</h3><p>我也终于遇到了git仓库被搞太大需要瘦身的情况了.</p>
<blockquote>
<p><a href="http://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">BFG</a> 是为将像大文件或者密码这些不想要的数据从 Git 仓库中删除而专门设计的，所以它有一一个简单的标志用来删除那些大的历史文件（不在当前的提交里面）：<code>--strip-blobs-bigger-than</code></p>
</blockquote>
<p>⚠️ 要用bfg你需要有java</p>
<ol>
<li>首先以<code>--mirror</code>选项从远程端下载仓库. 按照bfg的说法这样下到的是一个”bare repo”.</li>
</ol>
<blockquote>
<p>This is a bare repo, which means your normal files won’t be visible, but it is a full copy of the Git database of your repository</p>
</blockquote>
<p>(我试了一下普通clone的仓库操作完最后推送不上去…)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone --mirror git://example.com/some-big-repo.git</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>然后进入仓库, 然后按照文件大小或者文件名清理文件.</li>
</ol>
<p>❗️ 在这一步文件并没有在物理上被删除, 在这一步bfg会清理所有commit, branch, tag, 去掉该文件的记录.</p>
<ul>
<li>清理大于指定值的文件</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>大小超过 100MB 的任何文件（不包含在你<em>最近的</em>提交中的文件——因为 BFG <a href="http://rtyley.github.io/bfg-repo-cleaner/#protected-commits" target="_blank" rel="noopener">默认会保护你的最新提交的内容</a>）将会从你的Git仓库的历史记录中删除.</p>
</blockquote>
<ul>
<li>清理指定文件名文件:</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar bfg.jar --delete-files *.mp4</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>将上面清理出来的文件删除</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>当你觉得删得差不多就可以推送了. ❗️ 这样会改变远程端所有ref.</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></tbody></table></figure>

<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>我认为github现在已经远不止是托管代码 (也就是单纯把代码放在他的服务器) 那么简单的, 它已经建立起了一个<strong>远程协作生态</strong>.</p>
<p>关于github入门我很推荐他们的官方文档, 大部分是有中文版的, 比如:</p>
<p>🔗 <a href="https://help.github.com/cn/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener">GitHub术语表</a></p>
<p>🔗 <a href="https://github.github.com/training-kit/downloads/zh_CN/github-git-cheat-sheet/" target="_blank" rel="noopener">GitHub官方出品git使用cheat sheet</a></p>
<p>🔗 <a href="https://help.github.com/cn/github/getting-started-with-github/signing-up-for-github" target="_blank" rel="noopener">如何注册GitHub账号</a> (在这个页面左侧你可以看到还有辣么多页面值得你去看👍)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>版本控制</category>
        <category>语言</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Linux杂记</title>
    <url>/zh-CN/2019/02/27/Linux%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>最近使用Linux频繁了起来, 接触到更多各种各样的命令, 然后我脑容量不够了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span>
由于有<a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">TLDR</a>这种神器, 在这里并不会无脑记录所有看到的命令, 而是小白最常用或者不太容易懂含义的几个命令.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span>如果弄不清命令的含义, 我在
<a href="https://leojhonsong.github.io/zh-CN/%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD%E7%BC%A9%E5%86%99/">另一篇博客</a>
记录了一些缩写及对应含义, 希望有所帮助.</p>
<p>💡 推荐一个觉得很不错的Linux命令入门教程<a href="https://happypeter.github.io/LGCB/" target="_blank" rel="noopener">LGCB</a></p>
<a id="more"></a>

<h1 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h1><h2 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></tbody></table></figure>

<p>这条更加详细, 提issue时常用到</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></tbody></table></figure>

<h2 id="查看发行版版本"><a href="#查看发行版版本" class="headerlink" title="查看发行版版本"></a>查看发行版版本</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></tbody></table></figure>

<p>这个更详细:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo lsb_release -a</span><br></pre></td></tr></tbody></table></figure>

<h1 id="软件安装卸载等"><a href="#软件安装卸载等" class="headerlink" title="软件安装卸载等"></a>软件安装卸载等</h1><p>apt: <strong>Advanced Packaging Tools</strong></p>
<h2 id="源列表备份与恢复"><a href="#源列表备份与恢复" class="headerlink" title="源列表备份与恢复"></a>源列表备份与恢复</h2><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 我建议换源之前做好备份. 使用如下命令可备份<strong>source.list</strong>至
<strong>source.list_backup</strong>. 甚至再谨慎一些每次更新源列表后都可以做一份备份, 在文件名中加入时间或者更新信息来作区分.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br></pre></td></tr></tbody></table></figure>

<p>如果哪天把源列表弄脏了可以随时用一下命令恢复.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list_backup /etc/apt/sources.list</span><br></pre></td></tr></tbody></table></figure>

<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list</span><br></pre></td></tr></tbody></table></figure>

<p>另一种换源方式是进入source.list进行修改, 参见以下链接.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/ubuntu" target="_blank" rel="noopener">中科大Ubuntu镜像使用帮助</a></p>
<p>(我对这个和我校校名只有一字之差的学校还是很有好感<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>)</p>
<p>💡 其中以<strong>deb-src</strong>开头的行是源代码的地址, 只有取消这些行的注释才能下载源代码.</p>
<h2 id="包列表更新"><a href="#包列表更新" class="headerlink" title="包列表更新"></a>包列表更新</h2><p>这一命令虽然看似唰唰唰下了好些东西, 实际上只是下载了个软件目录, 然后我们执行 <code>sudo apt install
[package]</code> 的时候apt就会从这个列表中找到名字对应的下载连接之类的去下载和安装. 这就是为什么很多安装教程都会要求先执行一次这条命令 – 保证安装的是最新版.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure>

<h2 id="包升级"><a href="#包升级" class="headerlink" title="包升级"></a>包升级</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></tbody></table></figure>

<p>:warning: 需在运行<code>sudo apt update</code>后运行</p>
<h2 id="包搜索"><a href="#包搜索" class="headerlink" title="包搜索"></a>包搜索</h2><p>这怕是少数几条不用sudo的<code>apt</code>命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">apt search [package]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install [package]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="包卸载"><a href="#包卸载" class="headerlink" title="包卸载"></a>包卸载</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt remove [package]</span><br></pre></td></tr></tbody></table></figure>

<p>💡<code>apt remove</code>只会删除软件包而不会删除配置文件, 而手动删除配置文件还容易有
<a href="https://www.jianshu.com/p/f6176973b56f" target="_blank" rel="noopener">麻烦</a>, 因此不想用某软件了应当运行:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt purge [package]</span><br></pre></td></tr></tbody></table></figure>

<p>中文唤做<strong>净化</strong>! 💪</p>
<h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>有很多东西并不是用包管理工具就能轻松搞定的， 让人欲哭无泪， 主要有以下几种情况：</p>
<h3 id="下载下来的压缩包里有看着像安装脚本的玩意"><a href="#下载下来的压缩包里有看着像安装脚本的玩意" class="headerlink" title="下载下来的压缩包里有看着像安装脚本的玩意"></a>下载下来的压缩包里有看着像安装脚本的玩意</h3><p>这种一般会给出<strong>README</strong>的, 不用担心, 即便没给也可以用编辑器点开看着像安装用脚本的文件脑力运行一边看看是不是它😏 有的安装脚本是交互式的, 还是挺有趣的, 有的甚至有图形界面 (一般需要加选项才能有图形界面)</p>
<h3 id="有deb包"><a href="#有deb包" class="headerlink" title="有deb包"></a>有deb包</h3><h4 id="普通安装"><a href="#普通安装" class="headerlink" title="普通安装"></a>普通安装</h4><ol>
<li>有图形界面的话点击就能安装</li>
<li>终端进入deb包所在文件夹, 运行<code>sudo dpkg -i [package]</code></li>
</ol>
<h4 id="遇到报错"><a href="#遇到报错" class="headerlink" title="遇到报错"></a>遇到报错</h4><h5 id="修复依赖关系"><a href="#修复依赖关系" class="headerlink" title="修复依赖关系"></a>修复依赖关系</h5><p>有时候我们会因为缺少一些包而安装失败, 这个是个很容易解决的问题, 只需运行
<code>apt --fix-broken install</code>. 这样普通问题apt就能帮我们解决了✌️</p>
<p>💡另一条相同作用的命令是<code>apt install -f</code></p>
<h5 id="需要对包的依赖关系进行修改"><a href="#需要对包的依赖关系进行修改" class="headerlink" title="需要对包的依赖关系进行修改"></a>需要对包的依赖关系进行修改</h5><ol>
<li><p><strong>在要安装的deb包所在目录中</strong>创建相关文件夹:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir extract</span><br><span class="line">mkdir extract/DEBIAN</span><br><span class="line">mkdir build</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>解压出包中的文件到<strong>extract</strong>目录下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">dpkg -X [package] extract/</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>解压出包的控制信息到<strong>extract/DEBIAN/</strong>下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">dpkg -e [package] extract/DEBIAN/</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将修改后的内容重新进行打包生成deb包到<strong>build</strong>目录下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">dpkg-deb -b extract/ build/</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>进入<strong>build</strong>文件夹安装修改后的deb包</p>
</li>
</ol>
<h3 id="需要自己编译"><a href="#需要自己编译" class="headerlink" title="需要自己编译"></a>需要自己编译</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> 在搜索过程中看到
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">这篇文章</a>,
感觉对Linux下文件系统描述得很好, 比如其中说</p>
<blockquote>
<p>Linux系统中进程之外皆文件, 即便文件夹也是一个文件, 是记录了其他文件名的文件.
设备也被视为一个文件.</p>
</blockquote>
<p>再比如其中说到了
<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html/#major4" target="_blank" rel="noopener">Linux系统有多个文件系统</a>,
VFS 作为一个通用的文件系统, 抽象了文件系统的四个基本概念: 文件, 目录项
(dentry, directory entry的缩写), 索引节点 (inode) 及挂载点.</p>
<blockquote>
<p>文件名仅是为了方便人们的记忆和使用, 系统或程序通过inode号寻找正确的文件数据块.</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>ln: link</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html/#major2" target="_blank" rel="noopener">这里</a>
有对软链接与硬链接的比较. 其中:</p>
<ul>
<li>软链接以<strong>路径</strong>的形式存在,类似于Windows操作系统中的<strong>快捷方式</strong>. 硬链接以
<strong>文件副本</strong>的形式存在, 但不占用实际空间</li>
<li>软链接可以跨文件系统创建，硬链接不可以</li>
<li>软链接可以对一个不存在的文件名进行链接</li>
<li>软链接可以对目录进行链接, 硬链接不可以</li>
</ul>
<p>目前我只用到了软链, 还没有用到硬链. 个人觉得软链很方便, 它使得一个文件/文件夹在另一个地方有了一个时刻同步的备份. 比如可以像<a href="https://github.com/LeoJhonSong/vimrc" target="_blank" rel="noopener">这样</a>, 从github
下载了一个.vimrc, 将它软链到home目录 (vim默认从这里读取.vimrc). 这样一来无论是修改了这两处那一个.vimrc另一个也会同步. 这很方便将更改备份到github.</p>
<h3 id="建立软链"><a href="#建立软链" class="headerlink" title="建立软链"></a>建立软链</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ln -s [source] [destination]</span><br></pre></td></tr></tbody></table></figure>

<p>❗️要注意的是此处<code>destination</code>和<code>source</code>似乎必须写<strong>绝对路径</strong>, 不然建立的链接就是损坏的.
如果<code>destination</code>处写的是一个目录, 那会生成一个和源文件/文件夹同名的软链, 而如果<code>destination</code>
写的是一个存在的目录下一个不存在的名字, 那么会生成一个这个名字的软链, 和源文件/文件夹链接.</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>cp: copy</p>
<p>:warning: 目标位置必须已经存在, <code>cp</code>命令无法创建目录. 另外如果没有文件复制的权限会报错. <code>cp</code>命令不止可以复制, 还可以建立链接.
<code>cp</code>命令支持..表示上级文件夹等, 支持正则表达</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</p>
</li>
<li><p>-d：复制时建立软链接</p>
</li>
<li><p>-f：覆盖已经存在的目标文件而不给出提示</p>
</li>
<li><p>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span>保险起见每次都加上此选项</p>
</li>
<li><p>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</p>
</li>
<li><p>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</p>
</li>
<li><p>-l：建立硬链接, 不复制文件</p>
</li>
</ul>
<h3 id="正则使用举例"><a href="#正则使用举例" class="headerlink" title="正则使用举例"></a>正则使用举例</h3><p>将目录 <strong>/usr/men</strong> 中的以<code>m</code>打头的所有<code>.c</code>文件复制到目录 <strong>/usr/zh</strong> 中</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp /usr/men m*.c /usr/zh</span><br></pre></td></tr></tbody></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>rm: remove</p>
<h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li>-i 删除前逐一询问确认</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认</li>
<li>-r 将目录及以下之档案亦逐一删除</li>
</ul>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm [path/to/file] [path/to/another/file]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -r [path/to/folder]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="删除当前文件夹下所有文件及文件夹"><a href="#删除当前文件夹下所有文件及文件夹" class="headerlink" title="删除当前文件夹下所有文件及文件夹"></a>删除当前文件夹下所有文件及文件夹</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -r *</span><br></pre></td></tr></tbody></table></figure>

<h2 id="解压-压缩"><a href="#解压-压缩" class="headerlink" title="解压/压缩"></a>解压/压缩</h2><p>tar: tape archive. <code>tar</code> 命令原本是用来建立，还原备份文件的工具程序, 但Linux下最常见的压缩包就是tar.gz格式的. <strong>.gz</strong>是GNU zip的缩写.</p>
<p>❗️ 要注意<code>tar</code>命令无法解压 <strong>.rar</strong> 格式的压缩包, 也无法生成 <strong>.rar</strong> 格式. 需要另外安装
rar工具:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install rar</span><br></pre></td></tr></tbody></table></figure>

<p>另外在Linux下解压来自Windows的zip压缩包容易出<a href="#解压.zip压缩包中文文件名为乱码">文件名乱码问题</a>.</p>
<h3 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li>-c或–create 建立新的备份文件</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件</li>
<li>-t或–list 列出备份文件的内容</li>
<li>-v或–verbose 显示指令执行过程</li>
<li>-x或–extract或–get 从备份文件中还原文件</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件</li>
</ul>
<h3 id="列出压缩文件内容"><a href="#列出压缩文件内容" class="headerlink" title="列出压缩文件内容"></a>列出压缩文件内容</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -tvzf [source.tar.gz]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -xvzf [source.tar.gz]</span><br></pre></td></tr></tbody></table></figure>

<p>如果是.rar文件:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rar x [source.rar]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -czvf [target.tar.gz] [file1] [file2] [file3]</span><br></pre></td></tr></tbody></table></figure>

<p>如果是要压缩成.rar文件 (不是别人要求的话不推荐):</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rar a [compressede_package_name] [source_folder_name]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="格式化U盘"><a href="#格式化U盘" class="headerlink" title="格式化U盘"></a>格式化U盘</h2><p>虽然在 Ubuntu 下图形化界面里可以无脑格式化U盘, 但是有时候U盘出问题的时候需要在命令行蛮力格式化.
此处以U盘为 <strong>/dev/sdb1</strong> 为例.</p>
<p>首先确保U盘未挂载:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo umount /dev/sdb1</span><br></pre></td></tr></tbody></table></figure>

<p>然后将之格式化为FAT32格式(Linux, Windows都可识别的格式):</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo mkfs.vfat -F 32 /dev/sdb1</span><br></pre></td></tr></tbody></table></figure>

<p>这样之后可以回图形界面设置U盘的名字或者重新格式化为其他格式之类.</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><h3 id="查看所有环境变量"><a href="#查看所有环境变量" class="headerlink" title="查看所有环境变量"></a>查看所有环境变量</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export -p</span><br></pre></td></tr></tbody></table></figure>

<h3 id="查看PATH"><a href="#查看PATH" class="headerlink" title="查看PATH"></a>查看PATH</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></tbody></table></figure>

<h3 id="查看当前运行shell"><a href="#查看当前运行shell" class="headerlink" title="查看当前运行shell"></a>查看当前运行shell</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></tbody></table></figure>

<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> shell不止一种, 大多数Linux系统默认shell为
<strong>Bash shell</strong> (Bourne Again shell), 似乎<strong>Bourne shell</strong>仍是许多Unix系统默认的shell. 比较著名的还有
<strong>Z shell</strong> (Zsh), <strong>friendly interactive shell</strong> (fish).</p>
<h2 id="添加路径到PATH"><a href="#添加路径到PATH" class="headerlink" title="添加路径到PATH"></a>添加路径到PATH</h2><h3 id="临时添加"><a href="#临时添加" class="headerlink" title="临时添加"></a>临时添加</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export PATH=[path/to/append]:$PATH</span><br></pre></td></tr></tbody></table></figure>

<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 应注意export命令仅作用于当前终端.</p>
<p>:bulb: 在有些文档中会使用下面这样的方式来添加路径到PATH, 但我觉得这样不够稳妥. 因为用下面这种方式的话如果这个变量原本不存在, 假如我们添加<code>/usr/bin/bash</code>到PATH, 那么当我们使用
<code>echo $PATH</code>来查看PATH变量的值会发现其值为 <strong>:/usr/bin/bash</strong>. 这是因为bash会将
<strong>PATH=</strong>后的视为一整个字符串, 而 <strong>$PATH</strong>是取PATH现在的值的意思. 个人认为<code>/usr/bin/bash:</code>
比<code>:/usr/bin/bash</code> OK一些<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">😅</span></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export PATH=$PATH:[path/to/append]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="永久添加"><a href="#永久添加" class="headerlink" title="永久添加"></a>永久添加</h3><p>首先我们需要了解哪些文件与环境变量有关.</p>
<p>在Linux系统中<strong>最常见</strong>与环境配置有关的文件是四个shell初始化文件, 想要添加环境变量最常见的方法就是将命令添加到适当文件中, 这样每当shell被唤起, 在初始化时, 环境变量都会被添加进去.
但但不同情况下会加载不同的初始化文件, 究竟需要更改哪一个/几个呢? 他们的比较如下:</p>
<table>
<thead>
<tr>
<th></th>
<th><code>/etc/profile</code></th>
<th><code>/etc/bash.bashrc</code></th>
<th><code>~/.profile</code></th>
<th><code>~/.bashrc</code></th>
</tr>
</thead>
<tbody><tr>
<td>等级</td>
<td>系统级</td>
<td>系统级</td>
<td>用户级</td>
<td>用户级</td>
</tr>
<tr>
<td>自动加载的情况</td>
<td>login shell</td>
<td>interactive shell</td>
<td>login shell</td>
<td>interactive shell</td>
</tr>
<tr>
<td>作用于哪些shell</td>
<td>Bourne系shell</td>
<td>仅Bash</td>
<td>Bourne系shell</td>
<td>仅Bash</td>
</tr>
<tr>
<td>加载顺序</td>
<td>先</td>
<td>先</td>
<td>后</td>
<td>后</td>
</tr>
</tbody></table>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span>关于何时哪个文件会被加载也可以参考<a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_01_02.html" target="_blank" rel="noopener">这里</a></p>
<p>:warning: 在有些系统中不是<code>/etc/bash.bashrc</code>, 而是<code>/etc/bashrc</code></p>
<p>:warning: <code>/etc/profile</code>仅针对Bourne系shell是指当shell为Bourne Shell, Bash, ksh
等的时候<code>/etc/profile</code>才可能被加载, 而当我唤起一个<strong>zsh</strong>时, <strong>以上四个初始化文件都没有被加载</strong>
<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8">🤷♂</span></p>
<p>:warning: 在用户目录可能还存在<code>~/.bash_profile</code>, <code>~/.bash_login</code>这两文件, 系统会依次查找<code>~/.bash_profile</code>, <code>~/.bash_login</code> 和 <code>~/.profile</code>这三个配置文件, 读取和执行这三个中的<strong>第一个</strong>存在且可读的文件中命令, 因此建议将三个合并为一个.</p>
<p>:warning: 当<strong>bashrc</strong>一系和<strong>profile</strong>一系都会被加载时两者哪个会先被加载并不一定, 有点玄学… 经我测试运行<code>bash -cl bash</code> <strong>profile</strong>一系会先被加载, 而运行
<code>bash -l</code>则<strong>bashrc</strong>一系会先被加载<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span> 但很明确的一点是:
系统级初始化文件一定会先与用户级文件被加载. 即便根据应当允许用户个性化设置这种尝试也能推断出 (用户级初始化文件后于系统级初始化文件被加载, 所以用户级文件中的配置会覆盖系统级文件的对应配置)</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span>有关四种shell模式个人感觉坑挺多的:</p>
<ul>
<li><p><strong>login shell</strong>: 笼统地理解就是有<strong>输入用户名和密码</strong>这一过程才能进入的shell, 比如
<strong>通过ssh访问远程服务器</strong>, 否则就是<strong>non-login shell</strong> 但是! 比如<strong>通过<code>su</code>切换用户</strong>时默认进入的是<strong>non-login shell</strong>,
如需切换用户进入login shell需要加选项<code>-l</code><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span> 还有, 经过GitHub
广大网友建议, <strong>进入WSL</strong>默认进入的是<strong>login shell</strong>, 即便你并没有输入用户名密码.</p>
</li>
<li><p><strong>interactive shell</strong>指的是你一句电脑一句这样交互式的终端, 而<strong>no-interactive shell</strong>
指的是<strong>通过脚本</strong>, <strong>运行<code>bash -c [command]</code></strong>之类指哪打哪和电脑没有交流的shell.</p>
</li>
<li><p>检测当前是login shell还是non-login shell: 有一个特点是login模式运行的shell进程名第一个字符是-, 因此如果你输入<code>echo $0</code>输出的是<strong>-bash</strong>, 那么你就是在login shell中,
如果是<strong>bash</strong>, 那就是在non-login shell中.</p>
</li>
</ul>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8">🌟</span>有了以上的知识储备我们就知道需要将环境变量添加到什么文件里了.</p>
<h2 id="删除一个环境变量"><a href="#删除一个环境变量" class="headerlink" title="删除一个环境变量"></a>删除一个环境变量</h2><h3 id="临时删除"><a href="#临时删除" class="headerlink" title="临时删除"></a>临时删除</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export -n [VARIABLE]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h3><p>参考永久添加的操作.</p>
<h2 id="系统命令软链"><a href="#系统命令软链" class="headerlink" title="系统命令软链"></a>系统命令软链</h2><p>⭐️⭐️⭐️ <code>update-alternatives</code>是一条十分实用的命令! 这是Debian一系系统 (比如Ubuntu)
中创建, 删除, 管理系统命令软链的工具. 在一个系统中同时存在同一软件的多个版本是很常见的事, 比如
python2和python3并存, gcc多个版本并存. 当在命令行输入<code>python</code>时到底该进入python2还是
python3呢? update-altenatives能够帮助我们.</p>
<h3 id="创建-添加一个系统命令软链"><a href="#创建-添加一个系统命令软链" class="headerlink" title="创建/添加一个系统命令软链"></a>创建/添加一个系统命令软链</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --install [path/to/system_link] [command_name] [path/to/command_binary] [priority]</span><br></pre></td></tr></tbody></table></figure>

<p>几个参数分别是: 系统命令的链接, 系统命令名, 要用系统命令调用的软件的二进制文件的链接, 优先级大小</p>
<p>以<strong>python</strong>这个命令举例:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/python python /home/leo/anaconda3/bin/python3 100</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置系统命令软链"><a href="#配置系统命令软链" class="headerlink" title="配置系统命令软链"></a>配置系统命令软链</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --config [command_name]</span><br></pre></td></tr></tbody></table></figure>

<p>alternative软链系统会把优先级数值最大的一个软件二进制文件链接作为当前该系统命令链接到的二进制文件地址, 因此比如要改变python版本只需调整优先级大小.</p>
<h3 id="删除一个系统命令软链"><a href="#删除一个系统命令软链" class="headerlink" title="删除一个系统命令软链"></a>删除一个系统命令软链</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --remove [path/to/system_link] [command_name] [path/to/command_binary] [priority]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h1><h2 id="显示文件内容"><a href="#显示文件内容" class="headerlink" title="显示文件内容"></a>显示文件内容</h2><p>cat: concatenate</p>
<h3 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><p>-n 或 –number：由 1 开始对所有输出的行数编号。</p>
</li>
<li><p>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。</p>
</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>cat 也可以用来制作镜像文件. 例如要制作软盘的镜像文件, 将软盘放好后输入：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /dev/fd0 &gt; [OUTFILE]</span><br></pre></td></tr></tbody></table></figure>

<p>相反的, 如果想把 image file 写到软盘, 输入：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat [IMG_FILE] &gt; /dev/fd0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="覆盖目标文件的写入"><a href="#覆盖目标文件的写入" class="headerlink" title="覆盖目标文件的写入"></a>覆盖目标文件的写入</h2><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>一定别和添加内容到文件的命令搞混了!</p>
<h3 id="写入一些文件的内容"><a href="#写入一些文件的内容" class="headerlink" title="写入一些文件的内容"></a>写入一些文件的内容</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat [file1] [file2] &gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="写入一个字符串"><a href="#写入一个字符串" class="headerlink" title="写入一个字符串"></a>写入一个字符串</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo ["string"] &gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="添加到目标文件的写入"><a href="#添加到目标文件的写入" class="headerlink" title="添加到目标文件的写入"></a>添加到目标文件的写入</h2><h3 id="写入一些文件的内容-1"><a href="#写入一些文件的内容-1" class="headerlink" title="写入一些文件的内容"></a>写入一些文件的内容</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat [file1] [file2] &gt;&gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="写入一个字符串-1"><a href="#写入一个字符串-1" class="headerlink" title="写入一个字符串"></a>写入一个字符串</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo ["string"] &gt;&gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /dev/null &gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="文件权限设置"><a href="#文件权限设置" class="headerlink" title="文件权限设置"></a>文件权限设置</h1><p>chmod: change file mode bits</p>
<p>chown: change file owner and group</p>
<h2 id="所有人可运行"><a href="#所有人可运行" class="headerlink" title="所有人可运行"></a>所有人可运行</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod a+x</span><br></pre></td></tr></tbody></table></figure>

<p>拥有者, 群组可读写, 运行, 其他用户可读, 执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod 755</span><br></pre></td></tr></tbody></table></figure>

<p>用一个三位八进制数来表示文件权限, 规定4, 2和1表示读、写、执行权限, 每一位都是这三个数相加的结果, 三位分别表示u (user), g (group), o (others).</p>
<h1 id="后台不挂起运行"><a href="#后台不挂起运行" class="headerlink" title="后台不挂起运行"></a>后台不挂起运行</h1><p>通过在命令尾加上<code>&amp;</code>可以让命令在后台运行. <strong>后台运行</strong>是指<strong>当前进程不在前台占用屏幕</strong>. 后台运行的程序一样会把输出显示到终端, 通常通过在命令末尾加上<code>1&gt;/dev/null
2&gt;error.log</code> 将标准输出重定向至黑洞 (<code>/dev/null</code>是一个很特殊的设备, 写入它的内容都会被丢弃, 而读取它会得到EOF), 输出标准错误输出到当前文件夹的<code>error.log</code>.</p>
<p>💡 <code>&amp;</code>能让进程在后台运行, 但<strong>一旦当前终端关闭这个进程就会被挂起</strong>. 当进程被切换到后台, 称为<strong>job</strong></p>
<p>而<code>nohup [command]</code>能让进程不挂起地运行, 即退出当前终端进程仍然在运行. 但这条命令会一直占据终端而且不再接受输入, 因此关闭这个终端会提示还有程序在运行, 强行关闭的话这条命令就会被终止, 就更不用说不挂起运行了.</p>
<p>如果想不挂起后台运行要用下面这条. 这样关闭当前终端程序也会继续运行了😄</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nohup [command] &amp; 1&gt;/dev/null 2&gt;error.log</span><br></pre></td></tr></tbody></table></figure>

<p>💡 丢弃标准输出并将标准错误输出重定向到当前文件夹的<code>error.log</code>是我的习惯, 当然你可以重定向到别的地方.</p>
<h1 id="TCP-UDP工具"><a href="#TCP-UDP工具" class="headerlink" title="TCP/UDP工具"></a>TCP/UDP工具</h1><p>nc: netcat, 是一个读写TCP/UDP协议下数据的工具.</p>
<p>我感觉netcat能当作Windows下的TCP调试助手, 但也有远比TCP调试助手多的功能和用途,是很强大的工具, 但得自己加选项来实现各种功能, 可能还需要和其他工具配合, 使用不是很直观.</p>
<p>常用选项:</p>
<ul>
<li>-l listen, 监听</li>
<li>-u 使用UDP协议而不是默认的TCP协议</li>
<li>-v 显示详细信息</li>
<li>-z 指定nc只扫描端口而不发送数据过去, 不能和-l选项一起用</li>
<li>-w 一定时间内无法连接则timeout, 单位为秒</li>
</ul>
<p>我目前遇到的几种用法:</p>
<h2 id="监听某端口"><a href="#监听某端口" class="headerlink" title="监听某端口"></a>监听某端口</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>

<p>❗️ nc的manpage说在建立链接后就不要在意哪边是server哪边是client了.</p>
<h2 id="发送一段16进制的ASCII码"><a href="#发送一段16进制的ASCII码" class="headerlink" title="发送一段16进制的ASCII码"></a>发送一段16进制的ASCII码</h2><p>在看网友们实现这个时我体会到了linux命令是多么强大, 以下收录几个例子</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo '0006303030304e43' | xxd -r -p | nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo -ne '\x00\x06\x30\x30\x30\x30\x4e\x43' | nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo -ne "$(echo '0006303030304e43' | sed -e 's/../\\x&amp;/g')" | nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>

<h2 id="以16进制显示接收到的信息"><a href="#以16进制显示接收到的信息" class="headerlink" title="以16进制显示接收到的信息"></a>以16进制显示接收到的信息</h2><p>hd: hexdump
xxd: make a hexdump or do the reverse</p>
<p>hexdump和xxd都可以将数据转为16进制, 但体验后我觉得xxd更易记, 显示更直观.</p>
<p>xxd默认按单字节转换, 而hexdump默认按双字节小端转换, 差评.</p>
<h3 id="按单字节以一定格式显示"><a href="#按单字节以一定格式显示" class="headerlink" title="按单字节以一定格式显示"></a>按单字节以一定格式显示</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc localhost 8000 | xxd -c [cols]</span><br></pre></td></tr></tbody></table></figure>

<p>选项-c指定一行显示列数, 如果显示的数据是定长的话设置为数据长度很舒服. xxd默认两字节一组显示, 即两个字节间一个空格, 可以用<code>-g [bytes]</code>指定几个字节一组.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc localhost 8000 | hexdump -C</span><br></pre></td></tr></tbody></table></figure>

<p>选项-C指定按单字节以一定格式显示. 这个格式可以看hexdump的manpage下<code>-C</code>选项的描述</p>
<p>不过看manpage似乎hexdump支持的骚显示方式更多.</p>
<h2 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc -v -n -z -w 1 localhost 1-1000</span><br></pre></td></tr></tbody></table></figure>

<p>nc甚至可以通过重定向文件描述符来在端口使用终端 🐮🍺</p>
<p>在nc的manpage可以找到操作方式.</p>
<h1 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h1><h2 id="Ubuntu开机紫屏"><a href="#Ubuntu开机紫屏" class="headerlink" title="Ubuntu开机紫屏"></a>Ubuntu开机紫屏</h2><p>linux文件系统损坏导致的不正常开/关机, 此时一般等一等系统就会提示你进行文件系统修复.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">fsck -a /dev/sda1</span><br></pre></td></tr></tbody></table></figure>

<p>一般用这条命令修复. fsck (file system check) 是检测与修复文件系统的命令.<code>-a</code>选项会报告损坏
block并自动修复 (反正手动修复也只是确认是否修复).</p>
<p>具体参考<a href="https://blog.csdn.net/liujianlin01/article/details/82937708" target="_blank" rel="noopener">这里</a></p>
<h2 id="Ubuntu烦人的开机报错"><a href="#Ubuntu烦人的开机报错" class="headerlink" title="Ubuntu烦人的开机报错"></a>Ubuntu烦人的开机报错</h2><p>把这个报错关了就完事了😁</p>
<p>参考<a href="https://www.cnblogs.com/greatfish/p/8042026.html" target="_blank" rel="noopener">Ubuntu开机弹出System porgram detected</a></p>
<h2 id="ibus的中文输入法无法选择除第一个的候选词bug"><a href="#ibus的中文输入法无法选择除第一个的候选词bug" class="headerlink" title="ibus的中文输入法无法选择除第一个的候选词bug"></a>ibus的中文输入法无法选择除第一个的候选词bug</h2><p>需要删除几个缓存的数据库文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo rm -rf ~/.cache/ibus/libpinyin/</span><br></pre></td></tr></tbody></table></figure>

<p>这个issue具体参考<a href="https://github.com/libpinyin/ibus-libpinyin/issues/127" target="_blank" rel="noopener">这里</a></p>
<p>⭐️推荐直接换掉ibus转用<strong>fcitx</strong>. fcitx的中文输入法推荐<strong>GooglePinyin</strong>, 日语输入法推荐
<strong>Mocz</strong>. 通过以下命令可以安装.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装谷歌拼音</span></span><br><span class="line">sudo apt install fcitx-googlepinyin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Mocz日语输入法</span></span><br><span class="line">sudo apt install fcitx-mozc</span><br></pre></td></tr></tbody></table></figure>

<p>❗️值得一提的是fcitx的输入法分激活和非激活 (通常将英语设为非激活), 输入法切换快捷键也分两种,
一种在非激活输入法和激活输入法间切换, 一种在激活输入法间切换.</p>
<h2 id="没有显卡驱动无法正常显示"><a href="#没有显卡驱动无法正常显示" class="headerlink" title="没有显卡驱动无法正常显示"></a>没有显卡驱动无法正常显示</h2><p>有时候买了不靠谱的显卡可能你的发行版中没有, 或者你安装的时候没有安装对应的驱动, 因此开机后可能是花屏或者黑屏. 解决方法是: 开机时在grub界面按 <code>e</code> 进入编辑模式将什么什么splash后的—改为 
<code>nomodeset</code>. 这样就会让内核不改变显示设置, 保证至少能看到东西. (但这模式很有可能显示出来辣眼睛😅)</p>
<h2 id="解压-zip压缩包中文文件名为乱码"><a href="#解压-zip压缩包中文文件名为乱码" class="headerlink" title="解压.zip压缩包中文文件名为乱码"></a>解压.zip压缩包中文文件名为乱码</h2><p>当我在Ubuntu1804像往常解压<code>.tar.gz</code>文件那样用右键菜单的<strong>extract here</strong>解压<code>.zip</code>文件后我发现中文文件名全部变成了乱码, 文件里面倒是没问题.</p>
<p>这是因为<strong>zip压缩包并没有指明编码格式</strong>, 解压工具会以Linux的默认编码格式<strong>UTF-8</strong>解压, 而在系统语言为简体中文的Windows系统下默认<strong>字符集</strong>为<code>GBK</code>, <strong>编码格式</strong>为<code>EUC-CN</code>, 所以会文件名乱码.</p>
<p>我目前的解决方法是命令行输入以下命令解压.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">unzip -O cp936 [filename]</span><br></pre></td></tr></tbody></table></figure>

<p>此处选项<code>-O</code>指以指定编码格式解压. <strong>cp936</strong>指<a href="https://en.wikipedia.org/wiki/Code_page_936_(Microsoft_Windows)" target="_blank" rel="noopener">微软编写的代码页936页</a>的编码格式
(注意与<a href="https://en.wikipedia.org/wiki/Code_page_936_(IBM)" target="_blank" rel="noopener">IBM的code page936</a>区别),
即字符集为GBK, 编码格式为EUC-CN. (经我实验UTF-8编码的文件名以cp936编码解压出来显示正常…
我也不知道为什么)</p>
<h2 id="Linux系统时间和Windows系统时间差8小时"><a href="#Linux系统时间和Windows系统时间差8小时" class="headerlink" title="Linux系统时间和Windows系统时间差8小时"></a>Linux系统时间和Windows系统时间差8小时</h2><p>这个问题蛮有意思的:</p>
<p>Linux系统将硬件时间 (BIOS中的时间) 作为系统的<strong>UTC时间</strong>, 而Windows系统将硬件时间作为<strong>本地时间</strong>.也就是说如果现在我有一台在北京 (东八区) 的电脑, <strong>BIOS时间</strong>
为8:30 (24小时制), 那<strong>Linux系统时间</strong>为16:30, <strong>Windows系统时间</strong>为8:30.</p>
<p>因此Linux系统时间与Windows系统时间有时差是正常的 (可以通过设置让Windows系统将硬件时间作为UTC时间). 但我的Linux和Windows系统都开启了网络校时功能, 理论上即便存在上述问题也不应当表现出来, 而应是开机后自动校准了. 我面临的问题是Linux系统时间是准确的,而Windows系统时间总是早了8小时, 这说明Windows系统的网络校时功能未生效.</p>
<p>后来我发现是有个叫<strong>Windows Time</strong>的服务 (网络校时功能在这个服务里) 的启动类型不合理 (<strong>服务</strong>可以通过在开始搜索框搜索打开). 这个服务的缺省启动类型为<code>手动(触发器启动)</code>, 也就是说需要通过我们手动在某处触发. (与另一种启动类型<code>手动</code>的区别是后者只能在<strong>服务</strong>页面手动启动)举例来说, 每次我从Linux系统关机,重启打开Windows系统后, Windows系统显示的时间是不准确的, 此处<strong>Windows Time</strong>服务因为未触发,处于未运行状态, 而当我在设置的时间与地区里手动关闭 <strong>“自动设置时间”</strong> 再打开后, 我发现
<strong>Windows Time</strong>服务此时已经处于运行状态了.</p>
<p>🤦‍… 没准是微软的锅? 咱也不知道, 咱也不敢问.</p>
<p>当我将这个服务的启动类型设置为<code>自动(延迟启动)</code> (延迟启动指在所有系统服务启动后再启动本服务) 后问题解决.</p>
<h2 id="fcitx无法用Super-Space切换输入法"><a href="#fcitx无法用Super-Space切换输入法" class="headerlink" title="fcitx无法用Super+Space切换输入法"></a>fcitx无法用Super+Space切换输入法</h2><p>这是因为这个组合键被系统的输入法切换快捷键占用了. 在系统设置里 <strong>Devices -&gt;
Keyboard -&gt; Switch to next input source</strong> 关掉这个快捷键就可以了.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>我发布了扩展包!</title>
    <url>/zh-CN/2019/02/27/%E6%88%91%E5%8F%91%E5%B8%83%E4%BA%86%E6%89%A9%E5%B1%95%E5%8C%85/</url>
    <content><![CDATA[<p>看了Poy Chang 的<a href="https://poychang.github.io/build-vscode-extension/" target="_blank" rel="noopener">制作VSC扩展包</a>,
<a href="https://poychang.github.io/publish-extension-to-visual-studio-marketplace/" target="_blank" rel="noopener">发布扩展包至 Extension Marketplace</a>
两篇文章, 我兴趣大发, 也发布了自己的扩展包!</p>
<a id="more"></a>

<p>首先说说为什么想糊几个扩展包:</p>
<ol>
<li>好有趣, 假装自己也写了好几个很有用的扩展, 装逼利器</li>
<li>如果VSC启用了过多插件启动得会很慢, 但一个一个禁用插件又很费事. 但有趣的是只要禁用一个扩展包其中包含的扩展都会被禁用, 因此我把我使用的扩展按用途分类做成了扩展包. 这样批量禁用超方便👍</li>
</ol>
<p>实际上Poy说得很详细, 制作也很简单, 毕竟我只是想制作个扩展包, 只要把大佬们的插件整合一番就好了.
一套流程大致有以下几个步骤:</p>
<ol>
<li><p>安装 yeoman 和 VSC扩展生成器(我自己瞎翻译的), 安装VSC扩展管理工具(还是瞎翻译的)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br><span class="line">npm install -g vsce</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注册成为开发者, 搞到一个 <strong>Personal Access Tokens</strong></p>
<p>💡 Poy提供的注册接口我无法进入, 推荐点击 <a href="https://visualstudio.com" target="_blank" rel="noopener">https://visualstudio.com</a> 后登陆微软账号, 就能看到很明显的注册开发者账号的按钮了✌️<br>⚠️ 这个 token 一定要保存好阿, 这混蛋玩意只显示这一次, 而你有可能多次用到</p>
</li>
<li><p>生成扩展包模板</p>
</li>
<li><p>把扩展包的显示名, 扩展包的名字 (显示名和名字是不一样的, 你的扩展包显示名可以和其他人的重名,
但每个扩展的名字是唯一的), 概述, 随便想的版本号, 作者名, 扩展包的图标的地址,
在github的仓库地址, 想收录进扩展包的扩展的名字统统塞进 <strong>package.json</strong> .</p>
</li>
<li><p>糊一糊 <strong>README</strong> 和 <strong>CHANGELOG.md</strong></p>
</li>
<li><p>发布!</p>
</li>
</ol>
<p>这里是我发布的几个扩展包, 欢迎体验!</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.coding-assist-extension-pack" target="_blank" rel="noopener">Coding Assist Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.markdown-extension-pack" target="_blank" rel="noopener">Markdown Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.latex-extension-pack" target="_blank" rel="noopener">LaTeX Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.web-extension-pack" target="_blank" rel="noopener">Web Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.python-extension-pack" target="_blank" rel="noopener">Python Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.ccpp-extension-pack" target="_blank" rel="noopener">C/C++ Extension Pack</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>传感器滤波有感</title>
    <url>/zh-CN/2019/03/06/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%BB%A4%E6%B3%A2%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>滤波</category>
      </categories>
  </entry>
  <entry>
    <title>关于Linux下开发单片机的猜测</title>
    <url>/zh-CN/2019/03/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%8C%9C%E6%B5%8B/</url>
    <content><![CDATA[<p>现在也算个Linux爱好者啦, 但在Linux下怎么配置单片机开发环境我一直一头雾水, 直到最近我找到了相关文章!</p>
<a id="more"></a>

<p>💡 目前已经有
<a href="http://docs.platformio.org/en/stable/what-is-platformio.html" target="_blank" rel="noopener">PlatformIO</a>可以让我们进行大部分单片机, 嵌入式系统的开发, 但也有部分开发板他们还没有收录, 除了向项目提issue, 我们也可以尝试不用PlatformIO配置一套Linux下单片机开发环境.</p>
<p>网上虽然也有那么些讲在Linux开发单片机的文章, 但我看到的基本是开发C51, 顶多是有开发STM32的.
我是觉得没人会费事在 Linux 下开发C51, 反正我想开发的比如
<a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/xc2200-family-body/xc22xxm-series/sak-xc2267m-104f80lr-ab/" target="_blank" rel="noopener">英飞凌 (infineon) 的 XC2267M</a>,
<a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-based-processors-and-mcus/kinetis-cortex-m-mcus/k-seriesperformancem4/k6x-ethernet/kinetis-k60-100-mhz-mixed-signal-integration-microcontrollers-based-on-arm-cortex-m4-core:K60_100" target="_blank" rel="noopener">飞思卡尔 (Freescale) 的 k60</a>
之类是没看到相关文章🤷‍</p>
<p>🌟🌟🌟 最近我看到了两篇配置英飞凌XMC系列单片机开发环境的文章!
<a href="https://github.com/notandy/xmc4500-relax-linux" target="_blank" rel="noopener">xmc4500-relax-linux</a>讲述了在
Linux开发xmc4500需要什么工具以及编译方式,
<a href="https://github.com/furtnerthomas/Linux-XMC-Development" target="_blank" rel="noopener">Linux-XMC-Development</a>
则<strong>十分详细</strong>地讲述了如何配置基于<strong>eclipse</strong>的XMC系列单片机开发环境.</p>
<p>🔗 参考:</p>
<ul>
<li><a href="https://blog.csdn.net/thinkerleo1997/article/details/53145972" target="_blank" rel="noopener">在Linux下搭建51单片机的开发烧写环境</a></li>
<li><a href="https://www.amobbs.com/thread-5568167-1-1.html" target="_blank" rel="noopener">ubuntu下安装stm32开发环境 秒杀keil和IAR</a></li>
<li><a href="https://www.cnblogs.com/amanlikethis/p/3803736.html#lab35" target="_blank" rel="noopener">Linux下STM32开发环境的搭建</a></li>
</ul>
<p>参考以上几篇文章我明白了单片机开发都是以下流程, 那我猜只要找到对应工具就OK了:</p>
<ol>
<li>交叉编译生成 bin 或者 hex 文件</li>
<li>烧录到单片机</li>
<li>调试</li>
</ol>
<p>也就是说我们找到对应的交叉编译器, 烧录工具, 调试工具就可以了.</p>
<p>而什么是对应工具, 要在哪里找到对应工具这个问题又让我苦恼了一阵子, 但后来我发现特么就在每个单片机的页面上! (也可能是在该单片机的系列介绍页面)</p>
<p>比如 Infineon XC2267M 的交叉编译工具, 调试工具, 烧录工具都在
<a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/xc2200-family-body/xc22xxm-series/#!tools" target="_blank" rel="noopener">这里</a>
列了出来! 当然有些工具是收费的, 但<a href="http://www.infineonic.org/module/forum/thread-554295-1-1.html" target="_blank" rel="noopener">这都不是事</a>😁. 不过似乎这个免费版<a href="http://www.infineonic.org/module/forum/thread-487158-1-1.html" target="_blank" rel="noopener">有点点局限</a></p>
<p>另一款我提到的k60芯片也在介绍页面给出了相关工具的链接.</p>
<p>不过看起来很多工具都是基于Eclipse的. (但我觉得Eclipse的图标不好看所以就用过一次)</p>
<p>🔗 更多相关链接</p>
<ul>
<li><a href="https://blog.csdn.net/passerbyyuan/article/details/51404226" target="_blank" rel="noopener">单片机的下载方式分类</a></li>
<li><a href="https://blog.csdn.net/qlexcel/article/details/84374768" target="_blank" rel="noopener">程序编译生成的Hex、Bin、axf和elf格式</a></li>
<li><a href="http://www.21ic.com/jichuzhishi/mcu/write/2014-03-20/216132.html" target="_blank" rel="noopener">单片机ISP、IAP和ICP几种烧录方式的区别</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>配置</category>
        <category>Linux</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>对伺服电机PID的理解</title>
    <url>/zh-CN/2019/03/27/%E5%AF%B9%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BAPID%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>行吧, 继上次手搓简单卡尔曼算法后我又接触到了更多控制方面的东西. 想我一个电子工程的弟弟在这里研究术语都不知道几个的控制… 命苦啊! 最近在调机械腿, 应该说还在调那条腿, 对伺服电机里的PID算法有了些许感悟.</p>
<a id="more"></a>

<p>这条腿的传感噪声问题因为换了传感器已经解决了, 最近的问题是<strong>不能快速, 稳定, 准确的到达指定位置</strong>. 目前通过<strong>限制电机的加速度</strong>改善了情况.</p>
<h1 id="PID也没有那么简单"><a href="#PID也没有那么简单" class="headerlink" title="PID也没有那么简单"></a>PID也没有那么简单</h1><p>在改动前机械腿在低速状态 (很低速那种) 下表现得还是蛮好的, 但速度一旦快起来就明显有<strong>过冲</strong>, 是一抖一抖运动的, 到达位置时间反而比低速还长… 虽然我以前买了一个很简陋的四轴穿越机调过一点点PID, 感觉这算法也不难理解 (至少比卡尔曼好理解😁), 但这次发现要达到一定的精度PID也不是那么简单的东西: 经常是 “这参数加了20了怎么毛的变化都没有啊 黑人问号”, 但实际用起来又确实地感受到了差别. 并且当情况复杂的时候一个普通PID是不能满足的, 可能会用串级PID, 分段PID, 模糊PID, 专家系统PID, 容错PID, 前馈, 非线性控制之类的来改善😵</p>
<p>🔗 参考: <a href="https://www.zhihu.com/question/22603676/answer/28847509" target="_blank" rel="noopener">关于永磁同步电机交流伺服控制系统的算法问题？ - 小心假设的回答 - 知乎</a></p>
<h1 id="PI-·-PD-·-PID"><a href="#PI-·-PD-·-PID" class="headerlink" title="PI · PD · PID"></a>PI · PD · PID</h1><p>另外我知道了在工业中说是说PID控制器, 但<strong>实际大多是PI控制器</strong>, 因为D虽然可以增大系统阻尼, 使系统具有一定预见性, 增强了对微小变化的响应, 但也因此造成系统容易震荡, 不稳定. 而根据网上说的<strong>I比D更容易引起不稳定, 因为I引入了另一个极点.</strong> 具体啥时候用PI, PD, PID我还没有头绪.</p>
<p>🔗 参考:</p>
<ul>
<li><a href="https://www.zhihu.com/question/26944678/answer/44687208" target="_blank" rel="noopener">哪些控制类的算法惊艳了你？ - 三郎的回答 - 知乎</a></li>
<li><a href="http://www.sohu.com/a/155185294_464086" target="_blank" rel="noopener">PID控制算法精华和参数整定三大招</a></li>
</ul>
<h1 id="三环控制"><a href="#三环控制" class="headerlink" title="三环控制"></a>三环控制</h1><p>再有就是我大致理解了伺服电机三环PID是一种多么精妙而自然的设计.</p>
<p>在调PID的时候我和师兄一度绝望, 我就说: “要不我们只保留转距环, 上层的我们重新写一遍.”当时我们使用的是<strong>位置模式</strong>控制电机. 我看电机驱动器的说明书都看得晕呼呼的, 还没怎么理解三环控制.
但我要保留转距环的想法是很正常的:</p>
<p>电机最基本的控制方式就是控制流过电机的电流, 也就是控制电机输出的转距. 在这一环里不是单纯的PID, 驱动器还设置了一些阈值, 防止过流烧坏电机什么的. 这一环是驱动器自整定的, 但效果也不错, 因此我认为不必自己重写这一环.</p>
<p>然后我说:”上层我们用一个PID, 达到: 当当前位置比目标位置小就加正向转距, 当当前位置比目标位置大时加逆向转距的效果.”</p>
<p>学长立即指出这样机械腿到达位置时的<strong>速度是不定的</strong>.我:”那就加一环速度PID, 生成一个百分数乘以转距来达到控制达到目标位置时的速度的效果”</p>
<p>说完我一愣, 我特么这不是说了一遍<strong>电流环, 速度环, 位置环</strong>的所谓<strong>三环控制</strong>🐴</p>
<p>🔗 参考:</p>
<ul>
<li><a href="http://www.voidcn.com/article/p-hxjakzgh-pw.html" target="_blank" rel="noopener">伺服电机三环控制的原理（位置环，运动环，电流环）</a></li>
<li><a href="https://blog.csdn.net/Andy20081251/article/details/79457911" target="_blank" rel="noopener">浅谈伺服电机三种控制方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21311021" target="_blank" rel="noopener">伺服电机的控制方式简述</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>控制</category>
      </categories>
  </entry>
  <entry>
    <title>常见术语缩写</title>
    <url>/zh-CN/2019/03/02/%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<p>作为一个非英语母语的程序员, 经常看到各种奇奇怪怪的缩写让人摸不到头脑, 而如果能知道这些拼凑起来的字母是什么的缩写的话, 不仅便于记忆, 也便于理解. 另外能知道点冷知识还是很有意思
<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62c.png?v8">😬</span>因此在此记录我看到的各种缩写.
(英文中缩写分为Acronym, 首字母缩写和Abbreviation, 单词简写两种, 此处所说缩写<strong>主要指
abbreviation</strong>)</p>
<a id="more"></a>

<p>原本我想开一个GitHub仓库号召大家一起贡献的, 但随后我发现了
<a href="https://acronyms.thefreedictionary.com/ps" target="_blank" rel="noopener">这个网站</a>, 一方面看到有类似的工具了
(这个网站很不错的!),
一方面大家也可以看到<code>ps</code>这一个词在各种领域都有特定的含义, 总共多达248种全称, 如果我开的仓库也将所有对应全称收录的话, 过多的含义反而让它变得很鸡肋, 而只收录一些领域的含义未免小众. 因此决定只记录一下我认为有必要记录的缩写与对应全称.</p>
<table>
<thead>
<tr>
<th>abbr</th>
<th>full name</th>
<th>field</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>all/add</td>
<td>\</td>
</tr>
<tr>
<td>apt</td>
<td>Advanced Packaging Tools</td>
<td>Linux</td>
</tr>
<tr>
<td>arg</td>
<td>argument</td>
<td>\</td>
</tr>
<tr>
<td>ARP</td>
<td>Address Resolution Protocol</td>
<td>TCP/IP</td>
</tr>
<tr>
<td>awk</td>
<td>Aho Weinberger and Kernighan (此命令为三位作者的名字)</td>
<td>Linux command</td>
</tr>
<tr>
<td>bin</td>
<td>binary</td>
<td>\</td>
</tr>
<tr>
<td>cat</td>
<td>concatenate</td>
<td>Linux command</td>
</tr>
<tr>
<td>cd</td>
<td>change directory</td>
<td>Linux command</td>
</tr>
<tr>
<td>chkTeX</td>
<td>check LaTeX</td>
<td>LaTeX</td>
</tr>
<tr>
<td>ch</td>
<td>change</td>
<td>\</td>
</tr>
<tr>
<td>chmod</td>
<td>change mode / change permissions</td>
<td>Linux command</td>
</tr>
<tr>
<td>clk</td>
<td>clock</td>
<td>\</td>
</tr>
<tr>
<td>cp</td>
<td>copy</td>
<td>Linux command</td>
</tr>
<tr>
<td>CV</td>
<td>Computer Vision</td>
<td>Computer Vision</td>
</tr>
<tr>
<td>cwd</td>
<td>current working directory / chang working directory</td>
<td>\</td>
</tr>
<tr>
<td>dir</td>
<td>directory</td>
<td>\</td>
</tr>
<tr>
<td>dst</td>
<td>destination image</td>
<td>computer vision</td>
</tr>
<tr>
<td>env</td>
<td>environment</td>
<td>\</td>
</tr>
<tr>
<td>g</td>
<td>global / generate</td>
<td>\</td>
</tr>
<tr>
<td>GFW</td>
<td>Great Fire Wall</td>
<td>GFW</td>
</tr>
<tr>
<td>grep</td>
<td>global regular expression and print</td>
<td>Linux command</td>
</tr>
<tr>
<td>img</td>
<td>image</td>
<td>cv</td>
</tr>
<tr>
<td>int</td>
<td>integer</td>
<td>\</td>
</tr>
<tr>
<td>LANCE</td>
<td>Local Area Network Controller for Ethernet</td>
<td>CISCO router</td>
</tr>
<tr>
<td>lib</td>
<td>library</td>
<td>\</td>
</tr>
<tr>
<td>ln</td>
<td>link</td>
<td>Linux command</td>
</tr>
<tr>
<td>ls</td>
<td>list</td>
<td>Linux command</td>
</tr>
<tr>
<td>mkdir</td>
<td>make directory</td>
<td>Linux command</td>
</tr>
<tr>
<td>mnt</td>
<td>mount</td>
<td>Linux</td>
</tr>
<tr>
<td>mv</td>
<td>move</td>
<td>Linux command</td>
</tr>
<tr>
<td>passwd</td>
<td>password</td>
<td>Linux command</td>
</tr>
<tr>
<td>pkg</td>
<td>package</td>
<td>\</td>
</tr>
<tr>
<td>pwd</td>
<td>present working directory / password</td>
<td>Linux command / \</td>
</tr>
<tr>
<td>pts</td>
<td>pseudo tty slave</td>
<td>Linux / Unix</td>
</tr>
<tr>
<td>pty</td>
<td>pseudo tty</td>
<td>Linux / Unix</td>
</tr>
<tr>
<td>q</td>
<td>quit</td>
<td>\</td>
</tr>
<tr>
<td>rc</td>
<td>run command / run configure</td>
<td>Linux初始化文件</td>
</tr>
<tr>
<td>rm</td>
<td>remove</td>
<td>Linux command</td>
</tr>
<tr>
<td>RPM</td>
<td>Redhat Package Manager</td>
<td>Linux</td>
</tr>
<tr>
<td>sed</td>
<td>stream editor</td>
<td>Linux command</td>
</tr>
<tr>
<td>shebang</td>
<td>hash bang (#!)</td>
<td>\</td>
</tr>
<tr>
<td>src</td>
<td>source / source image</td>
<td>web / cv</td>
</tr>
<tr>
<td>ssh</td>
<td>Secure Shell</td>
<td>\</td>
</tr>
<tr>
<td>ssr</td>
<td>Socket Shell R</td>
<td>GFW</td>
</tr>
<tr>
<td>stat</td>
<td>status</td>
<td>\</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
<td>\</td>
</tr>
<tr>
<td>sys</td>
<td>system</td>
<td>\</td>
</tr>
<tr>
<td>tar</td>
<td>tape archive</td>
<td>Linux command</td>
</tr>
<tr>
<td>TLDR</td>
<td>Too Long; Didn’t Read 指前面太长没看, 此部分为概述性文字</td>
<td>\</td>
</tr>
<tr>
<td>tty</td>
<td>teletype, 通常指物理形式的终端</td>
<td>Linux / Unix</td>
</tr>
<tr>
<td>usr</td>
<td>Unix Shared/Software/System Resources</td>
<td>Linux / Unix</td>
</tr>
<tr>
<td>wc</td>
<td>word count</td>
<td>Linux command</td>
</tr>
<tr>
<td>yum</td>
<td>Yellow Dog Updater</td>
<td>Linux</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>我打算换电脑了</title>
    <url>/zh-CN/2019/03/30/%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/</url>
    <content><![CDATA[<p>行吧, 电脑城是真的坑. 这辈子不会进电脑城了. 不会真香的.</p>
<a id="more"></a>

<h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>我现在的电脑是刚入大学时买的, 在电脑城😁. 我进大学被一群大佬带飞之前是个纯小白, 每天打开电脑跟随360提示赚取积分那种. 后来在群里窥视大佬们聊天, 学到了第一课:</p>
<p>什么? <strong>360杀毒是毒瘤?</strong> 什么? <strong>电脑城就是个坑?</strong></p>
<p>我开始是不太信的, 后来我格式化了电脑告别360. 再后来我在小米之家看着和我电脑同价位但配置好许多的电脑沉默了一会.</p>
<p><strong>但是!!</strong> 这次出的幺蛾子让我忍不了. 前几天电脑刚开机就弹出👇</p>
<p><img src="%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/HardDiskProblems.png?50" alt="hard disk problems detected"></p>
<p>什么? <b style="color:red;">我硬盘快挂了?</b>
当时把我吓坏了, 还以为我硬盘要爆炸了, 点开了 <strong>Disks</strong> 工具的
<strong>SMART Data &amp; Self-Tests</strong>.</p>
<p><img src="%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/self-test.png" alt="self-test"></p>
<p>我???</p>
<p>上网搜索了一下<a href="https://help.ubuntu.com/stable/ubuntu-help/disk-check.html.en" target="_blank" rel="noopener">年老的硬盘就容易出这种事</a>. 加上那个self-test也说我硬盘 <strong>Old-Age</strong> 了, 最多也就该有<strong>50</strong>个的坏道我现在有<strong>16376</strong>个, 那大概硬盘是真的快挂了吧. 行吧.</p>
<p>秋头麻袋. 我这电脑才买了一年啊💢 我和几个群友交流了一下自认使用习惯还是不算差, 虽然没有及时发现坏道并隔离 (我才知道这玩意还能传染) 是我的锅, 但铁定我买来这电脑就有点问题. 忍不了💢</p>
<h2 id="信息整理"><a href="#信息整理" class="headerlink" title="信息整理"></a>信息整理</h2><p>顺便整理一下我从群友们那听来的购买笔记本电脑的知识点好了:</p>
<ul>
<li><p>只是编程不打游戏的话主要关注<strong>内存大小</strong>和<strong>硬盘读写速度</strong>就好了. (机械硬盘是不能要的, 这我已经得到血泪教训了)</p>
</li>
<li><p>笔记本电脑的话不管 <strong>i5</strong>, <strong>i7</strong> 还是 <strong>i9</strong> 区别很小, 因为一般散热性能都不够, 处理器升温之后性能下降, 基本性能差不多. 也就是说为了省钱买 <strong>i5</strong> 就可以了. 当然有钱肯定是 <strong>i9</strong>
走着.</p>
</li>
<li><p><strong>显卡</strong>一般也就游戏, 设计, 科学计算会用到的样子, 因此我这不打游戏的直男程序员就不需要太好的显卡了
(但我发现显卡过于差的话放PPT都卡)</p>
</li>
<li><p>虽然几个群友强烈安利我买有至少有2k画质显示屏的电脑, 或者买来后自己换一个屏幕, 因为2k以上分辨率的屏幕体验极佳. 但他们都说<strong>看惯了2k完全不适应1080P</strong>. 那我当然是只买1080P啊😁 另外个人觉得干活用的电脑没必要弄触屏屏幕, 鼠标都嫌打断思路, 更何况触摸屏.</p>
</li>
<li><p>虽然linux也是用户群体极大的系统, 但linux对一些硬件设备支持相当的差, 比如有人蓝牙经常断之类. 网上也有许多地方列出了一些公认linux支持不错的电脑. 我看了一圈感觉<strong>ThinkPad</strong>和 <strong>Dell</strong> 都值得信赖. 我还翻到了个<a href="https://certification.ubuntu.com/certification/desktop/" target="_blank" rel="noopener">Ubuntu 个人电脑认证硬件</a>. 不明觉厉.</p>
</li>
<li><p>另外个人觉得比较重要的一点是<strong>键盘背光灯</strong>! 晚上不开灯没有背光的话真的只能埋头打字啊!</p>
</li>
<li><p>很多电脑虽然 <strong>处理器, 内存, 显卡, 硬盘, 屏幕</strong> 这几项是一样或者相当的, 但价格相差很多. 这是因为其他方面有关. 比如说 <strong>电池容量</strong> (和续航能力有比较大的关系), <strong>接口数量及类型</strong> (比如有几个雷电3), <strong>电脑外壳材质</strong> (比如X1C是碳纤维外壳), 是否有<strong>指纹识别器</strong> (现在Linux下也有指纹识别器的驱动了, 似乎<em>可以拿来输入sudo的密码</em>), 是否有<strong>红外摄像头</strong> (这个linux下似乎没有相关驱动, 目前唯一用处似乎就是Windows Hello), <strong>可拓展性</strong> (比如ThinkPad T480可以把内存加到32G, 而T480S最多只能加到24G), 键盘手感 (我倒是一直用不惯机械键盘😒), <strong>售后服务</strong>等</p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Verilog杂记</title>
    <url>/zh-CN/2019/05/21/Verilog%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>Verilog学习笔记.</p>
<p>这学期上了数字电路课, 从最开始的了解每个逻辑门的物理工作原理到学习每个组合电路, 时序电路元件是如何由逻辑门构成的, 再到后来跟着指导书设计出了很简易的8位CPU, 我个人是觉得很震撼的. 这也让我小时候的一个问题得到了解答: 集成电路这么复杂的东西真的是人能设计出来的吗? 其实我一直是知道答案的,
这些小黑块既不可能是土里长出来的也不可能是从什么动物身上割下来的. 我只是一直不敢想象这么复杂而精妙的东西 (即便是一根充电线里的小巧电路也不是那时的我能弄清的). 最近我稍微体会到了那群伟大的工程师们是如何设计出了那样精密的芯片的: 不断积累基本模块. 实际上从最开始的黑底白字的电脑系统到现在繁华多样的炫酷系统, 也是很令人震撼的变化. 虽然大佬可能会觉得这些很简单, 但我仍认为该对这些技术保持敬畏之心.</p>
<a id="more"></a>

<h1 id="Quartus与Modelsim的安装"><a href="#Quartus与Modelsim的安装" class="headerlink" title="Quartus与Modelsim的安装"></a>Quartus与Modelsim的安装</h1><p>🔗 <a href="https://blog.csdn.net/weixin_38071135/article/details/82531594" target="_blank" rel="noopener">quartus16.1和modelsim-altera for linux的安装</a><br>🔗 <a href="https://coldnew.github.io/ce6f7a0a/" target="_blank" rel="noopener">DE2-115 開發紀錄: 在 Linux 下使用 ModelSim</a></p>
<p>参考上面两个链接 (后者算是对前者的补充)我成功在Ubuntu1804下安装了Quartus和Modelsim. 因为我懒得注册论坛帐号, 我并没有使用第一个链接中提供的破解文件, 而是使用了<a href="https://tsuhuai.wordpress.com/2015/02/17/altera-quartus-crack-for-linux-version/" target="_blank" rel="noopener">这里</a>提供的
15.0版的crack. 我装的也是15.0版的Quartus和Modelsim, 但问题和解决方法是一样的.</p>
<p>⭐️后来我发现Linux下用<a href="http://www.geda-project.org/" target="_blank" rel="noopener">gEDA</a>这个项目应该体验也很不错.
其中用<strong>icarus</strong>综合, 编译verilog代码, 用<strong>gscheme</strong>生成原理图, 用<strong>gtkwave</strong>看仿真波形图.</p>
<h1 id="verilog开发流程"><a href="#verilog开发流程" class="headerlink" title="verilog开发流程"></a>verilog开发流程</h1><p>🔗<a href="https://copyfuture.com/blogs-details/83fc5f52af0e6c318e3c5cfa5baf2ac0" target="_blank" rel="noopener">Verilog代码和FPGA硬件的映射关系</a> 这里通过一个例子清晰的展示了Verilog代码是怎样一步步映射到FPGA的基本逻辑单元的👍</p>
<h2 id="编写代码实现功能"><a href="#编写代码实现功能" class="headerlink" title="编写代码实现功能"></a>编写代码实现功能</h2><h2 id="验证功能-仿真"><a href="#验证功能-仿真" class="headerlink" title="验证功能(仿真)"></a>验证功能(仿真)</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><p>综合是把RTL级别的, 抽象层次较高的硬件代码综合成抽象层次较低的电路网表, 是一个具体优化+映射的过程,
能够对应到门级逻辑.</p>
<h3 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h3><p>把综合后的具体数字逻辑映射到指定型号的FPGA器件中去, 包括选择哪一些基本逻辑单元 (主要包含LUT和寄存器单元) 以及布局布线等.</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载是将整个编译过程完成的可下载二进制信息通过下载线从计算机端传递到FPGA开发板端, 并完成FPGA
内部电路的具体配置(LUT中的存储信息以及连接线的连接开关设置等等), 形成具有相应功能的功能电路.</p>
<h1 id="代码风格与语法纪要"><a href="#代码风格与语法纪要" class="headerlink" title="代码风格与语法纪要"></a>代码风格与语法纪要</h1><h2 id="有关模块"><a href="#有关模块" class="headerlink" title="有关模块"></a>有关模块</h2><p>🔗 <a href="http://jason0214.lofter.com/post/30cbe4_12a8f72" target="_blank" rel="noopener">关于Verilog的模块思想和模块的引用</a></p>
<blockquote>
<p>Verilog的开发应是<strong>自顶向下</strong>的，<strong>模块化</strong>的.</p>
</blockquote>
<p>一个系统由总设计师先进行系统描述(Spec), 将系统划分为若干模块, 编写模块模型(一般为行为级), 仿真验证后, 再把这些模块分配给下一层的设计师, 由他们完成模块的具体设计, 而总设计师负责各模块的接口定义.</p>
<blockquote>
<p>链接引用模块端口时, 注意括号内的是当前模块的端口, 括号外的是引用模块的端口.</p>
</blockquote>
<p>❗️一开始我看到Verilog中模块就像面向对象中的类一样, 调用模块也神似类的实例化, 曾以为其中有面向对象的思想, 后来发现我太想当然了: 面向对象的三大特征 (封装, 继承, 多态) 它只满足了封装, 显然不能算面向对象. 硬要说的话verilog包含了<strong>面向对象</strong>的思想, 而面向过程的程序设计方法正是:
“自顶向下, 逐步求精”. 当然, <strong>要时刻牢记Verilog是一门硬件语言</strong>.</p>
<p>一个模块可以采用以下方式描述设计:</p>
<ul>
<li>数据流方式</li>
<li>行为方式</li>
<li>结构方式</li>
<li>混合</li>
</ul>
<h2 id="有关always"><a href="#有关always" class="headerlink" title="有关always"></a>有关always</h2><p><code>always</code>实际上就是循环关键字, 而<code>always @()</code>则是条件循环关键字.</p>
<p>always块的讲究很多:</p>
<ol>
<li><p>写在括号内的称<strong>敏感事件列表</strong>, 当这些事件 (电平信号变化或者出现边沿信号) 发生时触发这个块. 一个敏感事件列表中不能同时包含电平敏感事件和边沿敏感事件. <strong>电平敏感事件意味着这是一个描述组合逻辑的always块</strong> (我们也可以在描述组合逻辑的always块的敏感事件列表中填<code>*</code>来让综合器根据always块内容来自动添加敏感事件), <strong>边沿敏感事件意味着这是一个描述时序逻辑的always
块</strong>.</p>
</li>
<li><p><strong>尽量只使用主时钟 (clk, rst) 作为always块的边沿敏感事件</strong>, 避免出错. 如果有其他信号边沿触发的事件可以通过<a href="https://blog.csdn.net/phenixyf/article/details/46364193" target="_blank" rel="noopener">这里</a>
提到的clk周期延时法将边沿触发转换为电平触发.</p>
</li>
<li><p><strong>不要将同一信号的上升沿敏感事件和下降沿包含在同一敏感事件列表</strong>, 因为它们可以合为一个电平敏感事件.</p>
</li>
<li><p><strong>尽量不要在多个always块中给同一变量赋值</strong>, 这样容易产生竞争冒险 (所有always块同时运行),
且无法综合. 如果一个变量的值与两个always块都有关且这两个always块无法合并, 可以参考<a href="https://blog.csdn.net/gududeyhc/article/details/8795202" target="_blank" rel="noopener">这种方法</a>. 另外也可以考虑用两个
always块的敏感事件生成一组新的敏感事件 (参考第二条).</p>
</li>
<li><p><strong>一个always块中不能混用阻塞赋值 (=) 和非阻塞赋值 (&lt;=)</strong>, 在描述组合逻辑的always块中使用
<code>=</code>, 在描述时序逻辑的always块中使用<code>&lt;=</code>.</p>
</li>
<li><p><strong>always块中的条件语句要与敏感事件相对应.</strong> 比如以下两段代码前者是错误的, 后者是正确的.</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rst)</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst)</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="关于default"><a href="#关于default" class="headerlink" title="关于default"></a>关于default</h2><p>在写case块时发现所有示例里都写出了default这种情况, 无论情况是否完备. 这让我有了两个问题:</p>
<ul>
<li>为什么一定要有default这种情况?</li>
<li>default情况该给变量赋什么值?</li>
</ul>
<h3 id="为什么一定要有default这种情况"><a href="#为什么一定要有default这种情况" class="headerlink" title="为什么一定要有default这种情况"></a>为什么一定要有default这种情况</h3><p>一些参考资料:</p>
<p>🔗<a href="https://blog.csdn.net/wordwarwordwar/article/details/80299636" target="_blank" rel="noopener">FPGA 和ASIC开发的区别</a></p>
<p>🔗<a href="https://www.eetoday.com/application/control/201806/1537.html" target="_blank" rel="noopener">当ASIC和FPGA之间的界限日益模糊，FPGA跟ASIC还有啥区别</a></p>
<p>🔗<a href="https://www.zhihu.com/question/20555065/answer/20357525" target="_blank" rel="noopener">知乎-请问：FPGA,PLD,CPLD,PLC,DSP什么区别？看他们的定义觉着都是可编程的逻辑器件</a></p>
<p>🔗<a href="https://forums.xilinx.com/t5/%E7%BB%BC%E5%90%88%E8%AE%A8%E8%AE%BA/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%AF%9B%E5%88%BA%E7%8E%B0%E8%B1%A1/td-p/295029" target="_blank" rel="noopener">组合逻辑设计中的毛刺现象</a></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span><a href="https://blog.csdn.net/surgeddd/article/details/4683657" target="_blank" rel="noopener">锁存器、触发器、寄存器和缓冲器的区别</a></p>
<ol>
<li><p>避免产生Latch.</p>
<blockquote>
<p>latch是一种对脉冲电平敏感的存储单元路径，可以在特定输入脉冲作用下改变电平</p>
</blockquote>
<p>由这个描述我们可以看出<strong>在if-else结构和case结构中很容易产生latch</strong>: 当遇到在当前情况没有赋值的变量或遇到没有定义的情况时需要沿用上一时刻的值, 因此我们需要一个<strong>存储上一时刻状态的器件</strong>,
并且是电平触发的 (if-else和case的判断条件都是电平), 这就是为什么latch会出现. 在
<a href="https://blog.csdn.net/u012923751/article/details/79475568?comment_content=%E6%84%9F%E8%B0%A2%21&amp;comment_replyId=&amp;article_id=79475568&amp;comment_userId=&amp;commentId=" target="_blank" rel="noopener">这篇文章</a>有控制语句产生latch的实例, 在<a href="https://zhuanlan.zhihu.com/p/34408492" target="_blank" rel="noopener">这篇文章</a>中有latch产生原因的详细讨论.</p>
<p>❗️ 值得注意的是, 即便if-else结构或者case结构完整了也并不能保证不会产生latch, 只是避免了因这种情况产生的latch.</p>
<p>至于为什么要避免产生latch, 因为此处产生的latch容易产生毛刺.</p>
<p>❗️ 此处的Latch特指PLD中的latch. 因为latch在实现同一功能时需要的门比用FF实现少, 在ASIC
开发中latch使用较多 (ASIC的设计中可以保证latch信号的质量). 而由于PLD芯片中的基本单元是查找表和触发器, 没有标准的latch单元, 因此FGPA中的latch更耗资源, 也容易产生毛刺. 并不是所有latch都容易产生毛刺.</p>
</li>
<li><p>方便调试</p>
<p>如果default对应的情况是不应当出现的情况, 在仿真时可以将default情况下的变量赋值为不定态X,
方便看出问题.</p>
</li>
<li><p>这已经是一种代码规范, 最好养成严谨的习惯, 避免出错.</p>
</li>
</ol>
<h3 id="default情况下该赋什么值"><a href="#default情况下该赋什么值" class="headerlink" title="default情况下该赋什么值"></a>default情况下该赋什么值</h3><p>如果default对应的情况不应当出现, 在仿真时将变量都赋值为不定态X, 方便看出错误 (在Modelsim里不定态的信号会显示为红色), 在实际应用时全部置零 (复位态).</p>
<h2 id="关于wire和reg"><a href="#关于wire和reg" class="headerlink" title="关于wire和reg"></a>关于wire和reg</h2><p>🔗<a href="https://www.zhihu.com/question/21021718/answer/17195122" target="_blank" rel="noopener">知乎-Verilog 中定义信号为什么要区分 wire 和 reg 两种类型？-屯屯屯屯的回答</a></p>
<p>🔗<a href="https://www.zhihu.com/question/21021718/answer/28802850https://www.zhihu.com/question/21021718" target="_blank" rel="noopener">知乎-Verilog 中定义信号为什么要区分 wire 和 reg 两种类型？-BruceX的回答</a></p>
<p>🔗<a href="https://link.zhihu.com/?target=http%3A//inst.eecs.berkeley.edu/~cs150/Documents/Nets.pdf" target="_blank" rel="noopener">UC Berkley讲义-Verilog: wire VS. reg</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>Verilog</category>
      </categories>
  </entry>
  <entry>
    <title>为什么我用Linux而不是Windows</title>
    <url>/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/</url>
    <content><![CDATA[<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>又过了一段时间, 我觉得对于这个问题我已经不在需要去想那么多理由来说服自己了. 在习惯了在Linux开发后我再在Windows试着做点小东西便发现这一切比起在Linux下来得束手束脚得多. 没有强大而美观的终端, 无法只通过编辑配置文件就轻松对软件进行配置, 无法一个命令改变文件权限, 系统语言为中文时的默认编码格式为cp936有时候也会给开发带来麻烦… 更别说windows没有强大的包管理工具…总之<strong>一切Windows防止普通用户误操作的措施让开发者变得十分拘束</strong>.</p>
<p><strong>WSL也不顶用</strong>. 我也一度十分推崇WSL, 但体验了一天不到我就果断删除了. <strong>我连自己环境都没配出来!</strong> 目前的WSL还bug很多, 比如我的终端字体根本不能正确显示 (这很重要好吧), 比如在Windows系统和WSL同时对一个文件进行了操作似乎会造成文件权限问题, 再比如我在Ubuntu1804的WSL中执行<code>sudo apt install pip</code>结果报错了… (这个问题并不只有我一个人遇到)</p>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然上大学前我是完全没听说过Linux的 (不是Linux不nb是我太菜), 但进大学后身边人人都说他好, 我也就早早地开始接触它. 从最开始在Win10上在虚拟机里装了Ubuntu16.04摸了几把, 到发现双系统爆炸好装就顺手装上了Ubuntu18.04体验, 到现在思考为什么我要用Linux, 思考要不要试试Ubuntu之外的Linux
系统, 感觉自己对Linux还是有了一定的了解.</p>
<p>在我刚装了双系统时就有同学问我Linux到底咋好, 我当时也没太体会出, 就一气胡说, 什么”没有毒瘤360”
啊, “不像Windows下乱七八糟的软件有各种开机加载项, 我这快坏掉的电脑运行Linux系统开机快”啊 (当时我的硬盘刚出现<a href="https://leojhonsong.github.io/zh-CN/%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/">要爆炸的迹象</a>),
总之我当时也说不上Linux哪里好到值得我不用Windows和它的Office套装.</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>因此当最近我再次想起这个问题时我进行了一番搜索:</p>
<ul>
<li>首先我搜了Linux和Windows的比较, 发现其实问题并不是”Linux比Windows好在哪”而是”Linux和
Windows哪个好?”</li>
</ul>
<p>🔗<a href="https://www.zhihu.com/question/24439007/answer/27872778?utm_source=qq&amp;utm_medium=social&amp;utm_oi=575568675688419328" target="_blank" rel="noopener">知乎话题-微软的 Web 服务器为何能屹立不倒？</a></p>
<p>🔗<a href="https://www.michaelhorowitz.com/Linux.vs.Windows.php" target="_blank" rel="noopener">LINUX vs WINDOWS</a></p>
<ul>
<li>然后我想到了解Linux和Windows的起源来发现他们设计理念, 运行方式的差异.</li>
</ul>
<p>🔗<a href="https://www.bbsmax.com/A/mo5kVo2JwR/" target="_blank" rel="noopener">操作系统Unix、Windows、Mac OS、Linux的故事</a></p>
<p>🔗<a href="https://linux.cn/article-3789-1.html" target="_blank" rel="noopener">一段关于 Unix 与 Linux 的暗黑史</a></p>
<p>我顺便搜了一下Linux在电影行业的应用</p>
<p>🔗<a href="https://blog.csdn.net/neo_liukun/article/details/6787507" target="_blank" rel="noopener">Linux与电影制作</a></p>
<ul>
<li>还有些杂乱的</li>
</ul>
<p>🔗<a href="https://www.jianshu.com/p/71158a9c8d03" target="_blank" rel="noopener">浏览黑暗网络的操作系统：Windows，Mac还是Linux？</a></p>
<p>🔗<a href="https://en.wikipedia.org/wiki/Comparison_of_operating_systems" target="_blank" rel="noopener">Comparison of operating systems</a></p>
<p>🔗<a href="https://meta.stackexchange.com/questions/10369/which-tools-and-technologies-are-used-to-build-the-stack-exchange-network" target="_blank" rel="noopener">What tools and technologies are used to build the Stack Exchange Network?</a></p>
<p>🔗<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Netperf-Windows-Linux" target="_blank" rel="noopener">Some Windows Server 2016 vs. Linux Network Benchmarks</a></p>
<p>🔗<a href="https://www.zhihu.com/question/19818863" target="_blank" rel="noopener">京东用 .NET 架构的原因是什么？</a></p>
<p>🔗<a href="https://www.zhihu.com/question/50117613/answer/119798303" target="_blank" rel="noopener">如何评价微软的 UI 设计？</a></p>
<h1 id="信息整理"><a href="#信息整理" class="headerlink" title="信息整理"></a>信息整理</h1><p>我们可以发现虽然Linux是在服务器领域发家的, 但现在Windows也在服务器领域占领了不小的份额. 并且在某些领域比起Linux反而Windows更受青睐. 很有意思的是在银行业Unix因为稳定性被使用, 而Windows
因为能提供因为Windows系统的原因出现的损失提供补偿而被使用, Linux看起来在银行业倒是没几家使用的样子.</p>
<p>实际上Linux和Windows在各方面的性能上并无什么差异, 让人们决定到底选择Linux还是Windows的因素我觉得可以<strong>主要</strong>可以分<strong>服务器领域</strong>和<strong>个人电脑领域</strong>两个方面来讨论.</p>
<h2 id="服务器领域"><a href="#服务器领域" class="headerlink" title="服务器领域"></a>服务器领域</h2><p>服务器都是公司在使用, 而公司是一定要赚钱的 (就算是非营利组织也是要靠钱来维持的), 因此很多决定因素都和💰有关.</p>
<p>因为是公司用的服务器, 因此很容易受到攻击, 另外因为很可能保存有公司重要资料因此要有公司内部人员来管理, 开发. 然后我们就看到: <strong>中小型IT企业普遍选择Windows, 而大型IT企业更倾向于选择Linux.</strong></p>
<p>❗️</p>
<ul>
<li>此处仅讨论IT领域, 因为其他领域我没了解到那么多, 并且讨论价值没那么大, 比如文学界的数据库服务器我不认为会使用Linux系统</li>
<li>此处的中小型公司指有一定技术水准的程序员的数量较少, 反之大型公司指技术实力雄厚的, 比如BAT</li>
</ul>
<p>中小型IT企业更青睐Windows是因为:</p>
<ol>
<li>Window<strong>s学习成本相对低</strong>, 甚至微软能提供良好的技术支持.</li>
<li>使用Linux看似省下了Windows激活码的钱, 但却需要大量资金来养一批有实力的技术人员在公司里才能达到或者超过使用来自微软的服务的体验 (紧急情况处理, 技术支持, 损失赔偿等), 对人手不够的公司来说Windows是个很好的选择. 就比如 Stack Exchange这公司, 还是很nb吧, 但人家的服务器一直在Windows平台使用微软的方案, 因为这公司一共就一百多人, 还分散在世界各地. 他们很明显没有足够的人手去搞骚东西, 而微软的服务很好地解决了他们的烦恼: 俺们就是想<strong>省心</strong>.</li>
<li>有许多银行也会使用Windows, 因为<strong>微软能为损失背锅</strong>. 另外不算各巨头公司的魔改的话Windows
系统的<strong>安全性很高</strong>, 毕竟他的源码是闭源的, 更不容易被人发现0day漏洞, 而微软的事故响应也很快, 比开源社区修bug不知快到哪去了. 经常有人认为Linux系统公布了源码, 那各位大牛肯定早把它修补得差不多了, 但事实并非如此, Linux也有许多漏洞, SUSE就曾爆出过重大漏洞. 而与Linux
有血缘的Unix则是因为在贝尔实验室已经经历了十数年的打熬, 才能做到如今的稳定性.</li>
</ol>
<p>而大型公司则是相反, 因为技术雄厚因此更愿意用Linux这样的开源系统, 甚至基于Linux魔改. 比如Google
就糊了<em>Goobuntu</em>, <em>gLinux</em>内部使用. 这些公司有钱有人, 那当然是选择高度定制化, 自己能完全把控的系统. 而没人会去魔改Windows拿来用, 那太骚了.</p>
<h2 id="个人电脑领域"><a href="#个人电脑领域" class="headerlink" title="个人电脑领域"></a>个人电脑领域</h2><p>以下的观点就主观一些了, 毕竟本文标题是 “我为什么用Linux” 😁</p>
<p>其实在PC端Windows各方面都有着很不俗的表现, 抛开游戏方面不谈 (这方面当然是Windows更合适, 但我是不打游戏的).</p>
<p>比如<strong>办公方面</strong>吊打Linux: Word, PPT, Excel, OneNote为首的Office套件实在好用, 虽然这些软件在Linux上可以访问网页版, 但经我测试有许多有用功能网页版并不具备. (OneDrive现在能在Linux很好的使用了倒是一大喜事) 无论WPS还是LibreOffice都存在很严重的图文串位问题. 至于
Latex在Linux平台体验并没有和Windows平台有什么区别.</p>
<p>再比如<strong>驱动方面</strong>, Windows确实比Linux做得好不少, 驱动比Linux全很多 (就比如很多电脑刚装了
Linux会有显卡, 网卡, 蓝牙等各种各样驱动问题而且解决起来没有在Windows那么容易). 甚至很多做硬件相关的企业都用Windows. 很多设备只做了Windows平台的驱动, 但我是没听说过只做了Linux平台驱动的设备.</p>
<p>而在<strong>美观程度</strong>方面个人认为只要想做, Linux桌面可以做到高度个性化, 因此可以很美观, 不像在
Windows即便你觉得什么东西丑爆了你也只能按照Windows的规矩来个性化. 即便自己配置觉得麻烦也可以直接偷别人的配置. 比如我打算以后按<a href="https://www.zhihu.com/question/26031045/answer/356288402" target="_blank" rel="noopener">这个样子</a>
折腾一番, 实在炫酷.</p>
<p>但要说到<strong>开发方面</strong>我认为Linux是比Windows好的选择. 无赖一点的解释: 既然以后在IT界很有可能需要用Linux, Linux学习成本又不低, 那何不早些接触Linux? 在微软实习的学长说他觉得那里的人人均会
Linux. 曾经看到说我们身周的设备90%以上用的系统都是Linux (虽然我觉得有点过了但反正极多, 而
Windows IoT才起步). 在和目标平台相同的平台上开发能提高发现问题的可能性. 另外Linux上没有
Windows上那么多针对普通用户设置的开关, 不会还需要自己开启IIS之类. 而且Linux不使用 <code>\\</code> 作为文件夹名称分割符, 感觉没那么容易混乱. 再有Windows自带的Windows Defender过于烦人, 默认设置甚至会实时扫描所有进程, 占用很多内存. 然后Linux文件以<code>LF</code>为换行符, 而Windows以<code>CLRF</code>为换行符, 因此到了Linux强迫症表示Git提交时再也看不到将文件从CRLF转到LF的提示了😁. Linux的好处太多啦, 还有环境好配, 命令行比图形界面更能让人提高效率等…</p>
<p>而还有一点超脱以上所有并且十分重要的原因: <strong>生态</strong>.</p>
<p>如果你要使用的工具, 祖传代码, 社区已有的成果, 公司生态等逼着你用Linux, 你又能有什么办法.</p>
<hr>
<p>我又发现了Windows可以diss的地方: 编码方式.</p>
<p>实例参见<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81">这里</a>. 这里有详细的吐槽 🔗<a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">知乎-Windows记事本的ANSI, Unicode, UTF-8这三种编码模式有什么区别？-梁海的回答</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>有关字符集与编码</title>
    <url>/zh-CN/2019/05/29/%E6%9C%89%E5%85%B3%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>当我在解决<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81">Linux下解压zip文件的问题</a>时发现编码方面的问题还蛮多的, 在此记录.</p>
<a id="more"></a>

<h1 id="Windows下编码方式的坑"><a href="#Windows下编码方式的坑" class="headerlink" title="Windows下编码方式的坑"></a>Windows下编码方式的坑</h1><p>🔗 <a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">知乎-Windows记事本的ANSI, Unicode, UTF-8这三种编码模式有什么区别？</a></p>
<p>🔗 <a href="https://www.zhihu.com/question/20167122" target="_blank" rel="noopener">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个</a></p>
<p>总结一下, 在Windows中:</p>
<ul>
<li>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码</li>
<li>所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16</li>
<li>所谓的「UTF-8」指的是带 BOM 的 UTF-8</li>
</ul>
<p>之前一直听说Windows自带的记事本不要用, 会自动在文件开头加一个东西, 导致一些地方显示该文件开头有一个 “?” , 一直不知道是多了个啥, 原来是UTF-8/UTF-16编码的文件会在文件开头多一个
BOM. <strong>UTF-8与带BOM的UTF-8的区别在于带BOM的UTF-8文件开头有U+FEFF.</strong> 微软使用带BOM的UTF-8
的目的是将UTF-8与ASCII等编码方式区分开, 但这就导致了在很多时候UTF-8默认是不带BOM时文件读取有误.</p>
<h1 id="GBK不是一种编码格式"><a href="#GBK不是一种编码格式" class="headerlink" title="GBK不是一种编码格式"></a>GBK不是一种编码格式</h1><p>GBK并不是一种编码格式, 而<strong>是一个字符集</strong>. 我觉得很low的是GBK的全称是 <strong>Guojia Biaozhun
Kuozhan</strong> 🤦‍…low得不要不要的. 不过也可以理解, 毕竟这三个字母是从”国标扩”的首拼发展来的.</p>
<h2 id="自整理的中文字符集发展史"><a href="#自整理的中文字符集发展史" class="headerlink" title="自整理的中文字符集发展史"></a>自整理的中文字符集发展史</h2><p>以下是我整理的中文字符集发展史:</p>
<ul>
<li>最开始中国国家标准化管理委员会发布了
<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D79E19D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB/T2312-1980</code></a> (<strong>GB</strong>为<strong>国标</strong>首拼, <strong>T</strong>是<strong>推</strong>, 指推广,
非强制性的标准), 包括了<strong>6763</strong>个常用汉字, 发布以后许多有汉字的语言也采用了这个字符集. 但这个字符集很不够, 缺少很多生僻字, 繁体字, 对日本, 韩国汉字收录也很不全.</li>
<li>微软根据GB2312做出了<code>cp936</code> (code page936), 字符集方案为GB2312, 编码方案为
<strong>EUC-CN</strong>.</li>
<li>1993年<strong>Unicode1.1</strong>发布后国标委抄过来发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D7860AD3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 13000.1-1993</code></a>.</li>
<li>这时微软利用<strong>cp936</strong>中收录GB2312-1980后未使用完的码位收录了GB13000.1-1993的全部字符,
这样既兼容了GB2312又添加了许多字符. 这个新版本cp936最早实现于<strong>Windows95简体中文版</strong>.
这之后微软又陆陆续续给cp936加了几个字符. 直到2002年<a href="https://www.iana.org/assignments/charset-reg/GBK" target="_blank" rel="noopener">IANA将cp936的字符集注册为<code>GBK</code></a>. GBK共收录<strong>21886</strong>个汉字和图形符号.</li>
<li>再后来因为字符还是不全 (比如emoji什么的)以及其他原因发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D79585D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 18030-2000</code></a>, 在
Windows的对应代码页为<code>cp54936</code>. 但值得一提的是尽管2000年就有了新标准, 但Windows系统的系统语言为简体中文时的默认代码页仍为<strong>cp936</strong>. 原因可以参考<a href="https://linux.cn/article-1213-1.html" target="_blank" rel="noopener">这里</a>. 文章大意: 微软划水, 国家也没上心.</li>
<li>最近的一版标准字符集是<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D800B5D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 18030-2005</code></a>. 但这个好像有点复杂, 我并没有太看懂, 反正和之前的几个标准很不同. 怎么个不一样可以参考<a href="https://zhuanlan.zhihu.com/p/31643128" target="_blank" rel="noopener">这里</a>.</li>
</ul>
<h1 id="Unicode与UTF-8是不同层面的东西"><a href="#Unicode与UTF-8是不同层面的东西" class="headerlink" title="Unicode与UTF-8是不同层面的东西"></a>Unicode与UTF-8是不同层面的东西</h1><p>我曾经以为Unicode是一种编码格式, 就像UTF-8是一种编码格式, 但后来我发现这两者根本是不同层面上的东西.</p>
<h2 id="Unicode与UCS"><a href="#Unicode与UCS" class="headerlink" title="Unicode与UCS"></a>Unicode与UCS</h2><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>与<strong>Unicode</strong> (统一码) 同一层面的概念是<strong>UCS</strong> (Universal Character Set, 通用字符集).
UCS和Unicode分别由<strong>ISO</strong> (国际标准化组织) 和<strong>一帮软件制造商</strong> (Xerox, 苹果等成立了个统一码联盟) 先后发起. 后来他们才合并工作. 实际上两者是差不多的玩意. 我并不相信统一码联盟在成立时不知道ISO已经在开发UCS了
(UCS项目启动比Unicode早<strong>4年</strong>), 而在这样的情况下还要开发Unicode, 个人认为是商业原因.
直到现在这仍然是两个独立的项目, 但项目进度同步且两个组织都宣称要和对方<strong>保持兼容</strong>. 个人觉得很蠢🤷‍</p>
<h3 id="两者差异"><a href="#两者差异" class="headerlink" title="两者差异"></a>两者差异</h3><p>硬要说的话其实Unicode与UCS有一些细节不同.</p>
<p>比如ISO/IEC 10646-1使用四种不同风格的变体来显示简体中文, 繁体中文, 日语, 韩语汉字, 但Unicode2.0中只有简体中文的变体. 因此有过日本人无法接受Unicode的说法. (现在应该是没这问题了)</p>
<p>应该还有小区别吧? 其他区别我不知道, 也懒得找了😁</p>
<h2 id="现代编码模型"><a href="#现代编码模型" class="headerlink" title="现代编码模型"></a>现代编码模型</h2><p>Unicode是一套有些复杂的编码系统, 并不是单纯一个字符集方案或是一个编码方案, 而是构建出了一个
<strong>现代编码模型</strong>. (这段话对UCS同理)</p>
<p>这个模型分五层:</p>
<ul>
<li>抽象字符集(Abstract character repertoire)</li>
<li>编码字符集(Coded Character Set)</li>
<li>字符编码方式(Character Encoding Form)</li>
<li>字符编码方案(Character Encoding Scheme)</li>
<li>传输编码语法(Transfer Encoding Syntax)</li>
</ul>
<p>按我的理解: 抽象字符集是一个抽象字符的<strong>集合</strong>, 不关注字形, 更关注字意. 比如钟和鐘的抽象字符是同一个, 而编码字符集是一个<strong>映射</strong>, 规定把一个抽象字符映射到哪个<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">字符平面</a>, 哪个<strong>码点</strong>. 但这并不是一一映射, 为了兼容或者有的字 (比如CJK字) 可能有多个变体. 字符编码方式又称为”storage format”, 我猜这是因为这一层<strong>将码点编码成码元</strong>(这里的编码方式就是<strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat,
包括UTF-8, UTF-16, UTF-32等方法), 而码元正是每次从文件中读取到的字符的格式.</p>
<p>Unicode编码模型详细阐述可以参考<a href="https://zhuanlan.zhihu.com/p/27026033" target="_blank" rel="noopener">这里</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>编码</category>
      </categories>
  </entry>
  <entry>
    <title>当我安利软体机器人时我在谈什么</title>
    <url>/zh-CN/2019/06/10/%E5%BD%93%E6%88%91%E5%AE%89%E5%88%A9%E8%BD%AF%E4%BD%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%97%B6%E6%88%91%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从小我就喜欢仿生机器人. 我敬畏着各种精妙的仿生设计和它们的设计者, 渴望着有朝一日我也能参与这样的工作. 当我看到波士顿动力的Atlas的仿生腿部结构时, 我就在想: 我们能不能造出人造人呢? 那时的我并没有想很多, 并不会去想这样浩大的工程的性价比, 并没有意识到背后的伦理问题, 只是出于一种探索, 好奇. 我也曾听到一句很有趣的话:</p>
<blockquote>
<p>“在一项技术成熟前不要谈论他的价值”</p>
</blockquote>
<p>法拉第在回答一位贵族夫人对发电机的用处的质疑时就反问到: “婴儿能做什么呢?”. 最近很火的<a href="https://www.bilibili.com/video/av54737593?from=search&amp;seid=16639379942704237214" target="_blank" rel="noopener">何同学对5G的看法</a>
也发人深省. 在他提醒后我才想起注意到有许多技术 (比如有款机器人的无线控制对传输速度要求很高, 4G无法满足)依赖于5G. 5G必将给我们的生活带来现在的我们无法想象的改变.</p>
<p>而<strong>软体机器人</strong>也必然是这样值得我们期待的技术.</p>
<a id="more"></a>

<p>我接触到的第一个软体机器人是<a href="https://journals.sagepub.com/doi/full/10.1177/1553350617745953" target="_blank" rel="noopener">一个集成在da Vinci内窥镜操作臂上的手术系统</a>. 它的灵活, 精准震撼了我.</p>
<p>📺 <a href="https://youtu.be/AI7M-JTC6_w" target="_blank" rel="noopener">这个视频</a><strong>感性地</strong>介绍了一些软体机器人能解决的需求, 实际应用, 研究方向.</p>
<blockquote>
<p>刚体机器人基本由电机控制, 需要精准控制, 对这些刚性机器人的运用倾向于<strong>专业化与
精确化</strong>, 它们很难表现出<strong>高度可变形能力与对复杂环境的适应性</strong>. 随着机器人运用
领域继续扩大, 医疗保健、复杂地形勘探等特殊领域对机器人提出了更加严苛的要求.</p>
</blockquote>
<p>🔗 <a href="https://zhuanlan.zhihu.com/p/30700859" target="_blank" rel="noopener">这篇文章</a>源自文力老师的报告, 讲到了软体机器人的定义, 发展历程, 发展趋势分析, 也有文老师举例从产生灵感到实现一个软体机器人的简述.</p>
<blockquote>
<p>所以从2011年到2017年, 这七年的时间内, 软体机器人从单一的材料过渡到了多材料, 再
到了智能材料, 最后有可能到生物材料, 这是一个发展的趋势. 所以从这个趋势结合起来
讲，未来的发展方向一定是它<strong>结合驱动、传感、变刚度、多功能的复合材料, 以及添加
软体机器人的控制方法</strong>. 目前控制方法这一块是比较欠缺的, 这是一个学术或者是创新
方面的一个主要的发展趋势.</p>
</blockquote>
<p>此处有个值得一提的概念: <strong>智能</strong>. 我目前的理解是: <strong>能与环境交互, 作出反馈</strong> (此处的智能和人工智能的智能不是一个含义)</p>
<p>目前主要的应用方向有:</p>
<ol>
<li>抓持作业</li>
<li>医疗康复 (比如康复训练或助力)</li>
<li>复杂环境勘探</li>
<li>微创外科手术</li>
</ol>
<p>当然我相信随着探究会逐渐发现更多的, 令人震惊的应用前景.</p>
<p>而软体机器人崛起的同时刚体机器人并不会退出舞台. 在工业等机器人负责输出大力矩的环境它们是无可替代的. 软体机器人目前还无法输出很大的力矩, 当然我认为他们不必具备这种能力, 软体机器人和刚体机器人应当是<strong>互补的</strong>而非哪个一定更优于哪个.</p>
<p>这太酷了!</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Robotics</category>
        <category>Soft Robotics</category>
      </categories>
  </entry>
  <entry>
    <title>有关人工智能的一点思考</title>
    <url>/zh-CN/2019/06/21/%E6%9C%89%E5%85%B3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>以下仅为个人见解</p>
<a id="more"></a>

<p>突然思考了一下<strong>什么是人工智能?</strong></p>
<blockquote>
<p>从学科角度讲, 人工智能是一门研究 <strong>模拟, 延伸, 扩展人类智能</strong> 的学科</p>
</blockquote>
<blockquote>
<p>人工智能是在机器上实现的人类智能</p>
</blockquote>
<p>这两条是我比较认可的对人工智能的描述. 可以看出<code>人工智能</code>是相对于<code>人类智能</code>的一个概念, 理解起来既简单又困难. 要说简单, 人工智能可以很直观的理解为<strong>人为制造的智能</strong>, 要说难, 人们至今仍在探索<strong>什么是人类智能</strong>. 这是一个极其抽象的哲学概念.
实际上试图制造人工智能正是人们探索人类智能的途径之一: 能知道如何制造出一个智能了, 我们也就基本摸清什么是人类智能了.</p>
<p>目前人工智能的实现有三种研究方法:</p>
<ul>
<li><strong>功能模拟</strong>: 符号主义, 认为人工智能源自数理逻辑, 以及人类智能的基本单元是符号, 认知的过程是符号表示下符号运算的过程.</li>
<li><strong>结构模拟</strong>: 连接主义, 认为人工智能源自仿生学, 特别是人脑模型的研究, 主要模拟神经元生理机制.</li>
<li><strong>行为模拟</strong>: 控制论主义, 认为人工智能源自控制论, 原理是控制论及激励-响应控制系统.</li>
</ul>
<p>回顾了一番后我终于理清了之前一直不太懂的 <strong>人工智能, 机器学习, 深度学习的关系</strong>:</p>
<p><code>人工智能</code>是人们提出的一个理想化的概念, 在得出人类智能的定义前谁也没法说出到底什么是人工智能, 到底某机器是否具备人工智能. <code>机器学习</code>是人们以制造人工智能为目标造出的各种具有部分智能的东西, 而<code>深度学习</code>是其中从仿生角度出发的研究.</p>
<p>💡很有意思的是智能另有一个含义: <strong>能对环境作出反馈</strong>. 比如智能材料, 狭义的智能机器人等.</p>
<p>这番思考总结后我认为图灵测试并不能<strong>绝对</strong>判定一个东西是否具有人类智能.</p>
<p>一方面<strong>中文房间</strong>实验是很有力的反驳. 也许有人认为这个实验所假设的完美的指导书是不存在的, 是理想化的, 但实际上图灵测试也是这样的东西, 能够完美检测被测试者是否具有智能的测试是不存在的. 我们只需要足够大的”指导书”就能够应付图灵测试. 参考<code>无穷大</code>
的数学定义, 我们可以有这样的结论: <strong>假设我们以M来衡量一个图灵测试的测试范围, 对任意给定M测试范围的图灵测试, 我们总能写出这样的”指导书”X: X让机器在当前图灵测试内表现得像一个人</strong>.</p>
<p>另一方面是因为我认为人们目前对人类智能的认知是不够的. 打个比方: 牛顿得出三条牛顿定律, 被人们奉为铁律, 后来相对论推翻了它, 牛顿定律变为了只在低速情况下适用. 但相对论又是绝对正确的吗? 目前它还没被推翻. 而我们对智能的判别甚至还停留在以经验来判断的阶段. (这里又存在一个哲学问题了: 存在绝对的真理吗? 这里我们暂且不讨论.) 也许我们可以说图灵测试在当前对人类智能的认知水平下可以作为是否具有智能的标准, 但它是那样的简陋, 早晚是要被取代的.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>机器人案例学习</title>
    <url>/zh-CN/2019/06/10/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>正如我在 <a href="https://leojhonsong.github.io/zh-CN/about/">about</a> 中提到的, <strong>我立志为软体机器人领域贡献一份力</strong>, 那就先从积累开始吧. 在此记录我觉得很精妙的机器人,
或可以用于机器人的”东西”, 参考学习💪</p>
<a id="more"></a>

<p>TODO</p>
<h1 id="Cassie家族"><a href="#Cassie家族" class="headerlink" title="Cassie家族"></a>Cassie家族</h1><h1 id="BDC家族"><a href="#BDC家族" class="headerlink" title="BDC家族"></a>BDC家族</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/zh-CN/2019/07/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.</p>
<p>经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了… 虽然我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知新, 再次”速成”一下.</p>
<a id="more"></a>

<h1 id="语句与行"><a href="#语句与行" class="headerlink" title="语句与行"></a>语句与行</h1><p>C语言我感觉对格式要求蛮宽松的, 可以一行多个语句 (每个语句必须以<code>;</code>结尾), 也可以跨行写语句(在行末写<code>\</code>折行), 不像python对缩进都有严格要求.</p>
<p>🌟 代码风格的话我只认<strong>VS风</strong>, 就是Visual Studio格式化出来的样式. 是的我是<strong>大括号换行派</strong>!</p>
<p>💡 要注意的是预编译指令必须一行不能写多个语句, 但可以折行.</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>有两种方式</p>
<h2 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h2><p>👇这种注释可以跨行写, 也可以在行内写</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="comment">/*comment*/</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*comment</span></span><br><span class="line"><span class="comment">comment</span></span><br><span class="line"><span class="comment">comment*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>💡值得一提的是只要出现 <strong>/*</strong> 就会被识别为注释的开始, 如果想把y除z指向的内存的值赋给x写成下面这样是不行的.</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">x = y<span class="comment">/*z</span></span><br></pre></td></tr></tbody></table></figure>

<p>但这个问题也很好解决, 用空格或括号就能解决.</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">x = y / *z</span><br><span class="line">x = y/(*z)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="不推荐的方式"><a href="#不推荐的方式" class="headerlink" title="不推荐的方式"></a>不推荐的方式</h2><p>这样只能单行注释</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">code  <span class="comment">// comment</span></span><br></pre></td></tr></tbody></table></figure>

<p>❗️要注意这种注释方式是借鉴自C++, 在C99中才被标准化, 而目前使用最广泛的是C89标准,
也就是说不使用是比较保险的.</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>C语言对内存的操作似乎很多, 也很注重内存管理.</p>
<p>C语言为内存的分配和管理提供了几个函数. 这些函数可以在 &lt;stdlib.h&gt; 头文件中找到.</p>
<p><strong>void *malloc(size_t size)</strong> 分配一块<code>size</code>大小的内存</p>
<p><strong>void *calloc(size_t num, size_t size)</strong> 分配一块储存了一个<code>num</code>长, 每个元素
<code>size</code>字节的内存并将所有位初始化为0</p>
<p><strong>void *realloc(void *ptr, size_t size)</strong> 重新分配内存, 把内存扩展到 newsize</p>
<p><strong>void free(void *ptr)</strong> 释放<code>ptr</code>所指向的内存</p>
<p>💡 malloc是memory allocate, realloc是reallocate, calloc不知道是啥.</p>
<h1 id="段与栈与堆"><a href="#段与栈与堆" class="headerlink" title="段与栈与堆"></a>段与栈与堆</h1><p><strong>段</strong> (segmentation)是指二进制可执行文件内的区域,所有某种特定类型信息被保存在里面.可以用<code>size</code>命令得到可执行文件中各个段的大小. <strong>正文段</strong> (Text Segment)用于储存指令, <strong>数据段</strong> (Data Segment)用于储存已初始化的全局变量, <strong>BSS段</strong> (BSS
Segment)用于储存未赋值的全局变量所需的空间.</p>
<p><strong>调用栈</strong>并不储存在可执行文件中,而是在运行时创建.调用栈所在的段称为堆栈段(Stack
Segment). 和其他段一样, 堆栈段也有自己的大小, 不能被越界访问, 否则就会出现段错误
(Segmentation Fault). 这种情况叫<strong>栈溢出</strong>.</p>
<p>栈空间有多大和操作系统相关. 在Linux中, 栈大小是由系统命令<code>ulimit</code>指定的, 例如
<code>ulimit -a</code>显示当前栈大小, 而<code>ulimit -s 32768</code>将把栈大小指定为32MB. 但在Windows
中, 栈大小是储存在可执行文件中的. 使用gcc可以这样指定可执行文件的栈大小: <code>gcc
-Wl,--stack=16777216</code>, 这样栈大小就变为16MB</p>
<p>💡 栈溢出不一定是递归调用过多导致的, 也可能是局部变量太大. 因此<strong>较大的数组建议储存为全局变量</strong>.</p>
<p><strong>栈</strong>是由编译器在需要时分配的, 不需要时自动清除的变量存储区. 里面的变量通常是局部变量, 函数参数等. <strong>堆</strong>是由<code>malloc()</code>函数分配的内存块,内存释放由程序员手动控制, 在C语言由<code>free()</code>完成.</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>较大的数组时应在main函数之外声明.</p>
<p><code>memset(a, 0, sizeof(a))</code>能方便地把数组a清零,它在<strong>string.h</strong>中定义.</p>
<p>用strcpy(a, b), strcmp(a, b), strcat(a, b)来执行“赋值”、“比较”和“连接”操作, 在
<strong>string.h</strong>中定义</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言中的字符串是以“\0”结尾的字符数组</p>
<p>不同操作系统的回车换行符是不一致的. Windows是“\r”和“\n”两个字符,Linux是“\n”,而
MacOS是“\r”. 如果在Windows下读取Windows文件, fgetc和getchar会把“\r””吃掉”, 只剩下“\n”; 但如果要在Linux下读取同样一个文件, 它们会忠实地先读取“\r”, 然后才是“\n”.</p>
<p>很有意思的一个小问题: “5”, ‘5’ 和 5 有什么区别?<br>“5”是一个字符串, ‘5’是一个字符常量, 5是一个数字常量</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>用int* a声明的变量a是指向int型变量的指针. 赋值a = &amp;b的含义是把变量b的地址存放在指针a中, 表达式<em>a代表a指向的变量, 既可以放在赋值符号的左边(左值), 也可以放在右边
(右值) 注意: <em>a是指“a指向的变量”, 而不仅是“a指向的变量所拥有的值”. 理解这一点相当重要. 例如, *a = *a + 1就是让a指向的变量自增1. 甚至可以把它写成(</em>a)++. 注意不要写成<em>a++, 因为<code>++</code>运算符的优先级高于取内容运算符 `</em>`, 实际上会被解释成</em>(a++).</p>
<h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><ul>
<li>一个指针变量加/减一个整数是将该指针变量的原值(是一个地址)和它指向的变量所占用的内存单元字节数相加或相减.</li>
<li>两个指针变量间可以做减法, 但前提是这两个指针是指向同一个数组的元素. 两指针变量差是两个指针之间的元素个数</li>
<li>如果两指针变量指向同一数组的元素, 他们可以进行比较运算. 另外所有指针都可以和
NULL进行相等/不想等比较.</li>
</ul>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></tbody></table></figure>

<p>宏名一般为大写, 以下划线连接单词.</p>
<p>看了网上资料我感觉在C中宏定义主要是以下作用</p>
<h3 id="增加代码抽象性"><a href="#增加代码抽象性" class="headerlink" title="增加代码抽象性"></a>增加代码抽象性</h3><p>用宏定义替代magic number, 或者嵌入式中一些寄存器的位操作, 一方面增强代码可读性
(不像魔数让人不明所以, 而寄存器的位操作也很不直观), 一方面增强代码可移植性 (比如从一种单片机移植到另一种单片机, 只需更改宏定义即可)</p>
<h3 id="防止重复定义"><a href="#防止重复定义" class="headerlink" title="防止重复定义"></a>防止重复定义</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXXX</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>在头文件里用这样的语句来防止头文件被重复引用. 有一些头文件被重复引用会增加编译器工作, 降低编译效率, 而有一些头文件被重复引用会引起冲突 (比如如果头文件里定义了全局变量, 会发生重复定义错误).</p>
<h3 id="控制代码编译"><a href="#控制代码编译" class="headerlink" title="控制代码编译"></a>控制代码编译</h3><p>通过Makefile控制编译选项.</p>
<p>还能像轮子哥<a href="https://www.zhihu.com/question/22608939/answer/21963056" target="_blank" rel="noopener">这样</a>当模板用.</p>
<p>❗️虽然宏定义的好处不少, 但除了以上情况尽量少用尽量不用宏定义, 因为这会让开发者看到的代码与编译器看到的代码不同, 容易导致想不到的问题.</p>
<h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><p>调试时重点关注两方面: <strong>当前行的跳转</strong>, <strong>变量的变化</strong></p>
<p>循环结构程序设计中最常见的两个问题: <strong>算术运算溢出</strong>, <strong>程序效率低下</strong></p>
<p>变量在未赋值之前的值是不确定的.</p>
<h1 id="gcc与gdb命令简记"><a href="#gcc与gdb命令简记" class="headerlink" title="gcc与gdb命令简记"></a>gcc与gdb命令简记</h1><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>常用选项:</p>
<table>
<thead>
<tr>
<th>name_of_option</th>
<th>我猜的全名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-o [filename]</td>
<td>output</td>
<td>指定输出文件名</td>
</tr>
<tr>
<td>-g</td>
<td>gdb</td>
<td>生成调试用的符号表</td>
</tr>
<tr>
<td>-Wall</td>
<td>warning all</td>
<td>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros.</td>
</tr>
<tr>
<td>-lm</td>
<td>link math.h</td>
<td>链接math.h. C++编译器会自动链接, 但C的代码使用了math.h却不启动这个选项很可能出错</td>
</tr>
<tr>
<td>-ansi</td>
<td>ANSI</td>
<td>检查代码是否符合ANSI标准 (常与-Wpedantic连用)</td>
</tr>
<tr>
<td>-Wpedantic</td>
<td>warning pedantic</td>
<td>Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any -std option used.</td>
</tr>
<tr>
<td>-O1, -O2, -O3</td>
<td>optimize</td>
<td>开启速度优化. 开启后编译出的程序比直接编译出的程序快, -O2比-O1快, -O3比-O2快, 但为了避免优化误解代码含义, 在算法比赛中推荐-O2. 当然如果程序十分规范就没有这种担心.</td>
</tr>
<tr>
<td>-DXX</td>
<td>define XX</td>
<td>在编译时定义XX符号 (此处XX是随意什么大写单词的意思), 位于#ifdef XX和#endif中间的语句会被编译</td>
</tr>
</tbody></table>
<h3 id="gcc与g"><a href="#gcc与g" class="headerlink" title="gcc与g++"></a>gcc与g++</h3><p><code>gcc</code>到底能不能编译C++程序?</p>
<p>在某种程度上<code>gcc</code>和<code>g++</code>都可以编译 <strong>.cpp</strong> 后缀的程序, 但是<code>gcc</code>命令不能自动和
C++程序使用的库链接. <code>gcc</code>把后缀为 <strong>.c</strong> 的当作是C程序,而<code>g++</code>将其当作C++程序.
两者都会将后缀为 <strong>.cpp</strong> 的程序视作C++程序, 要注意虽然C++是C的超集,但是两者对语法的要求是有区别的, C++的语法规则更加严谨一些. 编译阶段, <code>g++</code>会调用<code>gcc</code>,因为
<code>gcc</code>命令不能自动链接C＋＋库, 所以通常用<code>g++</code>来完成链接, 统一起见,干脆编译和链接统统用g++了, 这就给人一种错觉, 好像cpp程序只能用g++似的.</p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>💡执行gdb时加选项<code>-q</code> (quiet)可以去掉进入gdb开头的废话.</p>
<p>常用命令:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>全名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>l</td>
<td>list</td>
<td>列出十行代码. 但可以通过<code>set listsize</code>来更改显示多少行, 用<code>show listsize</code>能查看listsize. l后可以接行号, 函数名</td>
</tr>
<tr>
<td>r</td>
<td>run</td>
<td>开始运行程序</td>
</tr>
<tr>
<td>b</td>
<td>break</td>
<td>设置断点, b后接行号或函数名</td>
</tr>
<tr>
<td>c</td>
<td>continue</td>
<td>继续运行. 要注意在断点处停下后用c继续而不是r</td>
</tr>
<tr>
<td>n</td>
<td>next</td>
<td>下一行</td>
</tr>
<tr>
<td>s</td>
<td>step</td>
<td>与n的区别是n会执行完本行语句, 而有函数调用时s会停在函数内</td>
</tr>
<tr>
<td>u</td>
<td>until</td>
<td>执行到指定行号或者指定函数的开头</td>
</tr>
<tr>
<td>i</td>
<td>info</td>
<td>显示各种信息. 如i b显示所有断点,i disp显示display,而i lo显示所有局部变量</td>
</tr>
<tr>
<td>disp</td>
<td>display</td>
<td>把一个表达式设置为display, 当程序每次停下来时都会显示其值</td>
</tr>
<tr>
<td>cl</td>
<td>clear</td>
<td>取消断点, 和b的格式相同. 如果该位置有多个断点, 将同时取消</td>
</tr>
<tr>
<td>cond</td>
<td>condition</td>
<td>用来设置条件断点</td>
</tr>
<tr>
<td>ig</td>
<td>ignore</td>
<td>设置记次断点, count次以前不停止</td>
</tr>
<tr>
<td>wa</td>
<td>watch point</td>
<td>watch a(简写为wa a)可以在变量a修改时停下,并显示出修改前后的变量值</td>
</tr>
<tr>
<td>aw</td>
<td>all watch point</td>
<td>读写时都停下</td>
</tr>
<tr>
<td>rw</td>
<td>read watch point</td>
<td>被读取时停下</td>
</tr>
<tr>
<td>q</td>
<td>quit</td>
<td>退出gdb</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Python中的小技巧</title>
    <url>/zh-CN/2019/07/03/Python%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>俺也记不住语法, 在这里记录一下常见语句.</p>
<a id="more"></a>

<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查看自带的帮助文档"><a href="#查看自带的帮助文档" class="headerlink" title="查看自带的帮助文档"></a>查看自带的帮助文档</h2><p>用<code>help()</code>函数, 以<code>q</code>退出.</p>
<p>❗️ 使用help(module_name)时首先需要import该模块</p>
<h2 id="查看当前python解释器路径"><a href="#查看当前python解释器路径" class="headerlink" title="查看当前python解释器路径"></a>查看当前python解释器路径</h2><p>有时候写程序会发现莫名其妙的bug比如找不到某库, 路径不对等, 可能是因为用错了解释器. 用下面语句可以查看当前解释器的路径:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></tbody></table></figure>

<h2 id="在python解释器里清屏"><a href="#在python解释器里清屏" class="headerlink" title="在python解释器里清屏"></a>在python解释器里清屏</h2><p>搜了一下python里似乎没有很简短的清屏命令, 要用命令只能用类似以下这种:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">a = os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>💡 这是在Linux下清屏的命令, 在Windows要用<code>os.system('cls')</code></p>
<p>💡 将这条命令赋值给一个变量是为了窗口顶部不出现一个0. 你可以单独输入
<code>os.system('clear')</code>试试</p>
<p>但如果你是在<strong>Bash</strong>中打开的python可以用 <code>Ctrl + L</code>, 这是Bash的清屏快捷键.</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="生成等差数列"><a href="#生成等差数列" class="headerlink" title="生成等差数列"></a>生成等差数列</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list(range(begin, end, step))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="生成任意指定列表"><a href="#生成任意指定列表" class="headerlink" title="生成任意指定列表"></a>生成任意指定列表</h2><h3 id="利用列表推导式"><a href="#利用列表推导式" class="headerlink" title="利用列表推导式"></a>利用列表推导式</h3><p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性. <strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3
中都有支持
:</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure>

<p>e.g.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="利用lambda函数"><a href="#利用lambda函数" class="headerlink" title="利用lambda函数"></a>利用lambda函数</h3><p>lambda函数在python, C++, Java等语言中都有, 我理解的作用主要有三:</p>
<ul>
<li>少写几个字</li>
<li>能将一个”函数”以参数的形式传入另一个函数, ❗️注意此处普通函数能被传递并不是什么稀罕事, 更重要的是类似<a href="https://www.zhihu.com/question/20125256/answer/29733906" target="_blank" rel="noopener">这里</a>提到的”伪函数”</li>
<li>避免污染命名空间, 需要一个函数但不知道命什么名时用lambda函数</li>
</ul>
<p>lambda函数主要用在filter(), map(), reduce()中</p>
<p>💡 在python3中<code>reduce()</code>从内建函数中移除了, 被移到了functools模块中</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">2</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, foo)</span><br><span class="line">[<span class="number">18</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x * <span class="number">2</span> + <span class="number">10</span>, foo)</span><br><span class="line">[<span class="number">14</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">54</span>, <span class="number">44</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">64</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> reduce(<span class="keyword">lambda</span> x, y: x + y, foo)</span><br><span class="line"><span class="number">139</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="由列表生成字典"><a href="#由列表生成字典" class="headerlink" title="由列表生成字典"></a>由列表生成字典</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">c = dict(zip(a, b))</span><br></pre></td></tr></tbody></table></figure>

<h2 id="对字典按值排序"><a href="#对字典按值排序" class="headerlink" title="对字典按值排序"></a>对字典按值排序</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">d = {<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>: <span class="number">5</span>, <span class="string">'d'</span>:<span class="number">4</span>, <span class="string">'e'</span>:<span class="number">3</span>}</span><br><span class="line"></span><br><span class="line">sorted(d.items(), key=<span class="keyword">lambda</span> i: i[<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>sorted(iterable, /, *, key=None, reverse=False)</p>
<p>Return a new list containing all items from the iterable in ascending order.</p>
<p>A custom key function can be supplied to customize the sort order, and the
reverse flag can be set to request the result in descending order.</p>
</blockquote>
<p>即<code>iterable</code>处放一个可迭代的对象, <code>key</code>处放自定义函数来选取比较的参数, <code>reverse</code>
处设定是否反向</p>
<p><code>d.items()</code>返回可遍历的(键, 值) 元组数组, <code>key=lambda i: i[1]</code>即此处参与比较的参数是d的值</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Vim使用杂记</title>
    <url>/zh-CN/2019/07/10/vim%E4%BD%BF%E7%94%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>使用vim开发也有半年多啦, 不过配置vim也是个漫长的过程. 记录一下常用快捷键和用法和配置过程.</p>
<a id="more"></a>

<p>🌟首先放上我的<a href="https://github.com/LeoJhonSong/vimrc" target="_blank" rel="noopener">vimrc链接</a></p>
<p>在vim中, 多文件编辑主要涉及三个概念: <strong>窗口</strong>, <strong>标签页</strong>, <strong>缓冲区</strong></p>
<p>相关参考:</p>
<p>🔗 <a href="https://harttle.land/2015/11/14/vim-window.html" target="_blank" rel="noopener">Vim 多文件编辑：窗口</a><br>🔗 <a href="https://harttle.land/2015/11/12/vim-tabpage.html" target="_blank" rel="noopener">Vim 多文件编辑：标签页</a><br>🔗 <a href="https://harttle.land/2015/11/17/vim-buffer.html" target="_blank" rel="noopener">Vim 多文件编辑：缓冲区</a></p>
<p>❗️没有特别说明本文中的代码都是放在 <code>.vimrc</code> 中的.</p>
<h1 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h1><h2 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h2><p><kbd>Ctrl f</kbd> 下翻一页<br><kbd>Ctrl b</kbd> 上翻一页<br><kbd>Ctrl d</kbd> 下翻半页<br><kbd>Ctrl u</kbd> 上翻半页</p>
<h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><p>原本展开代码和折叠代码是绑定在了 <code>zo</code> (z open) 和 <code>zc</code> (z close), 不过我重新映射到了空格键, normal模式下按一次展开, 再按一次折叠, 感觉更方便一些.</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;space&gt;</span> @=((<span class="built_in">foldclosed</span>(<span class="built_in">line</span>(<span class="string">'.'</span>)) &lt; <span class="number">0</span>) ? <span class="string">'zc'</span> : <span class="string">'zo'</span>)<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外 <code>zn</code> 为全部展开, <code>zN</code> 为全部折叠.</p>
<h2 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h2><figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spell</span><br><span class="line"><span class="keyword">set</span> spellfile=~/.<span class="keyword">vim</span>/spell/<span class="keyword">en</span>.utf-<span class="number">8</span>.<span class="built_in">add</span></span><br></pre></td></tr></tbody></table></figure>

<p>按 <code>]s</code> 跳往下一错误拼写, <code>[s</code> 往前跳.</p>
<p>按 <code>zg</code> 将当前光标所在单词记录到字典 (指出当前word 是 good word), <code>zw</code> 将当前单词从字典删除 (指出当前word为wrong word)</p>
<p>vim允许同时使用多个字典, 通过输入 <code>:set spellfile+=path/to/dic/en.utf-8.add</code> 来添加, 但要注意这个文件后缀名一定是 <strong>.[encoding].add</strong></p>
<p>这之后你可以输入 <code>set spellfile?</code> 来查看当前在使用哪些字典, 要将单词添加到第一个字典就按 <code>1zg</code> , 添加到第二个就按 <code>2zg</code> . 很好的一点是spellfile这个变量只在当前缓冲区有效, 即每个文件可以使用不同的spellfile值. 这给保存单词到当前工作区带来了可能. 因此我设置了一个快捷键:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;C-z&gt;</span> :<span class="keyword">exe</span> <span class="string">"setlocal spellfile+="</span> . <span class="symbol">&lt;C-r&gt;</span>=<span class="built_in">shellescape</span>(<span class="built_in">fnamemodify</span>(<span class="string">"en.utf-8.add"</span>, <span class="string">":p"</span>), <span class="number">1</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样每次按<kbd>Ctrl , z</kbd>就会添加一个当前文件所在文件夹的字典到spellfile</p>
<h1 id="调整窗口"><a href="#调整窗口" class="headerlink" title="调整窗口"></a>调整窗口</h1><p>💡 <kbd>Ctrl w</kbd> 开头的都是与窗口有关的快捷键, w指window</p>
<h2 id="在窗口间移动"><a href="#在窗口间移动" class="headerlink" title="在窗口间移动"></a>在窗口间移动</h2><p><kbd>Ctrl w</kbd> 接 hjkl上下左右在各窗口间移动光标<br><kbd>Ctrl w t</kbd> 移动光标至最左上窗口<br><kbd>Ctrl w b</kbd> 移动光标至最右下窗口</p>
<h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>宽度调整:</p>
<p><kbd>Ctrl w [n] &gt;</kbd> 右移边界<br><kbd>Ctrl w [n] &lt;</kbd> 左移边界</p>
<p>💡默认增减1个字符宽度, 可以在Ctrl w和+/-间加数字来指定增减宽度. 不是最右边的窗口调整的是右边界, 最右边的窗口调整的是左边界.</p>
<p>高度调整:</p>
<p><kbd>Ctrl w [n] +</kbd> 增加高度<br><kbd>Ctrl w [n] -</kbd> 减小高度</p>
<p>通过设置以下几个键映射我可以十分方便地调整窗口大小</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F2&gt;</span> <span class="symbol">&lt;C-w&gt;</span>+</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F3&gt;</span> <span class="symbol">&lt;C-w&gt;</span>-</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F4&gt;</span> <span class="symbol">&lt;C-w&gt;</span>&lt;</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F5&gt;</span> <span class="symbol">&lt;C-w&gt;</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="调整位置"><a href="#调整位置" class="headerlink" title="调整位置"></a>调整位置</h2><p><kbd>Ctrl w</kbd> 接HJKL移动窗口至最上下左右并且宽度或高度为最大.
<kbd>Ctrl w r</kbd> 顺时针移动窗口<br><kbd>Ctrl w R</kbd> 逆时针移动窗口</p>
<h1 id="键映射"><a href="#键映射" class="headerlink" title="键映射"></a>键映射</h1><p>vim是能够进行高度个性化的编辑器, 因此每个人肯定都会添加一些自己顺手的快捷键, 因为我是从VSCode转来vim的, 因此我的快捷键设置一定程度上参考了VSC的快捷键设置. 用以在 <strong>.vimrc</strong> 中设定快捷键的命令有好几个, 我的vimrc里比较常用的是 <code>nnoremap</code> 和 <code>map</code> . 以下是我常用的命令及其含义.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>:noremap</td>
<td>nonrecursive map, 不可递归的映射</td>
</tr>
<tr>
<td>:nnoremap</td>
<td>normal nonrecursive map, 只在normal模式有效的noremap</td>
</tr>
<tr>
<td>:inoremap</td>
<td>insert nonrecursive map, 只在insert模式有效的noremap</td>
</tr>
<tr>
<td>:vnoremap</td>
<td>visual nonrecursive map, 只在visual模式有效的noremap</td>
</tr>
<tr>
<td>:map</td>
<td>可递归的映射</td>
</tr>
<tr>
<td>:nmap</td>
<td>normal map, 只在normal模式有效的map</td>
</tr>
</tbody></table>
<p>以下是各种映射命令对应有效的模式. 具体解释可以在vim里用 <code>:help</code> 命令查看.</p>
<p>💡顺带一提是可以把<a href="https://www.liuhaolin.com/vim/272.html" target="_blank" rel="noopener">vim的帮助文档设为中文</a>的</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td>:map   :noremap  :unmap</td>
<td>Normal, Visual, Select, Operator-pending</td>
</tr>
<tr>
<td>:nmap  :nnoremap :nunmap</td>
<td>Normal</td>
</tr>
<tr>
<td>:vmap  :vnoremap :vunmap</td>
<td>Visual and Select</td>
</tr>
<tr>
<td>:smap  :snoremap :sunmap</td>
<td>Select</td>
</tr>
<tr>
<td>:xmap  :xnoremap :xunmap</td>
<td>Visual</td>
</tr>
<tr>
<td>:omap  :onoremap :ounmap</td>
<td>Operator-pending</td>
</tr>
<tr>
<td>:map!  :noremap! :unmap!</td>
<td>Insert and Command-line</td>
</tr>
<tr>
<td>:imap  :inoremap :iunmap</td>
<td>Insert</td>
</tr>
<tr>
<td>:lmap  :lnoremap :lunmap</td>
<td>Insert, Command-line, Lang-Arg</td>
</tr>
<tr>
<td>:cmap  :cnoremap :cunmap</td>
<td>Command-line</td>
</tr>
<tr>
<td>:tmap  :tnoremap :tunmap</td>
<td>Terminal-Job</td>
</tr>
</tbody></table>
<p>💡 关于应当避免使用 <code>map</code> 的具体原因可以参考<a href="http://learnvimscriptthehardway.stevelosh.com/chapters/05.html#nonrecursive-mapping" target="_blank" rel="noopener">这里</a></p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h2><p>我用<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>来管理我的vim插件, 使用很简单, 写法可以参照我的vimrc. 每次要下载插件时在vim中输入 <code>:PlugInstall</code> 即可. 超好用😆</p>
<h2 id="NERDtree"><a href="#NERDtree" class="headerlink" title="NERDtree"></a>NERDtree</h2><p>NERDtree是一个不错的文件资源管理器, 体验和VSC的explorer差不多. 觉得每次输
<code>:NERDTreeToggle</code> 太麻烦的话可以键绑定一下:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;C-e&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>我绑定到了<kbd>Ctrl , e</kbd>, 和本来想绑的VSC里的<kbd>Ctrl shift e</kbd>不同. 因为在终端中<kbd>Ctrl
shift 字母</kbd>和<kbd>Ctrl 字母</kbd>的输出没有区别.</p>
<p>以下是几个我比较常用的NREDtree命令</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>切换NERDtree根目录到光标所在文件夹</td>
</tr>
<tr>
<td>R</td>
<td>刷新根目录</td>
</tr>
<tr>
<td>r</td>
<td>刷新光标所在目录</td>
</tr>
<tr>
<td>s</td>
<td>水平分屏打开</td>
</tr>
<tr>
<td>i</td>
<td>竖直分屏打开</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>vim</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/zh-CN/2019/08/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>… 前几天刚说最近没有用C的需求我就开始要写C++了 🤦</p>
<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>MATLAB杂记</title>
    <url>/zh-CN/2019/08/05/MATLAB%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>再开学的课程就要用MATLAB了, 而且了解很多机械系唯一要求学的编程语言就是MATLAB, 我决定还是稍微了解下.</p>
<a id="more"></a>

<p>首先, <a href="https://www.zhihu.com/question/37824202/answer/767114071" target="_blank" rel="noopener">MATLAB到底是不是编程语言?</a></p>
<p>从<strong>TIOBE</strong>上有MATLAB而且MATLAB排名还不低可以看出MATLAB确实是一门编程语言, 但从上面链接可以看出MATLAB算是<strong>残疾</strong>的编程语言, 很多特性没有, 更多的是<strong>用来验证算法可行性</strong>.但我又想验证算法可行性为啥不用Python什么的, 语法也不麻烦呀? 然后我发现原本用<strong>Octave</strong>教深度学习的吴恩达现在改用<strong>Python</strong>了 😁</p>
<p>💡 (这条是后来补的) 但其实随着使用我发现在<strong>矩阵计算方面</strong>MATLAB的语法还是比python简单很多.</p>
<p>因此我觉得MATLAB的优势主要就在:</p>
<ul>
<li>语法简单, 没有编程基础的工科生也能快速掌握, 尤其计算方面的语法比Python简单太多</li>
<li>集成度特别高, 各种工具都能轻松快速配置好</li>
<li>能和多种语言交互, 编写界面简单</li>
<li>很多工具都有图形界面, 操作简单, 按按键就可以, 不用写那么多代码.</li>
</ul>
<p>总而言之, 虽然缺点多多, MATLAB还是很值得一学的</p>
<h1 id="MATLAB软件个性化设置"><a href="#MATLAB软件个性化设置" class="headerlink" title="MATLAB软件个性化设置"></a>MATLAB软件个性化设置</h1><h2 id="设置初始工作文件夹"><a href="#设置初始工作文件夹" class="headerlink" title="设置初始工作文件夹"></a>设置初始工作文件夹</h2><p>使用HOME目录作为起始工作文件夹我觉得不是什么好事, 所以最好自己指定一个合适的目录. 我使用的是MATLAB默认的<code>userpath</code>, 即<strong>Documents/MATLAB</strong>文件夹. 一方面这个文件夹看着比较合理, 一方面MATLAB说<a href="https://ww2.mathworks.cn/help/matlab/matlab_env/matlab-startup-folder.html#bujzf43" target="_blank" rel="noopener">使用userpath作为初始工作文件夹有一定好处</a>.</p>
<p>Linux下设置MATLAB的初始工作文件夹方法和在Windows下改快捷方式的起始位置这种方法不一样, 要达到这个目的有两种方式:</p>
<ol>
<li>在终端输入 <code>matlab -useStartupFolderPref</code> 打开MATLAB. -useStartupFolderPref选项指定初始工作文件夹为在<strong>Preference</strong>中<strong>Initial working folder option</strong>的指定文件夹.</li>
<li>在终端输入 <code>matlab -sd [folder]</code> 打开MATLAB. -sd选项指定初始工作文件夹为[folder]文件夹.</li>
</ol>
<h2 id="更改编辑界面颜色主题"><a href="#更改编辑界面颜色主题" class="headerlink" title="更改编辑界面颜色主题"></a>更改编辑界面颜色主题</h2><p>在vim, VSC, VS, CLION, Pycharm等工具用惯了黑暗主题以后拿到啥都想先换个黑暗主题. 但是找了半天也只找到了设置编辑界面颜色主题的方式, 普通操作似乎并不能自定义丑陋的灰色工具栏.</p>
<p>最终我把界面变成了这样 👇</p>
<p><img src="MATLAB%E6%9D%82%E8%AE%B0/appearance.png" alt="界面"></p>
<ul>
<li>颜色主题是通过<a href="https://github.com/scottclowe/matlab-schemer" target="_blank" rel="noopener">MATLAB Schemer</a>里的脚本更换的, 一键更换好评👍 因为我比较喜欢糖果色的颜色主题然后又不喜欢注释是灰色 (不管在黑色背景还是白色背景里辨析度都很低), 于是选择的主题是<a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes#dark-steel" target="_blank" rel="noopener">Dark Steel</a>.</li>
<li>字体用的是<a href="https://github.com/powerline/fonts/tree/master/DejaVuSansMono" target="_blank" rel="noopener">DejaVu Sans Mono for Powerline</a>, 大小是11, 不过不知道为什么MATLAB显示不带效果的字体看着很粗糙, <strong>边缘锯齿状过于明显</strong>, 效果设置为了 <strong>bold</strong>, 这回好多了!</li>
<li>布局改成了和我常用的vim, VSC差不多的布局: 资源管理器在左上, 细节信息在左下, 编辑窗口在右</li>
</ul>
<h1 id="MATLAB语法和工具"><a href="#MATLAB语法和工具" class="headerlink" title="MATLAB语法和工具"></a>MATLAB语法和工具</h1><h2 id="在终端运行"><a href="#在终端运行" class="headerlink" title="在终端运行"></a>在终端运行</h2><p>曾经我因为嫌MATLAB界面太丑又不能个性化想过在终端像用交互式Python一样用交互式
MATLAB以及运行脚本. 我发现这是可行的:</p>
<p>在终端启动交互式MATLAB:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">matlab -nojvm</span><br></pre></td></tr></tbody></table></figure>

<p><code>-nojvm</code>选项本身是<strong>不启动Java虚拟机</strong>的意思, 但因为Matlab的GUI都是用Java写的
(听网上说的), 所以也有<code>-nosplash</code> (<strong>不显示启动画面</strong>), <code>-nodesktop</code>
(<strong>不启动图形界面</strong>) 的功能. 另外因为没有启动jvm这样启动MATLAB十分迅速.</p>
<p>💡 要注意用<code>-nojvm</code>选项时会创建图形界面的命令会报错.</p>
<p>在终端运行MATLAB脚本:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">matlab -batch [MATLAB_command]</span><br></pre></td></tr></tbody></table></figure>

<p><code>-batch</code>选项和<code>-r</code>选项的区别在于前者不会启动图形界面而后者会. 另外如果脚本中没有与图形界面有关的语句同样可以加上<code>-nojvm</code>选项.</p>
<p><strong>但是啊!</strong></p>
<p>我后来发现这样就<strong>本末倒置</strong>了! MATLAB的亮点我觉得一是所有变量都是全局变量, 能迅速可视化变量, 工具集成度非常高, 适合迅速验证各种算法, 二是社区非常完善, 提供了很多工具能轻松仿真很多模型.</p>
<p>因此只在终端的MATLAB是没有灵魂的MATLAB. <strong>如果终端里的MATLAB就能解决你的需求的话为什么不用Python?</strong> 🤤</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>MATLAB</category>
      </categories>
  </entry>
  <entry>
    <title>初学Socket通信</title>
    <url>/zh-CN/2019/08/07/%E5%88%9D%E5%AD%A6socket%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>记大二暑假北航实习</title>
    <url>/zh-CN/2019/08/05/%E8%AE%B0%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E5%8C%97%E8%88%AA%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<p>这个暑假我来到了北航<a href="http://softrobotics.buaa.edu.cn/peoples/peoples_ch/index.htm" target="_blank" rel="noopener">仿生软体机器人实验室</a>学习, 收获颇多.
结实了一群有趣的人, 得到了一些答案, 看到了更明确的方向, 坚定了我研究软体机器人的信念💪</p>
<a id="more"></a>

<p>如今我愈发觉得玄幻小说里一种很玄的情节其实很现实: <strong>历练总是能有些机缘!</strong></p>
<p>有些事情在事前真的无法预测, 比如在我这次前往北京学习一个半月之前, 我是完全想不到我能有什么收获的, 而最终的收获多到一两句说不清. <strong>如果在家仔细思考, 总会觉得一个半月那样短, 去了又能怎样?</strong> 再引用一句玄幻小说里的话:</p>
<blockquote>
<p>我辈修士, 当与天争命!</p>
</blockquote>
<p>事实证明, 只要自己主动抓住各种机会一个半月并不那样短暂.</p>
<p>这一个半月我干了许多事: 我浇筑了一套软体臂, 软体爪, 我试着帮实验室的学长解决实验面临的困难, 我每天站着巨久调试了半个月机器人, 我随实验室的队伍到大连参加了一个难度很高的比赛, 我在大连每天白嫖各种海鲜, 我和在中科院中关村学生公寓的室友相处不错还一块深夜吃了烧烤, 我给好几人上了家教课, 我经常和在北京的亲属玩,我, 我试图减肥并失败
🤦‍</p>
<h2 id="关于学习收获"><a href="#关于学习收获" class="headerlink" title="关于学习收获"></a>关于学习收获</h2><h3 id="在实验室的体会"><a href="#在实验室的体会" class="headerlink" title="在实验室的体会"></a>在实验室的体会</h3><p>实际上在前往文老师的实验室前我并没有真正接触到软体机器人: 只能自己看看资料算什么? 但我也很无奈啊, 想做的实验材料就动辄几千, 而花销小的实验一般是真-实验室阶段,
我一时半会研究不出什么名堂. 更何况我在电子科大并没有找到相关团队. 而到文老师实验室这段时间我不仅是更正了一些对软体机器人的理解, 更是对科研有了一些概念.</p>
<p>很幸运的是实验室所有人人都很好, 我很快就融入其中, 也有幸和几位学长探讨了他们的工作. 谢博士的废寝忘食令我记忆犹新. 好几次谢博因为想解决问题而晚去吃饭. 谢博也很虚心, 因为并不是电气专业出身, 实验遇到电气方面问题还拉我一起研究. 辉哥则和我聊了很多过来人的经验, 他建议说在国外科研更加自由, 能支持更基础的研究方向, 杂事更少, 老师和学生的关系更像合作伙伴, 而最后如果能留在国外就不用按国内五年一个职位的累死累活竞争等等. 结对调试机器人的同样来自四川的陈学长则和我分享了许多学习经验, 在我看来他的学习经历实在是一次逆袭. 而见到文老师前我同样没想到是这样一位爱夸人的总是在笑的老师. 这一个半月我更多的时间是和刘学长在一起, 他也教了我很多, 比如如何浇筑
(我一个学电气的是完全没做过这种事的), 而来实验室前的许多疑问我也从他那得到了解答
.</p>
<p>亲身站在实验室里我更直观的体会到了软体机器人是怎样的一个领域. 虽然刘学长觉得软体机器人现在发展趋势缓下来了, 但我觉得这个领域仍在萌芽阶段. 从我了解到的成果和在实验室近距离看学长们的工作来看, 除了软体抓手现在已经商业化了其他成果仍离走出实验室差很远, 有些甚至只是证明了一些结构的潜力, 说白了目前基本是空架子. 就比如实验室花了好几万买的液态金属打印机, 不光墨水贵, 还经常不出墨, 出墨也不够理想, 和谢博一起做实验的袁学长说某些方面甚至可能比不上以前手工浇筑的效果. 不过最近清华大学刚研发出了类似喷墨打印机原理的液态金属打印方式, 看论文效果很不错, 期待能尽早推出产品.
目前的成果之所以离投入应用还远一方面是因为目前的软体机器人因为使用的驱动方式, 能提供的驱动力普遍很小, 基本没有应用场景, 另一方面是因为目前软体机器人的控制基本是黑暗一片, 就算是一段较早出现的软体臂也没有一个称得上很好的闭环控制方法. 而针对非结构性环境的软体机器人如果连闭环都做不到还有何用? 虽然目前也有好几项人来控制, 机器人负责在人类很难触及的环境 (比如人体内, 十分狭窄的缝隙, 20m深的海底) 执行的成果, 但我认为自主始终是趋势.</p>
<p>另外一点在实验室学到的, 觉得很有意思的是如何记<strong>组会记录</strong>. 首先记肯定是要记的,
不然如果讨论的不是自己在参与的项目时岂不是在浪费时间? 我认为组会本就是集思广益大家相互交流经验的地方 (这点在我们组里也很明显, 每个人讲完自己的项目进度后老师会问大家的看法和建议), 因此如果在组会中只注意讲好自己的项目就本末倒置了. 记组会记录一方面帮助自己整理思路, 看看能给正在讲的同学什么帮助, 另一方面讲大家的经验记录下来,这样以后自己遇到类似问题就能有突破口, 另外老师有时候也会给一些写论文方面的指导,也值得记录. 我觉得记组会记录最好用OneNote这种手写的电子档, 自由度高, 适合写写画画整理思路, 电子档也更利于保存.</p>
<h3 id="对C-的体会"><a href="#对C-的体会" class="headerlink" title="对C++的体会"></a>对C++的体会</h3><p>再有就是我学习C++的速度还是令我觉得值得表扬的😆 实际上在这个暑假之前我是不会C++
的,顶多是大一上的时候学了最基础的C. 我是这个暑假开始时从学长那里继承了本紫色的**
算法竞赛入门经典<strong>巩固了下C语言, 了解了一些C++. 而到了实验室先是照着网上的模板写了个C++的TCP server, 然后和中科院的学长一起负责ROV的控制代码 (纯C++). 说实话一方面是大一上扎实的C基础帮了大忙 (我明明每一科都能很好地应用可我就是考不好真的好气), 另一方面则是我浏览器程序员的特长: 上网查资料发挥了巨大作用😁 这真的是现学现卖.好在学长把核心代码都写好了, 我就写了写语法很简单的控制流程什么的. 期间也因为不熟悉C++遇到了很多奇葩问题, 比如就因为在</strong>多线程C++程序**中用错了计时函数导致了计时不准, 程序崩溃等各种迷之错误… 反正一波C++速成后我对C++的印象极差, 标准库很落后, 坑很多, 语法很啰嗦 (和我最爱的Python比), 环境配置也比Python开发麻烦等等…</p>
<p>以后我自己写程序用到C/C++顶多是要求算力部分用C/C++来加速, 或者用到的工具只有
C/C++接口时.其他部分全部用Python糊!</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后想发表一番感慨: 虽然这只是我的大二暑假, 但实际上我在高三暑假就决定了以后研究机器人, 为此学习了许多, 做着各种各样的准备. 比如我学习了Python, 也针对机器人中很常用到的机器学习和CV分别做了一个小项目 (<a href="https://github.com/LeoJhonSong/SVM-Learning-Sample" target="_blank" rel="noopener">我的机器学习小项目</a>, <a href="https://github.com/LeoJhonSong/Fingertip-Drawboard" target="_blank" rel="noopener">我的CV小项目</a>)来学习了解, 比如我查阅了许多软体机器人的文献, 也曾自己试着<a href="https://leojhonsong.github.io/zh-CN/2018/12/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/">用仿真软件仿真软体机器人</a>,
以及即便曾经的我<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/为什么我用Linux而不是Windows/">曾找各种理由来说服自己用Linux</a> (当然后来就离不开Linux了)… 总之我曾努力学习过的东西都确实地派上了用场, 我感到自己的努力没有白费💪 我会再接再厉!</p>
<h2 id="关于家教"><a href="#关于家教" class="headerlink" title="关于家教"></a>关于家教</h2><p>另外我在北京这段时间在一个叫<strong>易教网</strong>的平台接了几份家教的工作. 经过了这一段时间的体验我觉得当家教是一件既有趣又促进自己学习还赚钱的事.</p>
<h2 id="关于北京"><a href="#关于北京" class="headerlink" title="关于北京"></a>关于北京</h2><p>第一次在北京待一个半月, 见识到了首都的另一面. 以前我是个京黑, 这次在北京的体验改变了我的印象, 让我变成了真*京黑😁 是的印象一点也没有变好! 或者说见到了好的一面,
但也加深了负面印象.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Linux终端呈现彩色输出</title>
    <url>/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: <strong>让特定类型的输出显示为特定的颜色</strong>!</p>
<a id="more"></a>

<p>比如这样:</p>
<p style="color:purple">
[MESSAGE] Turning left
</p>
<p style="color:yellow">
[DEBUG] target: 4
</p>
<p style="color:red">
[Error] target not found
</p>
<p style="color:purple">
[MESSAGE] Turning left
</p>
<p style="color:purple">
[MESSAGE] Diving
</p>
<p style="color:green">
[INFO] depth: 9m
</p>
<p style="color:purple">
[MESSAGE] Diving
</p>
<p style="color:green">
[INFO] depth: 10m
</p>
<p style="color:purple">
[MESSAGE] Forward
</p>
<p style="color:purple">
[MESSAGE] Turing right
</p>


<p>能极大的增强终端信息的可读性!😆</p>
<p>这应该是Linux终端的特性, (我并不清楚是否兼容Windows命令行), shell, python, C++的彩色文字语法几乎是一样的.</p>
<h2 id="颜色表"><a href="#颜色表" class="headerlink" title="颜色表"></a>颜色表</h2><table>
<thead>
<tr>
<th>前景色 (字体颜色) 代码</th>
<th>背景色代码</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>30</td>
<td>40</td>
<td>黑色</td>
</tr>
<tr>
<td>31</td>
<td>41</td>
<td>紅色</td>
</tr>
<tr>
<td>32</td>
<td>42</td>
<td>綠色</td>
</tr>
<tr>
<td>33</td>
<td>43</td>
<td>黃色</td>
</tr>
<tr>
<td>34</td>
<td>44</td>
<td>藍色</td>
</tr>
<tr>
<td>35</td>
<td>45</td>
<td>紫紅色</td>
</tr>
<tr>
<td>36</td>
<td>46</td>
<td>青藍色</td>
</tr>
<tr>
<td>37</td>
<td>47</td>
<td>白色</td>
</tr>
</tbody></table>
<h2 id="字体效果表"><a href="#字体效果表" class="headerlink" title="字体效果表"></a>字体效果表</h2><table>
<thead>
<tr>
<th>代码</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>默认</td>
</tr>
<tr>
<td>1</td>
<td>高亮(加粗)</td>
</tr>
<tr>
<td>4</td>
<td>下划线</td>
</tr>
<tr>
<td>5</td>
<td>闪烁</td>
</tr>
<tr>
<td>7</td>
<td>反色</td>
</tr>
<tr>
<td>8</td>
<td>不可见</td>
</tr>
</tbody></table>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h3><p>举例:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo "\e[31;43;1mError\!\e[0m"</span><br></pre></td></tr></tbody></table></figure>

<p>💡 如果上面这条命令不是彩色的, 执行<code>echo -e "\e[31;43;1mError\!\e[0m"</code></p>
<p>运行上面这条命令会输出一个黄底红色粗体字的”Error!”. 前景色, 背景色和字体效果的代码没有先后顺序之分. 建议每个<code>\e[a;b;c</code>都接一个<code>\e[0m</code>将字体效果恢复默认, 不然后续输出还是带特殊效果的.</p>
<h3 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h3><p>在<code>print()</code>中使用的示例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">"\033[31;43;1mError!\033[0m"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>或者可以通过python执行shell命令:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">'echo "\e[31;43;1mError!\e[0m"'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h3><p>在C++中使用的语法和在python中是一样的:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[31;43;1m"</span> &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; <span class="string">"\033[0m"</span> &lt;&lt; <span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>一个小技巧是可以单独写一个<code>color_print.h</code>, 内容示例:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET   <span class="meta-string">"\033[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK   <span class="meta-string">"\033[30m"</span>      <span class="comment">/* Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED     <span class="meta-string">"\033[31m"</span>      <span class="comment">/* Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN   <span class="meta-string">"\033[32m"</span>      <span class="comment">/* Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW  <span class="meta-string">"\033[33m"</span>      <span class="comment">/* Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE    <span class="meta-string">"\033[34m"</span>      <span class="comment">/* Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGENTA <span class="meta-string">"\033[35m"</span>      <span class="comment">/* Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN    <span class="meta-string">"\033[36m"</span>      <span class="comment">/* Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE   <span class="meta-string">"\033[37m"</span>      <span class="comment">/* White */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLACK   <span class="meta-string">"\033[1m\033[30m"</span>      <span class="comment">/* Bold Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDRED     <span class="meta-string">"\033[1m\033[31m"</span>      <span class="comment">/* Bold Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDGREEN   <span class="meta-string">"\033[1m\033[32m"</span>      <span class="comment">/* Bold Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDYELLOW  <span class="meta-string">"\033[1m\033[33m"</span>      <span class="comment">/* Bold Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLUE    <span class="meta-string">"\033[1m\033[34m"</span>      <span class="comment">/* Bold Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDMAGENTA <span class="meta-string">"\033[1m\033[35m"</span>      <span class="comment">/* Bold Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDCYAN    <span class="meta-string">"\033[1m\033[36m"</span>      <span class="comment">/* Bold Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDWHITE   <span class="meta-string">"\033[1m\033[37m"</span>      <span class="comment">/* Bold White */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(color, context) std::cout &lt;&lt; color &lt;&lt; context &lt;&lt; RESET &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在要显示彩色输出的cpp文件中引用这个头文件, 打印语句示例:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">print(BOLDRED, <span class="string">"Error!"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>因为是宏替换因此<code>context</code>字段其实可以随意填, 比如有一个变量<code>depth</code>, 用下面语句来打印深度是可以的:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">print(BOLDGREEN, <span class="string">"depth: "</span> &lt;&lt; depth &lt;&lt; <span class="string">"m"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>超好用!😆</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
        <category>Linux</category>
        <category>调试</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown安利&amp;Typora简要使用教程</title>
    <url>/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>在此我来安利一下<strong>Markdown</strong>和<strong>Typora</strong>.</p>
<a id="more"></a>

<h2 id="Markdown安利"><a href="#Markdown安利" class="headerlink" title="Markdown安利"></a>Markdown安利</h2><h3 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h3><p>Markdown是一门语言, 一门轻量级的<strong>标记语言</strong> (Markup Language). 有没有觉得这个词很眼熟? 是的, HTML全称<strong>HyperText Markup Language</strong>. Markdown和HTML同属于Markup
Language(Markdown是一门Markup Language是Markdown作者的恶趣味), 它们与C, Python等编程语言并不是一类东西. <strong>Markup</strong>这个词源自<strong>印刷业</strong>, 指的是在电子排版技术出现之前人们对印刷物内容的排版进行标记的方式. 比如一段文字应当是<strong>粗体</strong>, <em>斜体</em>,
<u>有下划线</u>还是<del>有删除线</del>, 使用什么字体, 字体大小, 左页边距应当是多少, 一张图片该放在哪里, 多大等等…</p>
<p>💡 也就是说以前的人们在将原稿最终印刷出来前想知道会印成什么样基本靠脑补, 而现在我们称这个由标记语言文件得到最终效果的过程为<strong>渲染</strong> (render).</p>
<p>而之所以我们说Markdown是一门<strong>轻量级</strong>的标记语言是因为在Markdown的语法比HTML等标记语言要简洁太多😆</p>
<ul>
<li>一</li>
<li>二</li>
</ul>
<p>比如👆 上面这个列表的Markdown实现代码为</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>一</span><br><span class="line"><span class="bullet">- </span>二</span><br></pre></td></tr></tbody></table></figure>

<p>而HTML实现代码为</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>但Markdown有时候也会让人觉得太过轻量级以至于缺少一些语法, 比如这个<u>下划线</u>
其实是用HTML标签实现的. 好在你也可以在Markdown文件中写HTML, 如今的Markdown渲染工具基本都支持这个功能.</p>
<p>也是由于上面这个原因, 在Markdown作者们推出的
<a href="https://commonmark.org/" target="_blank" rel="noopener"><strong>CommonMark</strong></a>的基础上有了添加了更多语法的各种
Markdown超集, 比如GitHub发布的<a href="https://github.github.com/gfm/" target="_blank" rel="noopener"><strong>GitHub Flavored
Markdown</strong></a>.</p>
<h3 id="Markdown应用广泛吗"><a href="#Markdown应用广泛吗" class="headerlink" title="Markdown应用广泛吗"></a>Markdown应用广泛吗</h3><p>实际上如今Markdown的使用相当广泛, 只要是支持所谓<strong>富文本</strong>的社区/论坛等, 比如说
<strong>GitHub</strong>, <strong>知乎</strong>, <strong>Stack OverFlow</strong>, <strong>CSDN博客</strong>, <strong>Wikipedia</strong>都是使用的
Markdown. 另外因为Markdown和HTML的转换十分容易, 目前大多个人博客都是编辑Markdown
格式的文章再生成HTML页面, 比如我正在码的也是Markdown文件.</p>
<p>再有就是目前大多数项目根目录的<strong>README</strong>文档都是Markdown格式, 而在线查看项目代码时
GitHub等代码托管网站都会自动将项目中所有Markdown文件渲染出来.</p>
<h3 id="为什么我们使用Markdown"><a href="#为什么我们使用Markdown" class="headerlink" title="为什么我们使用Markdown"></a>为什么我们使用Markdown</h3><p>以下是网上的一些总结和我个人的体会.</p>
<ol>
<li>Markdown的设计理念是易读易写, 因此<strong>即便不渲染Markdown文件的可读性也很高</strong>,
这让没有Markdown渲染工具的人也能很好地阅读, 而如果要脑力渲染HTML, 一会就眼晕了.</li>
<li>这种格式能让文档很方便的排列为很简洁好看的排版, <strong>能让人专注于书写内容</strong>, 不必费神排版</li>
<li>支持代码按语言的语法高亮</li>
<li><strong>能很方便的进行版本管理</strong>. 在要进行版本管理的项目中的Word文件简直是毒瘤, 不操作一番的话版本管理工具比如git并不能识别word文件具体变化, 而使用纯文本的
Markdown能让每次的更改被体现出来!</li>
<li><strong>占用空间小</strong> (可以想一想一个word文档的大小)</li>
<li><strong>能很容易地转为多种格式</strong>. Markdown和HTML是兄弟关系,因此Markdown文件能轻松转换成
<strong>HTML</strong>文件格式以及HTML文件能轻易转换为的格式(<strong>PDF</strong>, <strong>jpg</strong>, <strong>Epub</strong>等)
是显而易见的. 通过一些额外工具(比如<a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>)的帮助,
Markdown文件还能一键转化为更多文件格式,比如<strong>LaTeX</strong>, <strong>Word</strong>,
<strong>OpenOffice</strong>, <strong>Media Wiki</strong>等.</li>
<li>能方便的插入图片, 表格, 超链接等</li>
<li>兼容HTML语法, 因此我们想让页面显示成什么样就可以显示成什么样</li>
<li>可以兼容LaTeX语法, 可以很方便的显示复杂公式</li>
<li>还可以兼容<strong>Graphviz</strong>, <strong>Mermaid</strong>等流程图工具等等…</li>
</ol>
<h3 id="Markdown简明语法"><a href="#Markdown简明语法" class="headerlink" title="Markdown简明语法"></a>Markdown简明语法</h3><ul>
<li><p>一个标题以几个<code>#</code>开头, 空格后是文字. 以#的个数来表示第几级标题</p>
</li>
<li><p>以 - 开头接一个空格开始一个子弹列表, 以 1. 接空格开始一个有序列表</p>
</li>
<li><p>在要加粗的词两侧加 ** 来加粗. 如果要打出 ** 等特殊字符要在星号前加 \ 来转义 </p>
</li>
<li><p>在<strong>行内代码</strong>两侧加 ` .  注意这不是单引号, 在我键盘上在<kbd>Esc</kbd> 键下面. 当然这个不只是用来放行内代码的, 也可以放别的.</p>
</li>
<li><p>在代码块上下行加 ``` , 第一个```后写代码的语言.</p>
</li>
<li><p>在Typora这个软件里插入图片很容易, 直接<code>Ctrl V</code>粘贴就好了, 或者右键, 里面有插入图片的按键. 插入图片的markdown语法是</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">![<span class="string">当图片失效时此处显示的文字</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>插入超链接的语法和插入图片的语法很像, 此处举例说明. 这是点击进入百度的链接👉 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>表格用<code>|</code>分隔每个元素, 第一行是各列的名字, 第二行的 <code>|</code>间是<code>-</code>, 分隔列名和值. 以下是一个例子</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
</tbody></table>
<ul>
<li>更详细的语法说明在Typora内可以查看Typora自带的Markdown语法参考手册</li>
</ul>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569274096465.png" alt="1569274096465"></p>
<h2 id="Typora安利"><a href="#Typora安利" class="headerlink" title="Typora安利"></a>Typora安利</h2><p>那么用什么软件来写Markdown呢? 认准<a href="https://typora.io/#download" target="_blank" rel="noopener"><strong>Typora</strong></a>!</p>
<p>Typora的优点多到我不想写 (不其实是单纯不想写了), 最突出的优点我觉得是它的<strong>颜值</strong>,
以及<strong>能直接将图片粘贴到文件中</strong>.</p>
<h3 id="Typora快速入门"><a href="#Typora快速入门" class="headerlink" title="Typora快速入门"></a>Typora快速入门</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>在<strong>Themes</strong>一栏可以切换软件的主题</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569271897771.png" alt="1569271897771"></p>
<h4 id="大纲视图"><a href="#大纲视图" class="headerlink" title="大纲视图"></a>大纲视图</h4><p>可以按这个<strong>OutLine</strong>或者按左下角的小圆圈触发大纲视图, 点击大纲视图里的标题可以快速跳转.</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272130639.png" alt="1569272130639"></p>
<h4 id="源代码视图"><a href="#源代码视图" class="headerlink" title="源代码视图"></a>源代码视图</h4><p>按左下角这个<kbd>&lt;/&gt;</kbd>可以切换到源代码视图</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272534032.png" alt="1569272534032"></p>
<h4 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h4><p>右下角这里可以选择进行拼写检查的语言或者关闭这个功能.</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272445049.png" alt="1569272445049"></p>
<h4 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h4><p>按这个<strong>Preference</strong>可以进行更多偏好设置.</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272312746.png" alt="1569272312746"></p>
<p>以下是我的推荐设置</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051240.png" alt=""></p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20200227124912356.png" alt="image-20200227124912356"></p>
<p>勾选<strong>对网络图片应用上述规则</strong>那直接粘贴从浏览器复制的图片时Typora会自动将该图片下载到这个指定文件夹.</p>
<p>忽略单个换行让Typora遵循GFM: 单个换行不渲染为换行, 两个换行才渲染为换行</p>
<p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051204.png" alt=""></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础语法</title>
    <url>/zh-CN/2019/09/12/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇</p>
<a id="more"></a>

<h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><table>
<thead>
<tr>
<th>版本</th>
<th>实现方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>CPython</td>
<td>C语言写的Python</td>
<td>速度快</td>
</tr>
<tr>
<td>JPython</td>
<td>由Java编写的Python</td>
<td>可以直接调用Java的各种函数库</td>
</tr>
<tr>
<td>PyPy</td>
<td>由rPython编写的Python</td>
<td>更灵活, 易于使用和试验</td>
</tr>
<tr>
<td>IronPython</td>
<td>以. NET和Mono实现的Python</td>
<td>面向NET和ECMA CLI的Python实现</td>
</tr>
<tr>
<td>ZhPy</td>
<td>只是把Python翻译了一遍而已</td>
<td>又称中蟒, 可以完全用中文编程. 但中蟒目前已经停止更新了.</td>
</tr>
</tbody></table>
<p>我们通常所说的Python是<strong>CPython</strong>, 👇Python官方页面提供的是CPython</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1565579206457.png" alt="1565579206457"></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Python这种语言有<strong>Python2</strong>和<strong>Python3</strong>两个版本, 两者语法有少许不同, 比如Python2和Python3中<code>print()</code>的使用有区别, Python2和Python3中<code>input()</code>接受的数据类型有区别等.</p>
<p>最新的Python2对大部分Python2, 3不同的语法做了兼容, 而在Python3对Python2的语法兼容性很差, 但是提供了一个叫<a href="https://docs.python.org/zh-cn/3.7/library/2to3.html" target="_blank" rel="noopener">2to3</a>的脚本帮助我们将Python2的程序转换为Python3的程序.</p>
<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p><strong>万物皆对象</strong></p>
<p>python在设计初始是一种<strong>面向对象</strong>语言.</p>
<p>💡 面向对象是一种<strong>编程范式</strong></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python是一门<strong>动态类型</strong>语言</p>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>在Python3中有了一个新特性: <strong>类型注解</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure>

<p>正如其名, 注解只是标注一下, 有了类型注解的程序和没有类型注解的程序运行起来没有区别, 但它能帮助程序员更好的发现问题, 也能让IDE提供更准确的代码补全和语法检查.</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>有时候为了保证程序的严谨性我们会检查一下变量是不是我们设想它应该是的类型, 这个时候我们用 <code>isinstance()</code></p>
<p>之所以不使用 <code>type()</code> 是因为 <code>type()</code> 不会认为子类是一种父类类型, 不考虑继承关系. 举例说明:</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571027624789.png" alt="1571027624789"></p>
<h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>❗️ <strong>我们可以给不可变对象重新赋值, 但其内存地址会改变</strong>. 以下是体现给可变对象/不可变对象重新赋值时它们的内存地址变化的例子.</p>
<p>💡 <code>id()</code>能获取一个变量的内存地址</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571022411897.png" alt="1571022411897"></p>
<h4 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number (数字)"></a>Number (数字)</h4><ul>
<li>int (整数)</li>
<li>long (长整数)</li>
<li>float (浮点数, 即小数)</li>
<li>bool (布尔值, 即 <code>True</code> 和 <code>False</code> )</li>
</ul>
<p>Python中的Number我认为是比较特殊的, 因为它<strong>在内存中占用的空间大小是变动</strong>的.(在CPython中是如此, 但不知道为什么在IronPython下不是)</p>
<p>💡 用<code>sys.getsizeof()</code>可以知道一个变量的占用的内存大小</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571022628668.png" alt="1571022628668"></p>
<h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String (字符串)"></a>String (字符串)</h4><h4 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple (元组)"></a>Tuple (元组)</h4><h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>可变对象可能带来的危险举例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(l = [])</span>:</span></span><br><span class="line">    l.append(<span class="string">'add'</span>)</span><br><span class="line">    print(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc()</span><br></pre></td></tr></tbody></table></figure>

<h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List (列表)"></a>List (列表)</h4><p>💡 <strong>string</strong>和<strong>tuple</strong>都是特殊的<strong>list</strong></p>
<h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set (集合)"></a>Set (集合)</h4><h4 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary (字典)"></a>Dictionary (字典)</h4><p>👇 在网上偷的<strong>string, tuple, list, dictionary的突出区别比较</strong>.</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>是否可变</th>
<th>是否可迭代</th>
<th>是否可切片</th>
<th>访问方式</th>
<th>写法举例</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>下标索引</td>
<td>“abcd”</td>
</tr>
<tr>
<td>tuple</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>下标索引</td>
<td>(‘a’,‘b’,‘c’,‘d’,‘abcd’)</td>
</tr>
<tr>
<td>list</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>下标索引</td>
<td>[‘a’,‘b’,‘c’,‘d’,‘abcd’]</td>
</tr>
<tr>
<td>dictionary</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>关键字索引</td>
<td>{‘1’:‘a’,‘2’:‘b’}</td>
</tr>
</tbody></table>
<h3 id="Python中有关对象需要注意的问题"><a href="#Python中有关对象需要注意的问题" class="headerlink" title="Python中有关对象需要注意的问题"></a>Python中有关对象需要注意的问题</h3><p>python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响引用的这个变量, 而不可变对象不会. 在向类传递参数时也是如此.</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571033275137.png" alt="1571033275137"></p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="Python内置帮助文档"><a href="#Python内置帮助文档" class="headerlink" title="Python内置帮助文档"></a>Python内置帮助文档</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">help()</span><br></pre></td></tr></tbody></table></figure>

<p>调用<code>help()</code>后就会进入Python内置帮助文档, 然后输入想查的类名/函数名/属性名就可以看到对应的帮助文档.</p>
<p>:bulb: 要注意输入的只有名字, 不带括号什么的, 以及要看一个包里的函数文档时需要先引用该包. 比如如果想查看<strong>time.time()</strong>的帮助文档, 首先<code>import time</code>, 然后输入<code>help()</code>进入帮助文档, 然后输入<code>time.time</code>, 就会看到<strong>time.time()</strong>函数的帮助文档. 按一次<kbd>q</kbd>退出<strong>time.time()</strong>的文档, 再按一次<kbd>q</kbd>退出帮助文档返回交互式Python界面.</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在Python中 <code>#</code> 开头的为注释</p>
<h4 id="特殊注释"><a href="#特殊注释" class="headerlink" title="特殊注释"></a>特殊注释</h4><h5 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h5><p>shenbang (hashbang) 指的是以 <code>#!</code> 开头的语句. Linux操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数. 因为在很多语言中以 <code>#</code> 开头的是注释, 所以不会影响程序.</p>
<h5 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h5><p>有的python文件是这么开头的:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure>

<p>第一行是给<strong>Linux系统</strong>的程序加载器看的, 因此在Windows下不需要这句, 第二句是指定文件的编码格式为<strong>UTF-8</strong>, 避免文件中的<strong>非ASCII字符</strong>被识别为乱码.</p>
<h5 id="docstring"><a href="#docstring" class="headerlink" title="docstring"></a>docstring</h5><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(int x, int y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这里是docstring, 是特殊的注释, 能让IDE, 编辑器在鼠标移动到有docstring的函数, 类上时显示这段docstring</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = func(i)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="条件语句及循环"><a href="#条件语句及循环" class="headerlink" title="条件语句及循环"></a>条件语句及循环</h3><h4 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if, elif, else"></a>if, elif, else</h4><p>下面是按a &lt; 10, 10 &lt; a &lt; 20, 20 &lt; a &lt; 30, a &gt; 30分类的举例.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">20</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">30</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>

<p>另外有一种one liner会很喜欢的用法:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="number">2</span> <span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面这句与下面这句等效.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="生成器-·迭代器·range"><a href="#生成器-·迭代器·range" class="headerlink" title="生成器 ·迭代器·range"></a>生成器 ·迭代器·range</h4><p>语法类似于<a href="#切片">切片</a></p>
<h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性.<strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持:</p>
<ul>
<li>列表推导式</li>
<li>字典推导式</li>
<li>集合推导式</li>
</ul>
<p>列表推导式的语法:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">l = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure>

<p>使用举例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>因为tuple, string其实都是特殊的列表, 所以列表, 字符串, 元组都可以进行切片.</p>
<p>语法: l_sliced = a[begin : end : step]</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">l_sliced = l[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>在没有<strong>numpy</strong>库的情况下<strong>多维切片</strong>是通过推导式实现的:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">b = [a[i][:<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>💡 要注意函数名后的 <code>()</code> 也是一种运算符, 称为<strong>函数调用运算符</strong>. 如果调用函数的时候不加()只会创建一个该函数的对象而不会调用它.</p>
<h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>python中以 <code>def</code> 关键字定义函数, 结构如下:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数主体</span><br></pre></td></tr></tbody></table></figure>

<p>python中的函数可以有返回值也可以没有返回值</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.appeend(<span class="string">'add'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure>

<h3 id="用字典来实现case"><a href="#用字典来实现case" class="headerlink" title="用字典来实现case"></a>用字典来实现case</h3><p>示例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printdefault</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic = {</span><br><span class="line">    <span class="string">'a'</span>: print1,</span><br><span class="line">    <span class="string">'b'</span>: print2,</span><br><span class="line">	<span class="string">'default'</span>: printdefault}</span><br><span class="line"></span><br><span class="line">i = input(<span class="string">'input: '</span>)</span><br><span class="line">main = dic[i <span class="keyword">if</span> (i != <span class="string">'a'</span> <span class="keyword">or</span> i != <span class="string">'b'</span>) <span class="keyword">else</span> <span class="string">'default'</span>]</span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编码格式-1"><a href="#编码格式-1" class="headerlink" title="编码格式"></a>编码格式</h3><p>字符串经过<strong>编码（encode）</strong> 就成为了一堆数据, 反过来, 数据经过<strong>解码（decode）</strong> 就变回我们认识的字符串.</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/encode_decode.png" alt="img"></p>
<p>指定文件编码格式为 <code>utf-8</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure>

<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">💡</span> 如果不指定文件编码格式在有的Python2版本中无法识别中文, 即便是中文注释也会报错.</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Unicode_Decoding_and_Encoding.png" alt="Unicode Decoding and Encoding"></p>
<p>Linux系统默认编码格式是<strong>UTF-8</strong>, 系统语言是简体中文时Windows10的编码格式是<strong>GB2312</strong> (也称GBK, 国标扩展, cp936)</p>
<p>在python中 <code>str</code> 类型数据都以Unicode码点格式储存, 因此直接打印字符串会看到字符为’\u’开头</p>
<h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.write(<span class="string">"text"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br><span class="line">    f.write(<span class="string">"test"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>💡 <strong>使用with语句打开文件是最推荐的方式</strong>, 原因见<a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html" target="_blank" rel="noopener">这里</a></p>
<p>下表是open时要指定的读写模式的比较.</p>
<table>
<thead>
<tr>
<th>读写模式</th>
<th>是否可读</th>
<th>是否可写</th>
<th>文件指针位置</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>是</td>
<td>否</td>
<td>文件开头</td>
<td>读取文件, 如果文件不存在则报错</td>
</tr>
<tr>
<td>r+</td>
<td>是</td>
<td>是</td>
<td>文件开头</td>
<td>读取并写入文件, 如果文件不存在则报错</td>
</tr>
<tr>
<td>w</td>
<td>否</td>
<td>是</td>
<td>文件开头</td>
<td>覆写原文件, 如果文件不存在则创建</td>
</tr>
<tr>
<td>w+</td>
<td>是</td>
<td>是</td>
<td>文件开头</td>
<td>读取并覆盖写原内容, 如果文件不存在则创建</td>
</tr>
<tr>
<td>a</td>
<td>否</td>
<td>是</td>
<td>文件末尾</td>
<td>追加文件内容, 如果文件不存在则报错</td>
</tr>
<tr>
<td>a+</td>
<td>是</td>
<td>是</td>
<td>文件末尾</td>
<td>追加文件内容并且可读, 如果文件不存在则报错</td>
</tr>
</tbody></table>
<p>另外还有<code>b</code>模式, 以二进制打开, 允许我们对二进制文件进行编辑, <code>b</code>可以与其他模式组合使用, 比如
<code>rb</code></p>
<p>🔗 <a href="https://www.cnblogs.com/nulige/p/6128948.html" target="_blank" rel="noopener">python基础-文件读写’r’ 和 ‘rb’区别</a></p>
<h2 id="脚本和普通程序的区别"><a href="#脚本和普通程序的区别" class="headerlink" title="脚本和普通程序的区别"></a>脚本和普通程序的区别</h2><p>脚本这个词来源于戏剧, 能用于舞台演出的戏剧文本就称为<strong>脚本</strong>. 在编程中的脚本是解释执行的程序, 通常只用来做简单的处理, 做自动化处理</p>
<h2 id="解释器的使用技巧"><a href="#解释器的使用技巧" class="headerlink" title="解释器的使用技巧"></a>解释器的使用技巧</h2><p>在解释器中交互式编程时要注意缩进不要错</p>
<h3 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h3><p>python解释器本身没有清屏命令, 只能通过调用命令行的清屏命令来达到效果</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># Windows下</span></span><br><span class="line">os.system(<span class="string">'cls'</span>)</span><br><span class="line"><span class="comment"># Linux下</span></span><br><span class="line">os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>我推荐遵从<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a>. 当然一行一行看完这个规范不是一件令人愉快的事, 最简单的时刻遵守PEP8的方式是在代码工具里安一个<strong>代码风格检查器</strong> (linter).
检查你的代码是否符合PEP8的linter是<a href="http://pycodestyle.pycqa.org/en/latest/intro.html" target="_blank" rel="noopener">pycodestyle</a></p>
<p>💡 在VSC中可以在设置中搜索<strong>python.linting.pycodestyle</strong>, 勾选<strong>Pycodestyle Enabled</strong>, 这样在VSC中编写Python代码时使用的linter就是pycodestyle啦</p>
<p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571142193232.png" alt="1571142193232"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>意识到了我的中文有多差</title>
    <url>/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/</url>
    <content><![CDATA[<p>前阵子别人给我分享了<a href="https://www.byvoid.com/" target="_blank" rel="noopener">这个博客</a>, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!</p>
<a id="more"></a>

<p>先不提这个博主喜爱音韵学, 单说同样是理工科出身的博主, 我的表达能力和思想深度比他差了太多.</p>
<p>通常在解释一段程序时我会想好一会来组织语言, <strong>将我使用这段代码的意图尽可能体现出来, 描述尽可能准确, 有条理</strong>. 我对此体会良多: 当我刚开始接触一个领域, 在网上看资料时常常无法确定我理解得对不对, 需要结合多篇文章才能确定. 这是因为<strong>作者们自身接触这些许久, 无意识的省略了一些话</strong>. 但我认为文章既然要写出来就应该能让所有人无障碍的看懂, 不然只给自己看的话何不就放到自己github仓库?</p>
<p><a href="https://akaedu.github.io/book/index.html" target="_blank" rel="noopener">Linux C编程一站式学习</a>和
<a href="https://www.pyimagesearch.com" target="_blank" rel="noopener">pyimagesearch</a>的文章就让人觉得文章读起来很流畅很易懂, 不会浪费时间在理解文章上. 比如<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" target="_blank" rel="noopener">这篇文章</a>
曾带我轻松完成了困扰了我好几天的如何在树莓派上安装OpenCV的问题. 这个问题现在当然不会像前年那样困扰我, 但能有这样一篇好懂的文章指导我迅速完成我当然是十分乐意的.</p>
<p>因此我总是试图让我的文章能达到同样水准. 但我发现这很难. 说来可笑, 很多时候我甚至不知道怎么样去描述我的操作🤦‍ 而让文章有条理同样不是一件容易的事. 我感觉这和写一篇议论文围绕一个中心套用总分总的文章结构就可以写不一样, 我总是喜欢把一个主题的东西一股脑放到一篇文章里, 但我发现一方面<strong>文章太长会让人失去读下去的兴趣</strong>, 另一方面<strong>什么东西都往一篇文章里放会让文章失其重点</strong>. 我又不是在写书, 不如将一个主题的内容再按照几个重点分成几篇文章. 可<strong>将一篇文章分割为主题更明确的多篇文章</strong>对我来说并不是易事…</p>
<p>至于说<strong>byvoid</strong>的文章有思想深度, 从<a href="https://www.byvoid.com/zht/blog/why-the-usa-is-so-boring-1" target="_blank" rel="noopener">这篇文章</a>可见一斑. 我也喜欢旅游, 并且因为我小时候见了许多很美的自然景观, 我更倾向于体验一处的文化. 到一处游览后能有像<strong>byvoid</strong>这种深度的心得正是我所想努力做到的. 但一是我的文笔不够好,
二是我并没有做功课去研究旅游地的文化.</p>
<p>从<strong>byvoid</strong>的文章能体会到中文的魅力: 用得好了读起来十分流畅, 四字成语言简意赅地表达出了意思, 很多用以佐证的诗句更是回味无穷… 这只是我个人的体会, 我也知道很粗浅. 当然我并不后悔初高中没有投入大量精力背诵各种诗句, 品鉴各大文豪的文章: 体会不到这些的魅力时我背下来又有什么用呢?</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>我将Shell换为了zsh</title>
    <url>/zh-CN/2019/09/02/%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/</url>
    <content><![CDATA[<p>我把shell从<strong>bash</strong>换到<strong>zsh</strong>了. 原本我是根本没动过换shell的念头的, 但因为这段时间用的笔记本被别人装好了zsh, 我就将就着用了, 谁知真香…</p>
<a id="more"></a>

<p>不得不说zsh比bash确实好了许多:</p>
<ul>
<li>补全智能了太多! 比如切换路径时的补全不必区分大小写, 比如会根据历史命令给出建议, 比如如果命令里有<code>$(pwd)</code>这样的取值操作, 按一下<kbd>Tab</kbd>zsh会将其补全为对应的值.</li>
<li>支持一次输入多行命令再执行. 不像bash只能一行一行运行, 如果其中有命令是需要输入确认的, 那么下一条命令就会被当做这条命令的确认用输入中, 然后就会报错 🤷</li>
<li>Powerlevel9k这个主题很好看很强大, 能显示出包括<strong>git状态</strong>, <strong>当前Python环境</strong>,
<strong>命令执行时间</strong>, <strong>后台任务数量</strong>, <strong>当前时间</strong>在内的许多有用信息</li>
<li>zsh有许多很有用的插件</li>
</ul>
<p>总之我要到zsh去了, bash再见👋</p>
<p>下面是部分功能的展示</p>
<p><img src="%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/screencast.gif" alt=""></p>
<p>下面我大致说一下我的zsh配置</p>
<ul>
<li>zsh配置管理工具: <a href="https://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh</a></li>
<li>zsh插件管理工具: <a href="https://github.com/zsh-users/antigen" target="_blank" rel="noopener">Antigen</a></li>
<li>zsh主题: <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">Nerd-Fonts</a>字体(具体来说是<a href="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/DejaVuSansMono" target="_blank" rel="noopener">DejaVuSansMono Nerd</a>)的<a href="https://github.com/Powerlevel9k/powerlevel9k" target="_blank" rel="noopener">Powerlevel9k</a>主题</li>
</ul>
<p>以下是我的<code>~/.zshrc</code>中部分代码.</p>
<p>有关Powerlevel9k:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">POWERLEVEL9K_MODE='nerdfont-complete'</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND="black"</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND="blue"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON="echo   $(whoami) "</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_BACKGROUND="purple"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_FOREGROUND="white"</span><br><span class="line">POWERLEVEL9K_ANACONDA_BACKGROUND="chartreuse3"</span><br><span class="line">POWERLEVEL9K_ANACONDA_LEFT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_DIR_HOME_BACKGROUND='123'</span><br><span class="line">POWERLEVEL9K_DIR_HOME_SUBFOLDER_BACKGROUND='123'</span><br><span class="line"><span class="meta">#</span><span class="bash"> POWERLEVEL9K_DIR_ETC_BACKGROUND=<span class="string">'123'</span></span></span><br><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(custom_os_icon ssh anaconda root_indicator dir dir_writable vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(command_execution_time status background_jobs time)</span><br><span class="line">ZSH_THEME="powerlevel9k/powerlevel9k"</span><br></pre></td></tr></tbody></table></figure>

<p>有关zsh插件:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Which plugins would you like to load?</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Standard plugins can be found <span class="keyword">in</span> ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">source ~/Desktop/backup/zsh/antigen.zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the oh-my-zsh<span class="string">'s library.</span></span></span><br><span class="line">antigen use oh-my-zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Bundles from the default repo (robbyrussell<span class="string">'s oh-my-zsh).</span></span></span><br><span class="line">antigen bundle git</span><br><span class="line">antigen bundle pip</span><br><span class="line">antigen bundle command-not-found</span><br><span class="line"><span class="meta">#</span><span class="bash"> custom plugins</span></span><br><span class="line">antigen bundle zsh-users/zsh-syntax-highlighting</span><br><span class="line">antigen bundle zsh-users/zsh-autosuggestions</span><br><span class="line">antigen bundle sobolevn/wakatime-zsh-plugin</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the theme.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> antigen theme powerlevel9k/powerlevel9k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell Antigen that you<span class="string">'re done.</span></span></span><br><span class="line">antigen apply</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>配置</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>更好的Shebang使用方式</title>
    <url>/zh-CN/2019/09/13/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在Linux系统的脚本第一行我们通常用
<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang</a>语句来指明解释器路径, 一方面有的脚本没有文件后缀名, 需要通过shebang语句指明系统才知道要用什么解释器运行. 另一方面有时候为了兼容性我们会指明使用标准位置的系统安装版本解释器.</p>
<p>但我发现有时候我们并不能确定使用者把我们需要类型的解释器装到了地方, 如果我们只想指出<strong>使用的解释器类型</strong>而不是具体路径, 可以使用<code>/usr/bin/env</code>命令. 比如如果我们想用Python3解释器执行一个脚本, 可以在第一行加:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>env</code>会调用用户<strong>$PATH</strong>中首先出现的解释器版本.</p>
<p>当然对于更复杂的情况更建议专门写一段程序来决定用哪个解释器.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>我开始用集成开发工具部署我的博客</title>
    <url>/zh-CN/2019/10/06/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这几天分别尝试了用<strong>Travis CI</strong>和<strong>GitHub Action</strong>部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢<strong>GitHub Action</strong>, 因为它就是Github的, 集成度更高. 而且<strong>Github Action</strong>支持的触发条件更多样一些.</p>
<a id="more"></a>

<p>先分别放上我使用Travis和GitHub Action时的配置文件</p>
<p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/blob/02ce864f1cbe09d82c0dfe6f617b36737344d41e/.travis.yml" target="_blank" rel="noopener">Travis配置文件</a></p>
<p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/tree/Root/.github/workflows" target="_blank" rel="noopener">GitHub Action配置文件</a></p>
<h2 id="GitHub-Action的缺点"><a href="#GitHub-Action的缺点" class="headerlink" title="GitHub Action的缺点"></a>GitHub Action的缺点</h2><p>可以看出Travis要更<strong>成熟</strong>一些, 提供了一些很方便的功能, 比如要添加ssh known hosts, travis只需要</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">addons:</span></span><br><span class="line">  <span class="attr">ssh_known_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">github.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ssh.github.com</span></span><br></pre></td></tr></tbody></table></figure>

<p>而在GitHub Action中需要</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">login</span> <span class="string">ssh</span> <span class="string">and</span> <span class="string">git</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">~/.ssh</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">-e</span> <span class="string">"Host github.com\nStrictHostKeyChecking no\nIdentityFile ~/.ssh/id_rsa_github_action"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/config</span></span><br></pre></td></tr></tbody></table></figure>

<p>看起来GitHub Action的配置更短, 但这句是强行不验证github.com的服务器, 并没有Travis中的配置直观, 合理.</p>
<p>另外GitHub Action暂时还不支持<strong>缓存</strong>, 照<a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts" target="_blank" rel="noopener">这个样子</a>即便实现了也是很别扭的东西… 我觉得缓存还是一个很重要的功能. 一个最简单的例子: 没有缓存的public文件夹导致刚换到GitHub Action时我的每篇博客<strong>更新时间与我的最后一次上传时间相同</strong> (hexo通过对比source文件夹和public文件夹的时间戳来判断更新时间). 目前我是通过将master分支下载到public文件夹来蛮力解决的.</p>
<h2 id="GitHub-Action的优点"><a href="#GitHub-Action的优点" class="headerlink" title="GitHub Action的优点"></a>GitHub Action的优点</h2><p>当然GitHub Action的优点也是明显的, 比如我的代码的<strong>托管平台和持续集成平台合二为一</strong>, 不说管理起来方便了多少至少内心通达了😆</p>
<p>另外GitHub Action的支持的触发条件更加丰富, 比如用下面代码可以指定只有<code>Root</code>分支有推送且有<strong>source/en</strong>文件夹以外的文件变动时才运行. 换句话说只有配置文件或者中文博客内容发生变动时才运行.</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Root</span></span><br><span class="line">    <span class="attr">paths-ignore:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'source/en/**'</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<a href="https://docs.travis-ci.com/user/conditional-builds-stages-jobs/" target="_blank" rel="noopener">Travis的文档</a>中我并没有看到可以这么操作.</p>
<p>再有就是GitHub Action支持一个项目有<strong>多个</strong>workflow, 比如我的博客就同时在运行两个工作流: 一个生成并部署中文博客, 一个生成并部署英文博客. 这是一个十分吸引人的功能! 并且GitHub正试图将workflow打造成能<strong>轻松分享, 引用</strong>的东西, 这能极大减少人们写这些繁琐低级的配置文件的时间. 实际上GitHub已经<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">初步成功了</a>. 在我的配置中就引用了两个GitHub官方发布的action.</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">8.10</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="number">8.10</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>

<p>目前来说GitHub Action体验着很不错!</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>广受好评的机器人相关 (数学/物理/控制/计算机类) 网课列表</title>
    <url>/zh-CN/2020/02/22/%E5%B9%BF%E5%8F%97%E5%A5%BD%E8%AF%84%E7%9A%84%E6%95%B0%E5%AD%A6-IT%E7%B1%BB%E7%BD%91%E8%AF%BE%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>最近很多国内学校因为疫情开始在网上上课, 不过我们学校的网课体验很差… 网络问题暂且不说, 既然都是网课何不去学习那些广受好评的版本? 列出一些广受好评的课程链接, 希望能帮到一些同样在被迫害的同学们 (也方便我以后极速复习) 💩</p>
<a id="more"></a>

<p>❗️ 好的学习资料有很多, 种类也很多 (网课, 书, 网站, 习题集, 项目…) 为了避免内容太过杂乱此处只讨论网课.</p>
<p>P.S. 我觉得网课的好处是有老师的讲解十分易懂, 同时通过倍速播放可以极速学习 😏</p>
<p>💡 为达到最好效果, 我的做法是把网课视频都下载下来, 在vlc中<strong>设置播放时显示当前文件名及时间</strong>并倍速播放. 到关键点, 或者想要记笔记的地方就暂停并截屏保存到一个文件夹 (截屏软件推荐)</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="MIT-线性代数"><a href="#MIT-线性代数" class="headerlink" title="MIT-线性代数"></a>MIT-线性代数</h3><p>特点: 教授的粉笔巨大无比 😂</p>
<p>相较于国内老师从行列式入手, 这门课<strong>从几何空间的角度更加直观揭示线代的内核</strong>.</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1zx411g7gq" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">网易公开课链接</a></p>
<h3 id="MIT-概率论"><a href="#MIT-概率论" class="headerlink" title="MIT-概率论"></a>MIT-概率论</h3><p>🔗<a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">b站链接</a></p>
<h3 id="张宇考研-数学-微积分-线性代数-概率论"><a href="#张宇考研-数学-微积分-线性代数-概率论" class="headerlink" title="张宇考研-数学 (微积分, 线性代数, 概率论)"></a>张宇考研-数学 (微积分, 线性代数, 概率论)</h3><p>🔗<a href="https://www.youtube.com/watch?v=ghNtuabD6Ss&amp;list=PLRMOX8QaZK8z4yLzXRkiPO38R911V7TQE" target="_blank" rel="noopener">YouTube链接</a></p>
<h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><h3 id="北航-理论力学"><a href="#北航-理论力学" class="headerlink" title="北航-理论力学"></a>北航-理论力学</h3><p>王琪老师讲得特别贴合实际, 有许多很生动的例子 👍</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1k7411T7QU" target="_blank" rel="noopener">b站链接</a></p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="MIT-信号与系统"><a href="#MIT-信号与系统" class="headerlink" title="MIT-信号与系统"></a>MIT-信号与系统</h3><p><strong>奥本海姆亲授版!</strong> 相信国内大部分学信号与系统这门课的同学的课本都是奥本海姆编写的. 虽然这个是二十多年前录制的课程了, 演示时使用的是很古老的覆盖片和只有绿色荧光的电脑屏幕, 但是奥本海姆教授讲解得十分清晰, 处理信号的核心思想贯穿始终, 让人学得十分系统性.</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1xy4y167DD" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/free?pid=M8AROL7GG&amp;mid=M8AROOU9F" target="_blank" rel="noopener">网易公开课链接</a></p>
<h3 id="MIT-数字信号处理"><a href="#MIT-数字信号处理" class="headerlink" title="MIT-数字信号处理"></a>MIT-数字信号处理</h3><p>认准奥本海姆教授 👍</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1uk4y1R771" target="_blank" rel="noopener">b站链接</a></p>
<h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><h3 id="MIT-计算机科学及编程导论"><a href="#MIT-计算机科学及编程导论" class="headerlink" title="MIT-计算机科学及编程导论"></a>MIT-计算机科学及编程导论</h3><p>这门课主要针对<strong>从未接触过计算机科学或编程的人</strong>. 基于<strong>python</strong>讲解了基础的程序编写, 调试, 算法, 数据结构, 面向对象等内容, 比起知识的深度更注重知识的广度 (内容较为简单).</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1m4411U7gs" target="_blank" rel="noopener">b站链接</a> 
🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fbianchengdaolun.html" target="_blank" rel="noopener">网易公开课链接</a></p>
<h3 id="翁恺-C语言程序设计"><a href="#翁恺-C语言程序设计" class="headerlink" title="翁恺-C语言程序设计"></a>翁恺-C语言程序设计</h3><p>C语言入门课.</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1sJ411E7St" target="_blank" rel="noopener">b站链接</a> 🔗<a href="https://www.icourse163.org/course/ZJU-9001" target="_blank" rel="noopener">中国大学MOOC链接</a></p>
<h3 id="清华-数据结构与算法"><a href="#清华-数据结构与算法" class="headerlink" title="清华-数据结构与算法"></a>清华-数据结构与算法</h3><p>🔗<a href="https://www.bilibili.com/video/BV1jt4y117KR" target="_blank" rel="noopener">b站链接</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>文件命名规则总结</title>
    <url>/zh-CN/2020/02/06/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>如果待处理文件的文件名中含有一些特殊字符, 有许多程序会因为考虑不完善 (或者说程序员偷懒) 而出现识别不到文件, 文件处理出错, 结果不符合意图, 甚至程序崩溃的问题. 而为了方便自己偷懒, 我总结了一些命名文件的规则.</p>
<a id="more"></a>

<p>💡 我并不是说文件名命名必须遵循这些准则, 只是在程序设计/输入不够严谨 (也就是想偷懒的情况下) 这样的命名准则是最不容易导致错误的👍</p>
<h2 id="文件名中只应该包含数字-字母-汉字-下划线-连字符-句点"><a href="#文件名中只应该包含数字-字母-汉字-下划线-连字符-句点" class="headerlink" title="文件名中只应该包含数字, 字母, 汉字, 下划线, 连字符, 句点"></a>文件名中只应该包含数字, 字母, 汉字, 下划线, 连字符, 句点</h2><p>许多特殊字符会让程序出错, 下面举几个例子:</p>
<ul>
<li><code>文件名里 有空格.jpg</code> 这样的文件名很可能让程序以为要处理的文件的名字是<code>文件名里</code>, 因而找不到文件或者处理了错误的文件. 而<code>有空格.jpg</code>会被当成无效参数, 多余字符.</li>
<li><code>文件名里/有左斜杠.avi</code> 这样的文件名在很多程序里会被认为是一个名为<code>文件名里</code>的文件夹下的<code>有左斜杠.avi</code>文件, 因此可能得到<strong>没有<code>文件名里</code>这个文件夹</strong>的报错</li>
<li><code>文件名里(有)括号.gif</code> 比如在markdown文档中用<code>![](文件名里(有)括号.gif)</code>来引用这个gif, 在有的markdown渲染器会被渲染为<strong>)括号.gif</strong>. 因为前一个)被认为是markdown引用图片的<code>![]()</code>语法的结束符了.</li>
<li>在一些较老的程序中汉字也算是一种特殊字符. 比如在python2中如果不特意注意编码格式转换问题的话中文很容易被读取为乱码. 当然现在的程序大多是兼容汉字的. (Python2在已经终止维护了🕯)</li>
</ul>
<blockquote>
<p>空格用下划线代替, 其他字符用连字符代替</p>
</blockquote>
<p>如果你原本想要包含这些特殊字符在文件名中来表达一些逻辑关系, 我的做法是用_来代替空格, 用-来代替其他字符.</p>
<h2 id="当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字-并且位数不足的用0在左侧占位"><a href="#当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字-并且位数不足的用0在左侧占位" class="headerlink" title="当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位"></a>当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</h2><p>曾经我很困惑下面这两种情况的文件夹排序为什么不是从小到大的, 后来我发现前者是因为文件系统<strong>不把汉字数字作为排序用的数字</strong> (有意思的是我Ubuntu系统和Windows系统里图一情况排序不一样), 后一个是因为文件系统是<strong>逐字比较</strong>而不是把一串数字作为一个数 (windows系统和Ubuntu系统排序图2情况时都能正常排序)</p>
<blockquote>
<p>图一 Ubuntu系统下含汉字数字文件名排序</p>
</blockquote>
<p><img src="%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/image-20200207181027438.png" alt=""></p>
<blockquote>
<p>图二 百度云里含数字文件名排序</p>
</blockquote>
<p><img src="%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/Screenshot_20200207_181843.jpg" alt=""></p>
<p>因此如果想在文件名中包含有排序功能的数字, 或者表达顺序之意时应当<strong>用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</strong>.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>Graphviz简要语法</title>
    <url>/zh-CN/2020/03/12/Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://emden.github.io/" target="_blank" rel="noopener">Graphviz</a>是一个很强大的<strong>图形可视化工具</strong>. 它使用<strong>DOT</strong>语言来描述图形, 但它并不单纯是个绘图软件, 而是能接入程序, 进行函数调用流程, 决策树, 数据结构, 日志系统等图形关系生成, 而且可以是<strong>交互式</strong>的 (不过我暂时没研究过所以不太了解). 暂且不提这些扩展功能, graphviz的语法允许我们仅通过文字描述能绘制出样式极其丰富的图形, 这大大方便了对图形的改动的跟踪.</p>
<a id="more"></a>

<h2 id="有关官方文档"><a href="#有关官方文档" class="headerlink" title="有关官方文档"></a>有关官方文档</h2><p>graphviz.org这个网站也不知道是不是停止维护了, 所有除了指向其他人的项目的链接都是无效链接了… 我在上面放的graphviz的官网链接是<a href="https://gitlab.com/graphviz/graphviz" target="_blank" rel="noopener">graphviz的GitLab repo</a>提供的地址. (实际上我觉得这个项目对文档的维护<strong>很烂</strong>, 描述得很不清楚, 有些地方甚至有错误. 这也是为什么我要自己总结一篇常用语法).</p>
<p>官方给出的有助于编写DOT文件的文档我觉得就这几个:</p>
<ul>
<li><a href="https://emden.github.io/_pages/doc/info/lang.html" target="_blank" rel="noopener">DOT语言概述</a></li>
<li><a href="https://emden.github.io/_pages/doc/info/attrs.html" target="_blank" rel="noopener">节点, 边线, 图形的属性列表</a></li>
<li><a href="https://emden.github.io/_pages/doc/info/shapes.html" target="_blank" rel="noopener">节点的三种形状设定方式及节点的样式详解</a> (此处又不得不吐槽graphviz开发组的文档组织真的差)</li>
<li><a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">箭头的头部形状参数详解</a></li>
<li><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">graphviz中可用颜色及颜色主题列表</a></li>
</ul>
<p>但其实给我帮助最大的是<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener"><strong>被graphviz开发组嫌弃的旧版文档 (dot布局版)</strong></a></p>
<p>❗️ 因为我最常使用的是<strong>dot</strong>布局所以此处涉及的内容大部分为dot布局下的情况.</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>还是先来个Hello World 😏</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G{</span><br><span class="line">    Hello -&gt; World;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/helloworld.svg?20" alt=""></p>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>因为graphviz许多概念解释起来会套娃, 要理解概念A要先理解概念B, 要理解概念B则需要先知道什么是概念A 🤤 因此这里先放上一些常用属性来快速入门.</p>
<p>🌟 不明白到底如何使用属性的话点<a href="#属性">这里</a>快速跳转后文的实例.</p>
<table>
<thead>
<tr>
<th>用途</th>
<th>属性名</th>
<th>可选值</th>
<th>作用对象</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>轮廓颜色</td>
<td><code>color</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>节点, 边线, 簇</td>
<td></td>
</tr>
<tr>
<td>填充颜色</td>
<td><code>bgcolor</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>簇, 图</td>
<td><code>fillcolor</code>会覆盖<code>bgcolor</code></td>
</tr>
<tr>
<td>填充颜色</td>
<td><code>fillcolor</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>节点, 边线, 簇</td>
<td>需要与<code>style=filled</code>一起使用. 如果设置了<code>style=filled</code>但没有设置<code>fillcolor</code>那么<code>color</code>的值将被同时用于轮廓和填充</td>
</tr>
<tr>
<td>字体颜色</td>
<td><code>fontcolor</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>节点, 边线, 簇, 图</td>
<td></td>
</tr>
<tr>
<td>箭头方向</td>
<td><code>dir</code></td>
<td>“forward”, “back”, “both”, “none”</td>
<td>边线</td>
<td>正向/反向/双向/无箭头</td>
</tr>
<tr>
<td>箭头形状</td>
<td><code>arrowhead</code> <code>arrortail</code></td>
<td>见备注</td>
<td>边线</td>
<td>graphviz提供了极其丰富的箭头形状值, 常用值参见<a href="https://emden.github.io/_pages/doc/info/attrs.html#k:arrowType" target="_blank" rel="noopener">这里</a>, 箭头形状值的完整说明见<a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">这里</a></td>
</tr>
<tr>
<td>样式</td>
<td><code>style</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/attrs.html#k:style" target="_blank" rel="noopener">各对象样式说明</a></td>
<td>节点, 边线, 簇, 图</td>
<td>emmm这个style很难准确地翻译为中文, 因为这个属性被很笼统地赋予了四种对象…总的来说是在描述这个对象长什么样, 是虚线的还是加粗的又或是点点的</td>
</tr>
<tr>
<td>边线风格</td>
<td><code>splines</code></td>
<td>none, line, polyline, curved, ortho, spline</td>
<td>图</td>
<td>不显示边线/线段 (false)/线段 (true)/弧线/直角折线/常规. 到底什么样详见<a href="https://emden.github.io/_pages/doc/info/attrs.html#d:splines" target="_blank" rel="noopener">splines说明</a> emmmm我感觉<strong>polyline</strong>和<strong>spline</strong>并没有区别…再次吐槽graphviz开发组的混乱逻辑 😩</td>
</tr>
<tr>
<td>label水平对齐方式</td>
<td><code>labeljust</code></td>
<td>“l”, “r”</td>
<td>图, 簇</td>
<td>“l”就是和图/簇的左边界对齐, “r”就是和图/簇的右边界对齐. 如果父级显性设置了这一属性, 子图会继承这一属性. <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 实际上还有一个可选值, 就是不设置这个属性, 那么label就会居中对齐.</td>
</tr>
<tr>
<td>label垂直对齐方式</td>
<td><code>labelloc</code></td>
<td>“t”, “b”, “c”</td>
<td>节点, 图, 簇</td>
<td>对于图和簇只有”t”和”b”是可用的, 即标签只能设置在图/簇的顶部或者底部. 如果父级显性设置了这一属性, 子图会继承这一属性. 而对于一个节点, 只有当它的高度大于label这个属性才是可用的.</td>
</tr>
<tr>
<td>节点排布方向</td>
<td>rankdir</td>
<td>TB, BT, LR, RL</td>
<td>图</td>
<td>从上到下/从下到上/从左到右/从右到左</td>
</tr>
</tbody></table>
<h3 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout (布局)"></a>Layout (布局)</h3><p>💡 graphviz有一点不好的是节点在画布上的位置是<strong>由算法决定</strong>的, 不能<strong>完全</strong>自己设定, 因此有时候无法让图变得那么美观.</p>
<p>graphviz提供了多种<strong>用于排布节点, 边线箭头头部, 边线标签位置</strong>的布局算法.</p>
<p>因为了解graphviz的布局算法有助于我们更好的布局, 此处简单翻译一下<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener">被现在graphviz开发组嫌弃的旧版文档 (dot布局版)</a>描述的<strong>dot布局</strong>的图形绘制主要的四步:</p>
<ol>
<li><p>通过反转一些边线的指向来打破输入图形 (我猜这个输入图形说的是.dot文件) 中出现的所有循环 (因为dot布局算法是基于非循环图形的)</p>
</li>
<li><p>给各节点赋予不同的等级 (<code>rank</code>). (比如在一个top-to-bottom方向的图中等级决定了节点的纵坐标) 连接跨度超过一个等级的节点的边线会被分割成一串”虚拟”节点以及单位长度的边线</p>
<p>💡 后文会提及对节点的rank是可以进行一些设置的.</p>
</li>
<li><p>给同等级的节点排序, 避免绘图时出现边线的交叉 (估计只是减少交叉?)</p>
</li>
<li><p>在让边线尽可能短的情况下设定节点的横坐标, 然后绘制边线 (同样是假设是top-to-bottom方向的图)</p>
</li>
</ol>
<p>下面给出一些主要布局算法的简单说明和图例.</p>
<p>💡 以下布局的图例除了最后一个都来自<a href="https://emden.github.io/gallery/" target="_blank" rel="noopener">graphviz-gallary</a></p>
<h4 id="dot"><a href="#dot" class="headerlink" title="dot"></a>dot</h4><p>用于绘制<strong>有向图</strong>, 他的布局算法原理上面已经说了, 特点是绘制出的图<strong>很有层次</strong>.</p>
<p>❗️ 注意dot布局和DOT语言不是一个东西.</p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/cluster.png?20" alt="img"></p>
<h4 id="neato"><a href="#neato" class="headerlink" title="neato"></a>neato</h4><p>用于绘制<strong>无向图</strong>. neato布局算法的原理是构建一个虚拟物理模型并不断对其迭代最终得到一个<strong>最低总能量排布</strong> (low-energy configuration). 这个虚拟物理模型具体指的是在每个节点间放置一个<strong>理想弹簧</strong>, 这样得到的布局通常很合理. (在统计学中这种算法也被称作<strong>多维缩放</strong>). neato布局很适合用于<strong>通信网络</strong>及<strong>计算机程序</strong>的绘制.</p>
<p>💡 当图较大 (超过100个节点)时就该考虑换成fdp或者sfdp布局了</p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/ER.png?30" alt="在这里插入图片描述"></p>
<h4 id="fdp"><a href="#fdp" class="headerlink" title="fdp"></a>fdp</h4><p>同样是基于弹簧模型. 区别在于fdp算法的迭代是在试图减小节点间弹簧的力的大小而不是弹簧能量大小.</p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/fdpclust.png?40" alt="在这里插入图片描述"></p>
<h4 id="sfdp"><a href="#sfdp" class="headerlink" title="sfdp"></a>sfdp</h4><p>为大规模图而生的多尺度版fdp</p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/JGD_BIBD@bibd_17_3.gif?40" alt="在这里插入图片描述"></p>
<p>上面这个图得自🔗 <a href="http://yifanhu.net/GALLERY/GRAPHS/index.html" target="_blank" rel="noopener">A Gallery of Large Graphs</a>. 这个网站还有<strong>很多</strong>很壮观的图😳</p>
<h4 id="twopi"><a href="#twopi" class="headerlink" title="twopi"></a>twopi</h4><p>径向布局.</p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/twopi2.png?50" alt="在这里插入图片描述"></p>
<h4 id="circo"><a href="#circo" class="headerlink" title="circo"></a>circo</h4><p>圆形布局. 很适合有许多环路结构的图, 比如电信网络.</p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/circo.png?30" alt="在这里插入图片描述"></p>
<h3 id="有关三种主要描述对象"><a href="#有关三种主要描述对象" class="headerlink" title="有关三种主要描述对象"></a>有关三种主要描述对象</h3><p>DOT语言主要描述三种对象: <strong>graph</strong>, <strong>node</strong>, <strong>edge</strong>. 这里分别翻译为<strong>图</strong>, <strong>节点</strong>, <strong>边线</strong>. 每一种对象有各自可以设置的一组属性.</p>
<h4 id="Graph-图"><a href="#Graph-图" class="headerlink" title="Graph (图)"></a>Graph (图)</h4><p>最外层的graph (main graph)可以被设定为<strong>有向图</strong><code>digraph</code>(directed graph)或是<strong>无向图</strong><code>graph</code>(undirected graph). main graph内可以用<code>subgraph</code>来定义一个节点和边线的集合. 也可以通过设定最外层图为<code>strict digraph</code>或者<code>strict graph</code>来禁用<strong>multi-edges</strong>. 也就是说<code>strict digraph</code>会让有向图中一个指向节点和一个被指向节点间只能有一条边线 (不过反过来还可以有一条, 也就是两节点间最多两条边线), <code>strict graph</code>则会让无向图中两节点间只能有一条边线.</p>
<p>最外层的图又称top-level graph, root graph (反正开发组文档都没能统一这东西的叫法). 图可以有子图 (subgraph), 子图会继承父级的显式设置的大部分属性. 有一种特殊的子图被称为<a href="#Cluster-簇"><strong>簇</strong></a>.</p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node (节点)"></a>Node (节点)</h4><p>一个节点会<strong>在第一次在DOT文件中出现时被创建</strong>.</p>
<h4 id="Edge-边线"><a href="#Edge-边线" class="headerlink" title="Edge (边线)"></a>Edge (边线)</h4><p>一条边线会在几个节点被用<code>-&gt;</code>边线操作符连接时被创建.</p>
<p>💡 <strong>在graphviz中可以直接用中文作为节点名.</strong></p>
<h3 id="Label-标签"><a href="#Label-标签" class="headerlink" title="Label (标签)"></a>Label (标签)</h3><p>如果你想要显示的标签中有空格, 那通过把节点名用<code>""</code>括起来可以实现, 当然显式声明标签内容是更好的选择. 而<strong>如果你想让一些节点显示相同的标签那就必须显式声明节点的标签了</strong>, 因为节点名不能重复.</p>
<p>💡 label中可以使用转义字符比如<code>\n</code>来实现多行标签.</p>
<h4 id="HTML-like-Label"><a href="#HTML-like-Label" class="headerlink" title="HTML-like Label"></a>HTML-like Label</h4><p>为了能提供更丰富的样式, dot布局支持使用HTML语法的HTML-like标签 (看了下似乎其他布局不支持这种东西).</p>
<p>具体可用语法格式参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 总结下来就是目前支持以下几种类HTML元素:</p>
<ul>
<li>斜体 &lt;i&gt;</li>
<li>粗体 &lt;b&gt;</li>
<li>下划线 &lt;u&gt;</li>
<li>上划线 &lt;o&gt;</li>
<li>删除线 &lt;s&gt;</li>
<li>下角标 &lt;sub&gt;</li>
<li>上角标 &lt;sup&gt;</li>
<li>指定字体 &lt;font&gt;</li>
<li>换行符 &lt;br /&gt;</li>
<li>表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;</li>
<li>图片 &lt;img&gt;</li>
<li>水平/竖直分割线 &lt;hr&gt; &lt;vr&gt;</li>
</ul>
<p>❗️ 要注意这种类HTML标签只是<strong>借鉴自HTML</strong>, 和HTML元素并不完全一样, 因此<strong>并不支持html中其他写法和属性</strong>. 再比如HTML中是没有上面这个<code>&lt;vr&gt;</code>tag的😅</p>
<p>不得不说类HTML标签确实极大地提升了灵活性, 让我们能写出奇形怪状的节点形状, 能在标签中嵌入图片等, 详情参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 不过这东西写起来确实麻烦一些…</p>
<blockquote>
<p>一个展示类HTML标签能带来的丰富样式的例子</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">  rankdir=LR</span><br><span class="line">  node [shape=plaintext]</span><br><span class="line">  a [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD ROWSPAN="3" BGCOLOR="yellow"&gt;class&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD PORT="here" BGCOLOR="lightblue"&gt;qualifier&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  b [shape=ellipse style=filled</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BGCOLOR="bisque"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="3"&gt;elephant&lt;/TD&gt;</span><br><span class="line">          &lt;TD ROWSPAN="2" BGCOLOR="chartreuse" VALIGN="bottom" ALIGN="right"&gt;two&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" ROWSPAN="2"&gt;</span><br><span class="line">            &lt;TABLE BGCOLOR="grey"&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;corn&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD BGCOLOR="yellow"&gt;c&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;f&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">            &lt;/TABLE&gt;</span><br><span class="line">          &lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="white"&gt;penguin&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" BORDER="4" ALIGN="right" PORT="there"&gt;4&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  c [</span><br><span class="line">    label=&lt;long line 1&lt;BR/&gt;line 2&lt;BR ALIGN="LEFT"/&gt;line 3&lt;BR ALIGN="RIGHT"/&gt;&gt;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  subgraph { rank=same b c }</span><br><span class="line">  a:here -&gt; b:there [dir=both arrowtail=diamond]</span><br><span class="line">  c -&gt; b</span><br><span class="line">  d [shape=triangle]</span><br><span class="line">  d -&gt; c [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD BGCOLOR="red" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">          &lt;TD&gt;Edge labels&lt;BR/&gt;also&lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="blue" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/html-like_label.svg?60" alt=""></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是通过<code>name=value</code>形式来设置的. 节点与边线的属性需要放在<code>[]</code>方括号中.</p>
<blockquote>
<p>一个展示属性写法以及属性能做些什么的例子</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    size ="4,4"; //设置图形尺寸为4英寸长宽</span><br><span class="line">    方形节点 [shape=box];  /*这是一种注释写法*/</span><br><span class="line">    方形节点 -&gt; 上面是加粗线 [style=bold];</span><br><span class="line">    上面是加粗线 -&gt; 和下面的对比;</span><br><span class="line">    方形节点 -&gt; 上面是虚线 [style=dotted];</span><br><span class="line">    方形节点 -&gt; 重量更大导致垂直指下的节点[weight=4];</span><br><span class="line">    "和下面的对比" -&gt; { make_string; 上面是有标签的红线}  //可以一次连接多个节点</span><br><span class="line">    上面是虚线 -&gt; make_string;</span><br><span class="line">    edge [color=red];  // 这是另一种注释写法</span><br><span class="line">    方形节点 -&gt; 上面是有标签的红线 [label="100 times"];</span><br><span class="line">    make_string [label="多行\n标签"];</span><br><span class="line">    node [shape=box,style=filled,color=".7 .3 1.0"];</span><br><span class="line">    和下面的对比 -&gt; 在节点默认属性改变后才创建的节点;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/attr.svg" alt=""></p>
<h4 id="常用属性的默认值"><a href="#常用属性的默认值" class="headerlink" title="常用属性的默认值"></a>常用属性的默认值</h4><p><strong>图</strong>的默认属性:</p>
<ul>
<li>labeljust=”c”</li>
<li>labelloc=”b” (簇的默认值为”t”)</li>
<li>clusterrank=”local”</li>
<li>compound=false</li>
<li>rankdir=TB</li>
</ul>
<p><strong>节点</strong>的默认属性是:</p>
<ul>
<li>shape=ellipse</li>
<li>width=0.75</li>
<li>height=0.5</li>
<li>标签为节点名</li>
<li>labelloc=”c”</li>
</ul>
<h3 id="Cluster-簇"><a href="#Cluster-簇" class="headerlink" title="Cluster (簇)"></a>Cluster (簇)</h3><p>簇是一种会将属于这个子图的元素都<strong>框在一个长方形里</strong>的特殊子图. 如果一个子图的名字以<strong>cluster</strong>开头那么这个子图就会被认为是一个簇 (这个判定方式好暴力😅). 但是如果在根图中设置了<code>clusterrank=none</code>那么簇这种特殊的子图会被禁用.</p>
<p>这里我又要来吐槽graphviz开发组了! 看看他们是怎么<a href="https://emden.github.io/_pages/doc/info/attrs.html#a:clusterrank" target="_blank" rel="noopener">说明clusterrank这个属性</a>的:</p>
<blockquote>
<p>the modes “global” and “none” <strong>appear</strong> to be identical, both turning off the special cluster processing.</p>
</blockquote>
<p>为什么官方开发组都在用这种表推测的语气啊… 🙃这也太迷惑了</p>
<p>如果根图中设置了<code>compound=true</code>, 那么dot布局允许用边线连接节点和簇的边框. 这是通过设置边线的<code>lhead</code>和<code>ltail</code>属性来实现的. 这样以来, 虽然边线仍然是从一个节点指向另一个节点的, 但是设置了<code>lhead</code>或者<code>ltail</code>的一侧<strong>会看起来像是被簇的边框盖住了</strong>.</p>
<blockquote>
<p>一个使用簇, 并且有连接节点与簇的边线的例子</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    compound=true;</span><br><span class="line">    subgraph cluster0 {</span><br><span class="line">        a -&gt; b;</span><br><span class="line">        a -&gt; c;</span><br><span class="line">        b -&gt; d;</span><br><span class="line">        c -&gt; d;</span><br><span class="line">    }</span><br><span class="line">    subgraph cluster1 {</span><br><span class="line">        e -&gt; g;</span><br><span class="line">        e -&gt; f;</span><br><span class="line">    }</span><br><span class="line">    b -&gt; f [lhead=cluster1];</span><br><span class="line">    d -&gt; e;</span><br><span class="line">    c -&gt; g [ltail=cluster0,lhead=cluster1];</span><br><span class="line">    c -&gt; e [ltail=cluster0];</span><br><span class="line">    d -&gt; h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/cluster.svg?20" alt=""></p>
<h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><p>以下是几条我认为<strong>用来提示图的美观程度</strong>的语法.</p>
<h3 id="优化布局"><a href="#优化布局" class="headerlink" title="优化布局"></a>优化布局</h3><p>知道了上面提到的<a href="#Layout-布局">布局的原理</a>我们就可以进行一些更个性化的布局, 比如设置<code>rankdir</code>可以设置节点的排布方向, 默认为<strong>TB</strong>, top to bottom, 也就是从上到下. 可选值有<strong>TB</strong>, <strong>BT</strong>, <strong>LR</strong>, <strong>RL</strong>.</p>
<p>再比如设置节点的<code>rank</code>属性我们可以改变节点的布局. <code>rank</code>的可选值有: <strong>same</strong>, <strong>min</strong>, <strong>source</strong>, <strong>max</strong>, <strong>sink</strong>.</p>
<blockquote>
<p>一个展示设置rank属性能达到什么效果的例子 (代码和图形都截自旧版文档, 因为代码没给全我也懒得写, 就这么放着吧👍)</p>
</blockquote>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/image-20200313010630547.png?60" alt="image-20200313010630547"></p>
<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/image-20200313010749024.png?80" alt="image-20200313010749024"></p>
<h3 id="Node-Port-节点端口"><a href="#Node-Port-节点端口" class="headerlink" title="Node Port (节点端口)"></a>Node Port (节点端口)</h3><p>Graphviz提供了节点端口来指定边线应连接到节点的什么位置. 这提供了更高的个性化. 当没有被指定节点端口时边线是指向节点中心并在节点边界处被截断的.</p>
<p>一共有两种节点端口:</p>
<ul>
<li>基于方位的8个端口: n,ne, e, se, s, sw, w, nw</li>
<li>基<code>record</code>结构的端口: <code>shape=record</code>的节点可以以记录结构来定义端口. 而因为有&lt;TABLE&gt;元素的<a href="#html-like-label">HTML-like标签</a>与可以作为<code>shape=record</code>的扩展甚至替代品, 每个&lt;TD&gt;元素的<strong>PORT</strong>属性也都提供了一个到该单元格的端口名.</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    node [shape = box]</span><br><span class="line">    node0:n -&gt; node1:n [label = "n"]</span><br><span class="line">    node2:ne -&gt; node3:ne [label = "ne"]</span><br><span class="line">    node4:e -&gt; node5:e [label = "e"]</span><br><span class="line">    node6:se -&gt; node7:se [label = "se"]</span><br><span class="line">    node8:s -&gt; node9:s [label = "s"]</span><br><span class="line">    node10:sw -&gt; node11:sw [label = "sw"]</span><br><span class="line">    node12:w -&gt; node13:w [label = "w"]</span><br><span class="line">    node14:nw -&gt; node15:nw [label = "nw"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/node_port.svg" alt=""></p>
<h3 id="Concentrators-边线合并"><a href="#Concentrators-边线合并" class="headerlink" title="Concentrators (边线合并)"></a>Concentrators (边线合并)</h3><p>在根图中设置<code>concentrate=true</code>将允许边线融合来避免图变得一团乱麻.</p>
<p>边线合并的条件是:</p>
<ul>
<li>他们的方向相同</li>
<li>他们有相同的起点或终点</li>
<li>他们的长度大于1</li>
</ul>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="VSC的dot语言支持插件"><a href="#VSC的dot语言支持插件" class="headerlink" title="VSC的dot语言支持插件"></a>VSC的dot语言支持插件</h3><p>我最喜欢的画graphviz图的工具是VSC里的<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz" target="_blank" rel="noopener">Graphviz(dot)语言支持插件</a>, 是的它<strong>只支持dot布局</strong>. 虽然也可以用graph来声明顶层图, 但绘制出来的仍然是有向图🤦‍♂ 不过无伤大雅, 我基本只画dot布局的图.</p>
<p>VSC里也有提供直接在markdown文档中渲染graphviz的dot布局图的插件, 不过我觉得这样的兼容性太低, 没有这个插件的人只会看到一串代码, 因此我选择的是一个能提供<strong>DOT语法高亮</strong>, 能提供<strong>自动刷新</strong>的预览图, <strong>能生成svg图</strong>的插件. 只要把这个svg插入markdown就能在文档看到graphviz图了, 而每次更改图片后只需要覆盖原本的svg即可更新md文档中的图, 也很方便的👍</p>
<h3 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h3><p>也有很多在线网站提供在线绘制graphviz图的服务, 上网一搜就有, 不过我感觉做得都半斤八两, 体验不算好, 我认为只能拿来救急用, 因此也不给出推荐了.</p>
<p>💡 实际上有些工具绘制出的图都有细微风格差异, 你可以挨个体验出一个最喜欢的风格的工具.</p>
<p>不过比较有意思的是这个<a href="https://sketchviz.com/new" target="_blank" rel="noopener">sketchviz</a>, 绘制出的是<strong>手绘风</strong>的图.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>Graphviz</category>
      </categories>
  </entry>
  <entry>
    <title>VSC与PyPyCharm体验比较</title>
    <url>/zh-CN/2020/03/06/VSC%E4%B8%8EPyPyCharm%E4%BD%93%E9%AA%8C%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>2020年4月12日 Vim经验分享</title>
    <url>/zh-CN/2020/04/20/2020%E5%B9%B44%E6%9C%8812%E6%97%A5vim%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p><span></span></p>
<a id="more"></a>

<p>最近在<a href="https://uestc-msc.github.io/" target="_blank" rel="noopener">电子科大微软学生俱乐部</a>做了一次vim经验分享, 下面是当时的录像. 这个录像是用zoom的会议录制功能得到的. 顺带一提zoom是有Linux平台的目前为止体验最好的视频会议软件, zoom录制的会议视频似乎本身就会进行压缩, 不像用其他软件得到的会议录制我还要自己压缩一下. zoom要是再有网页端就更好了😆</p>
<iframe src="//player.bilibili.com/player.html?aid=710237273&amp;bvid=BV18Q4y1K744&amp;cid=177852832&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>然后因为当时准备得有些仓促导致有几个地方演示得不充分有的地方说串了, 所以我补全了幻灯片. 👇下面这个就是我的幻灯片, 使用<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">Markdown Preview Enhanced</a>制作的markdown幻灯片. 屏幕gif录制工具为<a href="https://github.com/phw/peek" target="_blank" rel="noopener">peek</a>, 键盘按键可视化工具为<a href="https://gitlab.com/screenkey/screenkey" target="_blank" rel="noopener">screenkey</a></p>
<div style="width:100%; padding-bottom:56.25%; position:relative;">
  <iframe src="https://leojhonsong.github.io/vim-share/vim.html" style="width:94%; height:94%; position:absolute; transform: translate(3%,3%); box-shadow: 0 0 6px 7px black;"></iframe>
</div>

<p>🔗 你也可以点击<a href="https://leojhonsong.github.io/vim-share/vim.html">这个链接</a>全屏观看. 这个幻灯片的源代码在<a href="https://github.com/LeoJhonSong/vim-share/blob/master/vim.md" target="_blank" rel="noopener">这里</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
        <category>vim</category>
      </categories>
  </entry>
  <entry>
    <title>单硬盘三系统安装记录</title>
    <url>/zh-CN/2020/04/04/%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>分享一下我在同一个SSD里同时安装Ubuntu, Windows, macOS三个系统并以GRUB作为开机引导的经验. 说实话过程并不复杂.</p>
<a id="more"></a>

<p>也不知道最近自己时间都浪费哪里去了😑 3月7号弄好的东西现在才得以闲下来记录一番. 先秀一张GRUB界面😏</p>
<p><img src="%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/grub.jpg" alt=""></p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>说说我的心路历程😏</p>
<p>直到上大学我都对电脑了解甚少, <strong>只知道有Windows系统</strong>, 并不知道还可以有其他系统, 更别说在这之上的骚操作了😂 上大学后<strong>我逐渐熟悉了Windows系统</strong>并且喜欢上了这个很有现代感的系统. 但随着我对编程的学习逐渐深入, 以及我为了尽早熟悉机器人相关知识而想要了解Linux系统, 在听人介绍后我费了些力气<strong>在虚拟机里装上了Ubuntu16.04</strong>, 不过那时候了解的还是太少, 只是跟着网上的教程将这个东西装好了, 没什么收获. 装好后因为那时也没什么夸张到要开虚拟机在Ubuntu里编程的项目, 所以就体验了几下就束之高阁了. 毕竟那时对于编程, 甚至查找资料的经验都太少了, 只看到一些令人头大的辣鸡资料, 因此并没能学到什么.</p>
<p>大一下的时候我选了一门叫智能嵌入式的课, 其中有个课题是要编写一个能手势识别的程序并移植到树莓派上. 因此我就买了一个树莓派3b+. 不过那时懵懂的我对于怎么给一个SD卡安装系统手足无措, 就在网上搜资料给树莓派依次装了Ubuntu Mate, ArchLinux, 最后才是Raspbian😂 (我记得Mate是因为我当时没有找到arm架构的国内源就抛弃了, 而ArchLinux我就根本没装上…) 费劲心力我最后总算是把那个课题做完了, 但一方面我写得很差, 再加上树莓派3b+对图像处理的性能很一般, 所以我的手势识别程序移植到树莓派后十分卡顿😅 那是我<strong>第一次将程序移植到Linux平台, 也是第一次接触Linux嵌入式</strong></p>
<p>后来在一个实验室学习时接触到了ROS, 而那时Ubuntu18.04已经较为成熟了, 我就安装了个Ubuntu18.04的虚拟机在里面跟着刷了一遍ROS基础教程, 这回算是<strong>对Ubuntu的基本使用比较了解了</strong>. 不过那时其实并完全不了解ROS的最大作用是什么, 只是知道很牛逼, 跟着教程做了一遍, 没多久就忘了, 只是了解到有那么些概念😁 那时我以为Linux系统也就那样, 我在虚拟机体验到的就是它的全部了. 因此那时有同学和我讨论装Linux虚拟机好还是Windows, Linux双系统好时, 我的想法就是这系统又没那么便利, 误操作带来的危险性又那么大, 当然是装在虚拟机好.</p>
<p>而我装Windows, Ubuntu双系统的契机应该是<a href="/zh-CN/2019/03/30/我打算换电脑了/">我电脑的机械硬盘开始老化</a>, 速度变得极慢. 那应该是我大二下刚开学的时候, 我实在忍受不了在机械硬盘运行本身就很耗资源的Windows系统了, 而那时我的编程活动也开始多起来, 再加上我偶然得知Ubuntu能识别到已经存在的Windows系统并傻瓜式安装, 我就给自己<strong>装了个Windows, Ubuntu双系统</strong>. 不久后我的机械硬盘彻底不行了就买个一个1T的SSD. 不过换了硬盘后我也还是装的双系统, 因为我<strong>逐渐尝到了Linux系统的甜头</strong>.</p>
<blockquote>
<p>我在<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/">另一篇文章</a>写了自己对Linux和Windows的对比</p>
</blockquote>
<p>而随着我逐渐熟悉Ubuntu, 我开始像大多数Linux用户那样折腾自己的配置, 美化环境😏 期间也尝试了挺多东西, 到现在也形成了自己的使用习惯. 不过很尴尬的是在美化方面, 我经常看到这个好康的在Linux没有但macOS有的字眼. 所以<strong>我开始眼馋macOS</strong>. 不过那时我也就是眼馋, 因为我对比了一番, 发现macOS从接口, 生态等角度都不太适合做嵌入式开发就没有想过安一个试试. (我也在VMware里折腾过macOS虚拟机, 但和Ubuntu虚拟机一样装了没多久就删了)</p>
<p>而直到最近, 我看到了很详细的黑苹果安装教程, 加上我一个同学根据那份教程成功安上了黑苹果, 我也蠢蠢欲动了. 毕竟疫情期间闲着也是闲着+都用双系统了再多一个也不多. 于是我折腾一番<strong>给单硬盘安装了三个系统</strong>😁</p>
<p>P.S. 第一次体验macOS的本土包一开始连怎么删除文件都没搞懂, 还是现查的😅 使用逻辑与Windows/Linux差得真的太多了! 甚至因为别扭一度弃用了几天. 不过光是macOS下终端的美观程度就把俺勾回来了🤤</p>
<p>之前也看到网上有人装三系统的文章, 但基本都用了些杂牌子工具一通瞎操作… 所以我分享一下自己较为<strong>清爽</strong>的安装方法.</p>
<p>❗️ 我的电脑是真的一点不矫情, 安装很顺利, 不保证你的电脑上同样的不会出幺蛾子.</p>
<h2 id="关于镜像烧录"><a href="#关于镜像烧录" class="headerlink" title="关于镜像烧录"></a>关于镜像烧录</h2><h3 id="镜像烧录工具"><a href="#镜像烧录工具" class="headerlink" title="镜像烧录工具"></a>镜像烧录工具</h3><p>镜像烧录工具是唯一需要的第三方工具了. 这里给出两个我推荐的镜像烧录工具.</p>
<ul>
<li><a href="https://rufus.ie/" target="_blank" rel="noopener">Rufus</a> 这是一个干净而强大的镜像烧录工具, 我还<strong>没遇到过它不能烧录的镜像</strong>, 操作简单的同时也提供了一定的可自定义选项. 问题在于它只有Windows端和macOS端, <strong>没有Linux端</strong></li>
<li><a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">balenaEtcher</a> 这个工具是<strong>全平台</strong>的, 这点很棒, 但是它的问题是它<strong>无法烧录Windows镜像</strong>.</li>
</ul>
<h3 id="推荐的镜像烧录顺序"><a href="#推荐的镜像烧录顺序" class="headerlink" title="推荐的镜像烧录顺序"></a>推荐的镜像烧录顺序</h3><p>我推荐的镜像烧录顺序:</p>
<ol>
<li><p>将三个系统镜像都放到移动硬盘里, 提前下好balenaEthcer的便携版Linux客户端, Rufus便携版也都放在移动硬盘里. 这样有需要我同时插上硬盘和一个U盘, 无需安装烧录工具就可以烧录系统.</p>
<p>❗️balenaEtcher网站直连下载速度有些慢, 建议在有翻墙工具的时候就翻墙下好 (如果你本来就没有当我没说😁)</p>
</li>
<li><p>在Windows下用<strong>Rufus</strong>提前烧录好<strong>Windows安装盘</strong>备用.</p>
</li>
<li><p>在Ubuntu下用<strong>balenaEtcher</strong>烧录了<strong>macOS安装盘</strong>然后安装macOS, 然后用之前准备的Windows安装盘安装Windows. (此处为什么会在Ubuntu操作会在<a href="#更改EFI分区文件">后文</a>说明)</p>
</li>
<li><p>在Windows下把刚才的macOS安装盘或者Windows安装盘随便哪个用<strong>Rufus</strong>重新烧录成<strong>Ubuntu安装盘</strong>, 安装Ubuntu.</p>
</li>
<li><p>没了</p>
</li>
</ol>
<p>💡 也就是说推荐准备<strong>两个</strong>U盘. 如果你没有两个U盘那你可以跳过第二步, 然后只要保证身边有另外一台Windows电脑就好了.</p>
<p>烧录一个镜像大致十分钟, 而安装每个系统平均下来十五分钟, 因此全过程<strong>一个多小时</strong>就能搞定.</p>
<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>我安装系统的顺序是:</p>
<ol>
<li>macOS10.15.4</li>
<li>Windows10</li>
<li>Ubuntu18.04</li>
</ol>
<p>之所以是先安装macOS是因为看网上都说<strong>macOS要求EFI分区不小于200MB</strong>, 否则在安装时会提示无法安装. 然后我搜了搜EFI分区扩容, 似乎并没什么清爽的办法. 因此时刻准备着重装系统的我判定<strong>还是直接格式化硬盘来得清爽</strong>. 然后在安装的时候先安装macOS那它自己就会处理好这个事情, 不需要我担心😁</p>
<p>(不过我把三个系统都装完这个EFI分区也才用了120MB, 也不知道它要那么大干嘛)</p>
<p>而最后才安装Ubuntu是基于两方面考虑:</p>
<ol>
<li>如果先装Ubuntu就意味着得给Windows系统留下一定空间. 那么就需要在安装Ubuntu过程中”Installation Type”这一页选择<code>Something else</code>来<strong>自己给Linux系统分区</strong> (如果不选这种方式, 另外两种方式都会使用硬盘剩余的所有空间). 然而麻烦的是你不光需要给Ubuntu系统分一个主分区, 你还需要讲这个主分区分成几个逻辑分区, 而且每个逻辑分区的大小有一定的讲究. 我目前没有研究过这里的门道并且我对Ubuntu安装程序帮我规划的各个分区的大小没有不满. 因此我决定不去管这种事, <strong>我选择最后来安装Ubuntu, 让安装程序用我给它剩下的空间自己看着办</strong>😏</li>
<li>Ubuntu安装程序能识别电脑里已经安装的Windows系统 (识别不到我的黑苹果系统), 并<strong>自动处理好与Windows系统共存的配置</strong>, 将Windows添加到GRUB引导项中. 因为我的主力系统是Ubuntu而且我也很喜欢使用GRUB作为开机引导程序, 因此这帮我省了一些事.</li>
</ol>
<h3 id="macOS安装"><a href="#macOS安装" class="headerlink" title="macOS安装"></a>macOS安装</h3><p>我使用的黑苹果镜像是<a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html" target="_blank" rel="noopener">在这个文章最后的百度云链接</a></p>
<p>❗️ 我安装完之后才从使用苹果系统的同学们那得知macOS10.15, 也就是Catalina目前bug还比较多, 外观上和10.14也没什么区别, 因此建议安装macOS<strong>10.14</strong>, 而不是10.15.</p>
<p>这个镜像很棒的一点是它不止包含一个macOS系统安装程序, <strong>还有一个Windows PE</strong>, 也就是一个可以从U盘启动的专门魔改过, 用于修复系统的Windows系统. 这个Windows PE中包含了大多数你在网上教你修复系统发中文教程中提到的各种看起来有点不靠谱的工具 😂</p>
<p>我安装macOS使用的是<a href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" target="_blank" rel="noopener">这个教程</a>. 跟着一步步操作就可以了. 安装好后发现有驱动问题等先放着不管, 把三个系统都装好再来看上面那个镜像的链接里提供的问题解决方案好了, 不然容易心情变得焦躁的 🤗</p>
<h4 id="更改EFI分区文件"><a href="#更改EFI分区文件" class="headerlink" title="更改EFI分区文件"></a>更改EFI分区文件</h4><p>看到网上说装黑苹果最重要的就是要有对应自己电脑型号的EFI文件, 过了这一关就八九不离十了.</p>
<p><a href="https://github.com/daliansky/Hackintosh#%E9%BB%91%E8%8B%B9%E6%9E%9C%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4%E6%9C%BA%E5%9E%8B%E6%95%B4%E7%90%86-by-%E6%88%91%E6%84%8F" target="_blank" rel="noopener">这里</a>是一份黑苹果爱好者们提供了EFI分区文件的笔记本和台式机的型号列表, 也有他们自己的安装过程分享. 我使用的是其中的<a href="https://github.com/YGQ8988/dell-3568" target="_blank" rel="noopener">Dell Inspiron 3568</a></p>
<p>💡 在安装前我也曾担心后续两个系统的安装会不会破坏已经安装好的macOS的EFI文件, 实验表明他们是互不干扰的, 不会看对方不顺眼就删掉对方 😏</p>
<h4 id="网卡问题"><a href="#网卡问题" class="headerlink" title="网卡问题"></a>网卡问题</h4><p>这似乎是在实体机安装黑苹果一定会有的问题, 有人是直接买了一个苹果能识别的网卡换上, 而我懒一点, 我买了一个有macOS驱动的外置网卡, Comfast的<strong>CF-811 AC</strong>, 很小一个, 不贵, 速度也很不错. macOS在使用这个外置网卡时不会认为在使用WiFi, 而是认为是接入了一个以太网. 唯一缺点是我还没有搞清如何让使用这样外置网卡的macOS连接上星巴克WiFi这样需要等它弹出登录页面才能用的公共WiFi–并不会有什么页面弹出 😓</p>
<h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>Windows的官方镜像可以在<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">I Tell You</a>的操作系统一栏找到, 而激活码在淘宝就可以买到, 只是需要一些搜索技巧 😏</p>
<p>在安装系统的第一步就会要你选择安装在哪里, 在此时创建一个想要的大小的分区选中就可以进行安装了. 因为我的硬盘是1TSSD, 所以我分了一个274G的分区给Windows, 绰绰有余. 如果我真用满了也意味着我该重装了.</p>
<h4 id="System-Reserved分区"><a href="#System-Reserved分区" class="headerlink" title="System Reserved分区"></a>System Reserved分区</h4><p>当你安好Windows系统后会发现在给Windows划分的分区前后多了两个分区, 一个叫<strong>System Reserved</strong>, 一个叫<strong>Microsoft Windows Recovery Environment</strong>如果你断定自己不会用到安装在硬盘的Windows系统的恢复模式 (实际上Windows安装盘的恢复模式或者Windows PE盘可能会是你遇到麻烦时的更好选择), 那么<strong>Microsoft Windows Recovery Environment</strong>这个分区可以随便删. 而<strong>System Reserved</strong>这个分区<strong>绝对不能随便删, 最好是别动</strong>. 血泪教训啊! 一次我看这分区不爽一气之下删掉了, 然后就因为缺少文件而无法启动Windows了…</p>
<p>🔗 <a href="https://www.zhihu.com/question/60154583" target="_blank" rel="noopener">Windows的System Reserved分区是什么以及能否删除</a></p>
<p>我找到了这个<a href="http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf" target="_blank" rel="noopener">Windows Boot Environment - Murali Ravirala (Microsoft)</a>, 里面讲述了Windows系统的启动过程, 提到了这个分区的作用.</p>
<p>总结下来意思就是<strong>System Reserved</strong>这个分区不能随便删, 要删还要不会出错操作很麻烦, 因此就别动它了 🤦‍♂</p>
<p>💡 值得一提的是Windows现在有了<strong>开发人员模式</strong>, 开启这个模式后在Windows开发的体验会好很多, 不会经常弄出些乱七八糟的错误.</p>
<h3 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h3><p>Ubuntu系统的安装就跟着<a href="https://ubuntu.com/tutorials/tutorial-install-ubuntu-desktop#1-overview" target="_blank" rel="noopener">官网安装教程</a>来是最简洁正确的. 唯一需要注意的是在官网教程第六步时, 因为之前安装了Windows系统, Ubuntu安装程序会检测到已安装的Windows系统, 并给出一个<strong>Install Ubuntu alongside Windows 10</strong>的选项. 选择这个是这种情况下最简单的安装方式. 另外选择这个的话Ubuntu安装程序会自动把Windows系统加入到GRUB中, 属实舒服.</p>
<p><strong>系统安装就全部完成了!</strong> 🎉</p>
<h2 id="GRUB配置及开机美化"><a href="#GRUB配置及开机美化" class="headerlink" title="GRUB配置及开机美化"></a>GRUB配置及开机美化</h2><p>然后是我在这次重装前一直不确定的事: 是否能把macOS引导项也加入GRUB? 经过我的尝试答案是可以!</p>
<p>在网上搜索后我知道了怎么样来配置GRUB的引导项, 其实真心不难.</p>
<h3 id="引导项设置"><a href="#引导项设置" class="headerlink" title="引导项设置"></a>引导项设置</h3><p>第一步是进入<code>/etc/grub.d/</code>, 添加/编辑引导项. ❗️ 建议在先备份这个路径下的文件, 等确认改动成功了再删除备份也不迟.</p>
<p>在我的这个路径下有这样一些文件. 是的这里甚至有一个README 😂</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">00_header</span><br><span class="line">05_debian_theme</span><br><span class="line">10_linux</span><br><span class="line">20_linux_xen</span><br><span class="line">20_memtest86+</span><br><span class="line">30_os-prober</span><br><span class="line">30_uefi-firmware</span><br><span class="line">40_custom</span><br><span class="line">41_custom</span><br><span class="line">README</span><br></pre></td></tr></tbody></table></figure>

<p>这个README的内容是这样的:</p>
<blockquote>
<p>All executable files in this directory are processed in shell expansion order.</p>
<p> 00_<em>: Reserved for 00_header.<br> 10_</em>: Native boot entries.<br> 20_*: Third party apps (e.g. memtest86+).  </p>
<p>The number namespace in-between is configurable by system installer and/or
administrator.  For example, you can add an entry to boot another OS as
01_otheros, 11_otheros, etc, depending on the position you want it to occupy in
the menu; and then adjust the default setting via /etc/default/grub.</p>
</blockquote>
<p>也就是说:</p>
<ul>
<li><strong>00_</strong>开头的是为<code>00_header</code>这个文件保留的, <strong>10_</strong>开头的是系统自带的引导项, 这个稍后解释. <strong>20_</strong>开头的是一些第三方软件的东西, 比如<code>20_memtest86+</code>是一个叫memtest86+的内存测试软件 (虽然不知道是干啥的).</li>
<li>除了上面这三个前缀的文件名是可以自由改动的, 要把数字改成多少取决于你想让这个文件代表的引导项出现代GRUB引导菜单的第几个. (这个文件的顺序看起来就是最后生成出的<code>/boot/grub/grub.cfg</code>这个文件里引导项的顺序)</li>
<li>这些文件写好之后在<code>/etc/default/grub</code>这个文件可以调一调设置.</li>
</ul>
<p>一个引导项文件的写法示例 (也就是我的macOS的引导项文件):</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">exec tail -n +3 $0</span><br><span class="line"># This file provides an easy way to add custom menu entries.  Simply type the</span><br><span class="line"># menu entries you want to add after this comment.  Be careful not to change</span><br><span class="line"># the 'exec tail' line above.</span><br><span class="line"></span><br><span class="line">menuentry 'macOS Catalina 10.15.3' --class macosx {</span><br><span class="line">    insmod part_gpt</span><br><span class="line">    insmod fat</span><br><span class="line">    search --no-floppy --fs-uuid --set=root 67E3-17ED</span><br><span class="line">    chainloader /EFI/CLOVER/CLOVERX64.efi</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中前5行是<code>40_custom</code>中给出的注释, 我就抄过来了. 然后由<code>menuentry</code>起头声明一个引导项. 然后<code>--class</code>用来设置这个引导项的类型, 直观来说就是在GRUB界面里图标的名字. 此处的类型为<strong>macosx</strong>, 也就是说在我使用的GRUB主题的<code>icons</code>文件夹中有同名 (除了后缀名) 图标的话到时候这个引导项在GRUB界面里的文字前面的图标就是这个叫<code>macosx.png</code>的图标.</p>
<p>在这个引导项大括号里的内容是和在GRUB命令行进入一个系统需要输入的命令是一样的, 我感觉算是一种脚本? 我也不太懂, 只能说说大概理解:</p>
<ul>
<li>第一行指定硬盘分区表的格式</li>
<li>第二行指定文件系统</li>
<li>第三行指定在uuid为<strong>67E3-17ED</strong>的分区搜索引导项的启动文件</li>
<li>第四行指定这个引导项使用的启动文件 (因为黑苹果实际是有Clover启动的, 因此macOS引导项的指定启动文件为Clover的启动文件)</li>
</ul>
<p>💡 其中<code>insmod</code>是<strong>ins</strong>ert <strong>mod</strong>e的缩写.</p>
<h3 id="Grub-tone"><a href="#Grub-tone" class="headerlink" title="Grub tone"></a>Grub tone</h3><p>在<code>etc/default/grub</code>这个文件里可以进行的设置有<code>GRUB_CMDLINE_LINUX_DEFAULT</code>, 这个在显卡不兼容时常用到的设置, 也有<code>GRUB_THEME</code>这个设置GRUB图形界面的主题的, 甚至可以通过<code>GRUB_INIT_TUNE</code>可以设置开机彩铃 😂</p>
<p>GRUB tone的值是什么意思以及可以看<a href="https://breadmaker.github.io/grub-tune-tester/" target="_blank" rel="noopener">GRUB_INIT_TUNE tester</a>, 这里也提供了一些好听的铃声. 我用过这个超级马里奥音效:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GRUB_INIT_TUNE="1750 523 1 392 1 523 1 659 1 784 1 1047 1 784 1 415 1 523 1 622 1 831 1 622 1 831 1 1046 1 1244 1 1661 1 1244 1 466 1 587 1 698 1 932 1 1175 1 1397 1 1865 1 1397 1"</span><br></pre></td></tr></tbody></table></figure>

<p>但是这个音效声音大小无法调节, 只能是最大声, 真的很大声那种😏 所以虽然很好玩, 我后来还是取消了这个设置.</p>
<h3 id="最后微调"><a href="#最后微调" class="headerlink" title="最后微调"></a>最后微调</h3><p>调整完上面两个后运行<code>update-grub</code>来更新<code>/boot/grub/grub.cfg</code>. 最后可以到<code>/boot/grub/grub.cfg</code>进行最后微调 (如果需要的话).</p>
<h3 id="开机美化"><a href="#开机美化" class="headerlink" title="开机美化"></a>开机美化</h3><p>Ubuntu开机过程中一共有三处可以美化:</p>
<ul>
<li>GRUB theme</li>
<li><a href="https://wiki.archlinux.org/index.php/plymouth" target="_blank" rel="noopener">Plymouth</a> theme</li>
<li><a href="https://wiki.archlinux.org/index.php/GDM" target="_blank" rel="noopener">GDM</a> theme</li>
</ul>
<p>我的GRUB主题是<a href="https://www.gnome-look.org/p/1009533/" target="_blank" rel="noopener">Aurora Penguinis GRUB2 Theme</a>, Plymouth主题是<a href="https://www.gnome-look.org/p/1009239/" target="_blank" rel="noopener">Aurora Penguinis Plymouth 2 Theme</a>. 而Gnome能使用的GDM主题我没看到什么我中意的, 就自行改动了一下<code>/usr/share/gnome-shell/theme/ubuntu.css</code>里的样式, 给登录界面加了个背景图片.</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-id">#lockDialogGroup</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#2c001e</span> <span class="built_in">url</span>(file:///home/leo/Pictures/login-screen/custom.jpg);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center; }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="关于启动"><a href="#关于启动" class="headerlink" title="关于启动"></a>关于启动</h2><p>最后放上几个在搜索资料过程中看到的好资料:</p>
<ul>
<li><a href="https://help.ubuntu.com/community/Installation?_ga=2.230386906.774703488.1586350910-773002345.1585209571" target="_blank" rel="noopener">Ubuntu系统安装教程考古</a> 在<strong>Either Shrink the Windows C: Drive to Make Room for Linux OR Turn off Windows Updating</strong>这部分可以找到有人遇到的Windows系统更新却破坏了Ubuntu系统是怎么回事. (也很明显我这不会出现这问题)</li>
<li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">阮一峰-计算机是如何启动的？</a> 在这里可以看到启动为什么叫<strong>boot</strong>, 也可以对启动过程中发生了什么有个大概了解.</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>配置</category>
        <category>Linux</category>
        <category>macOS</category>
        <category>启动</category>
        <category>GRUB</category>
      </categories>
  </entry>
  <entry>
    <title>笔记本电脑性能提升/选购指南</title>
    <url>/zh-CN/2020/05/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>自去年三月多开始有意识了解电脑配件至今已有一年多, 对这些乱七八糟的了解多了许多, 整理一下我对<strong>笔记本</strong>性能提升的经验以及选购指南. 因为我很了解在不了解这些时听到这些陌生概念的望而畏怯以及半信半疑, 我尽量解释得小白些.</p>
<p>❗️ 因为我自己没有台式机所以这里只谈笔记本相关.</p>
<a id="more"></a>

<h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><p>不同于台式机里什么配件都可以换,  比如很多笔记本的CPU, 显卡是焊死在主板上的. 即便你的笔记本支持更换这两样, 这也不是容易事. 因为笔记本的散热是精打细算设计好的, 更换了更好的CPU或者显卡通常以为着更大的发热量, 很容易导致过热然后出奇奇怪怪的问题.</p>
<p>因此为了提升笔记本性能常见的操作是<strong>更换硬盘和内存</strong>.</p>
<h3 id="更换硬盘"><a href="#更换硬盘" class="headerlink" title="更换硬盘"></a>更换硬盘</h3><h3 id="更换内存"><a href="#更换内存" class="headerlink" title="更换内存"></a>更换内存</h3><h2 id="选购指南"><a href="#选购指南" class="headerlink" title="选购指南"></a>选购指南</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>HPV与宫颈癌小知识</title>
    <url>/zh-CN/2021/01/11/HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>帮人查HPV疫苗的信息整理了一份资料出来, 就分享一下好了.</p>
<a id="more"></a>

<h2 id="HPV"><a href="#HPV" class="headerlink" title="HPV"></a>HPV</h2><p>HPV (human papilloma virus), 即<strong>人类乳头状瘤病毒</strong>. 和乳头没有关系, 是大部分类型得了会长出乳头状的瘤 (即疣, 皮肤上的粗糙, 坚硬颗粒), 有近200种类型. <strong>不论是一般身体部位或生殖器的皮肤, 只要有鳞状上皮, 就可以被人类乳突病毒感染的, 但每种HPV通常只能感染特定区域皮肤.</strong></p>
<h3 id="较常见HPV与疣的种类"><a href="#较常见HPV与疣的种类" class="headerlink" title="较常见HPV与疣的种类"></a>较常见HPV与疣的种类</h3><p>❗ 大多数时候感染后没有任何临床症状, 也就是说连下面这些疣都不会有. 而出现了疣的话大致可以分以下几种情况.</p>
<table>
<thead>
<tr>
<th>疣类型</th>
<th>说明</th>
<th>HPV类型</th>
<th>危害程度</th>
</tr>
</thead>
<tbody><tr>
<td>普通疣 (瘊子)</td>
<td>有着粗糙的表面, 通常发生在手及脚部, 但亦有可能在身体其他区域发生</td>
<td>2, 4 (最常见), 1, 3, 26, 29, 57</td>
<td>良性</td>
</tr>
<tr>
<td>扁平疣</td>
<td>扁平而光滑的疣, 呈现肉色, 可能一长就是许多个；最常发生在头、脸、颈部、手、手肘及膝盖</td>
<td>3, 10, 28</td>
<td>良性</td>
</tr>
<tr>
<td>丝状疣</td>
<td>呈螺丝或者指头状, 在颈部, 脸部, 尤其是嘴唇以及眼皮周围上发生, 常见于中老年, 孕妇等 (因为抵抗力下降). <strong>注意与皮赘区别</strong></td>
<td>1, 2, 4, 7, 26, 27, 28, 29</td>
<td>良性</td>
</tr>
<tr>
<td>跖疣</td>
<td>发生在足底部. <strong>注意与鸡眼, 老茧区别</strong></td>
<td>1 (最常见), 2, 3, 4, 27, 28, 58</td>
<td>良性</td>
</tr>
<tr>
<td>肛门生殖器疣 (尖锐湿疣)</td>
<td>长在肛门/生殖器附近. <strong>注意与珍珠疹, 假性湿疣区别</strong></td>
<td><strong>6, 11</strong> (90%), 13, 40, 42, 43, 44, 54, 61, 72, 81, 89</td>
<td>低危</td>
</tr>
<tr>
<td>(癌和子宫颈细胞化生不良)</td>
<td>与癌症有关, 特别是子宫颈癌, 并且还可能会导致一些外阴, 阴道, 阴茎, 肛门和口咽的癌. 男性也可能感染</td>
<td><strong>16, 18</strong> (70%宫颈癌, 90%肛门癌, 很大比例阴道癌), <strong>31, 33, 45, 52, 58</strong>(20%宫颈癌), 35, 39, 59</td>
<td>高危</td>
</tr>
</tbody></table>
<p>💡 高危/低危根据致癌性划分. 无论是高危类型的HPV还是低危类型的HPV, <strong>目前都没有明确有效的抗病毒治疗手段</strong>, 只能治疗HPV导致的病变</p>
<p>💡 <strong>由此可见只有四十余种HPV通过性行为传播且有危害性, 大部分HPV性质和脚气类似, 并非性传播</strong> (但是能通过疫苗预防的几种HPV确实只有与性相关的几种)</p>
<p>💡 从整体上看, 我国的感染型别与国际以及亚洲地区其他国家略有差异, 在细胞学正常人群中, 全球范围内最常见的HPV型别依次是 HPV 16/52/31/53, 而在我国排名前四的型别依次是HPV 16/18/58/52. <strong>除了广泛流行的 HPV 16/18 型, HPV 58/52 型在中国宫颈癌中占比为 14.7%, 明显高于全球占比  7.4%</strong>.</p>
<p>80%感染的HPV会在6-24个月内会被身体的免疫系统自动清除, 医学上称为<strong>一过性感染</strong>.</p>
<h3 id="感染HPV的常见途径"><a href="#感染HPV的常见途径" class="headerlink" title="感染HPV的常见途径"></a>感染HPV的常见途径</h3><ol start="2">
<li>间接接触传播 (共用拖鞋, 共用毛巾, 共用剃须刀, 公用马桶, 私人衣物等)</li>
<li>性传播</li>
<li>母婴传播</li>
<li>医源性感染</li>
</ol>
<h2 id="宫颈癌"><a href="#宫颈癌" class="headerlink" title="宫颈癌"></a>宫颈癌</h2><p>到目前为止, 宫颈癌是人类唯一一个找到病因且可预防的癌症种类. 中国女性 HPV 感染率按年龄呈[双峰] 分布：第一个高峰在[17-24 岁], 第二个高峰在[40-44 岁].</p>
<p>宫颈癌与hpv关联: 只有少数高危型的 HPV 持续感染才会有一定几率引发宫颈癌, 通常情况下持续感染经过 10-20 年的自然演化发展, 才可能会发展成为宫颈癌.</p>
<h3 id="中国《子宫颈癌综合防控指南》提出的三级预防策略"><a href="#中国《子宫颈癌综合防控指南》提出的三级预防策略" class="headerlink" title="中国《子宫颈癌综合防控指南》提出的三级预防策略"></a>中国《子宫颈癌综合防控指南》提出的三级预防策略</h3><ol>
<li><strong>一级预防 (治未病)</strong>: 开展健康教育和接种 HPV 预防性疫苗</li>
<li><strong>二级预防 (治初病)</strong>: 对所有适龄妇女定期开展宫颈癌筛查</li>
<li><strong>三级预防 (治已病)</strong>: 根据宫颈癌的临床分期, 开展适宜的手术、放疗、化疗及姑息疗法</li>
</ol>
<p>🌟 筛查比hpv疫苗重要得多</p>
<p><img src="HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/screening.jpg" alt="图片"></p>
<h2 id="HPV疫苗"><a href="#HPV疫苗" class="headerlink" title="HPV疫苗"></a>HPV疫苗</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>以L1蛋白外壳模拟HPV病毒, 本身不是病毒, 不会造成感染</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul>
<li><p>预防大部分有致癌风险的HPV</p>
</li>
<li><p><strong>感染过HPV也仍有接种价值</strong>: HPV感染或由此引发的宫颈病变治愈后, 进行HPV疫苗接种可以减少疾病的复发率. 理论上认为, 人体自然感染HPV后, 抵抗病毒的体系是细胞免疫, 主要在宫颈局部起作用, 产生的抗体水平很低, 不足以对抗病毒的再次进攻. 而疫苗是肌肉注射, 会引发人体产生强烈有效的免疫反应, 产生的抗体的滴度是自然感染的40倍以上, 这样就可以防止病毒的感染.</p>
</li>
</ul>
<h3 id="接种条件及方式"><a href="#接种条件及方式" class="headerlink" title="接种条件及方式"></a>接种条件及方式</h3><ul>
<li>对疫苗活性成分 (L1蛋白) 或任何辅料成分有超敏反应者禁用</li>
<li>目前大陆没有开放男性接种HPV疫苗 (国外可以)</li>
<li>肌肉注射 (首选上臂三角肌), 每次0.5ml</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/types.png" alt="image-20210109163343942"></p>
<p>共二, 四, 九价三种HPV疫苗, “价”指疫苗能预防的HPV亚种数. 目前全世界只有葛兰素史克 (英国), 默沙东 (美国), 万泰沧海 (中国) 三家能生产HPV疫苗, 其中四价, 九价疫苗目前只有默沙东能生产.</p>
<h3 id="性价比"><a href="#性价比" class="headerlink" title="性价比"></a>性价比</h3><p><strong>万泰沧海二价 &gt; GSK二价 &gt; 默沙东九价 &gt; 默沙东四价</strong></p>
<ul>
<li><p>万泰沧海疫苗价格低的原因在于研发原理带来的低成本. 默沙东疫苗基于酒酿酵母表达体系, GSK 疫苗基于<strong>昆虫细胞</strong>表达系统, 万泰沧海疫苗基于<strong>大肠杆菌</strong>表达体系.</p>
</li>
<li><p>万泰对16/18型保护效力高于进口疫苗, 且不良反应小</p>
</li>
<li><p>四价只比二价多了对尖锐湿疣的预防, 但是尖锐湿疣看网上信息意思基本是良性的, 因此不如九价性价比高</p>
</li>
<li><p>国内目前都是自费接种, 因此其实大部分人还是选择等九价. 不过可能出现打完一针后缺货的情况.</p>
</li>
<li><p>打过了二价或四价, 也可以再接种九价, 不过要等完成接种的一年后才可以, 而且有点亏</p>
</li>
</ul>
<h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>打疫苗要按周期, 一共打三次. 可以比建议时间晚几天, 但最好不要提前打. 这是为了产生最多的抗体. 提前打浪费. <strong>一年内完成三针产生的抗体量都是够的</strong>.</p>
<h3 id="保护能力持续时间"><a href="#保护能力持续时间" class="headerlink" title="保护能力持续时间"></a>保护能力持续时间</h3><p>尚不清楚, 目前可以确保是10年以上. (因为这个疫苗一共出现才十多年)</p>
<h3 id="年龄限制"><a href="#年龄限制" class="headerlink" title="年龄限制"></a>年龄限制</h3><p>九价建议注射年龄是16~26岁, 指第一针需要在26岁半前接种, 27岁前完成三针. 之所以国内对默沙东九价疫苗限制年龄段比国外窄是因为国内的默沙东九价疫苗临床数据目前只做了16-26岁女性的  (同时也有疫苗资源紧张的原因).也因为同样原因大陆没有开放男性接种HPV疫苗.</p>
<h3 id="供应量"><a href="#供应量" class="headerlink" title="供应量"></a>供应量</h3><p>九价供应短缺原因:</p>
<ul>
<li>国内缺口大: 国家统计局最新数据显示, 九价HPV疫苗的适龄人群 (16-26岁) 约<strong>1.2亿</strong>. 而按照智飞生物2019年九价HPV疫苗批签发量332.4万计算, 能够接种到该疫苗的人数还<strong>不足总数的1%</strong>. (按照10%的核心人群渗透率算)</li>
<li>九价国内审批只用了八天, 默沙东产量预估不足, 并且增加产能决心不强烈</li>
<li>目前国外很多市场已经淘汰二价, 四价疫苗, 以售卖九价疫苗为主.</li>
</ul>
<p>现状:</p>
<ul>
<li><p>目前只有默沙东一家生产九价疫苗. 2023年默沙东新生产线将投产.</p>
</li>
<li><p>截至2020年7月国内HPV疫苗研发概况👇 (可以看到甚至十一, 十四价HPV疫苗也已经开始研发了), 但是我看网上消息的意思, 直到2026年估计不会有国产九价疫苗上市 🤦‍♂ ️</p>
</li>
</ul>
<p><img src="HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/outline.jpeg" alt="img"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
</search>
