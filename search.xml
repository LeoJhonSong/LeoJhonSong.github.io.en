<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大家好</title>
    <url>/zh-CN/2018/12/22/%E5%A4%A7%E5%AE%B6%E5%A5%BD/</url>
    <content><![CDATA[<div data-align="right">
<p>Language: <a href="/2018/12/22/hello-world"><kbd>English</kbd></a> <a href="/zh-CN/2018/12/22/大家好"><kbd>中文</kbd></a></p>
</div>
<hr>
<strong>大家好！这里是我的第一篇博文！</strong>我猜你会看到这里的唯一原因是你太闲了😉
<div>
<sub><sub><sup><sup>也可能是除了这个我啥也没写</sup></sup></sub></sub>
</div>
<hr>
<p>OK，我终于独立于那些恶心的C*DN等中文博客网站建立了自己可爱的博客。完美。</p>
<p>我建立博客1️⃣是为了<strong>记录我的学习心得</strong>（我发现在博客立Flag能强迫我继续学下去不然我可能就摸了。）也可能看心情写点随笔。在当今这个知识碎片满天飞的时代这真的是一种很好的整理方式。另一个很重要的原因是2️⃣我想安利一些我觉得很nb的东西。安利使我快乐。</p>
<p>希望日后的我能谨记初衷。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历</title>
    <url>/zh-CN/2018/12/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p><strong>前言</strong> ：博主是个不怎么懂软件的菜鸟，前几天为了学习Soft Robotics企图装一个带SoftRobots插件的SOFA，但我搜了半天也没有较新的安装教程（连下载方式都变了好吗）。虽然有官网的安装教程但我在安装过程中还是出了很多意外。感慨于在身边诸多大佬们的帮助下我这个对软件一窍不通的人才安装成功，我以一个不怎么接触编程的人的角度写下这篇博客帮助也想学习Soft Robotics的各位。(博主为了写这篇教程忍痛把安好的SOFA删了又下了一遍） <a id="more"></a> <strong>P.S.</strong> 由于我并不是软件相关专业的有很多理解和做法可能并不准确，仅供参考，也欢迎指教。</p>
<p><strong><em>教程仍然是跟着<a href="https://project.inria.fr/softrobot/" target="_blank" rel="noopener">SOFT ROBOTS Plugins for SOFA官网</a>来的，顺序有些许调整，要更详细一些。</em></strong></p>
<p>官网教程是<a href="https://project.inria.fr/softrobot/install-get-started-2/download/" target="_blank" rel="noopener">这个</a>，<a href="https://project.inria.fr/softrobot/install-get-started-2/building-on-windows/" target="_blank" rel="noopener">这个</a>和<a href="https://www.sofa-framework.org/community/doc/getting-started/build/windows/" target="_blank" rel="noopener">这个</a></p>
<p>实际上开发SoftRobots插件的项目组也考虑到要装这个软件太麻烦了，提供了<a href="https://softroboticstoolkit.com/sofa/plugin" target="_blank" rel="noopener">一个已经嵌入了SOFA的Ubuntu虚拟机映像</a>,但这个下载链接无效了。不过据说给项目组发邮件的话回复很快。此处为了运行速度和想安在Windows系统下偏向虎山行。</p>
<h1 id="预备工作">预备工作</h1>
<p>要下一个SOFA，首先你得下一堆东西...</p>
<p><code>建议各位看完每一个小节下的内容再操作，有的提供不止一种方法</code></p>
<h2 id="visual-studio2015或以上版本">Visual Studio2015或以上版本</h2>
<blockquote>
<p>利用其中的<strong>MSVC编译器</strong>来编译本软件，只需要用到基础功能。</p>
</blockquote>
<p>建议安装<strong>VS2017 community</strong>版，安装可以参考<a href="https://blog.csdn.net/qq_36556893/article/details/79430133" target="_blank" rel="noopener">这个</a></p>
<h3 id="pthread库"><span id="pthread">pthread库</span></h3>
<blockquote>
<p>博主在Cmake时曾因缺少这个库报错。这是<strong>一个实行了POSIX线程标准的线程库</strong>，Windows下的pthreads-win32是从类Unix系统移植来的。</p>
</blockquote>
<p>或许你可以先跳过这一步，如果你也遇到了这个报错再安装也不迟。安装参考<a href="https://blog.csdn.net/cry1994/article/details/79115394?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">这个</a>。单纯安装后博主也遇到了左边链接中提到的 <strong>“timespec”:“struct”类型重定义</strong> 问题，因此建议加上那个宏定义。</p>
<h2 id="qt-版本-5.5.0">Qt (版本&gt;= 5.5.0)</h2>
<blockquote>
<p>我猜这个是用来绘制SOFA的图形界面的</p>
</blockquote>
<p>官网提供的下载链接是<a href="http://download.qt.io/official_releases/online_installers/" target="_blank" rel="noopener">这个</a>,选择<em>qt-unified-windows-x86-online.exe</em>，是在线安装包。你也可以安装<a href="https://download.qt.io/official_releases/qt/5.11/5.11.1/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">离线安装包</a>,选择<em>qt-opensource-windows-x86-5.11.1.exe</em>. 安装可以参考<a href="https://www.cnblogs.com/chenmingjun/p/8392713.html" target="_blank" rel="noopener">这个</a></p>
<p>但实际上，只是为了安装SOFA的话， <img alt="Qt组件" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/qt.jpg"> 只需要如上图这个<strong>MSVC 2017 64-bit</strong>组件(博主当初不知道，把Qt5.11.1和Tools下所有东西都装了，下死我了) ## Git</p>
<blockquote>
<p>接下来下载SOFA源代码，SoftRobots插件源代码，vcpkg等都要用到这个高级百*云</p>
</blockquote>
<p>安装和使用教程可以参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">廖雪峰老师的Git教程</a></p>
<h2 id="boost-版本-1.54.0">Boost (版本&gt;= 1.54.0)</h2>
<blockquote>
<p>Boost是一个影响甚大，应用广泛的C++库（SOFA基于C++）</p>
</blockquote>
<p>在大佬的推荐下博主并没有直接安装Boost，而是安装了<strong>一个面向VS的开源C++库集成器<em>Vcpkg</em></strong>,通过Vcpkg傻瓜式安装了Boost。Vcpkg的安装和使用教程参考<a href="https://blog.csdn.net/cjmqas/article/details/79282847" target="_blank" rel="noopener">这个</a>。</p>
<p>然后Boost的安装就很轻松愉快了：在Vcpkg.exe所在文件夹shift+右键点击<strong>在此处打开powershell</strong>，在powershell中</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#x64平台的电脑输入</span></span><br><span class="line">.\vcpkg.exe install Boost:x64-windows</span><br><span class="line"><span class="comment">#x86平台的电脑输入</span></span><br><span class="line">.\vcpkg.exe install Boost:x86-windows</span><br></pre></td></tr></tbody></table></figure>
<p>截至写博客时，通过这种方法下载下来的是Boost1.68.0</p>
<p><strong>P.S.</strong>当然你也可以直接安装Boost。实际上这样可能更容易让Cmake找到Boost，博主通过Vcpkg安装的Boost需要手动让Cmake找到，<a href="#Boost">见编译部分</a>。</p>
<h2 id="python-2.7">Python 2.7</h2>
<blockquote>
<p>我们所必须的SoftRobots插件很大程度上依赖于SofaPython插件，另外有了SoftPython插件SOFA才可以识别“.py",".pyscn"扩展名的文件。SofaPython插件是默认安装的，前提是你有Python2.7。</p>
</blockquote>
<p><code>注意，要成功安装SofaPython插件必须用Python2.7，不能使用Python3，否则生成Makefile时会出错。(血泪亲测)</code></p>
<p>因为博主之前为Python这个博主唯一接触过一点的语言下了<a href="https://www.anaconda.com/" target="_blank" rel="noopener">Anaconda</a>,于是博主试图用在Anaconda中激活的一个Python2.7环境来满足条件，但博主尝试了许久也无法让Cmake找到我这个2.7的Python，他只找到了在我Anaconda根目录的Python3.5...</p>
<p>因此我为了安装SOFA专门下了一个<a href="https://www.python.org/downloads/release/python-2715/" target="_blank" rel="noopener">Python2.7.15</a>(截至写博客时最新版Python2.7.x)。x64平台电脑下载<strong>Windows x86-64 MSI installer</strong>，x86平台电脑下载<strong>Windows x86 MSI installer</strong>。如果图省事一路默认选项安装即可（是的博主甚至安到了C盘）</p>
<p><br></p>
<p><strong>好的，有了以上这些我们可以开始下载SOFA了</strong></p>
<h1 id="下载">下载</h1>
<h2 id="sofa源代码下载">SOFA源代码下载</h2>
<p>SOFA官网提供稳定版（v18.06）和不稳定版。一开始博主下了稳定版，一秒下载两秒安装，那叫一个爽。但不幸的是<span style="color:red;">要安装SoftRobots插件的话只能安装不稳定版</span>。刺激。</p>
<p>找一个你认为适合安装SOFA的文件夹（博主安装在了D盘根目录），此处打开powershell，输入</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/sofa-framework/sofa.git sofa/src/</span><br></pre></td></tr></tbody></table></figure>
<p>然后你可以去看一集番。因为Github的鬼屎速度303.37MiB左右博主下了二十几分钟。</p>
<p>下好之后在<strong>sofa/</strong>文件夹下新建一个<strong>build</strong>文件夹一会放runsofa.sln和编译好的软件用。</p>
<h2 id="补充的库下载">补充的库下载</h2>
<p>需要额外下载四个库<strong>libPNG, libJPEG, libTIFF, Zlib, Glew</strong>.VS2015用户下载<a href="https://www.sofa-framework.org/download/WinDepPack/VS-2015/latest" target="_blank" rel="noopener">这个</a>，VS2017用户下载<a href="https://www.sofa-framework.org/download/WinDepPack/VS-2017/latest" target="_blank" rel="noopener">这个</a>。直接将解压出来的<strong>include，lib，licenses</strong>三个文件夹放到 <strong>sofa/src/</strong> 文件夹下就可以了。</p>
<h2 id="softrobots插件源代码下载">SoftRobots插件源代码下载</h2>
<p>进入<strong>sofa/src/applications/plugins</strong>文件夹，此处打开powershell，输入</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/SofaDefrost/SoftRobots</span><br></pre></td></tr></tbody></table></figure>
<p>这一次17.52MiB博主下了十分钟。(What?!)</p>
<p>实际上除了SoftRobots，项目组还提供了一个插件<a href="https://project.inria.fr/softrobot/install-get-started-2/download/" target="_blank" rel="noopener">SoftRobots.Inverse</a>,但这个插件目前不向公众开发。有兴趣的话各位可以发邮件给项目组，下载来试试。</p>
<p><em>别忘记将刚下的<strong>HIDAPI</strong>放进去</em></p>
<h1 id="生成runsofa.sln">生成runsofa.sln</h1>
<p>然后就可以点开CMake图形界面了，做好多次报错的心理准备。</p>
<blockquote>
<p>博主推荐先修改一下设定，打开<code>Options</code>下的<strong>Warning Messages...</strong>,像下面这样勾选抑制警告的两项，关掉可能很多条，干扰视线而不影响Cmake的Warning提示，有利于稍后更容易地找出报错原因。</p>
</blockquote>
<figure>
<img alt="Warning设置" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/warning.jpg"><figcaption>Warning设置</figcaption>
</figure>
<p>首先在<em>where is the source code</em>一栏填上你的<strong>sofa/src</strong>的地址，在<em>where to build the binaries</em>一栏填上你的<strong>sofa/build</strong>的地址，然后点击<code>Configure</code>。 <img alt="CMake地址" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/cmake.jpg"></p>
<p>然后为项目选择你将要使用的编译器，向下面这样选择。 <img alt="选择编译器" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/compiler.jpg"></p>
<p>P.S.虽然官网教程有提及可以使用<strong>Ninja</strong>来代替此处的选择，但我没研究出怎么使用，此处仍然选择VS的<strong>MSVC</strong>编译器。</p>
<blockquote>
<p>第一次Configure用时较长，，尤其是可能在<strong>Cloning into 'SofaHighOrder'...</strong>一行停留许久。你可以稍微歇息一下</p>
</blockquote>
<figure>
<img alt="报错" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/error.jpg"><figcaption>报错</figcaption>
</figure>
<p>然后是频繁出现地报错。</p>
<p>但不用担心，Configure这个操作本来就是要多次进行来逐渐更正错误，甚至可以在此期间调整要安装的插件。经过我的观察Generate多次也没有问题，只会在原本的基础上改动，不会出现重复的文件。因此放心大胆地来，每次你觉得修正了几个问题了就可以运行一次Configure。经过博主摸索发现了两种找报错原因的方式</p>
<ul>
<li>直接看<code>Configure</code>和<code>Generate</code>两个按键下面的信息框里的报错信息</li>
<li><img alt="看报错信息方式1" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/checkerror.jpg"></li>
<li>打开在<strong>sofa/src/build/CMakeFiles/</strong>下的<em>CMakeError.log</em>（错误日志）。这个日志会记录你在Cmake过程中所有的报错 (包括每一次Configure的报错)。我的经验是错误原因通常在”<strong>生成失败。</strong>“这句话附近。如果有多个错误，一个一个耐心解决。</li>
</ul>
<h2 id="sofa本体configure过程中遇到的一些报错及解决">SOFA本体Configure过程中遇到的一些报错及解决</h2>
<p>以下是博主在Cmake过程中遇到的一些报错及博主的解决方式。</p>
<h3 id="fatal-error-c1083-无法打开包括文件-pthread.h-no-such-file-or-directory">fatal error C1083: 无法打开包括文件: “pthread.h”: No such file or directory</h3>
<p>好的，如果你出了这个报错说明你刚刚没有安装<a href="#pthread">推荐你安的pthread库</a>，让你懒哈哈哈哈哈</p>
<p>不过即便安装pthread库后在<em>CMakeError.log</em>中仍然会有pthread相关报错。但不会影响SOFA的安装，可以忽略。</p>
<h3 id="unable-to-find-the-boost-header-files"><span id="Boost">Unable to find the Boost header files</span></h3>
<figure>
<img alt="Boost报错" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/Boosterror.png"><figcaption>Boost报错</figcaption>
</figure>
<p>如果你得到了类似这样的报错信息那你大概是像博主一样利用Vcpkg安装的Boost，Cmake没能找到你的Boost。(我错了，下次还犯)但用Vcpkg安装Boost真的很容易。Cmake给出了提示：</p>
<h4 id="方法1">方法1：</h4>
<figure>
<img alt="添加Entry" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/addEntry.png"><figcaption>添加Entry</figcaption>
</figure>
<p>点击<code>Add Entry</code>按键添加一个下面这样的Entry。</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Boost_ROOT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Type</td>
<td><strong>path</strong></td>
</tr>
<tr class="even">
<td>Value</td>
<td><strong>你安装Vcpkg的文件夹/vcpkg/installed/x64-windows/include</strong>(比如博主的是<em>D:64-windows\include</em>)</td>
</tr>
<tr class="odd">
<td>Description</td>
<td>空</td>
</tr>
</tbody>
</table>
<p><br> 注意Value不能填<b>你安装Vcpkg的文件夹/vcpkg/installed/x64-windows/include/boost</b>,需要填包含Boost文件夹的文件夹的路径，否则仍然会像上图那样报错。</p>
<h4 id="方法2">方法2：</h4>
<p>在环境变量中添加一个下面这样的系统变量</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 85%">
</colgroup>
<thead>
<tr class="header">
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Boost_ROOT</td>
<td><strong>你安装Vcpkg的文件夹/vcpkg/installed/x64-windows/include</strong>(比如博主的是<em>D:64-windows\include</em>)</td>
</tr>
</tbody>
</table>
<h3 id="sofasrcapplicationspluginssofahighorderexternalprojectconfig.cmake.in-does-not-exist.">sofa/src/applications/plugins/SofaHighOrder/ExternalProjectConfig.cmake.in does not exist.</h3>
<figure>
<img alt="缺少CMake.in文件" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/lackCMake.png"><figcaption>缺少CMake.in文件</figcaption>
</figure>
<p>有可能当添加SofaHighOrder的子目录EXTERNAL的时候会发生这样的报错，有时候又不会发生。我怀疑<em>ExternalProjectConfig.cmake.in</em>这个文件特别容易丢包。但解决很容易，博主在前面下载SOFA源码的Github仓库里找到了这个<a href="https://github.com/sofa-framework/sofa/tree/master/applications/plugins/SofaHighOrder" target="_blank" rel="noopener">ExternalProjectConfig.cmake.in</a>你说神不神奇。把这个文件下载下来放到<b>sofa/src/applications/plugins/SofaHighOrder/</b>文件夹下即可。(其实博主不知道怎么下这个文件，就在sofa/src/applications/plugins/SofaHighOrder/文件夹下新建了一个ExternalProjectConfig.cmake.in并把Github上该文件里的内容复制粘贴了进去)</p>
<p>在运行到SofaHighOrder这部分的时候你可能会碰到像下面这样的乱码，但不要紧，再Configure几次就没有了。</p>
<figure>
<img alt="乱码" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/messycode.png"><figcaption>乱码</figcaption>
</figure>
<h3 id="找不到python">找不到Python</h3>
<p>博主为此专门下了一个Python2.7。</p>
<p><code>你需要在搜索框中搜索Python以确保你确实添加上了SofaPython插件</code>。即便你单独下好了Python2.7你也可能需要手动勾选SofaPython选项（勾选前Enter列表中<strong>SofaPython_DIR</strong>显示找不到SofaPython，但你手动添加这个插件的话其实他找得到）</p>
<h3 id="找不到qt">找不到Qt</h3>
<p>类似找不到Boost的解决办法，点击<code>Add Entry</code>,添加一个下面这样的Entry</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>CMAKE_PREFIX_PATH</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Type</td>
<td><strong>path</strong></td>
</tr>
<tr class="even">
<td>Value</td>
<td><strong>你安装Qt的文件夹/Qt/5.11.1/msvc2017_64</strong>(比如博主的是<em>D:/Qt/5.11.1/msvc2017_64</em>)</td>
</tr>
<tr class="odd">
<td>Description</td>
<td>空</td>
</tr>
</tbody>
</table>
<p>再次运行Configure后刚添加的这个叫CMAKE_PREFIX_PATH的Entry会消失，取而代之的是一帮Qt的Entry</p>
<figure>
<img alt="那堆Qt的Entry" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/QtEntry.png"><figcaption>那堆Qt的Entry</figcaption>
</figure>
<p><strong>以上便是博主安装SOFA本体过程中遇到过的报错，如果你遇到了别的无法解决的报错也欢迎讨论</strong></p>
<p><img alt="无误反馈信息" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/noError.png"> 这是博主在加装SoftRobots插件前得到的无误的反馈信息。并且你会发现本来一片红色的Entry列表此时全都是白/灰这种看起来就很OK的颜色。(如果还有红色的请再Configure一次。这之后如果还有，忽略)</p>
<p>在此之前，在搜索框里输入python并确保你的<strong>PLUGIN_SOFAPYTHON</strong>打了勾，<strong>SofaPython_DIR</strong>不是not found</p>
<figure>
<img alt="确认SofaPython" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/checkPython.png"><figcaption>确认SofaPython</figcaption>
</figure>
<p>这样SOFA软件本体的安装就没有问题了，接下来添加SoftRobots插件(现在你在搜索框查找SoftRobots是什么也查不到的)。</p>
<h2 id="添加softrobots插件">添加SoftRobots插件</h2>
<blockquote>
<p>博主一开始没看到正规添加SoftRobots插件的方法，手足无措下自行修改了SOFA的CMakeList.txt文件安上的...(狗屎英语教程)</p>
</blockquote>
<p>正规方法是在搜索框搜索<strong>SOFA_EXTERNAL_DIRECTORIES</strong>，找到这个Entry并将Value填为<strong>你安装SOFA的文件夹/sofa/src/applications/plugins/SoftRobots</strong>(比如博主的是<em>D:/sofa/src/applications/plugins/SoftRobots</em>)，</p>
<figure>
<img alt="SoftRobots相关Entry" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/softRobotEntrry.jpg"><figcaption>SoftRobots相关Entry</figcaption>
</figure>
<p>再次Configure，你就得到了与SoftRobots相关的几个Entry。不勾选这几个可选组件orz博主研究了很久也没能成功安装他们。根据名字和需要的库博主猜测<strong>SOFTROBOTS_GAMETRAKCONTROLLER</strong>是一个实现可以通过usb设备或蓝牙和外设交互的组件，<strong>SOFTROBOTS_COMMUNICATIONCONTROLLER</strong>似乎是实现利用网络通信和外设交互的组件，而<strong>SOFTROBOTS_ROBOTINOCONTROLLER</strong>猜测需要配合<strong>Robotino</strong>使用。<strong>Robotino</strong>是一款商业化的移动机器人系统，明显买不起。博主暂时不需要这个插件。</p>
<p>再次Configure。</p>
<p>完美。</p>
<p>这是博主最终的无误版<strong>Configure</strong>的反馈信息。</p>
<figure>
<img alt="最终版反馈信息" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/reaction.png"><figcaption>最终版反馈信息</figcaption>
</figure>
<p>现在安装已经接近尾声了(步骤方面，时间方面还得要一会)，你可以选择性的再安装几个部件。(报错了的话就放弃吧哈哈哈哈哈)给出官网上<a href="https://www.sofa-framework.org/community/doc/getting-started/build/build-options/" target="_blank" rel="noopener">相关网页</a>以供参考。</p>
<p>当你对Configure的结果感到满意后，<code>Generate</code>，点击！</p>
<p><code>注意，编译完成之前暂时先不要关闭CMake界面，否则可能编译失败</code></p>
<h1 id="编译">编译</h1>
<blockquote>
<p>你可以睡前来做这个</p>
</blockquote>
<p>进入<strong>sofa/build/</strong>,用VS打开<em>Sofa.sln</em>,经过一段令人尴尬的等待，</p>
<figure>
<img alt="编译操作顺序" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/howtocompile.png"><figcaption>编译操作顺序</figcaption>
</figure>
<p>进入界面后先将解决方案配置调为<strong>Release</strong>，然后确保解决方案平台确实是你电脑的平台(博主的电脑是x64平台)，等待左下角显示<strong>就绪</strong>后，点击<strong>本地Windows调试器</strong>开始编译。</p>
<p>然后你就可以去睡觉了。(即便你想用电脑做点别的应该也很难，不知道是我人品太差还是SOFA的编译真的很考验电脑，我的电脑呈现出了这样的尴尬局面 )</p>
<figure>
<img alt="编译车祸现场" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/mess.png"><figcaption>编译车祸现场</figcaption>
</figure>
<p>第二天(博主的电脑编译了两个多小时)，你会看到一个无法打开ALL_BUILD的报错，这是正常现象，无须在意。</p>
<p><code>如果你没有看到其他报错，恭喜你编译成功了!</code></p>
<h1 id="测试">测试</h1>
<p>现在就可以来测试一下软件是否真的安装成功了。进入<strong>sofa/build/bin/release/</strong>，运行<em>rensofa.exe</em>,会进入这个蛇绕柱子的Demo。</p>
<figure>
<img alt="Demo" data-src="记一次在Win10下安装SOFA仿真软件并加装SoftRobots插件的经历/demo.jpg"><figcaption>Demo</figcaption>
</figure>
<p>你可以通过打开在SoftRobots下的几个Example来进一步测试。可以参考官网给出的<a href="https://project.inria.fr/softrobot/install-get-started-2/tutorial/" target="_blank" rel="noopener">样例教程</a>。或者你也可以探索SOFA官网上的<a href="https://www.sofa-framework.org/community/doc/getting-started/tutorials/" target="_blank" rel="noopener">入门教程</a>。</p>
<p><br></p>
<p><strong>至此，本次在Win10下安装SOFA仿真软件并加装SoftRobots插件的任务便完成了。</strong></p>
<p><strong>恭喜你能坚持安装完成，也祝你接下来的研究顺利。</strong></p>
<p><br> <br></p>
<blockquote>
<p>顺带一提，电子科大微软学生俱乐部真是个好地方，里面人才又多，说话又好听</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
      </categories>
  </entry>
  <entry>
    <title>配置VSCode中调试C/C++环境</title>
    <url>/zh-CN/2018/12/30/%E9%85%8D%E7%BD%AEVSCode%E4%B8%AD%E8%B0%83%E8%AF%95C-C-%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<div data-align="right">
<p>Language: <a href="/2018/12/30/Configure-C-C-environment-in-VSCode"><kbd>English</kbd></a> <a href="/zh-CN/2018/12/30/配置VSCode中调试C-C-环境"><kbd>中文</kbd></a></p>
</div>
<p>这里是为我在VSCode插件市场发布的 <a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.ccpp-extension-pack" target="_blank" rel="noopener">C/C++扩展包</a> 写的Windows下VSCode中C/C++配置教程<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span></p>
<a id="more"></a>
<p>实际上在<a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank" rel="noopener">VSCode的说明文档中C++部分</a> 对如何配置环境有十分详细的说明, 本文仅是对其的部分整理和解读<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span> 因此如果你的能力足够看官方文档当然是更好的选择<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8">👍</span></p>
<p>P.S.其实只要右键翻译成中文我觉得不难懂...</p>
<ol type="1">
<li><a href="#准备工作">准备工作</a>
<ol type="1">
<li><a href="#编译器">编译器</a>
<ol type="1">
<li><a href="#安装">安装</a></li>
<li><a href="#添加至path">添加至Path</a></li>
<li><a href="#测试">测试</a></li>
</ol></li>
<li><a href="#vscode插件">VSCode插件</a></li>
</ol></li>
<li><a href="#配置文件">配置文件</a>
<ol type="1">
<li><a href="#配置intellisense">配置IntelliSense</a></li>
<li><a href="#配置编译配置文件">配置编译配置文件</a>
<ol type="1">
<li><a href="#合起来">合起来!</a></li>
</ol></li>
<li><a href="#配置调试配置文件">配置调试配置文件</a>
<ol type="1">
<li><a href="#调试对象">调试对象</a></li>
<li><a href="#debugger路径及选项">Debugger路径及选项</a></li>
<li><a href="#启动前编译">启动前编译</a></li>
<li><a href="#合起来-1">合起来!</a></li>
</ol></li>
</ol></li>
<li><a href="#enjoy">Enjoy</a></li>
</ol>
<h1 id="准备工作">准备工作</h1>
<p>VSCode本身只是一个编辑器, 也就是一个记事本, 是不包含编译器的. 即便我们安装了cpptools 这个扩展, 他也并没有为我们安装编译器 (如果你想看看cpptools这个扩展里都有什么可以前往自己电脑的 **%HOMEPATH%\.vscode*, 找到<strong>ms-vscode.cpptools</strong> 去看看)</p>
<h2 id="编译器">编译器</h2>
<p>因此第一步我们需要安装编译器. 编译器不止一家, 在VSCode官方文档中推荐的是:</p>
<ul>
<li><p>Windows平台: <a href="https://sourceforge.net/projects/mingw-w64/" target="_blank" rel="noopener">MinGW-w64</a></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 要注意另有一个叫MinGW的东西, 虽然功能差不多, 但那个已经很久没更新了, 安装没MinGW-w64容易, 还不是官宣, 因此不推荐. 后面所说的MinGW实际指的是MinGW-w64, 我只是懒得打那么多字了</p></li>
<li>macOS: <a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">clang</a></li>
<li><p>Linux: <a href="https://gcc.gnu.org/" target="_blank" rel="noopener">gcc</a></p></li>
</ul>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>因为我没钱买Mac, 暂时也没需求在Linux配置VSCode, 本文仅针对<strong>Windows</strong> 平台, 当然也可以作为其他平台的参考. 甚至<a href="https://pimylifeup.com/raspberry-pi-visual-studio-code/" target="_blank" rel="noopener">有人在树莓派安装VSCode</a>.</p>
<p>P.S. 实际上编译器的选择并不是个令人头疼的事, 我们随时可以轻易的更换VSCode使用的编译器</p>
<h3 id="安装">安装</h3>
<p>将MinGW-w64下载下来之后点击安装, 以下几点要注意, 其余选项默认即可:</p>
<ul>
<li><p>安装向导第一页有一项是选择<code>Architecture</code> (即电脑的架构, 此处i386代指32位电脑, x86_64代指64位电脑), 此处选择<strong>x86_64</strong>. (当然如果你的电脑竟然是32位的话不用变)</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 如何查看自己电脑是32位还是64位?</p>
<p>Windows10的话, 前往 <strong>设置</strong> &gt; <strong>系统</strong> &gt; <strong>关于</strong> &gt; <strong>设备规格</strong> &gt; <strong>系统类型</strong></p>
<p>其他Windows的话上网搜索一下好啦 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8">😉</span></p></li>
<li><p>安装在哪里都可以, 但一定要是你找得到的地方, 因为安装完成后还要手动将MinGW加入<strong>Path</strong>.</p></li>
</ul>
<h3 id="添加至path">添加至Path</h3>
<p>安装完毕后我们需要将MinGW添加至<strong>Path</strong>, 这样我们通过命令行就可以调用它啦 (VSCode编译/调试 C/C++程序实际上就是在内置命令行中调用MinGW)</p>
<p>要将什么路径添加到<strong>Path</strong>呢? 因为添加到Path的路径是要调用的程序的exe文件所在的文件夹比如我将MinGW安装到了 <strong>D:-w6486_64-8.1.0-posix-seh-rt_v6-rev0</strong> 这个文件夹下, 那么我将 **D:-w6486_64-8.1.0-posix-seh-rt_v6-rev064*加入环境变量. 你会看到我们将要调用的<code>gcc</code>和<code>gdb</code>两个程序正在其中.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> 关于如何添加系统变量, <a href="https://jingyan.baidu.com/article/ca41422f17107a1eaf99ed64.html" target="_blank" rel="noopener">这篇百度知道</a>应该就够了</p>
<h3 id="测试">测试</h3>
<p>这之后! 我们测试一下, 在命令行输入<code>gcc</code></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 你看到的应当是:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\LeoJh&gt;gcc</span><br><span class="line">gcc: fatal error: no input files</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></tbody></table></figure>
<p>这是说gcc被成功唤起,我们已经成功完成编译器的配置了, 但你没告诉它要编译的文件路径, 所以他就报错了.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span>而如果你看到的是:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\LeoJh&gt;gcc</span><br><span class="line">'gcc' 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">或批处理文件。</span><br></pre></td></tr></tbody></table></figure>
<p>这是说无法从命令行调用gcc. 一种情况是没有把正确的路径加入<strong>Path</strong>, 另一种情况是该换电脑了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span></p>
<h2 id="vscode插件">VSCode插件</h2>
<p>搞定了编译器我们就离完成不远了! 实际上你现在已经可以开始开发C/C++了, 只不过是硬核一些. 不信你可以搓一段hello world放进一个.c文件, 比如<strong>test.c</strong>, 在该文件所在文件夹空白处按住<code>shift</code>同时按右键, 在此打开powershell, 输入<code>gcc test.c</code>, 然后你就会发现文件夹里多了一个<strong>a.exe</strong>. 这便是编译好的可执行文件了!</p>
<p>但这样无论是编辑还是编译还是调试体验都太差了, 于是我们安装一些好用的扩展提高效率.</p>
<p>因为我并不常在VSCode中编写C/C++, 因此<a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.ccpp-extension-pack" target="_blank" rel="noopener">我的扩展包</a> 中并没有几个插件. 但我认为这几个很不错的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<p>当然你看不上我的扩展包也没事<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>只需要安装了<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">官方C/C++支持扩展</a> 就能体验到很强大的支持了.</p>
<h1 id="配置文件">配置文件</h1>
<p>在有些教程中, 要在VSCode中开发C/C++需要配置<code>c_cpp_properties.json</code>, <code>tasks.json</code>, <code>launch.json</code>三样, 但现在不是这样了! 🎉 现在<code>c_cpp_properties.json</code>已经完全被 <code>settings.json</code>取代了, 也就是说在设置中就可以进行原来在<code>c_cpp_properties.json</code>中进行的配置! 这样的好处是我们可以针对不同的工作区进行不同的设置等. 另外, 稍后你也会看到随着VSC的更新<code>tasks.json</code>和<code>launch.json</code>的生成也变得十分简单!</p>
<p>🔗 关于设置取代了<code>c_cpp_properties.json</code>的说明参见<a href="https://github.com/Microsoft/vscode-cpptools/blob/master/Documentation/LanguageServer/Customizing%20Default%20Settings.md" target="_blank" rel="noopener">这里</a>, 另外给出对原本可以在<code>c_cpp_properties.json</code>中配置的内容的描述的<a href="https://github.com/Microsoft/vscode-cpptools/blob/master/Documentation/LanguageServer/c_cpp_properties.json.md" target="_blank" rel="noopener">链接</a></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 以下配置文件内容都以我的配置文件为例</p>
<h2 id="配置intellisense">配置IntelliSense</h2>
<p>正如前面所说, 我们不需要VSCode就可以编译/调试C/C++, 因此能够提供智能补全功能的 IntelliSence是<strong>cpptools</strong>这个插件很重要的一部分, 通过在<code>settings.json</code> (原本是 <code>c_cpp_properties.json</code>)中进行设置来设定IntelliSense的模式. 主要设置以下几个:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"C_Cpp.autocomplete": "Default",</span><br><span class="line">"C_Cpp.clang_format_style": "{ BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Allman, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 0, AccessModifierOffset: -4 }",</span><br><span class="line">"C_Cpp.clang_format_fallbackStyle": "{ BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, BreakBeforeBraces: Allman, AllowShortIfStatementsOnASingleLine: false, IndentCaseLabels: false, ColumnLimit: 0, AccessModifierOffset: -4 }",</span><br><span class="line">"C_Cpp.default.compilerPath": "D:\\Softwares\\mingw-w64\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\mingw64\\bin\\gcc.exe",</span><br><span class="line">"C_Cpp.default.cStandard": "c99",</span><br><span class="line">"C_Cpp.default.cppStandard": "c++11",</span><br><span class="line">"C_Cpp.default.intelliSenseMode": "gcc-x64",</span><br><span class="line">"C_Cpp.intelliSenseEngine": "Default",</span><br><span class="line">"C_Cpp.errorSquiggles": "Enabled",</span><br></pre></td></tr></tbody></table></figure>
<p>💡 其中<strong>C_Cpp.clang_format_style</strong>, <strong>C_Cpp.clang_format_fallbackStyle</strong>是VSC格式化C/C++代码的风格. 上面的配置是近似于<strong>Visual Studio</strong>格式化C/C++代码的风格. 我偏爱VS风格, 而如果你喜欢Google风格, 可以用下面这个值:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"C_Cpp.clang_format_style": "{BasedOnStyleStyle: Google, IndentWidth: 4}",</span><br><span class="line">"C_Cpp.clang_format_fallbackStyle": "{BasedOnStyleStyle: Google, IndentWidth: 4}",</span><br></pre></td></tr></tbody></table></figure>
<p>随着VSC的更新, VSC提供了一些<code>tasks.json</code>和<code>launch.json</code>的模板, 这让生成这两个文件变得十分容易! 下面这个gif👇 是一个生成<code>tasks.json</code>和<code>launch.json</code>的示例.</p>
<p><img data-src="配置VSCode中调试C-C-环境/example.gif"></p>
<p>💡 这个gif是在Linux系统 (Ubuntu) 下录制的.</p>
<p>下面则是对这两个文件内容的一些解释.</p>
<h2 id="配置编译配置文件">配置编译配置文件</h2>
<p>然后配置编译用的<code>tasks.json</code>.</p>
<p>✔️ 这个文件和之后配置的<code>launch.json</code>都是针对特定程序的, 如何生成这两个文件请参见VSCode官方文档. 但你可以将满意的<code>tasks.json</code>和<code>launch.json</code>放在一个包含许多工程的目录中, 那么这些工程都将使用这两个配置文件. 如果你想给这之中某个工程配置不同的配置你可以在这个工程的根目录另外生成<code>tasks.json</code>和<code>launch.json</code>, 会覆盖上一层的配置.</p>
<p>当你跟随VSCode官方文档创建了一个 <code>tasks.json</code> 之后, 将下面这个任务添加到tasks的列表, 至于自带的label为 <strong>echo</strong> 的任务你可以删掉或者不管他.</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="attr">"label"</span>: <span class="string">"Compile"</span>,</span><br><span class="line">   <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">   <span class="attr">"command"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">   <span class="attr">"args"</span>: [</span><br><span class="line">         <span class="string">"${file}"</span>,</span><br><span class="line">         <span class="string">"-o"</span>,</span><br><span class="line">         <span class="string">"${fileDirname}/${fileBasenameNoExtension}.exe"</span>,</span><br><span class="line">         <span class="string">"-g"</span>,</span><br><span class="line">         <span class="string">"-Wall"</span>,</span><br><span class="line">         <span class="string">"-std=c++17"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"group"</span>: {</span><br><span class="line">         <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">         <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>label</code>的意思是给这个任务取名为<strong>Compile</strong>, <a href="#启动前编译">稍后</a>会用到.</p>
<p>从中我们可以看出实际上当我们调用这个叫<strong>Compile</strong>的task的时候会在shell中输入:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gcc ${file} -o ${fileDirname}/${fileBasenameNoExtension}.exe -g -Wall -std=c++17</span><br></pre></td></tr></tbody></table></figure>
<p>其中<strong>${file}</strong>等是<a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener">VSCode中定义的变量</a></p>
<p><code>-o</code>选项使我们可以<a href="http://www.runoob.com/note/28613" target="_blank" rel="noopener">指定生成文件的名字</a></p>
<p>其他几个选项可以上网查查.</p>
<p><code>group</code>这里的配置是我们能通过快捷键 <code>Ctrl+shift+B</code>来执行该任务. 参见<a href="https://code.visualstudio.com/docs/editor/tasks#_typescript-hello-world" target="_blank" rel="noopener">这里</a></p>
<h3 id="合起来">合起来!</h3>
<p>因此我的 <code>tashs.json</code> 长这样:</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"Compile"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"${file}"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"${fileDirname}/${fileBasenameNoExtension}.exe"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"-Wall"</span>,</span><br><span class="line">                <span class="string">"-std=c++17"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"group"</span>: {</span><br><span class="line">                <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">                <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="配置调试配置文件">配置调试配置文件</h2>
<p>最后配置的这个是<code>launch.json</code>. 实际上这很简单, 因为VSCode已经提供了很多种模板, 需要改动的非常少.</p>
<p>通常我们选择 <strong>(gdb) Launch</strong> 这种模板. Launch指的是要调试的程序是在开始调试时才开始运行, Attach指的是开始调试时程序已经在运行了 (比如在服务器上的程序)</p>
<p>需要改动/添加的非常少:</p>
<h3 id="调试对象">调试对象</h3>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"program": "${workspaceFolder}/a.exe"</span><br></pre></td></tr></tbody></table></figure>
<p><code>program</code>指的是要调试的程序. 如果不特别指出的话大多数编译器默认将编译出来的可执行文件命名为 <strong>a.exe</strong>. 而如果你的<code>tasks.json</code>也像我一样加了 "-o ${fileDirname}/${fileBasenameNoExtension}.exe" 这个选项的话, 将会生成和源文件同名的可执行文件, 因此要用:</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"program": "${workspaceFolder}/${fileBasenameNoExtension}.exe"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="debugger路径及选项">Debugger路径及选项</h3>
<p>如果你在命令行输入 <code>gdb</code> 你会发现首先映入眼帘的是一串废话, 因此我们可以加上<code>-q</code>这个选项来让它少说废话.</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"miDebuggerPath": "gdb.exe",</span><br><span class="line">"miDebuggerArgs": "-q"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="启动前编译">启动前编译</h3>
<p>如果你担心自己忘记每次调试前先编译一遍已更改的代码 (不然你会哭出声响), 可以添加一个 <strong>preLaunchTask</strong>, 这个task指定为刚配置的那个<strong>Compile</strong>任务. 这样每次调试前程序都会被先编译一遍<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8">👍</span></p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"preLaunchTask": "Compile"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="合起来-1">合起来!</h3>
<p>因此我的<code>launch.json</code>长这样:</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"${workspaceFolder}/${fileBasenameNoExtension}.exe"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"${workspaceFolder}"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerPath"</span>: <span class="string">"gdb.exe"</span>,</span><br><span class="line">            <span class="attr">"miDebuggerArgs"</span>: <span class="string">"-q"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                {</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                }</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"Compile"</span></span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="enjoy">Enjoy</h1>
<p>这下我们可以轻松愉快的开发C/C++了! 祝各位水平日益提高<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f389.png?v8">🎉</span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>VSC</category>
      </categories>
  </entry>
  <entry>
    <title>搓一个Python/C++的简易卡尔曼滤波器</title>
    <url>/zh-CN/2019/01/07/%E6%90%93%E4%B8%80%E4%B8%AAPython-C-%E7%9A%84%E7%AE%80%E6%98%93%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<div data-align="right">
<p>Language: <a href="/Struggling-a-Simple-Kalman-Filter-by-Python-C"><code>English</code></a> <a href="/zh-CN/搓一个Python-C-的简易卡尔曼滤波器"><code>中文</code></a></p>
</div>
<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>滤波</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派杂记</title>
    <url>/zh-CN/2019/01/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>因为我是一个记性很差并且接触东西很杂的人, 很多很基础的命令根本记不住,但每次都去查一遍很浪费时间, 于是整理一下. 这是树莓派相关的.</p>
<a id="more"></a>
<p>首先不得不说<a href="https://www.raspberrypi.org/documentation" target="_blank" rel="noopener">树莓派官方文档</a>实在是文档范本! 即便是初学者也能得到<strong>友好全面</strong>的帮助! 文档里包含了使用树莓派的绝大多数完整, 深入的教程, 而且方法都十分清爽 😆</p>
<figure>
<embed src="树莓派杂记/15826242887468.jpg?50"><figcaption>img</figcaption>
</figure>
<blockquote>
<p>放一张树莓派4B布局图</p>
</blockquote>
<h2 id="关于树莓派4">关于树莓派4</h2>
<p>我买了一个4GB的DDR4内存的树莓派4B, 性能确实比树莓派3B+强大很多! 运行图像识别的python程序完全不成问题, 通过VNC的虚拟桌面, 用网页看b站高清视频只有40%的内存在被使用, 温度也并不高. 属实牛皮.</p>
<p>而我觉得最神奇的是树莓派4B的UART. 在树莓派3上使用UART一直是个麻烦事, 因为一共只内置两个UART, 其中一共是阉割版, 仅有的一个PL011 UART (硬件UART) 还默认被蓝牙模块占用了. 而树莓派4就很🐮🍺了. 他内置<strong>六个</strong>UART, 5个PL011 UART, 1个阉割UART. 开始看树莓派4引脚分配表时还以为我理解错了, 直到我看到这句话</p>
<blockquote>
<p>11.1. Overview</p>
<p>The BCM2711 device has six UARTs. One mini UART (UART1) and five PL011 UARTs (UART0, UART2,UART3, UART4 &amp; UART5). This section describes the PL011 UARTs</p>
</blockquote>
<p>🔗 开启UART2~5后从哪些GPIO端口连接参见<a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/rpi_DATA_2711_1p0.pdf" target="_blank" rel="noopener">树莓派4片上系统datasheet</a>的<strong>11.3. Primary UART Inputs and Outputs</strong>.</p>
<h2 id="gpio">GPIO</h2>
<p>🔗 <a href="https://www.raspberrypi.org/documentation/computers/os.html#gpio-and-the-40-pin-header" target="_blank" rel="noopener">树莓派官方GPIO部分文档</a></p>
<blockquote>
<p>放两张好看的树莓派引脚对照表 (实际上两张都不完善)</p>
</blockquote>
<figure>
<embed src="树莓派杂记/175605x4nx4ryrywnn7hyw.jpg?50"><figcaption>img</figcaption>
</figure>
<figure>
<embed src="树莓派杂记/GPIO-Pi4-1587126749653.png?50"><figcaption>Raspberry Pi 4 Model B GPIO Pinout Diagram | element14 | Raspberry Pi</figcaption>
</figure>
<p>🔗 这个<a href="http://pinout.xyz/" target="_blank" rel="noopener">交互式引脚排布图</a>对每种接口的介绍很详细.</p>
<p><del>运行<code>gpio readall</code>可以打印一张包含引脚真实输入/输出值的引脚表. 对于树莓派4需要手动操作一下更新<strong>wiringPi</strong>至版本<code>2.52</code>, 否则无法识别. 操作参考<a href="http://wiringpi.com/wiringpi-updated-to-2-52-for-the-raspberry-pi-4b/" target="_blank" rel="noopener">wiringPi updated to 2.52 for the Raspberry Pi 4B</a></del></p>
<figure>
<embed src="树莓派杂记/image-20200417205537326.png?80"><figcaption>image-20200417205537326</figcaption>
</figure>
<p>但<code>gpio readall</code>无法打印出每个引脚所有可用功能, 而运行<code>raspi-gpio funcs</code>可用打印所有gpio的上拉/下拉, 所有可用功能.</p>
<p>树莓派官方文档列出了几个很好用的gpio库, 其中这个<a href="https://gpiozero.readthedocs.io/" target="_blank" rel="noopener">GPIO Zero</a>将GPIO分类封装成了一些很简洁的类, 看起来很值得一试.</p>
<blockquote>
<p>wiringPi的开发者被嘴臭网友喷自闭了, 停止维护项目了, 现在GPIO Zero是最好的代替, 安装后执行<code>pinout</code>也可以输出一个很直观的引脚功能表.</p>
</blockquote>
<h3 id="串口">串口</h3>
<p><del>如前面提到的, 树莓派4内置6个UART. 关于如何同时使用多个UART可用看看<a href="https://www.raspberrypi.org/forums/viewtopic.php?f=107&amp;t=244827&amp;sid=478967f5e58d920a422de08085f343d8" target="_blank" rel="noopener">这个讨论</a>. 截止目前树莓派还没有就此更新官方文档.</del></p>
<blockquote>
<p>泪目, 官方更新文档详细介绍各代树莓派主副串口如何分配, mini-UART是什么, 以及如何配置了: <a href="https://www.raspberrypi.org/documentation/computers/configuration.html#configuring-uarts" target="_blank" rel="noopener">文档</a></p>
</blockquote>
<p>官方文档给出了这样几个概念:</p>
<ul>
<li>主串口: 从<code>GPIO14</code>, <code>GPIO15</code> (引脚8, 引脚10) 连接到的串口. 主串口默认绑定了Linux串口控制台, 可以<a href="https://www.raspberrypi.org/documentation/computers/configuration.html#disabling-the-linux-serial-console" target="_blank" rel="noopener">在<code>raspi-config</code>中关闭</a>, 变成正常串口.</li>
<li>副串口 (蓝牙串口): 副串口无法直接从40pin端口连接到, 在大部分树莓派中都是连接到了蓝牙模块, 基本上是只能给蓝牙用的串口.</li>
<li>PL011串口: 遵循ARM提出的PL011电气规格的串口, 包括UART0, UART2, UART3, UART4, UART5 (后四个只有树莓派4有)</li>
<li>mini串口: 丐版串口, 包括UART1, 我感觉是专门拿来连蓝牙的.</li>
</ul>
<p>比如说在树莓派3中UART0默认分配为了蓝牙串口, mini串口被分配为了该从<code>GPIO14</code>, <code>GPIO15</code>连接的主串口, 但<strong>mini串口不管作为主串口还是副串口都默认没有开启</strong>, 因此手动开启mini串口后才可以从<code>GPIO14</code>, <code>GPIO15</code>连接到mini串口的UART1.</p>
<p>💡看过上面的BCM2711的datasheet会发现无法从树莓派的40pin端口上连接到mini串口的UART1, <code>GPIO32</code>, <code>GPIO33</code>或者<code>GPIO40</code>, <code>GPIO41</code>都没有被实现到这个40pin端口上. 因此我估计要想连到UART1只能将mini串口作为主串口, 从<code>GPIO14</code>, <code>GPIO15</code>连.</p>
<p>PL011串口与mini串口的区别根据树莓派官方文档总结下来就是:</p>
<ul>
<li>mini串口的FIFO更小而没有流控制功能, 因此在高波特率下更容易丢帧</li>
<li>mini串口的时钟参考源是系统时钟, 因此很可能一直在变化, 因此波特率是不稳定的 (因此使用时要求固定系统时钟频率)</li>
<li>mini串口没有断线检测</li>
<li>mini串口没有没有帧错误检测</li>
<li>mini串口没有奇偶校验位</li>
<li>mini串口没有接收超时中断</li>
<li>mini串口没有DCD，DSR，DTR或RI信号</li>
</ul>
<p>emmm看起来就是个废物呢. 我感觉就拿来作为蓝牙串口就好.</p>
<p>关于如何在树莓派3B+等设备上启动UART0与外部通信, <a href="https://www.raspberrypi.org/documentation/computers/configuration.html#uarts-and-device-tree" target="_blank" rel="noopener">官方教程</a>是通过添加设备树overlay的方式来实现的. <code>disable-bt</code>overlay会禁用蓝牙并使UART0成为主串口, <code>miniuart-bt</code>会切换蓝牙到使用mini串口并使UART0成为主串口, 但这样会限制蓝牙的最大波特率 (我觉得影响不大).</p>
<h2 id="故障提示">故障提示</h2>
<h3 id="固件警告图标">固件警告图标</h3>
<p>有时候屏幕右上角会有表示异常状态图标出现 (如果你有显示屏的话), 图标及对应含义如下:</p>
<ul>
<li>⚡ 闪电 : 电源电压不足</li>
<li>🌡 温度计: 温度过高</li>
</ul>
<p>🔗 <a href="https://www.raspberrypi.org/documentation/computers/configuration.html#firmware-warning-icons" target="_blank" rel="noopener">对应官方文档</a></p>
<p>(以前还有种表示电源电流不足的彩虹图标, 看文档现在似乎没有这个了)</p>
<h3 id="led警告闪烁代码">LED警告闪烁代码</h3>
<p>如果树莓派因为一些神秘原因无法启动或者需要断电, 电源插口旁边的LED会以特定次数闪烁, 闪烁代码及对应状态查看<a href="https://www.raspberrypi.org/documentation/computers/configuration.html#led-warning-flash-codes" target="_blank" rel="noopener">对应官方文档</a></p>
<h2 id="vnc使用">VNC使用</h2>
<p><a href="https://www.raspberrypi.org/documentation/computers/remote-access.html#vnc" target="_blank" rel="noopener">VNC使用的官方文档</a>已经把大多数东西都说清了. 值得一提的是如果树莓派没有连接显示器, (这特么不是废话吗, 如果有屏幕谁还需要VNC😅) 直接用RealVNC访问树莓派ip很可能看到的不是树莓派界面, 而是看到<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=216737" target="_blank" rel="noopener">Cannot currently show the dekstop</a>这样的字样. 树莓派官方对这种情况给出的办法是使用虚拟桌面, 每次需要手动启动. 而上面这个链接里提到其实只需在<code>raspi-config</code>中手动指定一个分辨率就能正常使用了, 亲测有效.</p>
<p>💡 我觉得VNC也就是偷懒用的, 虽然ssh无法看到画面但大多数需要看到画面的需求都可以用别的方式满足. 比如使用<a href="https://www.raspberrypi.org/documentation/remote-access/ssh/sshfs.md" target="_blank" rel="noopener">sshfs</a>来将树莓派文件当做本地文件编辑, 比如通过创建RTSP (实时视频流)或者使用<a href="https://elinux.org/RPi-Cam-Web-Interface#Remote_access_to_website_with_User.2FPass_and_changing_port" target="_blank" rel="noopener">RPi-Cam-Web-Interface</a>这样成熟的工具实现远程查看摄像头输出/自定义视频流.</p>
<p>当然如果你想玩树莓派自带的那些推荐软件那当我没说 😁</p>
<h3 id="开启vnc的server与viewer的剪贴板共享">开启VNC的server与viewer的剪贴板共享</h3>
<p>在linux中执行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vncconfig -nowin&amp;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="屏幕调节">屏幕调节</h2>
<h3 id="禁止息屏">禁止息屏</h3>
<p>最近买了一块7寸触摸显示屏😁 (不我没有在炫耀), 发现系统默认开启了息屏功能, 但我的应用场景要求屏幕常亮. 问题不大, 这个可以禁用. 在网上看到了两种方法:</p>
<h4 id="通过raspbian默认桌面显示管理器lightdm">通过Raspbian默认桌面显示管理器lightdm</h4>
<p>进入 <code>/etc/lightdm/lightdm.cfg</code>, 找到 <strong>[Seat:*]</strong> 字段, 取消<code>xserver-command</code> 的注释, 设置为:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">xserver-command=X -s 0 -dpms</span><br></pre></td></tr></tbody></table></figure>
<p>⚠️ 需要重启树莓派</p>
<p>其中:</p>
<ul>
<li><code>-s</code> 设置屏幕保护不启用</li>
<li><code>-dpms</code> 关闭电源节能管理, 我猜这是 <strong>D</strong>isplay <strong>P</strong>ower <strong>M</strong>anagemant <strong>S</strong>ystem的缩写</li>
</ul>
<h4 id="使用screen.sh">使用<code>Screen.sh</code></h4>
<p>在 <code>/etc/profile.d/</code>下新建<code>Screen.sh</code>, 写入:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">xsetdpms 0 0 0</span><br><span class="line">xsets off</span><br></pre></td></tr></tbody></table></figure>
<p>⚠️ 需要重启树莓派</p>
<p>列出一些相关指令及其含义</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>xset s off</td>
<td>禁用屏幕保护</td>
</tr>
<tr class="even">
<td>xset s 3600 3600</td>
<td>设置空闲时间为1小时</td>
</tr>
<tr class="odd">
<td>xset -dpms</td>
<td>关闭 DPMS</td>
</tr>
<tr class="even">
<td>xset s off -dpms</td>
<td>禁用 DPMS 并阻止屏幕进入空闲</td>
</tr>
<tr class="odd">
<td>xset dpms force off</td>
<td>立即关闭屏幕</td>
</tr>
<tr class="even">
<td>xset dpms force standby</td>
<td>强制屏幕进入待命状态</td>
</tr>
<tr class="odd">
<td>xset dpms force suspend</td>
<td>强制屏幕进入暂停状态</td>
</tr>
</tbody>
</table>
<h3 id="屏幕亮度调节">屏幕亮度调节</h3>
<p>调节范围为0-255</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo [value] &gt; /sys/class/backlight/rpi-backlight/brightness</span><br></pre></td></tr></tbody></table></figure>
<h3 id="关闭背光">关闭背光</h3>
<p>看网上说法关闭背光和关闭显示屏的区别在于只关闭背光的话屏幕其实仍在工作, 如果自己拿光照还是能看到画面的. 也就是说关闭背光应该和将屏幕亮度调至0效果一样.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo 0 &gt; /sys/class/backlight/rpi_backlight/bl_power</span><br></pre></td></tr></tbody></table></figure>
<p>0为开启背光，1为关闭背光. (我总觉得这和通常对01的理解不同)</p>
<h2 id="查看cpu温度">查看CPU温度</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /sys/class/thermal/thermal_zone0/temp</span><br></pre></td></tr></tbody></table></figure>
<p>这个返回值除1000就是一个<strong>摄氏度</strong>单位的CPU温度值了</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>硬件</category>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>麦语言速成</title>
    <url>/zh-CN/2019/01/17/%E9%BA%A6%E8%AF%AD%E8%A8%80%E9%80%9F%E6%88%90/</url>
    <content><![CDATA[<blockquote>
<p>因为父亲经常炒期货，我速成一下<a href="https://www.wenhua.com.cn/myy/" target="_blank" rel="noopener">麦语言</a>来减轻一下他的工作量吧。</p>
</blockquote>
<a id="more"></a>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 我体验下来觉得期货风险真的特别大, 能看盘时还是盯着点比较好.</p>
<p>随着我逐渐了解才发现量化交易并没有我想象中那么简单...单说 <a href="https://www.zhihu.com/question/25404359" target="_blank" rel="noopener">这些业内人士使用的语言</a>就五花八门...<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span> <a href="https://zhuanlan.zhihu.com/p/33839493" target="_blank" rel="noopener">这位仁兄</a>则让我大概了解了局面. 站在一个接触编程有一段时间的人的角度，我是觉得用C#编写模型比用麦语言看着NB多了，但我明显没那水平和精力,更何况我觉得知乎这个提问里的回答都说的很有道理,<a href="https://www.zhihu.com/question/36803590" target="_blank" rel="noopener">能赚钱的工具就是好工具</a> 。还是老老实实研究一下传说中用<strong>易语言</strong>编写的麦语言<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span></p>
<blockquote>
<p>看资料过程中<a href="http://www.tradeblazer.net/" target="_blank" rel="noopener">交易开拓者</a>(简称<strong>TB</strong>)和 <a href="https://www.multicharts.cn/" target="_blank" rel="noopener">MultiCharts</a>(简称<strong>MC</strong>)也经常被提及。</p>
</blockquote>
<h2 id="主要参考资料">主要参考资料</h2>
<p>我觉得最蛋疼的是这玩意好像没法debug啊!!<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f627.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f627.png?v8">😧</span></p>
<ul>
<li><a href="麦语言速成/教程.zip">网上找到的一套PPT教程</a>，并附上对应视频教程的<a href="https://pan.baidu.com/s/1foE6ORfqdGHyTQ-ZW9NPVg" target="_blank" rel="noopener">百度云链接</a></li>
<li><a href="http://www.wenhua.com.cn/guide/wh8/index.htm" target="_blank" rel="noopener">智赢wh8使用说明书</a></li>
<li><a href="http://www.wenhua.com.cn/guide/views41a3.htm" target="_blank" rel="noopener">wh8趋势跟踪模型语法参考</a></li>
<li><a href="http://www.wenhua.com.cn/guide/wh8_zjyfhs2.htm" target="_blank" rel="noopener">wh8算法交易模型语法参考</a></li>
</ul>
<p>这套PPT有文华财经的水印，大概是官方教程吧。而且我觉得讲得很浅显也比较详细了,好评<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<h2 id="麦语言语法简记">麦语言语法简记</h2>
<h3 id="算法交易模型与趋势跟踪模型">算法交易模型与趋势跟踪模型</h3>
<p>打开wh8后我发现可以用来交易的分两种模型 (即代码), 分 <a href="http://www.wenhua.com.cn/new_guide/Wh8/view4_6.html" target="_blank" rel="noopener">算法交易模型和趋势跟踪模型</a>, 普通的趋势交易策略使用趋势模型编写，加载到程序化平台运行实现自动交易；与趋势无关的盘口高频交易模型，需要用算法模型编写. 一开始我并没有理解这两种模型的区别, (实际这两个模型的名字非常直白的指出了两者的应用领域) 看到算法交易模型使用的是类C语法就果断开始写这个, 后来我才发现其中区别:</p>
<ul>
<li>趋势跟踪模型中可以调用很多常用分析指标, 比如布林通道, 比如指数加权移动平均, 更注重对目标的<strong>趋势</strong>的分析</li>
<li>算法跟踪模型更多的是能调用未经处理的精确数据, 甚至不提供EMA等很常用的分析指标 (如果需要只能自己写), 这类模型更注重于对<strong>实时行情</strong> (即<strong>盘口</strong>) 的处理.</li>
<li>算法交易模型的回测只提供一日的tick数据, 不支持更久的回测.</li>
</ul>
<p>看了wh8说明书中<a href="http://www.wenhua.com.cn/new_guide/Wh8/view4_5.html" target="_blank" rel="noopener">相关章节</a> 个人觉得算法交易模型更多应当与趋势跟踪模型配合使用, 说明书有句话说得好</p>
<blockquote>
<p>利用趋势模型可以有效捕捉趋势行情的交易方向，当交易方向确定，下一步便是寻找入场点。一个精准的入场点位是交易成功的起点，使用盘口的高频报价辅助判断无疑是最合适的方案</p>
</blockquote>
<p>也即是说由<strong>趋势模型</strong>判断是做多还是做空, 由<strong>算法模型</strong>判断买, 卖精确时间是比较科学的运用方式.</p>
<p>由于我需要写的模型并不要求高频交易, 主要的是做小时线, 因此只建立趋势模型. (趋势模型语法太低级也只好忍了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>)</p>
<h3 id="一开一平信号过滤模型加减仓模型等">一开一平信号过滤模型·加减仓模型等</h3>
<p>以上是一种分类方式, 另外按交易行为分类可以分为一开一平信号过滤模型, 加减仓模型等模型. <strong>一开一平模型</strong>限定了必须一平跟随一开或者一开跟随一平, 如果是简单模型还是很方便, 但无法特定开仓手数, 只能在开始运行模型时指定整个模型开仓手数, 也无法加仓. 而<strong>加减仓模型</strong>打破了前述弊端, 但需要自己设置开闭仓信号滤波器, 费点脑子. <a href="http://www.wenhua.com.cn/popwin/cxhmingci.htm" target="_blank" rel="noopener">模型列表</a></p>
<h3 id="算法交易模型与c的比较">算法交易模型与C的比较</h3>
<p>因为也体验了一会算法模型的语法, 稍作整理. 使用下来感觉与C语言语法区别主要如下:</p>
<ul>
<li>不需要引用头文件</li>
<li>变量可以用<strong>GLOBAL_VAR</strong>或<strong>VAR</strong>关键字来声明, 变量是动态数据类型, 似乎也可以使用 <strong>WriteGlobal</strong>, <strong>WriteGlobalF</strong> 等来定义整型, 浮点等变量. (文华给出的所有示例中定义变量竟然全部定义的全局变量也是很迷了)</li>
<li>函数类型可以是<strong>VOID</strong>或<strong>VAR</strong>, 当然如果需要返回值需要定义为<strong>VAR</strong>型</li>
<li>函数, 变量可以先引用后声明</li>
<li>麦语言的函数是可以有返回值的! 但是要把要返回的值括起来. (参考<a href="http://www.wenhua.com.cn/guide/wh8_zjyfhs2.htm" target="_blank" rel="noopener">这里</a>)</li>
</ul>
<h3 id="趋势跟踪模型语法简记">趋势跟踪模型语法简记</h3>
<table>
<caption>heavy_check_mark: 常用语句:</caption>
<thead>
<tr class="header">
<th>语句</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td><strong>等于</strong>操作符 :warning:趋势模型中赋值操作符为<code>:=</code>. 应注意等于操作符<strong>只有一个</strong>=</td>
</tr>
<tr class="even">
<td>:</td>
<td>定义变量并且加载模型时显示图线. 冒号前为变量名.</td>
</tr>
<tr class="odd">
<td>:=</td>
<td>定义变量并且不显示图线</td>
</tr>
<tr class="even">
<td>#IMPORT [PERIOD,N,FORMULA] AS VAR</td>
<td><a href="#跨周期编写">见下</a></td>
</tr>
<tr class="odd">
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr class="even">
<td>||</td>
<td>逻辑或</td>
</tr>
<tr class="odd">
<td>IF, THEN</td>
<td>参见<a href="http://www.wenhua.com.cn/guide/views41a3.htm" target="_blank" rel="noopener">这里</a></td>
</tr>
</tbody>
</table>
<h3 id="模组">模组</h3>
<p>算法交易模型中可以调用的一大串函数有类似<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f447.png?v8">👇</span>这样的函数说明.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">注：</span><br><span class="line">该函数前必须用AA.的形式来调用，其中AA为字符串变量或者模组名。该函数不能单独使用。</span><br></pre></td></tr></tbody></table></figure>
<p>开始我以为模组也是模型的意思, 后来看到示例里的用法似乎模组类似于<strong>类</strong>, 每个模组对应一个实例, 可以调用里面的各种函数来处理这个合约的数据, 而且每个模型也可以是一个模组一个模型可以调用另一个模型的函数, 就很像类. <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8">🤔</span>我是这样理解的</p>
<h3 id="逻辑判断">逻辑判断</h3>
<p>看过wh8给出的示例后我发现官方风格写法里趋势模型基本没有用过IF, ELSE什么的, 普遍是一句话浓缩一串条件搞定. 主要这玩意语法就让人懒得写IF, ELSE...而算法模型中运用IF, ELSE较多.</p>
<p>很有意思的是趋势模型中可以将一串判断条件赋值给一个变量作为布林变量. 然后通常是以下面这样的形式来调用</p>
<p><code>[布林变量], [交易指令]</code></p>
<p>另外趋势模型中逻辑运算操作符只有逻辑与和逻辑或, 如果需要其他运算, 我是使用的<code>NOT()</code>函数</p>
<h3 id="跨周期编写">跨周期编写</h3>
<p>跨周期模型函数: #IMPORT [PERIOD,N,FORMULA]</p>
<p>举例: <code>#IMPORT[DAY,2,WHBXSF] AS VAR1</code><br>
调取自定义2日线周期上WHBXSF指标中的数据. 需要先编写被引用的指标 (只有一串变量的模型似乎称为<strong>指标</strong>)</p>
<p>具体可以参考<a href="http://www.2818668.com/369.html" target="_blank" rel="noopener">这个</a></p>
<h2 id="疑问">疑问</h2>
<ul>
<li>到现在我也不确定这些模型是循环运行还是怎么在执行, 如果是循环运行一次运行时间是多长</li>
</ul>
<h2 id="附录">附录</h2>
<p>搜索过程中看到的<a href="https://zhuanlan.zhihu.com/p/52867020" target="_blank" rel="noopener">十六套经典策略</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>量化交易</category>
        <category>语言</category>
        <category>麦语言</category>
      </categories>
  </entry>
  <entry>
    <title>Bug List</title>
    <url>/zh-CN/2019/02/05/Bug-List/</url>
    <content><![CDATA[<p>我想记录一下我遇到过的各种bug, 不论大小. 原本我从一开始学编程的时候就在这么做了, 但我也忘了我什么时候竟然怠慢了这件事! 我会想到记录这些是上大学前的暑假看到 <a href="https://zhuanlan.zhihu.com/p/22266788" target="_blank" rel="noopener">这篇让人深受启发的教诲</a>而想要养成的习惯之一. 我认为这绝对不是浪费时间. 正如初高中学习时的错题本 (虽然我那时的错题本一共也没能记几笔) 只要我偶尔能想起来记几笔, 我想总是能为以后节省一些时间的.</p>
<a id="more"></a>
<h1 id="有时候等号两侧不能加空格">有时候等号两侧不能加空格</h1>
<ul>
<li>在bash中赋值时等号两侧不能有空格</li>
<li>在swift中等号两侧要不都加等号, 要不都不加, 不可只有单侧有等号</li>
</ul>
<h1 id="此python非彼python">此python非彼python</h1>
<p>有时会遇到明明刚安装了一个包但调用的时候报错未找到该包, 再次安装显示已安装最新版的神奇情况</p>
<p>有以下几种可能 (总体来说是安装包的python环境和调用包的python环境不一样):</p>
<ol type="1">
<li><p>如果你是用命令行安装的 (或者你安装了Anaconda,用conda安装的), 在IDE中调用的, 那你应当检查一下你的IDE调用的pytohn interpreter和cmd调用的是不是一个了. 比如Anaconda自带的Spyder默认的是python2.7, 但我设置的cmd调用的是一个3.6.4的python</p>
<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> Anaconda中切换Spyder环境可以参考 <a href="https://www.zhihu.com/question/49144687" target="_blank" rel="noopener">这里</a></li>
<li><p>如果环境中同时有python2和python3, 有可能将包安装到了python2的环境中但你的程序是 python3的程序, 可以将<code>pip install</code> 换为 <code>pip3 install</code> 试试</p></li>
</ol>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 如果安装了conda那么安装python库最好使用conda, 尽量不要混用conda和pip, <strong>conda和pip的包格式不同, 两者是不兼容的, 甚至有的库在conda和pip中名字不同</strong>. 有关在conda中没有某库但pip中有的情况可以参考<a href="https://www.zhihu.com/question/49144687" target="_blank" rel="noopener">这里</a>, 而关于混用conda与pip的危害可以参考<a href="http://onoz000.hatenablog.com/entry/2018/02/11/142347" target="_blank" rel="noopener">这位日本兄弟的文章</a></p>
<h1 id="谨防数据溢出">谨防数据溢出</h1>
<p>这个例子是我在尝试细化图像的时候遇到的</p>
<h2 id="代码">代码</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Xihua</span><span class="params">(image, array, num=<span class="number">1</span>)</span>:</span></span><br><span class="line">    iXihua = np.zeros(image.shape, np.uint8)</span><br><span class="line">    iXihua = image.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        VThin(iXihua, array)</span><br><span class="line">    <span class="keyword">return</span> iXihua</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VThin</span><span class="params">(image, array)</span>:</span></span><br><span class="line">    h = height</span><br><span class="line">    w = width</span><br><span class="line">    NEXT = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">            <span class="keyword">if</span> NEXT == <span class="number">0</span>:</span><br><span class="line">                NEXT = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                M = (image[i, j<span class="number">-1</span>] + image[i, j] + image[i, j+<span class="number">1</span>]) <span class="keyword">if</span> <span class="number">0</span>&lt;j&lt;w<span class="number">-1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> image[i, j] == <span class="number">0</span> <span class="keyword">and</span> M != <span class="number">0</span>:</span><br><span class="line">                    a = [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">-1</span>&lt;(i<span class="number">-1</span>+k)&lt;h <span class="keyword">and</span> <span class="number">-1</span> &lt;(j<span class="number">-1</span>+l)&lt;w <span class="keyword">and</span> image[i<span class="number">-1</span>+k, j<span class="number">-1</span>+l]==<span class="number">255</span>:</span><br><span class="line">                                a[k*<span class="number">3</span>+l] = <span class="number">1</span></span><br><span class="line">                    sum = a[<span class="number">0</span>]*<span class="number">1</span>+a[<span class="number">1</span>]*<span class="number">2</span>+a[<span class="number">2</span>]*<span class="number">4</span>+a[<span class="number">3</span>]*<span class="number">8</span>+a[<span class="number">5</span>]*<span class="number">16</span>+a[<span class="number">6</span>]*<span class="number">32</span>+a[<span class="number">7</span>]*<span class="number">64</span>+a[<span class="number">8</span>]*<span class="number">128</span></span><br><span class="line">                    image[i, j] = array[sum] * <span class="number">255</span></span><br><span class="line">                    <span class="keyword">if</span> array[sum] == <span class="number">1</span>:</span><br><span class="line">                        NEXT = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></tbody></table></figure>
<h2 id="报错信息">报错信息</h2>
<figure>
<img alt="报错信息" data-src="Bug-List/图像细化代码的报错.png"><figcaption>报错信息</figcaption>
</figure>
<h2 id="原因">原因</h2>
<p>M默认与image[i, j]同数据类型，而image[i, j]设定的是ubyte类型，范围-255~256，M极有可能数据溢出。</p>
<h2 id="解决方法">解决方法</h2>
<p>将18行改为下面代码, 将M数据类型强制转为int</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">M = (int(image[i, j<span class="number">-1</span>]) + int(image[i, j]) + int(image[i, j+<span class="number">1</span>])) <span class="keyword">if</span> <span class="number">0</span>&lt;j&lt;w<span class="number">-1</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="迭代中的计数器记得归零">迭代中的计数器记得归零</h1>
<p>在迭代中的迭代中的计数器 (简称迭中迭) 要记得在一次迭代后归零, 或者应当将一次迭代的代码分割出来封装成一个函数, 在函数中给计数器设定初值. 这样每次调用都会是从零开始而不是累积的.</p>
<h1 id="python中赋值的坑">python中赋值的坑</h1>
<p>一次我得到一个list, 想要将其从小到大重新排序, 但不影响原来的list. 因此我试图将这个<code>list</code> 复制到<code>listSort</code>中, 对listSort排序:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">listSort = list</span><br><span class="line">listSort.sort()</span><br></pre></td></tr></tbody></table></figure>
<p>但我发现这样完全没有达到我的目的! list会随着listSort的改变而改变, 与我想保持list不变的目的完全相悖. 随后我才知道在python中<strong>赋值是将变量名指向对象</strong>, 与C语言中变量不止是个名字, 也是字节集合并真实存在于内存某个位置上的情况是不同的.</p>
<h2 id="错误原因">错误原因</h2>
<h3 id="可变对象与不可变对象">可变对象与不可变对象</h3>
<p>python中的不可变对象有:</p>
<ul>
<li>int</li>
<li>float</li>
<li>bool</li>
<li>string</li>
<li>tuple</li>
</ul>
<p>python中的可变对象有:</p>
<ul>
<li>list</li>
<li>dict</li>
<li>set</li>
</ul>
<p>:exclamation: 要注意python中对一个可变对象重新赋值对象重新赋值对象地址不会变化, 而对一个不可变对象重新赋值其地址会发生改变 (可以用<code>id(var)</code>语句来查看变量的地址).</p>
<p>另外python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响外层该变量, 而不可变对象不会. 在向类传递参数时也是如此.</p>
<p>可变对象有时是一种很方便的特性, 但很多时候是<strong>很危险的</strong>.</p>
<h4 id="函数默认参数一定要设定为不可变对象">函数默认参数一定要设定为<strong>不可变对象</strong></h4>
<p>否则可能会引发一些错误, 我们来看下面一个例子:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(l=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>    l.append(<span class="string">'add'</span>)</span><br><span class="line"><span class="meta">... </span>    print(l)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'add'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'add'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码是正常运行的, 我们来看下面这些:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc()</span><br><span class="line">[<span class="string">'add'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc()</span><br><span class="line">[<span class="string">'add'</span>, <span class="string">'add'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myfunc()</span><br><span class="line">[<span class="string">'add'</span>, <span class="string">'add'</span>, <span class="string">'add'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>按理说应该每次都是<code>['add']</code>, 但是现在出现了意想不到的错误.</p>
<p>这是因为<code>l = []</code>是在<strong>函数定义时就确定下来了的</strong>, 所以之后每次调用这个函数, 使用的<strong>l</strong>都是同一个, 如果不指定这个参数的新值, 就会出现上面这个问题.</p>
<p>上面这个<strong>l</strong>可以默认设置为<strong>None</strong>, 这就是一个不可变对象.</p>
<h4 id="类的属性通常是可变对象">类的属性通常是可变对象</h4>
<p>有意思的是类的属性通常都是可以访问和修改的, 也就是说属性都是可变对象. 主要有两种方法使我们可以创建不可变的属性:</p>
<ul>
<li>设置<code>__setattr__</code>直接抛出异常, 即只要想设置属性值, 就会抛出异常</li>
<li>设置<code>__slot__</code>限制属性的访问, 如果属性都不能访问了, 那就肯定不能修改</li>
</ul>
<h2 id="复制列表的正确操作">复制列表的正确操作</h2>
<p>:link: 这个<a href="https://www.cnblogs.com/ifantastic/p/3811145.html" target="_blank" rel="noopener">链接</a>说明了我的错误原因并列出了五种复制列表的方法的比较, 但实际上还有一种 <a href="https://www.programiz.com/python-programming/methods/list/copy" target="_blank" rel="noopener">我很喜欢的方法</a> 他没有列出. 从中可以看出<code>copy.deepcopy()</code>是最保险的方法.</p>
<h2 id="赋值-浅拷贝与深拷贝">赋值, 浅拷贝与深拷贝</h2>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> 请参考<a href="https://www.jianshu.com/p/1059318d38e0" target="_blank" rel="noopener">这里</a></p>
<h1 id="python写入中文字符串变乱码">python写入中文字符串变乱码</h1>
<p>🔗 <a href="https://ericfu.me/python-2-str-and-unicode/" target="_blank" rel="noopener">Python 2 字符串编码踩坑小结</a></p>
<p>虽然我并不怎么写python2的代码但👆这篇文章确实对python中编码问题很有启发.</p>
<p>🔗 <a href="https://www.nltk.org/book/ch03.html" target="_blank" rel="noopener">Processing Raw Text</a></p>
<p>而在网上搜图的时候我搜到了这段讲python中处理文本的各种方法的话.</p>
<p>其中提到了如下图这样的方式防止出现乱码.</p>
<figure>
<img alt="Unicode Decoding and Encoding" data-src="Bug-List/Unicode_Decoding_and_Encoding.png"><figcaption>Unicode Decoding and Encoding</figcaption>
</figure>
<p>正如 "Python 2 字符串编码踩坑小结" 中提到的, 在python3中<code>str</code>类型数据都以Unicode码点格式储存. 实际上我们<a href="https://zh.wikipedia.org/wiki/Unicode#%E8%BE%93%E5%85%A5%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">可以直接输入Unicode码点</a>.</p>
<h1 id="verilog中要写完整控制语句">Verilog中要写完整控制语句</h1>
<p>Verilog中如果不写完整if-else结构和case结构会产生latch, 会将毛刺传给下一级电路的那种latch.</p>
<p>参见我的另一篇博客 <a href="https://leojhonsong.github.io/zh-CN/Verilog%E6%9D%82%E8%AE%B0/#%E5%85%B3%E4%BA%8E%20default">Verilog 杂记-有关default</a></p>
<h1 id="verilog中因不同条件触发的变量应在不同always块中描述">Verilog中因不同条件触发的变量应在不同always块中描述</h1>
<p>参见我的另一篇博客 <a href="https://leojhonsong.github.io/zh-CN/Verilog%E6%9D%82%E8%AE%B0/#%E6%9C%89%E5%85%B3%20always">Verilog 杂记-有关always</a></p>
<h1 id="c字符串赋值坑">C++字符串赋值坑</h1>
<p>在写一段C++代码时我遇到了这样的问题: 用如下代码给一个string类型的变量<code>str</code>赋值为 "0300003e", 也就是一个16进制表示的ASCII编码值为 fe fe 03 00 00 3e fd 的字符串,但这样做始终只能让<code>str</code>的值变为"03"!</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"\xfe\xfe\x03\x00\x00\x3e\xfd"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>但同时我发现用<code>assign()</code>来指定长度赋值就不会出现这种问题:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">str.assign(<span class="string">"\xfe\xfe\x03\x00\x00\x3e\xfd"</span>, <span class="number">7</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>⚠️要注意的是传给<code>assign()</code>的字符串长度不能用<code>length()</code>, <code>size()</code>等函数来给出, 他们同样会把\0视为字符串末尾... 我的方法是手动给出, 反正我的程序里字符串是定长的.</p>
<p>我拿这个问题问我的C++大佬同学, 他说应该是因为\0让C++认为字符串到头了, 于是只有前三个字符.</p>
<p>我说: ? 我这字符串里哪有\0? 你别骗我读书少.</p>
<p>然后他发了一张图来:</p>
<figure>
<img alt="C++字符串结束符" data-src="Bug-List/C++字符串结束符.jpg"><figcaption>C++字符串结束符</figcaption>
</figure>
<p>...我是真的吃了读书少的亏, 竟然特么\0和00是一个意思🤦‍</p>
<p>然后在string类型变量里写入\0的方法似乎只有用<code>assign()</code>和指定字符串长度的构造函数 . 其实用<code>=</code>赋值在变量声明和定义同时出现时是只有字符串值这个参数的构造函数, 否则就是只有字符串值这个参数的<code>assign()</code>函数.</p>
<h1 id="socket的address-already-in-use问题">socket的Address already in use问题</h1>
<p>前几天写了一段socket服务器端的代码, 运行了一遍没毛病, 再运行第二遍竟然在创建业务 socket时报错了. 过了一会运行第三遍竟然又没问题了🤦‍ 我记得报错似乎是这个<strong>Error: Address already in use</strong>, 我的服务器端监听的端口处于 <strong>TIME_WAIT</strong> 状态. 后来我发现<a href="https://stackoverflow.com/questions/15198834/bind-failed-address-already-in-use/15199016#15199016" target="_blank" rel="noopener">这个描述</a> 符合我的情况 (虽然我是在创建业务socket时出错的). 没想到是因为socket关得太慢了我重新启动程序时上次程序的socket还在占用端口...虽然我觉得这有点神奇但设置 <strong>SO_REUSEADDR</strong> 确实解决了我的问题. 解决方法很简单,紧跟着创建了监听socket代码的那一行后面加两句:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">setsocketopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br></pre></td></tr></tbody></table></figure>
<p>或者更严谨一点:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(enable)) &lt; <span class="number">0</span>)</span><br><span class="line">    error(<span class="string">"setsockopt(SO_REUSEADDR) failed"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h1 id="make编译提示clock-skew-detected">make编译提示Clock skew detected</h1>
<p>有次在用make编译时给出如下warning:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make: warning: Clock skew detected. Your build may be incomplete.</span><br></pre></td></tr></tbody></table></figure>
<p>💡 Clock skew 可以翻译时钟错误</p>
<p>我当时都懵了, 这编译咋还和时间扯上关系了...查了一下说这个warning是说<strong>某个文件的时间戳大于系统的当前时间</strong>. 而之所以说编译可能不完全是因为<strong>make完全依赖各个文件的时间戳来确定哪个文件最近被修改了, 随后决定哪个文件需要重新生成</strong>, 因此文件时间戳出问题了的话, make对需要编译哪些文件的判断可能出错. 虽然此处只是文件时间大于系统时间, 看起来并没有顺序问题. 但是因为时间戳问题通常出现于<strong>NFS</strong> (网络文件系统) 中, 因为不同设备的时间不同步而导致, 而这<strong>很可能导致最新的代码无法被应</strong>用, 算是很严重的问题, 因此make还是会给出给出warning.</p>
<p>但是! 我一直是在本地运行的, 通常来说是不会出现这种问题的啊...</p>
<p>后来我发现是因为<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#Linux%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%92%8CWindows%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%B7%AE8%E5%B0%8F%E6%97%B6">我Linux系统时间比Windows系统时间多八个小时</a>, 而虽然我的Linux系统能够自动进行网络校时, 但我这次关闭Windows系统 (Windows系统校准过时间) 再打开Linux系统使用过程中并没有联网... <strong>这使得Linux系统时间比实际时间少了8个小时</strong>. 那么如果距我上次对Makefile的修改没到八个小时就会遇到这个warning 😁</p>
<p>💡 这个问题解决起来很简单, 只需要<code>touch</code>每一个文件来更新时间戳即可. 找到当前目录下每个文件并touch的命令如下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">find . -type f -exec touch {} +</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Bug List</category>
      </categories>
  </entry>
  <entry>
    <title>Git杂记</title>
    <url>/zh-CN/2019/02/27/Git%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>先有git, 许久后才有了GitHub等代码托管平台. git是一个软件而GitHub是一个网站. 他们的关系是你可以通过git将你的代码托管给GitHub (就是把你的代码存到GitHub的服务器上). 不过随着发展, 这些代码托管平台现在提供极为丰富的服务, 我认为其中生态做得最好的还得是github. 从github自带的github pages, github action到应用市场的各种应用, 应有尽有.</p>
<a id="more"></a>
<h2 id="git">git</h2>
<p>git是一个<strong>分布式版本控制</strong>软件. 与它齐名的另一个版本控制软件是<strong>SVN</strong>.</p>
<p>🔗 <a href="https://blog.csdn.net/xiaoqiangyonghu/article/details/78400313" target="_blank" rel="noopener">为什么要版本控制及分布式版本控制原理</a></p>
<h3 id="图形化软件">图形化软件</h3>
<p>虽然有人仍喜欢用纯命令行, 并且有的命令确实只能在命令行输入 (很多命令图形界面无法提供), 但我平时更喜欢使用图形化软件来操作git. 此处推荐三款软件.</p>
<h4 id="github-desktop">GitHub Desktop</h4>
<p>🔗 <a href="https://desktop.github.com/" target="_blank" rel="noopener">下载地址</a></p>
<p>GitHub官方客户端. 这是一个对新手很友好的客户端, 我自己也在用. 它的缺点是<strong>只能管理托管在GitHub的git仓库</strong>. 它很有用的一点是<strong>能在一个面板上看到你每个仓库的更新情况</strong>. (我经常忘记哪个仓库有没有上传)</p>
<p>❗️ 要打开软件等它检测一会才会显示出来状态.</p>
<figure>
<img alt="image-20200227141011525" data-src="Git杂记/image-20200227141011525.png"><figcaption>image-20200227141011525</figcaption>
</figure>
<blockquote>
<p>仓库名字后有蓝色点表示有本地更改未提交, 有向上箭头表示有本地提交未上传, 有向下箭头表示有远程端有比本地更新的提交需要拉取.</p>
</blockquote>
<p>🔗 <a href="https://help.github.com/cn/desktop/contributing-to-projects" target="_blank" rel="noopener">GitHub Desktop使用帮助</a></p>
<h4 id="tower">Tower</h4>
<p>🔗 <a href="https://www.git-tower.com/" target="_blank" rel="noopener">下载地址</a></p>
<p>这个软件看起来比GitHub Desktop功能强大些, 并且不像后者只能管理托管在GitHub的git仓库. 这个软件只能免费试用, 但申请了这个<a href="https://education.github.com/pack" target="_blank" rel="noopener">GitHub学生大礼包</a>的话可以免费用一年.</p>
<h4 id="开发工具集成的git管理">开发工具集成的git管理</h4>
<p>🌟 实际上这是我最常使用的方式</p>
<figure>
<img alt="img" data-src="Git杂记/image-202002271546.png"><figcaption>img</figcaption>
</figure>
<p>这是装了<strong>GitLens</strong>插件的<strong>Visual Studio Code</strong>的源代码控制面板和编辑窗口截图. 可以看到左下角显示了当前分支及同步状态, 编辑窗口里有颜色条标示文件更改情况, 右上角有可以对文件进行的一些git操作, etc...</p>
<h3 id="登陆git">登陆git</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config --global user.name "Your Name"</span><br><span class="line">git config --global user.email "email@example.com"</span><br></pre></td></tr></tbody></table></figure>
<p>⚠ 建议每台设备使用不同的<code>user.name</code>, 这样才能区分它们. 为了方便记忆可以统一使用<strong>昵称-设备型号</strong>的命名方式.</p>
<p>值得一提的是git的配置文件分三级: 系统级(所有用户的), 全局级(当前用户的), 仓库级. 在配置时分别使用<code>--system</code>, <code>--global</code>, <code>--local</code>参数来访问. 如果想直接进入配置文件而不是一个参数一个参数地设置可以使用:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config -e</span><br></pre></td></tr></tbody></table></figure>
<p>要注意默认情况下<code>git config -e</code>访问<strong>仓库级配置文件</strong>.</p>
<h3 id="http连接与ssh连接">http连接与ssh连接</h3>
<p>最常用的连接git远程仓库的方式是通过http, ssh这两种协议.</p>
<p><strong>我建议使用http连接</strong>, 一方面http连接无论从远程端下载还是上传到远程端都会比用ssh<strong>快许多</strong> (原因我不清楚, 但确实是这样), 另一方面对于普通用户来说http连接<strong>麻烦事少一些</strong>. 这里的麻烦事指的是如果想通过ssh连接远程端那么需要在本地生成ssh秘钥对并把生成的公钥添加到远程端.</p>
<p>💡 也许有人说通过http连接每次push都需要输入账号密码, 但其实可以设置git记住账号密码:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></tbody></table></figure>
<p>另外在github的<a href="https://help.github.com/en/github/using-git/which-remote-url-should-i-use" target="_blank" rel="noopener">在克隆仓库时使用什么协议</a>中也是推荐使用http协议😏</p>
<h4 id="有关ssh">有关SSH</h4>
<h5 id="获取ssh-key">获取SSH Key</h5>
<p>首先查看有没有<code>~/.ssh</code>这个文件夹以及文件夹下有没有类似<code>id_rsa</code>和<code>id_rsa.pub</code>的文件. 如果有, 那就不用生成了.</p>
<p>这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥可以放心地告诉任何人. 比如加入GitHub的SSH Key.</p>
<h6 id="生成key">生成key</h6>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果没有特别需求(比如甚至想设置密码), 直接连敲三次回车.</p>
<p>💡 其实在输入命令后第一个选项是指定生成的秘钥文件名, 可以指定为<code>id_rsa_github</code>, <code>id_rsa_gitee</code>这样, 加上远程端的名字, 这样有多个远程端时也不会混乱.</p>
<h5 id="同时上传到多个远程端">同时上传到多个远程端</h5>
<p>新建<code>~/.ssh/config</code>, 如果远程端是github和gitee, github和gitee的ssh key是像上面说的这样命名的, 那么内容如下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitee</span><br></pre></td></tr></tbody></table></figure>
<h3 id="常用命令">常用命令</h3>
<h4 id="克隆一个repository">克隆一个repository</h4>
<p>💡 <strong>克隆与下载的区别</strong>: 如果下载一个仓库的压缩包, 你获得的只是这个仓库<strong>当前版本</strong>的代码, 而如果克隆一个仓库则首先得到的是记录了该仓库所有版本的版本库, 然后git从中释放出了当前版本. 这个版本库就是仓库根目录的<code>.git</code>文件夹. 因此经常出现到开发后期.git文件夹大小比当前版本的代码大很多的情况.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></tbody></table></figure>
<p>🔗 <a href="https://help.github.com/cn/github/creating-cloning-and-archiving-repositories/cloning-a-repository" target="_blank" rel="noopener">GitHub中文帮助文档-如何从GitHub克隆仓库</a></p>
<h5 id="让克隆更快">让克隆更快</h5>
<h6 id="克隆特定分支">克隆特定分支</h6>
<p>一个社区活跃的项目通常会有许多分支, 其中会有很多是你不需要关注的, 别人正在开发feature或者修bug等的分支, 可以通过只克隆指定分支来减少不必要的下载时间.</p>
<p>❗️ 这样的坏处是在本地看不到其他分支.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone -b &lt;branch&gt; --single-branch &lt;url&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>❗️ 如果不带<code>--single-branch</code>这个参数那效果仅仅是在完成克隆后切换到你指定的这个分支, 克隆的仍是<strong>完整的, 有多个分支的仓库</strong> (如果你的仓库有多个分支的话)</p>
<p>当你想要从远程端再弄下来一个分支<code>B</code>, 但仍不想要其他分支: </p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git remote set-branches --add origin B</span><br><span class="line">git fetch</span><br><span class="line">git checkout B</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>当你强迫症犯了想要把所有分支都下下来时: </p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"</span><br><span class="line">git fetch</span><br></pre></td></tr></tbody></table></figure><p></p>
<h6 id="浅克隆">浅克隆</h6>
<p>随着时间推移版本库的迭代次数可能越来越多, 多到对你来说并不是所有版本都是有意义的了. 比如涉及到某个文件的提交次数可能有100次, 但可能只有后20次对你是有意义, 你可能会查看的, 那么此时可以通过指定克隆深度来减少不必要的下载时间.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone --depth &lt;depth&gt; &lt;url&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>克隆 https://github.com/LeoJhonSong/vimrc 这个仓库master分支最新一次提交到用户主目录下的<code>.vimrc</code>文件夹: </p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone -b master --single-branch --depth 1 https://github.com/LeoJhonSong/vimrc ~/.vimrc</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>当你发现你克隆的提交次数少了, 你需要看更往前的提交但仍不想把所有提交都克隆下来的时候, 你可以: 1. 再往前多下几个提交 <code>git fetch --deepen=&lt;depth&gt;</code> 2. 把直到一个指定日期的提交都下下来 <code>git fetch --shallow-since=15/11/2012</code></p>
<p>而当你又犯强迫症了😏想要将这个浅克隆转为一个完整深度的克隆时, 输入: </p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git fetch --unshallow</span><br></pre></td></tr></tbody></table></figure><p></p>
<h6 id="利用代理">利用代理</h6>
<p>很多人的代码托管在GitHub (这意味着服务器在美国), 因此可能下载/上传速度很慢. 如果你知道你的翻墙工具的代理端口那么你可以设置git使用这个端口, 速度会好很多. (如果你的翻墙工具是直接全局代理了所有流量那么不需要这一步)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比如我知道自己VPN的http代理端口为: 127.0.0.1:1234,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> socks代理端口为: 127.0.0.1:5678</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置git使用http代理端口</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1234</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置git使用socks代理端口</span></span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:5678</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消git使用代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></tbody></table></figure>
<h6 id="利用gitee">利用gitee</h6>
<p>如果你没有翻墙工具或者你的翻墙工具失效了😏, 那么还有一种曲折一点的方式可以快速克隆下来.</p>
<p>正如上面所说, 之所以从github克隆仓库速度很慢是因为它的服务器离我们太远了, 因此如果你习惯了直连github克隆仓库的破速度再体验从国内服务器克隆仓库的MB级速度你一定会感动得泪流满面👍</p>
<p>而我要说的就是利用一个国内的很棒的代码托管平台<strong>gitee</strong>提供的一个很贴心的功能: <strong>从github/gitlab导入仓库</strong>! (推荐大家也体验一下gitee, 它还提供了一些很贴心的github所没有的小功能)</p>
<p>利用gitee可以从github导入仓库, 我们可以轻松将一个仓库从遥不可及的服务器移到国内服务器来🎉 gitee导入仓库的时间可以忽略不计, 然后与从github克隆仓库一样的流程急速将仓库克隆到本地! 但一般网烂到这种程度我们还选择克隆仓库而不是下载压缩包是因为要加入开发, 因此从gitee克隆下来仓库后需要<strong>更改远程端的地址为github的仓库地址</strong>.</p>
<p>打开仓库根目录下<code>.git/config</code>文件, 你会看到类似下面这样的字段:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[remote "origin"]</span><br><span class="line">    url = https://gitee.com/someone/something.git</span><br></pre></td></tr></tbody></table></figure>
<p>你只需要把url中的<code>gitee</code>改为<code>github</code>就可以了😏神不神奇</p>
<h4 id="查看状态">查看状态</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure>
<h4 id="暂存所有更改">暂存所有更改</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></tbody></table></figure>
<h4 id="提交">提交</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></tbody></table></figure>
<h4 id="推送">推送</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></tbody></table></figure>
<p>⚠️ 个人仓库的话提交之后一定不要忘记上传! 我在格式化电脑前忘记将本地commit上传, 失去了好几篇博文啊😢 (但应该一般没有我这么蠢的)</p>
<p>💡 在VSC中可以通过设置<code>git.enableSmartCommit</code>, <code>git.postCommitCommand</code>两项来实现<strong>暂存所有更改, 提交, 推送的一键三连</strong>😏 不过我只在自己随意写的版本库中这样用, <strong>在正规开发流程中十分不推荐提交后立即推送</strong>, 因为传到了远程端再想更改提交的内容会很麻烦. 应当完成一个阶段后再进行推送. (另外可能还需要<code>git rebase</code>等)</p>
<h3 id="git仓库瘦身">git仓库瘦身</h3>
<p>我也终于遇到了git仓库被搞太大需要瘦身的情况了.</p>
<blockquote>
<p><a href="http://rtyley.github.io/bfg-repo-cleaner/" target="_blank" rel="noopener">BFG</a> 是为将像大文件或者密码这些不想要的数据从 Git 仓库中删除而专门设计的，所以它有一一个简单的标志用来删除那些大的历史文件（不在当前的提交里面）：<code>--strip-blobs-bigger-than</code></p>
</blockquote>
<p>⚠️ 要用bfg你需要有java</p>
<ol type="1">
<li>首先以<code>--mirror</code>选项从远程端下载仓库. 按照bfg的说法这样下到的是一个"bare repo".</li>
</ol>
<blockquote>
<p>This is a bare repo, which means your normal files won't be visible, but it is a full copy of the Git database of your repository</p>
</blockquote>
<p>(我试了一下普通clone的仓库操作完最后推送不上去...)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone --mirror git://example.com/some-big-repo.git</span><br></pre></td></tr></tbody></table></figure>
<ol start="2" type="1">
<li>然后进入仓库, 然后按照文件大小或者文件名清理文件.</li>
</ol>
<p>❗️ 在这一步文件并没有在物理上被删除, 在这一步bfg会清理所有commit, branch, tag, 去掉该文件的记录.</p>
<ul>
<li>清理大于指定值的文件</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>大小超过 100MB 的任何文件（不包含在你<em>最近的</em>提交中的文件——因为 BFG <a href="http://rtyley.github.io/bfg-repo-cleaner/#protected-commits" target="_blank" rel="noopener">默认会保护你的最新提交的内容</a>）将会从你的Git仓库的历史记录中删除.</p>
</blockquote>
<ul>
<li>清理指定文件名文件:</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar bfg.jar --delete-files *.mp4</span><br></pre></td></tr></tbody></table></figure>
<ol start="3" type="1">
<li>将上面清理出来的文件删除</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br></pre></td></tr></tbody></table></figure>
<ol start="4" type="1">
<li>当你觉得删得差不多就可以推送了. ❗️ 这样会改变远程端所有ref.</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></tbody></table></figure>
<h2 id="github">GitHub</h2>
<p>我认为github现在已经远不止是托管代码 (也就是单纯把代码放在他的服务器) 那么简单的, 它已经建立起了一个<strong>远程协作生态</strong>.</p>
<p>关于github入门我很推荐他们的官方文档, 大部分是有中文版的, 比如:</p>
<p>🔗 <a href="https://help.github.com/cn/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener">GitHub术语表</a></p>
<p>🔗 <a href="https://github.github.com/training-kit/downloads/zh_CN/github-git-cheat-sheet/" target="_blank" rel="noopener">GitHub官方出品git使用cheat sheet</a></p>
<p>🔗 <a href="https://help.github.com/cn/github/getting-started-with-github/signing-up-for-github" target="_blank" rel="noopener">如何注册GitHub账号</a> (在这个页面左侧你可以看到还有辣么多页面值得你去看👍)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>CI/CD</category>
        <category>杂记</category>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Linux杂记</title>
    <url>/zh-CN/2019/02/27/Linux%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>最近使用Linux频繁了起来, 接触到更多各种各样的命令, 然后我脑容量不够了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span> 由于有<a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">TLDR</a>这种神器, 在这里并不会无脑记录所有看到的命令, 而是小白最常用或者不太容易懂含义的几个命令.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span>如果弄不清命令的含义, 我在 <a href="https://leojhonsong.github.io/zh-CN/%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD%E7%BC%A9%E5%86%99/">另一篇博客</a> 记录了一些缩写及对应含义, 希望有所帮助.</p>
<p>💡 推荐一个觉得很不错的Linux命令入门教程<a href="https://happypeter.github.io/LGCB/" target="_blank" rel="noopener">LGCB</a></p>
<a id="more"></a>
<h1 id="查看版本">查看版本</h1>
<h2 id="查看内核版本">查看内核版本</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></tbody></table></figure>
<p>这条更加详细, 提issue时常用到</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></tbody></table></figure>
<h2 id="查看发行版版本">查看发行版版本</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></tbody></table></figure>
<p>这个更详细:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo lsb_release -a</span><br></pre></td></tr></tbody></table></figure>
<h1 id="软件安装卸载等">软件安装卸载等</h1>
<p>apt: <strong>Advanced Packaging Tools</strong></p>
<h2 id="源列表备份与恢复">源列表备份与恢复</h2>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 我建议换源之前做好备份. 使用如下命令可备份<strong>source.list</strong>至 <strong>source.list_backup</strong>. 甚至再谨慎一些每次更新源列表后都可以做一份备份, 在文件名中加入时间或者更新信息来作区分.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br></pre></td></tr></tbody></table></figure>
<p>如果哪天把源列表弄脏了可以随时用一下命令恢复.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list_backup /etc/apt/sources.list</span><br></pre></td></tr></tbody></table></figure>
<h2 id="换源">换源</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list</span><br></pre></td></tr></tbody></table></figure>
<p>另一种换源方式是进入source.list进行修改, 参见以下链接.</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/ubuntu" target="_blank" rel="noopener">中科大Ubuntu镜像使用帮助</a></p>
<p>(我对这个和我校校名只有一字之差的学校还是很有好感<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>)</p>
<p>💡 其中以<strong>deb-src</strong>开头的行是源代码的地址, 只有取消这些行的注释才能下载源代码.</p>
<h2 id="包列表更新">包列表更新</h2>
<p>这一命令虽然看似唰唰唰下了好些东西, 实际上只是下载了个软件目录, 然后我们执行 <code>sudo apt install [package]</code> 的时候apt就会从这个列表中找到名字对应的下载连接之类的去下载和安装. 这就是为什么很多安装教程都会要求先执行一次这条命令 -- 保证安装的是最新版.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure>
<h2 id="包升级">包升级</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></tbody></table></figure>
<p>:warning: 需在运行<code>sudo apt update</code>后运行</p>
<h2 id="包搜索">包搜索</h2>
<p>这怕是少数几条不用sudo的<code>apt</code>命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">apt search [package]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="包安装">包安装</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install [package]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="包卸载">包卸载</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt remove [package]</span><br></pre></td></tr></tbody></table></figure>
<p>💡<code>apt remove</code>只会删除软件包而不会删除配置文件, 而手动删除配置文件还容易有 <a href="https://www.jianshu.com/p/f6176973b56f" target="_blank" rel="noopener">麻烦</a>, 因此不想用某软件了应当运行:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt purge [package]</span><br></pre></td></tr></tbody></table></figure>
<p>中文唤做<strong>净化</strong>! 💪</p>
<h2 id="进阶操作">进阶操作</h2>
<p>有很多东西并不是用包管理工具就能轻松搞定的， 让人欲哭无泪， 主要有以下几种情况：</p>
<h3 id="下载下来的压缩包里有看着像安装脚本的玩意">下载下来的压缩包里有看着像安装脚本的玩意</h3>
<p>这种一般会给出<strong>README</strong>的, 不用担心, 即便没给也可以用编辑器点开看着像安装用脚本的文件脑力运行一边看看是不是它😏 有的安装脚本是交互式的, 还是挺有趣的, 有的甚至有图形界面 (一般需要加选项才能有图形界面)</p>
<h3 id="有deb包">有deb包</h3>
<h4 id="普通安装">普通安装</h4>
<ol type="1">
<li>有图形界面的话点击就能安装</li>
<li>终端进入deb包所在文件夹, 运行<code>sudo dpkg -i [package]</code></li>
</ol>
<h4 id="遇到报错">遇到报错</h4>
<h5 id="修复依赖关系">修复依赖关系</h5>
<p>有时候我们会因为缺少一些包而安装失败, 这个是个很容易解决的问题, 只需运行 <code>apt --fix-broken install</code>. 这样普通问题apt就能帮我们解决了✌️</p>
<p>💡另一条相同作用的命令是<code>apt install -f</code></p>
<h5 id="需要对包的依赖关系进行修改">需要对包的依赖关系进行修改</h5>
<ol type="1">
<li><p><strong>在要安装的deb包所在目录中</strong>创建相关文件夹:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir extract</span><br><span class="line">mkdir extract/DEBIAN</span><br><span class="line">mkdir build</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>解压出包中的文件到<strong>extract</strong>目录下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">dpkg -X [package] extract/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>解压出包的控制信息到<strong>extract/DEBIAN/</strong>下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">dpkg -e [package] extract/DEBIAN/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>将修改后的内容重新进行打包生成deb包到<strong>build</strong>目录下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">dpkg-deb -b extract/ build/</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>进入<strong>build</strong>文件夹安装修改后的deb包</p></li>
</ol>
<h3 id="需要自己编译">需要自己编译</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>
<h1 id="文件系统">文件系统</h1>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> 在搜索过程中看到 <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">这篇文章</a>, 感觉对Linux下文件系统描述得很好, 比如其中说</p>
<blockquote>
<p>Linux系统中进程之外皆文件, 即便文件夹也是一个文件, 是记录了其他文件名的文件. 设备也被视为一个文件.</p>
</blockquote>
<p>再比如其中说到了 <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html/#major4" target="_blank" rel="noopener">Linux系统有多个文件系统</a>, VFS 作为一个通用的文件系统, 抽象了文件系统的四个基本概念: 文件, 目录项 (dentry, directory entry的缩写), 索引节点 (inode) 及挂载点.</p>
<blockquote>
<p>文件名仅是为了方便人们的记忆和使用, 系统或程序通过inode号寻找正确的文件数据块.</p>
</blockquote>
<h2 id="链接">链接</h2>
<p>ln: link</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span> <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html/#major2" target="_blank" rel="noopener">这里</a> 有对软链接与硬链接的比较. 其中:</p>
<ul>
<li>软链接以<strong>路径</strong>的形式存在,类似于Windows操作系统中的<strong>快捷方式</strong>. 硬链接以 <strong>文件副本</strong>的形式存在, 但不占用实际空间</li>
<li>软链接可以跨文件系统创建，硬链接不可以</li>
<li>软链接可以对一个不存在的文件名进行链接</li>
<li>软链接可以对目录进行链接, 硬链接不可以</li>
</ul>
<p>目前我只用到了软链, 还没有用到硬链. 个人觉得软链很方便, 它使得一个文件/文件夹在另一个地方有了一个时刻同步的备份. 比如可以像<a href="https://github.com/LeoJhonSong/vimrc" target="_blank" rel="noopener">这样</a>, 从github 下载了一个.vimrc, 将它软链到home目录 (vim默认从这里读取.vimrc). 这样一来无论是修改了这两处那一个.vimrc另一个也会同步. 这很方便将更改备份到github.</p>
<h3 id="建立软链">建立软链</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ln -s [source] [destination]</span><br></pre></td></tr></tbody></table></figure>
<p>❗️要注意的是此处<code>destination</code>和<code>source</code>似乎必须写<strong>绝对路径</strong>, 不然建立的链接就是损坏的. 如果<code>destination</code>处写的是一个目录, 那会生成一个和源文件/文件夹同名的软链, 而如果<code>destination</code> 写的是一个存在的目录下一个不存在的名字, 那么会生成一个这个名字的软链, 和源文件/文件夹链接.</p>
<h2 id="复制">复制</h2>
<p>cp: copy</p>
<p>:warning: 目标位置必须已经存在, <code>cp</code>命令无法创建目录. 另外如果没有文件复制的权限会报错. <code>cp</code>命令不止可以复制, 还可以建立链接. <code>cp</code>命令支持..表示上级文件夹等, 支持正则表达</p>
<h3 id="常用选项">常用选项</h3>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</li>
<li>-d：复制时建立软链接</li>
<li>-f：覆盖已经存在的目标文件而不给出提示</li>
<li><p>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖</p>
<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span>保险起见每次都加上此选项</li>
<li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</li>
<li><p>-l：建立硬链接, 不复制文件</p></li>
</ul>
<h3 id="正则使用举例">正则使用举例</h3>
<p>将目录 <strong>/usr/men</strong> 中的以<code>m</code>打头的所有<code>.c</code>文件复制到目录 <strong>/usr/zh</strong> 中</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp /usr/men m*.c /usr/zh</span><br></pre></td></tr></tbody></table></figure>
<h2 id="删除">删除</h2>
<p>rm: remove</p>
<h3 id="常用选项-1">常用选项</h3>
<ul>
<li>-i 删除前逐一询问确认</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认</li>
<li>-r 将目录及以下之档案亦逐一删除</li>
</ul>
<h3 id="删除文件">删除文件</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm [path/to/file] [path/to/another/file]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除文件夹">删除文件夹</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -r [path/to/folder]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除当前文件夹下所有文件及文件夹">删除当前文件夹下所有文件及文件夹</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -r *</span><br></pre></td></tr></tbody></table></figure>
<h2 id="解压压缩">解压/压缩</h2>
<p>tar: tape archive. <code>tar</code> 命令原本是用来建立，还原备份文件的工具程序, 但Linux下最常见的压缩包就是tar.gz格式的. <strong>.gz</strong>是GNU zip的缩写.</p>
<p>❗️ 要注意<code>tar</code>命令无法解压 <strong>.rar</strong> 格式的压缩包, 也无法生成 <strong>.rar</strong> 格式. 需要另外安装 rar工具:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt install rar</span><br></pre></td></tr></tbody></table></figure>
<p>另外在Linux下解压来自Windows的zip压缩包容易出<a href="#解压.zip压缩包中文文件名为乱码">文件名乱码问题</a>.</p>
<h3 id="常用选项-2">常用选项</h3>
<ul>
<li>-c或--create 建立新的备份文件</li>
<li>-f&lt;备份文件&gt;或--file=&lt;备份文件&gt; 指定备份文件<!--备份文件--><!--备份文件--></li>
<li>-t或--list 列出备份文件的内容</li>
<li>-v或--verbose 显示指令执行过程</li>
<li>-x或--extract或--get 从备份文件中还原文件</li>
<li>-z或--gzip或--ungzip 通过gzip指令处理备份文件</li>
</ul>
<h3 id="列出压缩文件内容">列出压缩文件内容</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -tvzf [source.tar.gz]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="解压文件">解压文件</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -xvzf [source.tar.gz]</span><br></pre></td></tr></tbody></table></figure>
<p>如果是.rar文件:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rar x [source.rar]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="压缩文件">压缩文件</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -czvf [target.tar.gz] [file1] [file2] [file3]</span><br></pre></td></tr></tbody></table></figure>
<p>如果是要压缩成.rar文件 (不是别人要求的话不推荐):</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rar a [compressede_package_name] [source_folder_name]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="格式化u盘">格式化U盘</h2>
<p>虽然在 Ubuntu 下图形化界面里可以无脑格式化U盘, 但是有时候U盘出问题的时候需要在命令行蛮力格式化. 此处以U盘为 <strong>/dev/sdb1</strong> 为例.</p>
<p>首先确保U盘未挂载:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo umount /dev/sdb1</span><br></pre></td></tr></tbody></table></figure>
<p>然后将之格式化为FAT32格式(Linux, Windows都可识别的格式):</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo mkfs.vfat -F 32 /dev/sdb1</span><br></pre></td></tr></tbody></table></figure>
<p>这样之后可以回图形界面设置U盘的名字或者重新格式化为其他格式之类. # 环境变量</p>
<h2 id="查看环境变量">查看环境变量</h2>
<h3 id="查看所有环境变量">查看所有环境变量</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export -p</span><br></pre></td></tr></tbody></table></figure>
<h3 id="查看path">查看PATH</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></tbody></table></figure>
<h3 id="查看当前运行shell">查看当前运行shell</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></tbody></table></figure>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> shell不止一种, 大多数Linux系统默认shell为 <strong>Bash shell</strong> (Bourne Again shell), 似乎<strong>Bourne shell</strong>仍是许多Unix系统默认的shell. 比较著名的还有 <strong>Z shell</strong> (Zsh), <strong>friendly interactive shell</strong> (fish).</p>
<h2 id="添加路径到path">添加路径到PATH</h2>
<h3 id="临时添加">临时添加</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export PATH=[path/to/append]:$PATH</span><br></pre></td></tr></tbody></table></figure>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 应注意export命令仅作用于当前终端.</p>
<p>:bulb: 在有些文档中会使用下面这样的方式来添加路径到PATH, 但我觉得这样不够稳妥. 因为用下面这种方式的话如果这个变量原本不存在, 假如我们添加<code>/usr/bin/bash</code>到PATH, 那么当我们使用 <code>echo $PATH</code>来查看PATH变量的值会发现其值为 <strong>:/usr/bin/bash</strong>. 这是因为bash会将 <strong>PATH=</strong>后的视为一整个字符串, 而 <strong>$PATH</strong>是取PATH现在的值的意思. 个人认为<code>/usr/bin/bash:</code> 比<code>:/usr/bin/bash</code> OK一些<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">😅</span></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export PATH=$PATH:[path/to/append]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="永久添加">永久添加</h3>
<p>首先我们需要了解哪些文件与环境变量有关.</p>
<p>在Linux系统中<strong>最常见</strong>与环境配置有关的文件是四个shell初始化文件, 想要添加环境变量最常见的方法就是将命令添加到适当文件中, 这样每当shell被唤起, 在初始化时, 环境变量都会被添加进去. 但但不同情况下会加载不同的初始化文件, 究竟需要更改哪一个/几个呢? 他们的比较如下:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><code>/etc/profile</code></th>
<th><code>/etc/bash.bashrc</code></th>
<th><code>~/.profile</code></th>
<th><code>~/.bashrc</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>等级</td>
<td>系统级</td>
<td>系统级</td>
<td>用户级</td>
<td>用户级</td>
</tr>
<tr class="even">
<td>自动加载的情况</td>
<td>login shell</td>
<td>interactive shell</td>
<td>login shell</td>
<td>interactive shell</td>
</tr>
<tr class="odd">
<td>作用于哪些shell</td>
<td>Bourne系shell</td>
<td>仅Bash</td>
<td>Bourne系shell</td>
<td>仅Bash</td>
</tr>
<tr class="even">
<td>加载顺序</td>
<td>先</td>
<td>先</td>
<td>后</td>
<td>后</td>
</tr>
</tbody>
</table>
<p>🔗 实际上在Linux系统中有非常多配置文件可以用来设置环境变量, 可以看看<a href="https://blog.lilydjwg.me/2020/7/22/linux-environment-variables.215496.html" target="_blank" rel="noopener">Linux的环境变量怎么设</a></p>
<p>⚠️ 在有些系统中不是<code>/etc/bash.bashrc</code>, 而是<code>/etc/bashrc</code></p>
<p>⚠️ <code>/etc/profile</code>仅针对Bourne系shell是指当shell为Bourne Shell, Bash, ksh 等的时候<code>/etc/profile</code>才可能被加载, 而当我唤起一个<strong>zsh</strong>时, <strong>以上四个初始化文件都没有被加载</strong> <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8">🤷♂</span></p>
<p>⚠️ 在用户目录可能还存在<code>~/.bash_profile</code>, <code>~/.bash_login</code>这两文件, 系统会依次查找<code>~/.bash_profile</code>, <code>~/.bash_login</code> 和 <code>~/.profile</code>这三个配置文件, 读取和执行这三个中的<strong>第一个</strong>存在且可读的文件中命令, 因此建议将三个合并为一个.</p>
<p>⚠️ 当<strong>bashrc</strong>一系和<strong>profile</strong>一系都会被加载时两者哪个会先被加载并不一定, 有点玄学... 经我测试运行<code>bash -cl bash</code> <strong>profile</strong>一系会先被加载, 而运行 <code>bash -l</code>则<strong>bashrc</strong>一系会先被加载<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span> 但很明确的一点是: 系统级初始化文件一定会先与用户级文件被加载. 即便根据应当允许用户个性化设置这种尝试也能推断出 (用户级初始化文件后于系统级初始化文件被加载, 所以用户级文件中的配置会覆盖系统级文件的对应配置)</p>
<p>✔️ 有关四种shell模式个人感觉坑挺多的:</p>
<ul>
<li><strong>login shell</strong>: 笼统地理解就是有<strong>输入用户名和密码</strong>这一过程才能进入的shell, 比如 <strong>通过ssh访问远程服务器</strong>, 否则就是<strong>non-login shell</strong> 但是! 比如<strong>通过<code>su</code>切换用户</strong>时默认进入的是<strong>non-login shell</strong>, 如需切换用户进入login shell需要加选项<code>-l</code><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f926-2642.png?v8">🤦♂</span> 还有, 经过GitHub 广大网友建议, <strong>进入WSL</strong>默认进入的是<strong>login shell</strong>, 即便你并没有输入用户名密码.</li>
<li><p><strong>interactive shell</strong>指的是你一句电脑一句这样交互式的终端, 而<strong>no-interactive shell</strong> 指的是<strong>通过脚本</strong>, <strong>运行<code>bash -c [command]</code></strong>之类指哪打哪和电脑没有交流的shell.</p></li>
<li><p>检测当前是login shell还是non-login shell: 有一个特点是login模式运行的shell进程名第一个字符是-, 因此如果你输入<code>echo $0</code>输出的是<strong>-bash</strong>, 那么你就是在login shell中, 如果是<strong>bash</strong>, 那就是在non-login shell中.</p></li>
</ul>
<p>🌟 有了以上的知识储备我们就知道需要将环境变量添加到什么文件里了.</p>
<h2 id="删除一个环境变量">删除一个环境变量</h2>
<h3 id="临时删除">临时删除</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export -n [VARIABLE]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="永久删除">永久删除</h3>
<p>参考永久添加的操作.</p>
<h2 id="系统命令软链">系统命令软链</h2>
<p>⭐️⭐️⭐️ <code>update-alternatives</code>是一条十分实用的命令! 这是Debian一系系统 (比如Ubuntu) 中创建, 删除, 管理系统命令软链的工具. 在一个系统中同时存在同一软件的多个版本是很常见的事, 比如 python2和python3并存, gcc多个版本并存. 当在命令行输入<code>python</code>时到底该进入python2还是 python3呢? update-altenatives能够帮助我们.</p>
<h3 id="创建添加一个系统命令软链">创建/添加一个系统命令软链</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --install [path/to/system_link] [command_name] [path/to/command_binary] [priority]</span><br></pre></td></tr></tbody></table></figure>
<p>几个参数分别是: 系统命令的链接, 系统命令名, 要用系统命令调用的软件的二进制文件的链接, 优先级大小</p>
<p>以<strong>python</strong>这个命令举例:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/python python /home/leo/anaconda3/bin/python3 100</span><br></pre></td></tr></tbody></table></figure>
<h3 id="配置系统命令软链">配置系统命令软链</h3>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --config [command_name]</span><br></pre></td></tr></tbody></table></figure>
<p>alternative软链系统会把优先级数值最大的一个软件二进制文件链接作为当前该系统命令链接到的二进制文件地址, 因此比如要改变python版本只需调整优先级大小.</p>
<h3 id="删除一个系统命令软链">删除一个系统命令软链</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">update-alternatives --remove [path/to/system_link] [command_name] [path/to/command_binary] [priority]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="文本编辑">文本编辑</h1>
<h2 id="显示文件内容">显示文件内容</h2>
<p>cat: concatenate</p>
<h3 id="常用选项-3">常用选项</h3>
<ul>
<li><p>-n 或 --number：由 1 开始对所有输出的行数编号。</p></li>
<li><p>-b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。</p></li>
</ul>
<h3 id="镜像">镜像</h3>
<p>cat 也可以用来制作镜像文件. 例如要制作软盘的镜像文件, 将软盘放好后输入：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /dev/fd0 &gt; [OUTFILE]</span><br></pre></td></tr></tbody></table></figure>
<p>相反的, 如果想把 image file 写到软盘, 输入：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat [IMG_FILE] &gt; /dev/fd0</span><br></pre></td></tr></tbody></table></figure>
<h2 id="覆盖目标文件的写入">覆盖目标文件的写入</h2>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>一定别和添加内容到文件的命令搞混了!</p>
<h3 id="写入一些文件的内容">写入一些文件的内容</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat [file1] [file2] &gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="写入一个字符串">写入一个字符串</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo ["string"] &gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="添加到目标文件的写入">添加到目标文件的写入</h2>
<h3 id="写入一些文件的内容-1">写入一些文件的内容</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat [file1] [file2] &gt;&gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="写入一个字符串-1">写入一个字符串</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo ["string"] &gt;&gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="清空文件内容">清空文件内容</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /dev/null &gt; [target_file]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="文件权限设置">文件权限设置</h1>
<p>chmod: change file mode bits</p>
<p>chown: change file owner and group</p>
<h2 id="所有人可运行">所有人可运行</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod a+x</span><br></pre></td></tr></tbody></table></figure>
<p>拥有者, 群组可读写, 运行, 其他用户可读, 执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod 755</span><br></pre></td></tr></tbody></table></figure>
<p>用一个三位八进制数来表示文件权限, 规定4, 2和1表示读、写、执行权限, 每一位都是这三个数相加的结果, 三位分别表示u (user), g (group), o (others).</p>
<h1 id="后台不挂起运行">后台不挂起运行</h1>
<p>通过在命令尾加上<code>&amp;</code>可以让命令在后台运行. <strong>后台运行</strong>是指<strong>当前进程不在前台占用屏幕</strong>. 后台运行的程序一样会把输出显示到终端, 通常通过在命令末尾加上<code>1&gt;/dev/null 2&gt;error.log</code> 将标准输出重定向至黑洞 (<code>/dev/null</code>是一个很特殊的设备, 写入它的内容都会被丢弃, 而读取它会得到EOF), 输出标准错误输出到当前文件夹的<code>error.log</code>.</p>
<p>💡 <code>&amp;</code>能让进程在后台运行, 但<strong>一旦当前终端关闭这个进程就会被挂起</strong>. 当进程被切换到后台, 称为<strong>job</strong></p>
<p>而<code>nohup [command]</code>能让进程不挂起地运行, 即退出当前终端进程仍然在运行. 但这条命令会一直占据终端而且不再接受输入, 因此关闭这个终端会提示还有程序在运行, 强行关闭的话这条命令就会被终止, 就更不用说不挂起运行了.</p>
<p>如果想不挂起后台运行要用下面这条. 这样关闭当前终端程序也会继续运行了😄</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nohup [command] &amp; 1&gt;/dev/null 2&gt;error.log</span><br></pre></td></tr></tbody></table></figure>
<p>💡 丢弃标准输出并将标准错误输出重定向到当前文件夹的<code>error.log</code>是我的习惯, 当然你可以重定向到别的地方.</p>
<h1 id="tcpudp工具">TCP/UDP工具</h1>
<p>nc: netcat, 是一个读写TCP/UDP协议下数据的工具.</p>
<p>我感觉netcat能当作Windows下的TCP调试助手, 但也有远比TCP调试助手多的功能和用途,是很强大的工具, 但得自己加选项来实现各种功能, 可能还需要和其他工具配合, 使用不是很直观.</p>
<p>常用选项:</p>
<ul>
<li>-l listen, 监听</li>
<li>-u 使用UDP协议而不是默认的TCP协议</li>
<li>-v 显示详细信息</li>
<li>-z 指定nc只扫描端口而不发送数据过去, 不能和-l选项一起用</li>
<li>-w 一定时间内无法连接则timeout, 单位为秒</li>
</ul>
<p>我目前遇到的几种用法:</p>
<h2 id="监听某端口">监听某端口</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>
<p>❗️ nc的manpage说在建立链接后就不要在意哪边是server哪边是client了.</p>
<h2 id="发送一段16进制的ascii码">发送一段16进制的ASCII码</h2>
<p>在看网友们实现这个时我体会到了linux命令是多么强大, 以下收录几个例子</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo '0006303030304e43' | xxd -r -p | nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo -ne '\x00\x06\x30\x30\x30\x30\x4e\x43' | nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo -ne "$(echo '0006303030304e43' | sed -e 's/../\\x&amp;/g')" | nc -l localhost 8000</span><br></pre></td></tr></tbody></table></figure>
<h2 id="以16进制显示接收到的信息">以16进制显示接收到的信息</h2>
<p>hd: hexdump xxd: make a hexdump or do the reverse</p>
<p>hexdump和xxd都可以将数据转为16进制, 但体验后我觉得xxd更易记, 显示更直观.</p>
<p>xxd默认按单字节转换, 而hexdump默认按双字节小端转换, 差评.</p>
<h3 id="按单字节以一定格式显示">按单字节以一定格式显示</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc localhost 8000 | xxd -c [cols]</span><br></pre></td></tr></tbody></table></figure>
<p>选项-c指定一行显示列数, 如果显示的数据是定长的话设置为数据长度很舒服. xxd默认两字节一组显示, 即两个字节间一个空格, 可以用<code>-g [bytes]</code>指定几个字节一组.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc localhost 8000 | hexdump -C</span><br></pre></td></tr></tbody></table></figure>
<p>选项-C指定按单字节以一定格式显示. 这个格式可以看hexdump的manpage下<code>-C</code>选项的描述</p>
<p>不过看manpage似乎hexdump支持的骚显示方式更多.</p>
<h2 id="扫描端口">扫描端口</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">nc -v -n -z -w 1 localhost 1-1000</span><br></pre></td></tr></tbody></table></figure>
<p>nc甚至可以通过重定向文件描述符来在端口使用终端 🐮🍺</p>
<p>在nc的manpage可以找到操作方式.</p>
<h1 id="遇到过的问题">遇到过的问题</h1>
<h2 id="ubuntu开机紫屏">Ubuntu开机紫屏</h2>
<p>linux文件系统损坏导致的不正常开/关机, 此时一般等一等系统就会提示你进行文件系统修复.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">fsck -a /dev/sda1</span><br></pre></td></tr></tbody></table></figure>
<p>一般用这条命令修复. fsck (file system check) 是检测与修复文件系统的命令.<code>-a</code>选项会报告损坏 block并自动修复 (反正手动修复也只是确认是否修复).</p>
<p>具体参考<a href="https://blog.csdn.net/liujianlin01/article/details/82937708" target="_blank" rel="noopener">这里</a></p>
<h2 id="ubuntu烦人的开机报错">Ubuntu烦人的开机报错</h2>
<p>把这个报错关了就完事了😁</p>
<p>参考<a href="https://www.cnblogs.com/greatfish/p/8042026.html" target="_blank" rel="noopener">Ubuntu开机弹出System porgram detected</a></p>
<h2 id="ibus的中文输入法无法选择除第一个的候选词bug">ibus的中文输入法无法选择除第一个的候选词bug</h2>
<p>需要删除几个缓存的数据库文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo rm -rf ~/.cache/ibus/libpinyin/</span><br></pre></td></tr></tbody></table></figure>
<p>这个issue具体参考<a href="https://github.com/libpinyin/ibus-libpinyin/issues/127" target="_blank" rel="noopener">这里</a></p>
<p>⭐️推荐直接换掉ibus转用<strong>fcitx</strong>. fcitx的中文输入法推荐<strong>GooglePinyin</strong>, 日语输入法推荐 <strong>Mocz</strong>. 通过以下命令可以安装.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装谷歌拼音</span></span><br><span class="line">sudo apt install fcitx-googlepinyin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Mocz日语输入法</span></span><br><span class="line">sudo apt install fcitx-mozc</span><br></pre></td></tr></tbody></table></figure>
<p>❗️值得一提的是fcitx的输入法分激活和非激活 (通常将英语设为非激活), 输入法切换快捷键也分两种, 一种在非激活输入法和激活输入法间切换, 一种在激活输入法间切换.</p>
<h2 id="没有显卡驱动无法正常显示">没有显卡驱动无法正常显示</h2>
<p>有时候买了不靠谱的显卡可能你的发行版中没有, 或者你安装的时候没有安装对应的驱动, 因此开机后可能是花屏或者黑屏. 解决方法是: 开机时在grub界面按 <code>e</code> 进入编辑模式将什么什么splash后的---改为 <code>nomodeset</code>. 这样就会让内核不改变显示设置, 保证至少能看到东西. (但这模式很有可能显示出来辣眼睛😅)</p>
<h2 id="解压.zip压缩包中文文件名为乱码">解压.zip压缩包中文文件名为乱码</h2>
<p>当我在Ubuntu1804像往常解压<code>.tar.gz</code>文件那样用右键菜单的<strong>extract here</strong>解压<code>.zip</code>文件后我发现中文文件名全部变成了乱码, 文件里面倒是没问题.</p>
<p>这是因为<strong>zip压缩包并没有指明编码格式</strong>, 解压工具会以Linux的默认编码格式<strong>UTF-8</strong>解压, 而在系统语言为简体中文的Windows系统下默认<strong>字符集</strong>为<code>GBK</code>, <strong>编码格式</strong>为<code>EUC-CN</code>, 所以会文件名乱码.</p>
<p>我目前的解决方法是命令行输入以下命令解压.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">unzip -O cp936 [filename]</span><br></pre></td></tr></tbody></table></figure>
<p>此处选项<code>-O</code>指以指定编码格式解压. <strong>cp936</strong>指<a href="https://en.wikipedia.org/wiki/Code_page_936_(Microsoft_Windows)" target="_blank" rel="noopener">微软编写的代码页936页</a>的编码格式 (注意与<a href="https://en.wikipedia.org/wiki/Code_page_936_(IBM)" target="_blank" rel="noopener">IBM的code page936</a>区别), 即字符集为GBK, 编码格式为EUC-CN. (经我实验UTF-8编码的文件名以cp936编码解压出来显示正常... 我也不知道为什么)</p>
<h2 id="linux系统时间和windows系统时间差8小时">Linux系统时间和Windows系统时间差8小时</h2>
<p>这个问题蛮有意思的:</p>
<p>Linux系统将硬件时间 (BIOS中的时间) 作为系统的<strong>UTC时间</strong>, 而Windows系统将硬件时间作为<strong>本地时间</strong>.也就是说如果现在我有一台在北京 (东八区) 的电脑, <strong>BIOS时间</strong> 为8:30 (24小时制), 那<strong>Linux系统时间</strong>为16:30, <strong>Windows系统时间</strong>为8:30.</p>
<p>因此Linux系统时间与Windows系统时间有时差是正常的 (可以通过设置让Windows系统将硬件时间作为UTC时间). 但我的Linux和Windows系统都开启了网络校时功能, 理论上即便存在上述问题也不应当表现出来, 而应是开机后自动校准了. 我面临的问题是Linux系统时间是准确的,而Windows系统时间总是早了8小时, 这说明Windows系统的网络校时功能未生效.</p>
<p>后来我发现是有个叫<strong>Windows Time</strong>的服务 (网络校时功能在这个服务里) 的启动类型不合理 (<strong>服务</strong>可以通过在开始搜索框搜索打开). 这个服务的缺省启动类型为<code>手动(触发器启动)</code>, 也就是说需要通过我们手动在某处触发. (与另一种启动类型<code>手动</code>的区别是后者只能在<strong>服务</strong>页面手动启动)举例来说, 每次我从Linux系统关机,重启打开Windows系统后, Windows系统显示的时间是不准确的, 此处<strong>Windows Time</strong>服务因为未触发,处于未运行状态, 而当我在设置的时间与地区里手动关闭 <strong>"自动设置时间"</strong> 再打开后, 我发现 <strong>Windows Time</strong>服务此时已经处于运行状态了.</p>
<p>🤦‍... 没准是微软的锅? 咱也不知道, 咱也不敢问.</p>
<p>当我将这个服务的启动类型设置为<code>自动(延迟启动)</code> (延迟启动指在所有系统服务启动后再启动本服务) 后问题解决.</p>
<h2 id="fcitx无法用superspace切换输入法">fcitx无法用Super+Space切换输入法</h2>
<p>这是因为这个组合键被系统的输入法切换快捷键占用了. 在系统设置里 <strong>Devices -&gt; Keyboard -&gt; Switch to next input source</strong> 关掉这个快捷键就可以了.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>操作系统</category>
        <category>杂记</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>我发布了扩展包!</title>
    <url>/zh-CN/2019/02/27/%E6%88%91%E5%8F%91%E5%B8%83%E4%BA%86%E6%89%A9%E5%B1%95%E5%8C%85/</url>
    <content><![CDATA[<p>看了Poy Chang 的<a href="https://poychang.github.io/build-vscode-extension/" target="_blank" rel="noopener">制作VSC扩展包</a>, <a href="https://poychang.github.io/publish-extension-to-visual-studio-marketplace/" target="_blank" rel="noopener">发布扩展包至 Extension Marketplace</a> 两篇文章, 我兴趣大发, 也发布了自己的扩展包!</p>
<a id="more"></a>
<p>首先说说为什么想糊几个扩展包:</p>
<ol type="1">
<li>好有趣, 假装自己也写了好几个很有用的扩展, 装逼利器</li>
<li>如果VSC启用了过多插件启动得会很慢, 但一个一个禁用插件又很费事. 但有趣的是只要禁用一个扩展包其中包含的扩展都会被禁用, 因此我把我使用的扩展按用途分类做成了扩展包. 这样批量禁用超方便👍</li>
</ol>
<p>实际上Poy说得很详细, 制作也很简单, 毕竟我只是想制作个扩展包, 只要把大佬们的插件整合一番就好了. 一套流程大致有以下几个步骤:</p>
<ol type="1">
<li><p>安装 yeoman 和 VSC扩展生成器(我自己瞎翻译的), 安装VSC扩展管理工具(还是瞎翻译的)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br><span class="line">npm install -g vsce</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>注册成为开发者, 搞到一个 <strong>Personal Access Tokens</strong></p>
💡 Poy提供的注册接口我无法进入, 推荐点击 https://visualstudio.com 后登陆微软账号, 就能看到很明显的注册开发者账号的按钮了✌️<br>
⚠️ 这个 token 一定要保存好阿, 这混蛋玩意只显示这一次, 而你有可能多次用到</li>
<li>生成扩展包模板</li>
<li>把扩展包的显示名, 扩展包的名字 (显示名和名字是不一样的, 你的扩展包显示名可以和其他人的重名, 但每个扩展的名字是唯一的), 概述, 随便想的版本号, 作者名, 扩展包的图标的地址, 在github的仓库地址, 想收录进扩展包的扩展的名字统统塞进 <strong>package.json</strong> .</li>
<li>糊一糊 <strong>README</strong> 和 <strong>CHANGELOG.md</strong></li>
<li><p>发布!</p></li>
</ol>
<p>这里是我发布的几个扩展包, 欢迎体验!</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.coding-assist-extension-pack" target="_blank" rel="noopener">Coding Assist Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.markdown-extension-pack" target="_blank" rel="noopener">Markdown Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.latex-extension-pack" target="_blank" rel="noopener">LaTeX Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.web-extension-pack" target="_blank" rel="noopener">Web Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.python-extension-pack" target="_blank" rel="noopener">Python Extension Pack</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LeoJhonSong.ccpp-extension-pack" target="_blank" rel="noopener">C/C++ Extension Pack</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>VSC</category>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>关于Linux下开发单片机的猜测</title>
    <url>/zh-CN/2019/03/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%BC%80%E5%8F%91%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E7%8C%9C%E6%B5%8B/</url>
    <content><![CDATA[<p>现在也算个Linux爱好者啦, 但在Linux下怎么配置单片机开发环境我一直一头雾水, 直到最近我找到了相关文章!</p>
<a id="more"></a>
<p>💡 目前已经有 <a href="http://docs.platformio.org/en/stable/what-is-platformio.html" target="_blank" rel="noopener">PlatformIO</a>可以让我们进行大部分单片机, 嵌入式系统的开发, 但也有部分开发板他们还没有收录, 除了向项目提issue, 我们也可以尝试不用PlatformIO配置一套Linux下单片机开发环境.</p>
<p>网上虽然也有那么些讲在Linux开发单片机的文章, 但我看到的基本是开发C51, 顶多是有开发STM32的. 我是觉得没人会费事在 Linux 下开发C51, 反正我想开发的比如 <a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/xc2200-family-body/xc22xxm-series/sak-xc2267m-104f80lr-ab/" target="_blank" rel="noopener">英飞凌 (infineon) 的 XC2267M</a>, <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-based-processors-and-mcus/kinetis-cortex-m-mcus/k-seriesperformancem4/k6x-ethernet/kinetis-k60-100-mhz-mixed-signal-integration-microcontrollers-based-on-arm-cortex-m4-core:K60_100" target="_blank" rel="noopener">飞思卡尔 (Freescale) 的 k60</a> 之类是没看到相关文章🤷‍</p>
<p>🌟🌟🌟 最近我看到了两篇配置英飞凌XMC系列单片机开发环境的文章! <a href="https://github.com/notandy/xmc4500-relax-linux" target="_blank" rel="noopener">xmc4500-relax-linux</a>讲述了在 Linux开发xmc4500需要什么工具以及编译方式, <a href="https://github.com/furtnerthomas/Linux-XMC-Development" target="_blank" rel="noopener">Linux-XMC-Development</a> 则<strong>十分详细</strong>地讲述了如何配置基于<strong>eclipse</strong>的XMC系列单片机开发环境.</p>
<p>🔗 参考:</p>
<ul>
<li><a href="https://blog.csdn.net/thinkerleo1997/article/details/53145972" target="_blank" rel="noopener">在Linux下搭建51单片机的开发烧写环境</a></li>
<li><a href="https://www.amobbs.com/thread-5568167-1-1.html" target="_blank" rel="noopener">ubuntu下安装stm32开发环境 秒杀keil和IAR</a></li>
<li><a href="https://www.cnblogs.com/amanlikethis/p/3803736.html#lab35" target="_blank" rel="noopener">Linux下STM32开发环境的搭建</a></li>
</ul>
<p>参考以上几篇文章我明白了单片机开发都是以下流程, 那我猜只要找到对应工具就OK了:</p>
<ol type="1">
<li>交叉编译生成 bin 或者 hex 文件</li>
<li>烧录到单片机</li>
<li>调试</li>
</ol>
<p>也就是说我们找到对应的交叉编译器, 烧录工具, 调试工具就可以了.</p>
<p>而什么是对应工具, 要在哪里找到对应工具这个问题又让我苦恼了一阵子, 但后来我发现特么就在每个单片机的页面上! (也可能是在该单片机的系列介绍页面)</p>
<p>比如 Infineon XC2267M 的交叉编译工具, 调试工具, 烧录工具都在 <a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/xc2200-family-body/xc22xxm-series/#!tools" target="_blank" rel="noopener">这里</a> 列了出来! 当然有些工具是收费的, 但<a href="http://www.infineonic.org/module/forum/thread-554295-1-1.html" target="_blank" rel="noopener">这都不是事</a>😁. 不过似乎这个免费版<a href="http://www.infineonic.org/module/forum/thread-487158-1-1.html" target="_blank" rel="noopener">有点点局限</a></p>
<p>另一款我提到的k60芯片也在介绍页面给出了相关工具的链接.</p>
<p>不过看起来很多工具都是基于Eclipse的. (但我觉得Eclipse的图标不好看所以就用过一次)</p>
<p>🔗 更多相关链接</p>
<ul>
<li><a href="https://blog.csdn.net/passerbyyuan/article/details/51404226" target="_blank" rel="noopener">单片机的下载方式分类</a></li>
<li><a href="https://blog.csdn.net/qlexcel/article/details/84374768" target="_blank" rel="noopener">程序编译生成的Hex、Bin、axf和elf格式</a></li>
<li><a href="http://www.21ic.com/jichuzhishi/mcu/write/2014-03-20/216132.html" target="_blank" rel="noopener">单片机ISP、IAP和ICP几种烧录方式的区别</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>操作系统</category>
        <category>Linux</category>
        <category>嵌入式</category>
      </categories>
  </entry>
  <entry>
    <title>对伺服电机PID的理解</title>
    <url>/zh-CN/2019/03/27/%E5%AF%B9%E4%BC%BA%E6%9C%8D%E7%94%B5%E6%9C%BAPID%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>行吧, 继上次手搓简单卡尔曼算法后我又接触到了更多控制方面的东西. 想我一个电子工程的弟弟在这里研究术语都不知道几个的控制... 命苦啊! 最近在调机械腿, 应该说还在调那条腿, 对伺服电机里的PID算法有了些许感悟.</p>
<a id="more"></a>
<p>这条腿的传感噪声问题因为换了传感器已经解决了, 最近的问题是<strong>不能快速, 稳定, 准确的到达指定位置</strong>. 目前通过<strong>限制电机的加速度</strong>改善了情况.</p>
<h1 id="pid也没有那么简单">PID也没有那么简单</h1>
<p>在改动前机械腿在低速状态 (很低速那种) 下表现得还是蛮好的, 但速度一旦快起来就明显有<strong>过冲</strong>, 是一抖一抖运动的, 到达位置时间反而比低速还长... 虽然我以前买了一个很简陋的四轴穿越机调过一点点PID, 感觉这算法也不难理解 (至少比卡尔曼好理解😁), 但这次发现要达到一定的精度PID也不是那么简单的东西: 经常是 "这参数加了20了怎么毛的变化都没有啊 黑人问号", 但实际用起来又确实地感受到了差别. 并且当情况复杂的时候一个普通PID是不能满足的, 可能会用串级PID, 分段PID, 模糊PID, 专家系统PID, 容错PID, 前馈, 非线性控制之类的来改善😵</p>
<p>🔗 参考: <a href="https://www.zhihu.com/question/22603676/answer/28847509" target="_blank" rel="noopener">关于永磁同步电机交流伺服控制系统的算法问题？ - 小心假设的回答 - 知乎</a></p>
<h1 id="pi-pd-pid">PI · PD · PID</h1>
<p>另外我知道了在工业中说是说PID控制器, 但<strong>实际大多是PI控制器</strong>, 因为D虽然可以增大系统阻尼, 使系统具有一定预见性, 增强了对微小变化的响应, 但也因此造成系统容易震荡, 不稳定. 而根据网上说的<strong>I比D更容易引起不稳定, 因为I引入了另一个极点.</strong> 具体啥时候用PI, PD, PID我还没有头绪.</p>
<p>🔗 参考: - <a href="https://www.zhihu.com/question/26944678/answer/44687208" target="_blank" rel="noopener">哪些控制类的算法惊艳了你？ - 三郎的回答 - 知乎</a> - <a href="http://www.sohu.com/a/155185294_464086" target="_blank" rel="noopener">PID控制算法精华和参数整定三大招</a></p>
<h1 id="三环控制">三环控制</h1>
<p>再有就是我大致理解了伺服电机三环PID是一种多么精妙而自然的设计.</p>
<p>在调PID的时候我和师兄一度绝望, 我就说: "要不我们只保留转距环, 上层的我们重新写一遍."当时我们使用的是<strong>位置模式</strong>控制电机. 我看电机驱动器的说明书都看得晕呼呼的, 还没怎么理解三环控制. 但我要保留转距环的想法是很正常的:</p>
<p>电机最基本的控制方式就是控制流过电机的电流, 也就是控制电机输出的转距. 在这一环里不是单纯的PID, 驱动器还设置了一些阈值, 防止过流烧坏电机什么的. 这一环是驱动器自整定的, 但效果也不错, 因此我认为不必自己重写这一环.</p>
<p>然后我说:"上层我们用一个PID, 达到: 当当前位置比目标位置小就加正向转距, 当当前位置比目标位置大时加逆向转距的效果."</p>
<p>学长立即指出这样机械腿到达位置时的<strong>速度是不定的</strong>.我:"那就加一环速度PID, 生成一个百分数乘以转距来达到控制达到目标位置时的速度的效果"</p>
<p>说完我一愣, 我特么这不是说了一遍<strong>电流环, 速度环, 位置环</strong>的所谓<strong>三环控制</strong>🐴</p>
<p>🔗 参考:</p>
<ul>
<li><a href="http://www.voidcn.com/article/p-hxjakzgh-pw.html" target="_blank" rel="noopener">伺服电机三环控制的原理（位置环，运动环，电流环）</a></li>
<li><a href="https://blog.csdn.net/Andy20081251/article/details/79457911" target="_blank" rel="noopener">浅谈伺服电机三种控制方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21311021" target="_blank" rel="noopener">伺服电机的控制方式简述</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法</category>
        <category>自动控制</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>常见术语缩写</title>
    <url>/zh-CN/2019/03/02/%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<p>作为一个非英语母语的程序员, 经常看到各种奇奇怪怪的缩写让人摸不到头脑, 而如果能知道这些拼凑起来的字母是什么的缩写的话, 不仅便于记忆, 也便于理解. 另外能知道点冷知识还是很有意思 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62c.png?v8">😬</span>因此在此记录我看到的各种缩写. (英文中缩写分为Acronym, 首字母缩写和Abbreviation, 单词简写两种, 此处所说缩写<strong>主要指 abbreviation</strong>)</p>
<a id="more"></a>
<p>原本我想开一个GitHub仓库号召大家一起贡献的, 但随后我发现了 <a href="https://acronyms.thefreedictionary.com/ps" target="_blank" rel="noopener">这个网站</a>, 一方面看到有类似的工具了 (这个网站很不错的!), 一方面大家也可以看到<code>ps</code>这一个词在各种领域都有特定的含义, 总共多达248种全称, 如果我开的仓库也将所有对应全称收录的话, 过多的含义反而让它变得很鸡肋, 而只收录一些领域的含义未免小众. 因此决定只记录一下我认为有必要记录的缩写与对应全称.</p>
<table>
<thead>
<tr class="header">
<th>abbr</th>
<th>full name</th>
<th>field</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>all/add</td>
<td>|</td>
</tr>
<tr class="even">
<td>apt</td>
<td>Advanced Packaging Tools</td>
<td>Linux</td>
</tr>
<tr class="odd">
<td>arg</td>
<td>argument</td>
<td>|</td>
</tr>
<tr class="even">
<td>ARP</td>
<td>Address Resolution Protocol</td>
<td>TCP/IP</td>
</tr>
<tr class="odd">
<td>awk</td>
<td>Aho Weinberger and Kernighan (此命令为三位作者的名字)</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>bin</td>
<td>binary</td>
<td>|</td>
</tr>
<tr class="odd">
<td>cat</td>
<td>concatenate</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>cd</td>
<td>change directory</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>chkTeX</td>
<td>check LaTeX</td>
<td>LaTeX</td>
</tr>
<tr class="even">
<td>ch</td>
<td>change</td>
<td>|</td>
</tr>
<tr class="odd">
<td>chmod</td>
<td>change mode / change permissions</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>clk</td>
<td>clock</td>
<td>|</td>
</tr>
<tr class="odd">
<td>cp</td>
<td>copy</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>CV</td>
<td>Computer Vision</td>
<td>Computer Vision</td>
</tr>
<tr class="odd">
<td>cwd</td>
<td>current working directory / chang working directory</td>
<td>|</td>
</tr>
<tr class="even">
<td>dir</td>
<td>directory</td>
<td>|</td>
</tr>
<tr class="odd">
<td>dst</td>
<td>destination image</td>
<td>computer vision</td>
</tr>
<tr class="even">
<td>env</td>
<td>environment</td>
<td>|</td>
</tr>
<tr class="odd">
<td>g</td>
<td>global / generate</td>
<td>|</td>
</tr>
<tr class="even">
<td>GFW</td>
<td>Great Fire Wall</td>
<td>GFW</td>
</tr>
<tr class="odd">
<td>grep</td>
<td>global regular expression and print</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>img</td>
<td>image</td>
<td>cv</td>
</tr>
<tr class="odd">
<td>int</td>
<td>integer</td>
<td>|</td>
</tr>
<tr class="even">
<td>LANCE</td>
<td>Local Area Network Controller for Ethernet</td>
<td>CISCO router</td>
</tr>
<tr class="odd">
<td>lib</td>
<td>library</td>
<td>|</td>
</tr>
<tr class="even">
<td>ln</td>
<td>link</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>ls</td>
<td>list</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>mkdir</td>
<td>make directory</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>mnt</td>
<td>mount</td>
<td>Linux</td>
</tr>
<tr class="even">
<td>mv</td>
<td>move</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>passwd</td>
<td>password</td>
<td>Linux command</td>
</tr>
<tr class="even">
<td>pkg</td>
<td>package</td>
<td>|</td>
</tr>
<tr class="odd">
<td>pwd</td>
<td>present working directory / password</td>
<td>Linux command / |</td>
</tr>
<tr class="even">
<td>pts</td>
<td>pseudo tty slave</td>
<td>Linux / Unix</td>
</tr>
<tr class="odd">
<td>pty</td>
<td>pseudo tty</td>
<td>Linux / Unix</td>
</tr>
<tr class="even">
<td>q</td>
<td>quit</td>
<td>|</td>
</tr>
<tr class="odd">
<td>rc</td>
<td>run command / run configure</td>
<td>Linux初始化文件</td>
</tr>
<tr class="even">
<td>rm</td>
<td>remove</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>RPM</td>
<td>Redhat Package Manager</td>
<td>Linux</td>
</tr>
<tr class="even">
<td>sed</td>
<td>stream editor</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>shebang</td>
<td>hash bang (#!)</td>
<td>|</td>
</tr>
<tr class="even">
<td>src</td>
<td>source / source image</td>
<td>web / cv</td>
</tr>
<tr class="odd">
<td>ssh</td>
<td>Secure Shell</td>
<td>|</td>
</tr>
<tr class="even">
<td>ssr</td>
<td>Socket Shell R</td>
<td>GFW</td>
</tr>
<tr class="odd">
<td>stat</td>
<td>status</td>
<td>|</td>
</tr>
<tr class="even">
<td>str</td>
<td>string</td>
<td>|</td>
</tr>
<tr class="odd">
<td>sys</td>
<td>system</td>
<td>|</td>
</tr>
<tr class="even">
<td>tar</td>
<td>tape archive</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>TLDR</td>
<td>Too Long; Didn't Read 指前面太长没看, 此部分为概述性文字</td>
<td>|</td>
</tr>
<tr class="even">
<td>tty</td>
<td>teletype, 通常指物理形式的终端</td>
<td>Linux / Unix</td>
</tr>
<tr class="odd">
<td>usr</td>
<td>Unix Shared/Software/System Resources</td>
<td>Linux / Unix</td>
</tr>
<tr class="even">
<td>wc</td>
<td>word count</td>
<td>Linux command</td>
</tr>
<tr class="odd">
<td>yum</td>
<td>Yellow Dog Updater</td>
<td>Linux</td>
</tr>
</tbody>
</table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>我打算换电脑了</title>
    <url>/zh-CN/2019/03/30/%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/</url>
    <content><![CDATA[<p>行吧, 电脑城是真的坑. 这辈子不会进电脑城了. 不会真香的.</p>
<a id="more"></a>
<h2 id="吐槽一下">吐槽一下</h2>
<p>我现在的电脑是刚入大学时买的, 在电脑城😁. 我进大学被一群大佬带飞之前是个纯小白, 每天打开电脑跟随360提示赚取积分那种. 后来在群里窥视大佬们聊天, 学到了第一课:</p>
<p>什么? <strong>360杀毒是毒瘤?</strong> 什么? <strong>电脑城就是个坑?</strong></p>
<p>我开始是不太信的, 后来我格式化了电脑告别360. 再后来我在小米之家看着和我电脑同价位但配置好许多的电脑沉默了一会.</p>
<p><strong>但是!!</strong> 这次出的幺蛾子让我忍不了. 前几天电脑刚开机就弹出👇</p>
<figure>
<embed src="我打算换电脑了/HardDiskProblems.png?50"><figcaption>hard disk problems detected</figcaption>
</figure>
<p>什么? <b style="color:red;">我硬盘快挂了?</b> 当时把我吓坏了, 还以为我硬盘要爆炸了, 点开了 <strong>Disks</strong> 工具的 <strong>SMART Data &amp; Self-Tests</strong>.</p>
<figure>
<img alt="self-test" data-src="我打算换电脑了/self-test.png"><figcaption>self-test</figcaption>
</figure>
<p>我???</p>
<p>上网搜索了一下<a href="https://help.ubuntu.com/stable/ubuntu-help/disk-check.html.en" target="_blank" rel="noopener">年老的硬盘就容易出这种事</a>. 加上那个self-test也说我硬盘 <strong>Old-Age</strong> 了, 最多也就该有<strong>50</strong>个的坏道我现在有<strong>16376</strong>个, 那大概硬盘是真的快挂了吧. 行吧.</p>
<p>秋头麻袋. 我这电脑才买了一年啊💢 我和几个群友交流了一下自认使用习惯还是不算差, 虽然没有及时发现坏道并隔离 (我才知道这玩意还能传染) 是我的锅, 但铁定我买来这电脑就有点问题. 忍不了💢</p>
<h2 id="信息整理">信息整理</h2>
<p>顺便整理一下我从群友们那听来的购买笔记本电脑的知识点好了:</p>
<ul>
<li><p>只是编程不打游戏的话主要关注<strong>内存大小</strong>和<strong>硬盘读写速度</strong>就好了. (机械硬盘是不能要的, 这我已经得到血泪教训了)</p></li>
<li><p>笔记本电脑的话不管 <strong>i5</strong>, <strong>i7</strong> 还是 <strong>i9</strong> 区别很小, 因为一般散热性能都不够, 处理器升温之后性能下降, 基本性能差不多. 也就是说为了省钱买 <strong>i5</strong> 就可以了. 当然有钱肯定是 <strong>i9</strong> 走着.</p></li>
<li><p><strong>显卡</strong>一般也就游戏, 设计, 科学计算会用到的样子, 因此我这不打游戏的直男程序员就不需要太好的显卡了 (但我发现显卡过于差的话放PPT都卡)</p></li>
<li><p>虽然几个群友强烈安利我买有至少有2k画质显示屏的电脑, 或者买来后自己换一个屏幕, 因为2k以上分辨率的屏幕体验极佳. 但他们都说<strong>看惯了2k完全不适应1080P</strong>. 那我当然是只买1080P啊😁 另外个人觉得干活用的电脑没必要弄触屏屏幕, 鼠标都嫌打断思路, 更何况触摸屏.</p></li>
<li><p>虽然linux也是用户群体极大的系统, 但linux对一些硬件设备支持相当的差, 比如有人蓝牙经常断之类. 网上也有许多地方列出了一些公认linux支持不错的电脑. 我看了一圈感觉<strong>ThinkPad</strong>和 <strong>Dell</strong> 都值得信赖. 我还翻到了个<a href="https://certification.ubuntu.com/certification/desktop/" target="_blank" rel="noopener">Ubuntu 个人电脑认证硬件</a>. 不明觉厉.</p></li>
<li><p>另外个人觉得比较重要的一点是<strong>键盘背光灯</strong>! 晚上不开灯没有背光的话真的只能埋头打字啊!</p></li>
<li><p>很多电脑虽然 <strong>处理器, 内存, 显卡, 硬盘, 屏幕</strong> 这几项是一样或者相当的, 但价格相差很多. 这是因为其他方面有关. 比如说 <strong>电池容量</strong> (和续航能力有比较大的关系), <strong>接口数量及类型</strong> (比如有几个雷电3), <strong>电脑外壳材质</strong> (比如X1C是碳纤维外壳), 是否有<strong>指纹识别器</strong> (现在Linux下也有指纹识别器的驱动了, 似乎<em>可以拿来输入sudo的密码</em>), 是否有<strong>红外摄像头</strong> (这个linux下似乎没有相关驱动, 目前唯一用处似乎就是Windows Hello), <strong>可拓展性</strong> (比如ThinkPad T480可以把内存加到32G, 而T480S最多只能加到24G), 键盘手感 (我倒是一直用不惯机械键盘😒), <strong>售后服务</strong>等</p></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Verilog杂记</title>
    <url>/zh-CN/2019/05/21/Verilog%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>Verilog学习笔记.</p>
<p>这学期上了数字电路课, 从最开始的了解每个逻辑门的物理工作原理到学习每个组合电路, 时序电路元件是如何由逻辑门构成的, 再到后来跟着指导书设计出了很简易的8位CPU, 我个人是觉得很震撼的. 这也让我小时候的一个问题得到了解答: 集成电路这么复杂的东西真的是人能设计出来的吗? 其实我一直是知道答案的, 这些小黑块既不可能是土里长出来的也不可能是从什么动物身上割下来的. 我只是一直不敢想象这么复杂而精妙的东西 (即便是一根充电线里的小巧电路也不是那时的我能弄清的). 最近我稍微体会到了那群伟大的工程师们是如何设计出了那样精密的芯片的: 不断积累基本模块. 实际上从最开始的黑底白字的电脑系统到现在繁华多样的炫酷系统, 也是很令人震撼的变化. 虽然大佬可能会觉得这些很简单, 但我仍认为该对这些技术保持敬畏之心.</p>
<a id="more"></a>
<h1 id="quartus与modelsim的安装">Quartus与Modelsim的安装</h1>
<p>🔗 <a href="https://blog.csdn.net/weixin_38071135/article/details/82531594" target="_blank" rel="noopener">quartus16.1和modelsim-altera for linux的安装</a><br>
🔗 <a href="https://coldnew.github.io/ce6f7a0a/" target="_blank" rel="noopener">DE2-115 開發紀錄: 在 Linux 下使用 ModelSim</a></p>
<p>参考上面两个链接 (后者算是对前者的补充)我成功在Ubuntu1804下安装了Quartus和Modelsim. 因为我懒得注册论坛帐号, 我并没有使用第一个链接中提供的破解文件, 而是使用了<a href="https://tsuhuai.wordpress.com/2015/02/17/altera-quartus-crack-for-linux-version/" target="_blank" rel="noopener">这里</a>提供的 15.0版的crack. 我装的也是15.0版的Quartus和Modelsim, 但问题和解决方法是一样的.</p>
<p>⭐️后来我发现Linux下用<a href="http://www.geda-project.org/" target="_blank" rel="noopener">gEDA</a>这个项目应该体验也很不错. 其中用<strong>icarus</strong>综合, 编译verilog代码, 用<strong>gscheme</strong>生成原理图, 用<strong>gtkwave</strong>看仿真波形图.</p>
<h1 id="verilog开发流程">verilog开发流程</h1>
<p>🔗<a href="https://copyfuture.com/blogs-details/83fc5f52af0e6c318e3c5cfa5baf2ac0" target="_blank" rel="noopener">Verilog代码和FPGA硬件的映射关系</a> 这里通过一个例子清晰的展示了Verilog代码是怎样一步步映射到FPGA的基本逻辑单元的👍</p>
<h2 id="编写代码实现功能">编写代码实现功能</h2>
<h2 id="验证功能仿真">验证功能(仿真)</h2>
<h2 id="编译">编译</h2>
<h3 id="语法分析">语法分析</h3>
<h3 id="综合">综合</h3>
<p>综合是把RTL级别的, 抽象层次较高的硬件代码综合成抽象层次较低的电路网表, 是一个具体优化+映射的过程, 能够对应到门级逻辑.</p>
<h3 id="适配">适配</h3>
<p>把综合后的具体数字逻辑映射到指定型号的FPGA器件中去, 包括选择哪一些基本逻辑单元 (主要包含LUT和寄存器单元) 以及布局布线等.</p>
<h2 id="下载">下载</h2>
<p>下载是将整个编译过程完成的可下载二进制信息通过下载线从计算机端传递到FPGA开发板端, 并完成FPGA 内部电路的具体配置(LUT中的存储信息以及连接线的连接开关设置等等), 形成具有相应功能的功能电路.</p>
<h1 id="代码风格与语法纪要">代码风格与语法纪要</h1>
<h2 id="有关模块">有关模块</h2>
<p>🔗 <a href="http://jason0214.lofter.com/post/30cbe4_12a8f72" target="_blank" rel="noopener">关于Verilog的模块思想和模块的引用</a></p>
<blockquote>
<p>Verilog的开发应是<strong>自顶向下</strong>的，<strong>模块化</strong>的.</p>
</blockquote>
<p>一个系统由总设计师先进行系统描述(Spec), 将系统划分为若干模块, 编写模块模型(一般为行为级), 仿真验证后, 再把这些模块分配给下一层的设计师, 由他们完成模块的具体设计, 而总设计师负责各模块的接口定义.</p>
<blockquote>
<p>链接引用模块端口时, 注意括号内的是当前模块的端口, 括号外的是引用模块的端口.</p>
</blockquote>
<p>❗️一开始我看到Verilog中模块就像面向对象中的类一样, 调用模块也神似类的实例化, 曾以为其中有面向对象的思想, 后来发现我太想当然了: 面向对象的三大特征 (封装, 继承, 多态) 它只满足了封装, 显然不能算面向对象. 硬要说的话verilog包含了<strong>面向对象</strong>的思想, 而面向过程的程序设计方法正是: "自顶向下, 逐步求精". 当然, <strong>要时刻牢记Verilog是一门硬件语言</strong>.</p>
<p>一个模块可以采用以下方式描述设计:</p>
<ul>
<li>数据流方式</li>
<li>行为方式</li>
<li>结构方式</li>
<li>混合</li>
</ul>
<h2 id="有关always">有关always</h2>
<p><code>always</code>实际上就是循环关键字, 而<code>always @()</code>则是条件循环关键字.</p>
<p>always块的讲究很多:</p>
<ol type="1">
<li>写在括号内的称<strong>敏感事件列表</strong>, 当这些事件 (电平信号变化或者出现边沿信号) 发生时触发这个块. 一个敏感事件列表中不能同时包含电平敏感事件和边沿敏感事件. <strong>电平敏感事件意味着这是一个描述组合逻辑的always块</strong> (我们也可以在描述组合逻辑的always块的敏感事件列表中填<code>*</code>来让综合器根据always块内容来自动添加敏感事件), <strong>边沿敏感事件意味着这是一个描述时序逻辑的always 块</strong>.</li>
<li><strong>尽量只使用主时钟 (clk, rst) 作为always块的边沿敏感事件</strong>, 避免出错. 如果有其他信号边沿触发的事件可以通过<a href="https://blog.csdn.net/phenixyf/article/details/46364193" target="_blank" rel="noopener">这里</a> 提到的clk周期延时法将边沿触发转换为电平触发.</li>
<li><strong>不要将同一信号的上升沿敏感事件和下降沿包含在同一敏感事件列表</strong>, 因为它们可以合为一个电平敏感事件.</li>
<li><strong>尽量不要在多个always块中给同一变量赋值</strong>, 这样容易产生竞争冒险 (所有always块同时运行), 且无法综合. 如果一个变量的值与两个always块都有关且这两个always块无法合并, 可以参考<a href="https://blog.csdn.net/gududeyhc/article/details/8795202" target="_blank" rel="noopener">这种方法</a>. 另外也可以考虑用两个 always块的敏感事件生成一组新的敏感事件 (参考第二条).</li>
<li><strong>一个always块中不能混用阻塞赋值 (=) 和非阻塞赋值 (&lt;=)</strong>, 在描述组合逻辑的always块中使用 <code>=</code>, 在描述时序逻辑的always块中使用<code>&lt;=</code>.</li>
<li><p><strong>always块中的条件语句要与敏感事件相对应.</strong> 比如以下两段代码前者是错误的, 后者是正确的.</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rst)</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst)</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="关于default">关于default</h2>
<p>在写case块时发现所有示例里都写出了default这种情况, 无论情况是否完备. 这让我有了两个问题:</p>
<ul>
<li>为什么一定要有default这种情况?</li>
<li>default情况该给变量赋什么值?</li>
</ul>
<h3 id="为什么一定要有default这种情况">为什么一定要有default这种情况</h3>
<p>一些参考资料:</p>
<p>🔗<a href="https://blog.csdn.net/wordwarwordwar/article/details/80299636" target="_blank" rel="noopener">FPGA 和ASIC开发的区别</a></p>
<p>🔗<a href="https://www.eetoday.com/application/control/201806/1537.html" target="_blank" rel="noopener">当ASIC和FPGA之间的界限日益模糊，FPGA跟ASIC还有啥区别</a></p>
<p>🔗<a href="https://www.zhihu.com/question/20555065/answer/20357525" target="_blank" rel="noopener">知乎-请问：FPGA,PLD,CPLD,PLC,DSP什么区别？看他们的定义觉着都是可编程的逻辑器件</a></p>
<p>🔗<a href="https://forums.xilinx.com/t5/%E7%BB%BC%E5%90%88%E8%AE%A8%E8%AE%BA/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%AF%9B%E5%88%BA%E7%8E%B0%E8%B1%A1/td-p/295029" target="_blank" rel="noopener">组合逻辑设计中的毛刺现象</a></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span><a href="https://blog.csdn.net/surgeddd/article/details/4683657" target="_blank" rel="noopener">锁存器、触发器、寄存器和缓冲器的区别</a></p>
<ol type="1">
<li><p>避免产生Latch.</p>
<blockquote>
<p>latch是一种对脉冲电平敏感的存储单元路径，可以在特定输入脉冲作用下改变电平</p>
</blockquote>
<p>由这个描述我们可以看出<strong>在if-else结构和case结构中很容易产生latch</strong>: 当遇到在当前情况没有赋值的变量或遇到没有定义的情况时需要沿用上一时刻的值, 因此我们需要一个<strong>存储上一时刻状态的器件</strong>, 并且是电平触发的 (if-else和case的判断条件都是电平), 这就是为什么latch会出现. 在 <a href="https://blog.csdn.net/u012923751/article/details/79475568?comment_content=%E6%84%9F%E8%B0%A2%21&amp;comment_replyId=&amp;article_id=79475568&amp;comment_userId=&amp;commentId=" target="_blank" rel="noopener">这篇文章</a>有控制语句产生latch的实例, 在<a href="https://zhuanlan.zhihu.com/p/34408492" target="_blank" rel="noopener">这篇文章</a>中有latch产生原因的详细讨论.</p>
<p>❗️ 值得注意的是, 即便if-else结构或者case结构完整了也并不能保证不会产生latch, 只是避免了因这种情况产生的latch.</p>
<p>至于为什么要避免产生latch, 因为此处产生的latch容易产生毛刺.</p>
<p>❗️ 此处的Latch特指PLD中的latch. 因为latch在实现同一功能时需要的门比用FF实现少, 在ASIC 开发中latch使用较多 (ASIC的设计中可以保证latch信号的质量). 而由于PLD芯片中的基本单元是查找表和触发器, 没有标准的latch单元, 因此FGPA中的latch更耗资源, 也容易产生毛刺. 并不是所有latch都容易产生毛刺.</p></li>
<li><p>方便调试</p>
<p>如果default对应的情况是不应当出现的情况, 在仿真时可以将default情况下的变量赋值为不定态X, 方便看出问题.</p></li>
<li><p>这已经是一种代码规范, 最好养成严谨的习惯, 避免出错.</p></li>
</ol>
<h3 id="default情况下该赋什么值">default情况下该赋什么值</h3>
<p>如果default对应的情况不应当出现, 在仿真时将变量都赋值为不定态X, 方便看出错误 (在Modelsim里不定态的信号会显示为红色), 在实际应用时全部置零 (复位态).</p>
<h2 id="关于wire和reg">关于wire和reg</h2>
<p>🔗<a href="https://www.zhihu.com/question/21021718/answer/17195122" target="_blank" rel="noopener">知乎-Verilog 中定义信号为什么要区分 wire 和 reg 两种类型？-屯屯屯屯的回答</a></p>
<p>🔗<a href="https://www.zhihu.com/question/21021718/answer/28802850https://www.zhihu.com/question/21021718" target="_blank" rel="noopener">知乎-Verilog 中定义信号为什么要区分 wire 和 reg 两种类型？-BruceX的回答</a></p>
<p>🔗<a href="https://link.zhihu.com/?target=http%3A//inst.eecs.berkeley.edu/~cs150/Documents/Nets.pdf" target="_blank" rel="noopener">UC Berkley讲义-Verilog: wire VS. reg</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
        <category>语言</category>
        <category>Verilog</category>
      </categories>
  </entry>
  <entry>
    <title>为什么我用Linux而不是Windows</title>
    <url>/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/</url>
    <content><![CDATA[<h1 id="更新">更新</h1>
<p>又过了一段时间, 我觉得对于这个问题我已经不在需要去想那么多理由来说服自己了. 在习惯了在Linux开发后我再在Windows试着做点小东西便发现这一切比起在Linux下来得束手束脚得多. 没有强大而美观的终端, 无法只通过编辑配置文件就轻松对软件进行配置, 无法一个命令改变文件权限, 系统语言为中文时的默认编码格式为cp936有时候也会给开发带来麻烦... 更别说windows没有强大的包管理工具...总之<strong>一切Windows防止普通用户误操作的措施让开发者变得十分拘束</strong>.</p>
<p><strong>WSL也不顶用</strong>. 我也一度十分推崇WSL, 但体验了一天不到我就果断删除了. <strong>我连自己环境都没配出来!</strong> 目前的WSL还bug很多, 比如我的终端字体根本不能正确显示 (这很重要好吧), 比如在Windows系统和WSL同时对一个文件进行了操作似乎会造成文件权限问题, 再比如我在Ubuntu1804的WSL中执行<code>sudo apt install pip</code>结果报错了... (这个问题并不只有我一个人遇到)</p>
<a id="more"></a>
<h1 id="前言">前言</h1>
<p>虽然上大学前我是完全没听说过Linux的 (不是Linux不nb是我太菜), 但进大学后身边人人都说他好, 我也就早早地开始接触它. 从最开始在Win10上在虚拟机里装了Ubuntu16.04摸了几把, 到发现双系统爆炸好装就顺手装上了Ubuntu18.04体验, 到现在思考为什么我要用Linux, 思考要不要试试Ubuntu之外的Linux 系统, 感觉自己对Linux还是有了一定的了解.</p>
<p>在我刚装了双系统时就有同学问我Linux到底咋好, 我当时也没太体会出, 就一气胡说, 什么"没有毒瘤360" 啊, "不像Windows下乱七八糟的软件有各种开机加载项, 我这快坏掉的电脑运行Linux系统开机快"啊 (当时我的硬盘刚出现<a href="https://leojhonsong.github.io/zh-CN/%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/">要爆炸的迹象</a>), 总之我当时也说不上Linux哪里好到值得我不用Windows和它的Office套装.</p>
<h1 id="相关链接">相关链接</h1>
<p>因此当最近我再次想起这个问题时我进行了一番搜索:</p>
<ul>
<li>首先我搜了Linux和Windows的比较, 发现其实问题并不是"Linux比Windows好在哪"而是"Linux和 Windows哪个好?"</li>
</ul>
<p>🔗<a href="https://www.zhihu.com/question/24439007/answer/27872778?utm_source=qq&amp;utm_medium=social&amp;utm_oi=575568675688419328" target="_blank" rel="noopener">知乎话题-微软的 Web 服务器为何能屹立不倒？</a></p>
<p>🔗<a href="https://www.michaelhorowitz.com/Linux.vs.Windows.php" target="_blank" rel="noopener">LINUX vs WINDOWS</a></p>
<ul>
<li>然后我想到了解Linux和Windows的起源来发现他们设计理念, 运行方式的差异.</li>
</ul>
<p>🔗<a href="https://www.bbsmax.com/A/mo5kVo2JwR/" target="_blank" rel="noopener">操作系统Unix、Windows、Mac OS、Linux的故事</a></p>
<p>🔗<a href="https://linux.cn/article-3789-1.html" target="_blank" rel="noopener">一段关于 Unix 与 Linux 的暗黑史</a></p>
<p>我顺便搜了一下Linux在电影行业的应用</p>
<p>🔗<a href="https://blog.csdn.net/neo_liukun/article/details/6787507" target="_blank" rel="noopener">Linux与电影制作</a></p>
<ul>
<li>还有些杂乱的</li>
</ul>
<p>🔗<a href="https://www.jianshu.com/p/71158a9c8d03" target="_blank" rel="noopener">浏览黑暗网络的操作系统：Windows，Mac还是Linux？</a></p>
<p>🔗<a href="https://en.wikipedia.org/wiki/Comparison_of_operating_systems" target="_blank" rel="noopener">Comparison of operating systems</a></p>
<p>🔗<a href="https://meta.stackexchange.com/questions/10369/which-tools-and-technologies-are-used-to-build-the-stack-exchange-network" target="_blank" rel="noopener">What tools and technologies are used to build the Stack Exchange Network?</a></p>
<p>🔗<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Netperf-Windows-Linux" target="_blank" rel="noopener">Some Windows Server 2016 vs. Linux Network Benchmarks</a></p>
<p>🔗<a href="https://www.zhihu.com/question/19818863" target="_blank" rel="noopener">京东用 .NET 架构的原因是什么？</a></p>
<p>🔗<a href="https://www.zhihu.com/question/50117613/answer/119798303" target="_blank" rel="noopener">如何评价微软的 UI 设计？</a></p>
<h1 id="信息整理">信息整理</h1>
<p>我们可以发现虽然Linux是在服务器领域发家的, 但现在Windows也在服务器领域占领了不小的份额. 并且在某些领域比起Linux反而Windows更受青睐. 很有意思的是在银行业Unix因为稳定性被使用, 而Windows 因为能提供因为Windows系统的原因出现的损失提供补偿而被使用, Linux看起来在银行业倒是没几家使用的样子.</p>
<p>实际上Linux和Windows在各方面的性能上并无什么差异, 让人们决定到底选择Linux还是Windows的因素我觉得可以<strong>主要</strong>可以分<strong>服务器领域</strong>和<strong>个人电脑领域</strong>两个方面来讨论.</p>
<h2 id="服务器领域">服务器领域</h2>
<p>服务器都是公司在使用, 而公司是一定要赚钱的 (就算是非营利组织也是要靠钱来维持的), 因此很多决定因素都和💰有关.</p>
<p>因为是公司用的服务器, 因此很容易受到攻击, 另外因为很可能保存有公司重要资料因此要有公司内部人员来管理, 开发. 然后我们就看到: <strong>中小型IT企业普遍选择Windows, 而大型IT企业更倾向于选择Linux.</strong></p>
<p>❗️</p>
<ul>
<li>此处仅讨论IT领域, 因为其他领域我没了解到那么多, 并且讨论价值没那么大, 比如文学界的数据库服务器我不认为会使用Linux系统</li>
<li>此处的中小型公司指有一定技术水准的程序员的数量较少, 反之大型公司指技术实力雄厚的, 比如BAT</li>
</ul>
<p>中小型IT企业更青睐Windows是因为:</p>
<ol type="1">
<li>Window<strong>s学习成本相对低</strong>, 甚至微软能提供良好的技术支持.</li>
<li>使用Linux看似省下了Windows激活码的钱, 但却需要大量资金来养一批有实力的技术人员在公司里才能达到或者超过使用来自微软的服务的体验 (紧急情况处理, 技术支持, 损失赔偿等), 对人手不够的公司来说Windows是个很好的选择. 就比如 Stack Exchange这公司, 还是很nb吧, 但人家的服务器一直在Windows平台使用微软的方案, 因为这公司一共就一百多人, 还分散在世界各地. 他们很明显没有足够的人手去搞骚东西, 而微软的服务很好地解决了他们的烦恼: 俺们就是想<strong>省心</strong>.</li>
<li>有许多银行也会使用Windows, 因为<strong>微软能为损失背锅</strong>. 另外不算各巨头公司的魔改的话Windows 系统的<strong>安全性很高</strong>, 毕竟他的源码是闭源的, 更不容易被人发现0day漏洞, 而微软的事故响应也很快, 比开源社区修bug不知快到哪去了. 经常有人认为Linux系统公布了源码, 那各位大牛肯定早把它修补得差不多了, 但事实并非如此, Linux也有许多漏洞, SUSE就曾爆出过重大漏洞. 而与Linux 有血缘的Unix则是因为在贝尔实验室已经经历了十数年的打熬, 才能做到如今的稳定性.</li>
</ol>
<p>而大型公司则是相反, 因为技术雄厚因此更愿意用Linux这样的开源系统, 甚至基于Linux魔改. 比如Google 就糊了<em>Goobuntu</em>, <em>gLinux</em>内部使用. 这些公司有钱有人, 那当然是选择高度定制化, 自己能完全把控的系统. 而没人会去魔改Windows拿来用, 那太骚了.</p>
<h2 id="个人电脑领域">个人电脑领域</h2>
<p>以下的观点就主观一些了, 毕竟本文标题是 "我为什么用Linux" 😁</p>
<p>其实在PC端Windows各方面都有着很不俗的表现, 抛开游戏方面不谈 (这方面当然是Windows更合适, 但我是不打游戏的).</p>
<p>比如<strong>办公方面</strong>吊打Linux: Word, PPT, Excel, OneNote为首的Office套件实在好用, 虽然这些软件在Linux上可以访问网页版, 但经我测试有许多有用功能网页版并不具备. (OneDrive现在能在Linux很好的使用了倒是一大喜事) 无论WPS还是LibreOffice都存在很严重的图文串位问题. 至于 Latex在Linux平台体验并没有和Windows平台有什么区别.</p>
<p>再比如<strong>驱动方面</strong>, Windows确实比Linux做得好不少, 驱动比Linux全很多 (就比如很多电脑刚装了 Linux会有显卡, 网卡, 蓝牙等各种各样驱动问题而且解决起来没有在Windows那么容易). 甚至很多做硬件相关的企业都用Windows. 很多设备只做了Windows平台的驱动, 但我是没听说过只做了Linux平台驱动的设备.</p>
<p>而在<strong>美观程度</strong>方面个人认为只要想做, Linux桌面可以做到高度个性化, 因此可以很美观, 不像在 Windows即便你觉得什么东西丑爆了你也只能按照Windows的规矩来个性化. 即便自己配置觉得麻烦也可以直接偷别人的配置. 比如我打算以后按<a href="https://www.zhihu.com/question/26031045/answer/356288402" target="_blank" rel="noopener">这个样子</a> 折腾一番, 实在炫酷.</p>
<p>但要说到<strong>开发方面</strong>我认为Linux是比Windows好的选择. 无赖一点的解释: 既然以后在IT界很有可能需要用Linux, Linux学习成本又不低, 那何不早些接触Linux? 在微软实习的学长说他觉得那里的人人均会 Linux. 曾经看到说我们身周的设备90%以上用的系统都是Linux (虽然我觉得有点过了但反正极多, 而 Windows IoT才起步). 在和目标平台相同的平台上开发能提高发现问题的可能性. 另外Linux上没有 Windows上那么多针对普通用户设置的开关, 不会还需要自己开启IIS之类. 而且Linux不使用 <code>\\</code> 作为文件夹名称分割符, 感觉没那么容易混乱. 再有Windows自带的Windows Defender过于烦人, 默认设置甚至会实时扫描所有进程, 占用很多内存. 然后Linux文件以<code>LF</code>为换行符, 而Windows以<code>CLRF</code>为换行符, 因此到了Linux强迫症表示Git提交时再也看不到将文件从CRLF转到LF的提示了😁. Linux的好处太多啦, 还有环境好配, 命令行比图形界面更能让人提高效率等...</p>
<p>而还有一点超脱以上所有并且十分重要的原因: <strong>生态</strong>.</p>
<p>如果你要使用的工具, 祖传代码, 社区已有的成果, 公司生态等逼着你用Linux, 你又能有什么办法.</p>
<hr>
<p>我又发现了Windows可以diss的地方: 编码方式.</p>
<p>实例参见<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81">这里</a>. 这里有详细的吐槽 🔗<a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">知乎-Windows记事本的ANSI, Unicode, UTF-8这三种编码模式有什么区别？-梁海的回答</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>有关字符集与编码</title>
    <url>/zh-CN/2019/05/29/%E6%9C%89%E5%85%B3%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>当我在解决<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81">Linux下解压zip文件的问题</a>时发现编码方面的问题还蛮多的, 在此记录.</p>
<a id="more"></a>
<h1 id="windows下编码方式的坑">Windows下编码方式的坑</h1>
<p>🔗 <a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">知乎-Windows记事本的ANSI, Unicode, UTF-8这三种编码模式有什么区别？</a></p>
<p>🔗 <a href="https://www.zhihu.com/question/20167122" target="_blank" rel="noopener">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个</a></p>
<p>总结一下, 在Windows中:</p>
<ul>
<li>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码</li>
<li>所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16</li>
<li>所谓的「UTF-8」指的是带 BOM 的 UTF-8</li>
</ul>
<p>之前一直听说Windows自带的记事本不要用, 会自动在文件开头加一个东西, 导致一些地方显示该文件开头有一个 "?" , 一直不知道是多了个啥, 原来是UTF-8/UTF-16编码的文件会在文件开头多一个 BOM. <strong>UTF-8与带BOM的UTF-8的区别在于带BOM的UTF-8文件开头有U+FEFF.</strong> 微软使用带BOM的UTF-8 的目的是将UTF-8与ASCII等编码方式区分开, 但这就导致了在很多时候UTF-8默认是不带BOM时文件读取有误.</p>
<h1 id="gbk不是一种编码格式">GBK不是一种编码格式</h1>
<p>GBK并不是一种编码格式, 而<strong>是一个字符集</strong>. 我觉得很low的是GBK的全称是 <strong>Guojia Biaozhun Kuozhan</strong> 🤦‍...low得不要不要的. 不过也可以理解, 毕竟这三个字母是从"国标扩"的首拼发展来的.</p>
<h2 id="自整理的中文字符集发展史">自整理的中文字符集发展史</h2>
<p>以下是我整理的中文字符集发展史:</p>
<ul>
<li>最开始中国国家标准化管理委员会发布了 <a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D79E19D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB/T2312-1980</code></a> (<strong>GB</strong>为<strong>国标</strong>首拼, <strong>T</strong>是<strong>推</strong>, 指推广, 非强制性的标准), 包括了<strong>6763</strong>个常用汉字, 发布以后许多有汉字的语言也采用了这个字符集. 但这个字符集很不够, 缺少很多生僻字, 繁体字, 对日本, 韩国汉字收录也很不全.</li>
<li>微软根据GB2312做出了<code>cp936</code> (code page936), 字符集方案为GB2312, 编码方案为 <strong>EUC-CN</strong>.</li>
<li>1993年<strong>Unicode1.1</strong>发布后国标委抄过来发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D7860AD3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 13000.1-1993</code></a>.</li>
<li>这时微软利用<strong>cp936</strong>中收录GB2312-1980后未使用完的码位收录了GB13000.1-1993的全部字符, 这样既兼容了GB2312又添加了许多字符. 这个新版本cp936最早实现于<strong>Windows95简体中文版</strong>. 这之后微软又陆陆续续给cp936加了几个字符. 直到2002年<a href="https://www.iana.org/assignments/charset-reg/GBK" target="_blank" rel="noopener">IANA将cp936的字符集注册为<code>GBK</code></a>. GBK共收录<strong>21886</strong>个汉字和图形符号.</li>
<li>再后来因为字符还是不全 (比如emoji什么的)以及其他原因发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D79585D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 18030-2000</code></a>, 在 Windows的对应代码页为<code>cp54936</code>. 但值得一提的是尽管2000年就有了新标准, 但Windows系统的系统语言为简体中文时的默认代码页仍为<strong>cp936</strong>. 原因可以参考<a href="https://linux.cn/article-1213-1.html" target="_blank" rel="noopener">这里</a>. 文章大意: 微软划水, 国家也没上心.</li>
<li>最近的一版标准字符集是<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D800B5D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 18030-2005</code></a>. 但这个好像有点复杂, 我并没有太看懂, 反正和之前的几个标准很不同. 怎么个不一样可以参考<a href="https://zhuanlan.zhihu.com/p/31643128" target="_blank" rel="noopener">这里</a>.</li>
</ul>
<h1 id="unicode与utf-8是不同层面的东西">Unicode与UTF-8是不同层面的东西</h1>
<p>我曾经以为Unicode是一种编码格式, 就像UTF-8是一种编码格式, 但后来我发现这两者根本是不同层面上的东西.</p>
<h2 id="unicode与ucs">Unicode与UCS</h2>
<h3 id="两者关系">两者关系</h3>
<p>与<strong>Unicode</strong> (统一码) 同一层面的概念是<strong>UCS</strong> (Universal Character Set, 通用字符集). UCS和Unicode分别由<strong>ISO</strong> (国际标准化组织) 和<strong>一帮软件制造商</strong> (Xerox, 苹果等成立了个统一码联盟) 先后发起. 后来他们才合并工作. 实际上两者是差不多的玩意. 我并不相信统一码联盟在成立时不知道ISO已经在开发UCS了 (UCS项目启动比Unicode早<strong>4年</strong>), 而在这样的情况下还要开发Unicode, 个人认为是商业原因. 直到现在这仍然是两个独立的项目, 但项目进度同步且两个组织都宣称要和对方<strong>保持兼容</strong>. 个人觉得很蠢🤷‍</p>
<h3 id="两者差异">两者差异</h3>
<p>硬要说的话其实Unicode与UCS有一些细节不同.</p>
<p>比如ISO/IEC 10646-1使用四种不同风格的变体来显示简体中文, 繁体中文, 日语, 韩语汉字, 但Unicode2.0中只有简体中文的变体. 因此有过日本人无法接受Unicode的说法. (现在应该是没这问题了)</p>
<p>应该还有小区别吧? 其他区别我不知道, 也懒得找了😁</p>
<h2 id="现代编码模型">现代编码模型</h2>
<p>Unicode是一套有些复杂的编码系统, 并不是单纯一个字符集方案或是一个编码方案, 而是构建出了一个 <strong>现代编码模型</strong>. (这段话对UCS同理)</p>
<p>这个模型分五层:</p>
<ul>
<li>抽象字符集(Abstract character repertoire)</li>
<li>编码字符集(Coded Character Set)</li>
<li>字符编码方式(Character Encoding Form)</li>
<li>字符编码方案(Character Encoding Scheme)</li>
<li>传输编码语法(Transfer Encoding Syntax)</li>
</ul>
<p>按我的理解: 抽象字符集是一个抽象字符的<strong>集合</strong>, 不关注字形, 更关注字意. 比如钟和鐘的抽象字符是同一个, 而编码字符集是一个<strong>映射</strong>, 规定把一个抽象字符映射到哪个<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">字符平面</a>, 哪个<strong>码点</strong>. 但这并不是一一映射, 为了兼容或者有的字 (比如CJK字) 可能有多个变体. 字符编码方式又称为"storage format", 我猜这是因为这一层<strong>将码点编码成码元</strong>(这里的编码方式就是<strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat, 包括UTF-8, UTF-16, UTF-32等方法), 而码元正是每次从文件中读取到的字符的格式.</p>
<p>Unicode编码模型详细阐述可以参考<a href="https://zhuanlan.zhihu.com/p/27026033" target="_blank" rel="noopener">这里</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>编码</category>
      </categories>
  </entry>
  <entry>
    <title>当我安利软体机器人时我在谈什么</title>
    <url>/zh-CN/2019/06/10/%E5%BD%93%E6%88%91%E5%AE%89%E5%88%A9%E8%BD%AF%E4%BD%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%97%B6%E6%88%91%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从小我就喜欢仿生机器人. 我敬畏着各种精妙的仿生设计和它们的设计者, 渴望着有朝一日我也能参与这样的工作. 当我看到波士顿动力的Atlas的仿生腿部结构时, 我就在想: 我们能不能造出人造人呢? 那时的我并没有想很多, 并不会去想这样浩大的工程的性价比, 并没有意识到背后的伦理问题, 只是出于一种探索, 好奇. 我也曾听到一句很有趣的话: &gt; "在一项技术成熟前不要谈论他的价值"</p>
<p>法拉第在回答一位贵族夫人对发电机的用处的质疑时就反问到: "婴儿能做什么呢?". 最近很火的<a href="https://www.bilibili.com/video/av54737593?from=search&amp;seid=16639379942704237214" target="_blank" rel="noopener">何同学对5G的看法</a> 也发人深省. 在他提醒后我才想起注意到有许多技术 (比如有款机器人的无线控制对传输速度要求很高, 4G无法满足)依赖于5G. 5G必将给我们的生活带来现在的我们无法想象的改变.</p>
<p>而<strong>软体机器人</strong>也必然是这样值得我们期待的技术.</p>
<a id="more"></a>
<p>我接触到的第一个软体机器人是<a href="https://journals.sagepub.com/doi/full/10.1177/1553350617745953" target="_blank" rel="noopener">一个集成在da Vinci内窥镜操作臂上的手术系统</a>. 它的灵活, 精准震撼了我.</p>
<p>📺 <a href="https://youtu.be/AI7M-JTC6_w" target="_blank" rel="noopener">这个视频</a><strong>感性地</strong>介绍了一些软体机器人能解决的需求, 实际应用, 研究方向.</p>
<blockquote>
<p>刚体机器人基本由电机控制, 需要精准控制, 对这些刚性机器人的运用倾向于<strong>专业化与 精确化</strong>, 它们很难表现出<strong>高度可变形能力与对复杂环境的适应性</strong>. 随着机器人运用 领域继续扩大, 医疗保健、复杂地形勘探等特殊领域对机器人提出了更加严苛的要求.</p>
</blockquote>
<p>🔗 <a href="https://zhuanlan.zhihu.com/p/30700859" target="_blank" rel="noopener">这篇文章</a>源自文力老师的报告, 讲到了软体机器人的定义, 发展历程, 发展趋势分析, 也有文老师举例从产生灵感到实现一个软体机器人的简述.</p>
<blockquote>
<p>所以从2011年到2017年, 这七年的时间内, 软体机器人从单一的材料过渡到了多材料, 再 到了智能材料, 最后有可能到生物材料, 这是一个发展的趋势. 所以从这个趋势结合起来 讲，未来的发展方向一定是它<strong>结合驱动、传感、变刚度、多功能的复合材料, 以及添加 软体机器人的控制方法</strong>. 目前控制方法这一块是比较欠缺的, 这是一个学术或者是创新 方面的一个主要的发展趋势.</p>
</blockquote>
<p>此处有个值得一提的概念: <strong>智能</strong>. 我目前的理解是: <strong>能与环境交互, 作出反馈</strong> (此处的智能和人工智能的智能不是一个含义)</p>
<p>目前主要的应用方向有:</p>
<ol type="1">
<li>抓持作业</li>
<li>医疗康复 (比如康复训练或助力)</li>
<li>复杂环境勘探</li>
<li>微创外科手术</li>
</ol>
<p>当然我相信随着探究会逐渐发现更多的, 令人震惊的应用前景.</p>
<p>而软体机器人崛起的同时刚体机器人并不会退出舞台. 在工业等机器人负责输出大力矩的环境它们是无可替代的. 软体机器人目前还无法输出很大的力矩, 当然我认为他们不必具备这种能力, 软体机器人和刚体机器人应当是<strong>互补的</strong>而非哪个一定更优于哪个.</p>
<p>这太酷了!</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Robotics</category>
        <category>Soft Robotics</category>
      </categories>
  </entry>
  <entry>
    <title>有关人工智能的一点思考</title>
    <url>/zh-CN/2019/06/21/%E6%9C%89%E5%85%B3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>以下仅为个人见解</p>
<a id="more"></a>
<p>突然思考了一下<strong>什么是人工智能?</strong></p>
<blockquote>
<p>从学科角度讲, 人工智能是一门研究 <strong>模拟, 延伸, 扩展人类智能</strong> 的学科</p>
</blockquote>
<blockquote>
<p>人工智能是在机器上实现的人类智能</p>
</blockquote>
<p>这两条是我比较认可的对人工智能的描述. 可以看出<code>人工智能</code>是相对于<code>人类智能</code>的一个概念, 理解起来既简单又困难. 要说简单, 人工智能可以很直观的理解为<strong>人为制造的智能</strong>, 要说难, 人们至今仍在探索<strong>什么是人类智能</strong>. 这是一个极其抽象的哲学概念. 实际上试图制造人工智能正是人们探索人类智能的途径之一: 能知道如何制造出一个智能了, 我们也就基本摸清什么是人类智能了.</p>
<p>目前人工智能的实现有三种研究方法:</p>
<ul>
<li><strong>功能模拟</strong>: 符号主义, 认为人工智能源自数理逻辑, 以及人类智能的基本单元是符号, 认知的过程是符号表示下符号运算的过程.</li>
<li><strong>结构模拟</strong>: 连接主义, 认为人工智能源自仿生学, 特别是人脑模型的研究, 主要模拟神经元生理机制.</li>
<li><strong>行为模拟</strong>: 控制论主义, 认为人工智能源自控制论, 原理是控制论及激励-响应控制系统.</li>
</ul>
<p>回顾了一番后我终于理清了之前一直不太懂的 <strong>人工智能, 机器学习, 深度学习的关系</strong>:</p>
<p><code>人工智能</code>是人们提出的一个理想化的概念, 在得出人类智能的定义前谁也没法说出到底什么是人工智能, 到底某机器是否具备人工智能. <code>机器学习</code>是人们以制造人工智能为目标造出的各种具有部分智能的东西, 而<code>深度学习</code>是其中从仿生角度出发的研究.</p>
<p>💡很有意思的是智能另有一个含义: <strong>能对环境作出反馈</strong>. 比如智能材料, 狭义的智能机器人等.</p>
<p>这番思考总结后我认为图灵测试并不能<strong>绝对</strong>判定一个东西是否具有人类智能.</p>
<p>一方面<strong>中文房间</strong>实验是很有力的反驳. 也许有人认为这个实验所假设的完美的指导书是不存在的, 是理想化的, 但实际上图灵测试也是这样的东西, 能够完美检测被测试者是否具有智能的测试是不存在的. 我们只需要足够大的"指导书"就能够应付图灵测试. 参考<code>无穷大</code> 的数学定义, 我们可以有这样的结论: <strong>假设我们以M来衡量一个图灵测试的测试范围, 对任意给定M测试范围的图灵测试, 我们总能写出这样的"指导书"X: X让机器在当前图灵测试内表现得像一个人</strong>.</p>
<p>另一方面是因为我认为人们目前对人类智能的认知是不够的. 打个比方: 牛顿得出三条牛顿定律, 被人们奉为铁律, 后来相对论推翻了它, 牛顿定律变为了只在低速情况下适用. 但相对论又是绝对正确的吗? 目前它还没被推翻. 而我们对智能的判别甚至还停留在以经验来判断的阶段. (这里又存在一个哲学问题了: 存在绝对的真理吗? 这里我们暂且不讨论.) 也许我们可以说图灵测试在当前对人类智能的认知水平下可以作为是否具有智能的标准, 但它是那样的简陋, 早晚是要被取代的.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>机器人案例学习</title>
    <url>/zh-CN/2019/06/10/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>正如我在 <a href="https://leojhonsong.github.io/zh-CN/about/">about</a> 中提到的, <strong>我立志为软体机器人领域贡献一份力</strong>, 那就先从积累开始吧. 在此记录我觉得很精妙的机器人, 或可以用于机器人的"东西", 参考学习💪</p>
<a id="more"></a>
<p>TODO</p>
<h1 id="cassie家族">Cassie家族</h1>
<h1 id="bdc家族">BDC家族</h1>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/zh-CN/2019/07/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.</p>
<p>经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了... 虽然我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知新, 再次"速成"一下.</p>
<a id="more"></a>
<h1 id="语句与行">语句与行</h1>
<p>C语言我感觉对格式要求蛮宽松的, 可以一行多个语句 (每个语句必须以<code>;</code>结尾), 也可以跨行写语句(在行末写<code>\</code>折行), 不像python对缩进都有严格要求.</p>
<p>🌟 代码风格的话我只认<strong>VS风</strong>, 就是Visual Studio格式化出来的样式. 是的我是<strong>大括号换行派</strong>!</p>
<p>💡 要注意的是预编译指令必须一行不能写多个语句, 但可以折行.</p>
<h1 id="注释">注释</h1>
<p>有两种方式</p>
<h2 id="推荐的方式">推荐的方式</h2>
<p>👇这种注释可以跨行写, 也可以在行内写</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="comment">/*comment*/</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*comment</span></span><br><span class="line"><span class="comment">comment</span></span><br><span class="line"><span class="comment">comment*/</span></span><br></pre></td></tr></tbody></table></figure>
<p>💡值得一提的是只要出现 <strong>/*</strong> 就会被识别为注释的开始, 如果想把y除z指向的内存的值赋给x写成下面这样是不行的.</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">x = y<span class="comment">/*z</span></span><br></pre></td></tr></tbody></table></figure>
<p>但这个问题也很好解决, 用空格或括号就能解决.</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">x = y / *z</span><br><span class="line">x = y/(*z)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="不推荐的方式">不推荐的方式</h2>
<p>这样只能单行注释</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">code  <span class="comment">// comment</span></span><br></pre></td></tr></tbody></table></figure>
<p>❗️要注意这种注释方式是借鉴自C++, 在C99中才被标准化, 而目前使用最广泛的是C89标准, 也就是说不使用是比较保险的.</p>
<h1 id="内存">内存</h1>
<p>C语言对内存的操作似乎很多, 也很注重内存管理.</p>
<p>C语言为内存的分配和管理提供了几个函数. 这些函数可以在 &lt;stdlib.h&gt; 头文件中找到.</p>
<p><strong>void *malloc(size_t size)</strong> 分配一块<code>size</code>大小的内存</p>
<p><strong>void *calloc(size_t num, size_t size)</strong> 分配一块储存了一个<code>num</code>长, 每个元素 <code>size</code>字节的内存并将所有位初始化为0</p>
<p><strong>void *realloc(void *ptr, size_t size)</strong> 重新分配内存, 把内存扩展到 newsize</p>
<p><strong>void free(void *ptr)</strong> 释放<code>ptr</code>所指向的内存</p>
<p>💡 malloc是memory allocate, realloc是reallocate, calloc不知道是啥.</p>
<h1 id="段与栈与堆">段与栈与堆</h1>
<p><strong>段</strong> (segmentation)是指二进制可执行文件内的区域,所有某种特定类型信息被保存在里面.可以用<code>size</code>命令得到可执行文件中各个段的大小. <strong>正文段</strong> (Text Segment)用于储存指令, <strong>数据段</strong> (Data Segment)用于储存已初始化的全局变量, <strong>BSS段</strong> (BSS Segment)用于储存未赋值的全局变量所需的空间.</p>
<p><strong>调用栈</strong>并不储存在可执行文件中,而是在运行时创建.调用栈所在的段称为堆栈段(Stack Segment). 和其他段一样, 堆栈段也有自己的大小, 不能被越界访问, 否则就会出现段错误 (Segmentation Fault). 这种情况叫<strong>栈溢出</strong>.</p>
<p>栈空间有多大和操作系统相关. 在Linux中, 栈大小是由系统命令<code>ulimit</code>指定的, 例如 <code>ulimit -a</code>显示当前栈大小, 而<code>ulimit -s 32768</code>将把栈大小指定为32MB. 但在Windows 中, 栈大小是储存在可执行文件中的. 使用gcc可以这样指定可执行文件的栈大小: <code>gcc -Wl,--stack=16777216</code>, 这样栈大小就变为16MB</p>
<p>💡 栈溢出不一定是递归调用过多导致的, 也可能是局部变量太大. 因此<strong>较大的数组建议储存为全局变量</strong>.</p>
<p><strong>栈</strong>是由编译器在需要时分配的, 不需要时自动清除的变量存储区. 里面的变量通常是局部变量, 函数参数等. <strong>堆</strong>是由<code>malloc()</code>函数分配的内存块,内存释放由程序员手动控制, 在C语言由<code>free()</code>完成.</p>
<h1 id="数组">数组</h1>
<p>较大的数组应在main函数之外声明.</p>
<p><code>memset(a, 0, sizeof(a))</code>能方便地把数组a清零,这个函数在<strong>string.h</strong>里.</p>
<p>用<code>strcpy(a, b)</code>, <code>strcmp(a, b)</code>, <code>strcat(a, b)</code>来执行“赋值”、“比较”和“连接”操作, 这三个函数也在 <strong>string.h</strong>中</p>
<h2 id="字符串">字符串</h2>
<p>C语言中的字符串是以“\0”结尾的字符数组</p>
<p>不同操作系统的回车换行符是不一致的. Windows是“和“”两个字符,Linux是“”,而 MacOS是“. 如果在Windows下读取Windows文件, fgetc和getchar会把“"吃掉”, 只剩下“”; 但如果要在Linux下读取同样一个文件, 它们会忠实地先读取“, 然后才是“”.</p>
<p>很有意思的一个小问题: "5", '5' 和 5 有什么区别?<br>
"5"是一个字符串, '5'是一个字符常量, 5是一个数字常量</p>
<h1 id="指针">指针</h1>
<p>用int* a声明的变量a是指向int型变量的指针. 赋值a = &amp;b的含义是把变量b的地址存放在指针a中, 表达式<em>a代表a指向的变量, 既可以放在赋值符号的左边(左值), 也可以放在右边 (右值) 注意: </em>a是指“a指向的变量”, 而不仅是“a指向的变量所拥有的值”. 理解这一点相当重要. 例如, <em>a = </em>a + 1就是让a指向的变量自增1. 甚至可以把它写成(<em>a)++. 注意不要写成</em>a++, 因为<code>++</code>运算符的优先级高于取内容运算符 <code>*</code>, 实际上会被解释成*(a++).</p>
<h2 id="指针的运算">指针的运算</h2>
<ul>
<li>一个指针变量加/减一个整数是将该指针变量的原值(是一个地址)和它指向的变量所占用的内存单元字节数相加或相减.</li>
<li>两个指针变量间可以做减法, 但前提是这两个指针是指向同一个数组的元素. 两指针变量差是两个指针之间的元素个数</li>
<li>如果两指针变量指向同一数组的元素, 他们可以进行比较运算. 另外所有指针都可以和 NULL进行相等/不想等比较.</li>
</ul>
<h1 id="预处理">预处理</h1>
<h2 id="宏定义">宏定义</h2>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></tbody></table></figure>
<p>宏名一般为大写, 以下划线连接单词.</p>
<p>看了网上资料我感觉在C中宏定义主要是以下作用</p>
<h3 id="增加代码抽象性">增加代码抽象性</h3>
<p>用宏定义替代magic number, 或者嵌入式中一些寄存器的位操作, 一方面增强代码可读性 (不像魔数让人不明所以, 而寄存器的位操作也很不直观), 一方面增强代码可移植性 (比如从一种单片机移植到另一种单片机, 只需更改宏定义即可)</p>
<h3 id="防止重复定义">防止重复定义</h3>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXXX</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>在头文件里用这样的语句来防止头文件被重复引用. 有一些头文件被重复引用会增加编译器工作, 降低编译效率, 而有一些头文件被重复引用会引起冲突 (比如如果头文件里定义了全局变量, 会发生重复定义错误).</p>
<h3 id="控制代码编译">控制代码编译</h3>
<p>通过Makefile控制编译选项.</p>
<p>还能像轮子哥<a href="https://www.zhihu.com/question/22608939/answer/21963056" target="_blank" rel="noopener">这样</a>当模板用.</p>
<p>❗️虽然宏定义的好处不少, 但除了以上情况尽量少用尽量不用宏定义, 因为这会让开发者看到的代码与编译器看到的代码不同, 容易导致想不到的问题.</p>
<h1 id="调试技巧">调试技巧</h1>
<p>调试时重点关注两方面: <strong>当前行的跳转</strong>, <strong>变量的变化</strong></p>
<p>循环结构程序设计中最常见的两个问题: <strong>算术运算溢出</strong>, <strong>程序效率低下</strong></p>
<p>变量在未赋值之前的值是不确定的.</p>
<h1 id="gcc与gdb命令简记">gcc与gdb命令简记</h1>
<h2 id="gcc">gcc</h2>
<p>常用选项:</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>name_of_option</th>
<th>我猜的全名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-o [filename]</td>
<td>output</td>
<td>指定输出文件名</td>
</tr>
<tr class="even">
<td>-g</td>
<td>gdb</td>
<td>生成调试用的符号表</td>
</tr>
<tr class="odd">
<td>-Wall</td>
<td>warning all</td>
<td>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros.</td>
</tr>
<tr class="even">
<td>-lm</td>
<td>link math.h</td>
<td>链接math.h. C++编译器会自动链接, 但C的代码使用了math.h却不启动这个选项很可能出错</td>
</tr>
<tr class="odd">
<td>-ansi</td>
<td>ANSI</td>
<td>检查代码是否符合ANSI标准 (常与-Wpedantic连用)</td>
</tr>
<tr class="even">
<td>-Wpedantic</td>
<td>warning pedantic</td>
<td>Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any -std option used.</td>
</tr>
<tr class="odd">
<td>-O1, -O2, -O3</td>
<td>optimize</td>
<td>开启速度优化. 开启后编译出的程序比直接编译出的程序快, -O2比-O1快, -O3比-O2快, 但为了避免优化误解代码含义, 在算法比赛中推荐-O2. 当然如果程序十分规范就没有这种担心.</td>
</tr>
<tr class="even">
<td>-DXX</td>
<td>define XX</td>
<td>在编译时定义XX符号 (此处XX是随意什么大写单词的意思), 位于#ifdef XX和#endif中间的语句会被编译</td>
</tr>
</tbody>
</table>
<h3 id="gcc与g">gcc与g++</h3>
<p><code>gcc</code>到底能不能编译C++程序?</p>
<p>在某种程度上<code>gcc</code>和<code>g++</code>都可以编译 <strong>.cpp</strong> 后缀的程序, 但是<code>gcc</code>命令不能自动和 C++程序使用的库链接. <code>gcc</code>把后缀为 <strong>.c</strong> 的当作是C程序,而<code>g++</code>将其当作C++程序. 两者都会将后缀为 <strong>.cpp</strong> 的程序视作C++程序, 要注意虽然C++是C的超集,但是两者对语法的要求是有区别的, C++的语法规则更加严谨一些. 编译阶段, <code>g++</code>会调用<code>gcc</code>,因为 <code>gcc</code>命令不能自动链接C＋＋库, 所以通常用<code>g++</code>来完成链接, 统一起见,干脆编译和链接统统用g++了, 这就给人一种错觉, 好像cpp程序只能用g++似的.</p>
<h2 id="gdb">gdb</h2>
<p>💡执行gdb时加选项<code>-q</code> (quiet)可以去掉进入gdb开头的废话.</p>
<p>常用命令:</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>全名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>l</td>
<td>list</td>
<td>列出十行代码. 但可以通过<code>set listsize</code>来更改显示多少行, 用<code>show listsize</code>能查看listsize. l后可以接行号, 函数名</td>
</tr>
<tr class="even">
<td>r</td>
<td>run</td>
<td>开始运行程序</td>
</tr>
<tr class="odd">
<td>b</td>
<td>break</td>
<td>设置断点, b后接行号或函数名</td>
</tr>
<tr class="even">
<td>c</td>
<td>continue</td>
<td>继续运行. 要注意在断点处停下后用c继续而不是r</td>
</tr>
<tr class="odd">
<td>n</td>
<td>next</td>
<td>下一行</td>
</tr>
<tr class="even">
<td>s</td>
<td>step</td>
<td>与n的区别是n会执行完本行语句, 而有函数调用时s会停在函数内</td>
</tr>
<tr class="odd">
<td>u</td>
<td>until</td>
<td>执行到指定行号或者指定函数的开头</td>
</tr>
<tr class="even">
<td>i</td>
<td>info</td>
<td>显示各种信息. 如i b显示所有断点,i disp显示display,而i lo显示所有局部变量</td>
</tr>
<tr class="odd">
<td>disp</td>
<td>display</td>
<td>把一个表达式设置为display, 当程序每次停下来时都会显示其值</td>
</tr>
<tr class="even">
<td>cl</td>
<td>clear</td>
<td>取消断点, 和b的格式相同. 如果该位置有多个断点, 将同时取消</td>
</tr>
<tr class="odd">
<td>cond</td>
<td>condition</td>
<td>用来设置条件断点</td>
</tr>
<tr class="even">
<td>ig</td>
<td>ignore</td>
<td>设置记次断点, count次以前不停止</td>
</tr>
<tr class="odd">
<td>wa</td>
<td>watch point</td>
<td>watch a(简写为wa a)可以在变量a修改时停下,并显示出修改前后的变量值</td>
</tr>
<tr class="even">
<td>aw</td>
<td>all watch point</td>
<td>读写时都停下</td>
</tr>
<tr class="odd">
<td>rw</td>
<td>read watch point</td>
<td>被读取时停下</td>
</tr>
<tr class="even">
<td>q</td>
<td>quit</td>
<td>退出gdb</td>
</tr>
</tbody>
</table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>语言</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Python中的小技巧</title>
    <url>/zh-CN/2019/07/03/Python%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>俺也记不住语法, 在这里记录一下常见语句.</p>
<a id="more"></a>
<h1 id="基本操作">基本操作</h1>
<h2 id="查看自带的帮助文档">查看自带的帮助文档</h2>
<p>用<code>help()</code>函数, 以<code>q</code>退出.</p>
<p>❗️ 使用help(module_name)时首先需要import该模块</p>
<h2 id="查看当前python解释器路径">查看当前python解释器路径</h2>
<p>有时候写程序会发现莫名其妙的bug比如找不到某库, 路径不对等, 可能是因为用错了解释器. 用下面语句可以查看当前解释器的路径:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></tbody></table></figure>
<h2 id="在python解释器里清屏">在python解释器里清屏</h2>
<p>搜了一下python里似乎没有很简短的清屏命令, 要用命令只能用类似以下这种:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">a = os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>💡 这是在Linux下清屏的命令, 在Windows要用<code>os.system('cls')</code></p>
<p>💡 将这条命令赋值给一个变量是为了窗口顶部不出现一个0. 你可以单独输入 <code>os.system('clear')</code>试试</p>
<p>但如果你是在<strong>Bash</strong>中打开的python可以用 <code>Ctrl + L</code>, 这是Bash的清屏快捷键.</p>
<h1 id="列表">列表</h1>
<h2 id="生成等差数列">生成等差数列</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list(range(begin, end, step))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="生成任意指定列表">生成任意指定列表</h2>
<h3 id="利用列表推导式">利用列表推导式</h3>
<p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性. <strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持 :</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure>
<p>e.g.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="利用lambda函数">利用lambda函数</h3>
<p>lambda函数在python, C++, Java等语言中都有, 我理解的作用主要有三:</p>
<ul>
<li>少写几个字</li>
<li>能将一个"函数"以参数的形式传入另一个函数, ❗️注意此处普通函数能被传递并不是什么稀罕事, 更重要的是类似<a href="https://www.zhihu.com/question/20125256/answer/29733906" target="_blank" rel="noopener">这里</a>提到的"伪函数"</li>
<li>避免污染命名空间, 需要一个函数但不知道命什么名时用lambda函数</li>
</ul>
<p>lambda函数主要用在filter(), map(), reduce()中</p>
<p>💡 在python3中<code>reduce()</code>从内建函数中移除了, 被移到了functools模块中</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">2</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, foo)</span><br><span class="line">[<span class="number">18</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x * <span class="number">2</span> + <span class="number">10</span>, foo)</span><br><span class="line">[<span class="number">14</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">54</span>, <span class="number">44</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">64</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> reduce(<span class="keyword">lambda</span> x, y: x + y, foo)</span><br><span class="line"><span class="number">139</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="字典">字典</h1>
<h2 id="由列表生成字典">由列表生成字典</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">c = dict(zip(a, b))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="对字典按值排序">对字典按值排序</h2>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">d = {<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>: <span class="number">5</span>, <span class="string">'d'</span>:<span class="number">4</span>, <span class="string">'e'</span>:<span class="number">3</span>}</span><br><span class="line"></span><br><span class="line">sorted(d.items(), key=<span class="keyword">lambda</span> i: i[<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>sorted(iterable, /, *, key=None, reverse=False)</p>
<p>Return a new list containing all items from the iterable in ascending order.</p>
<p>A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order.</p>
</blockquote>
<p>即<code>iterable</code>处放一个可迭代的对象, <code>key</code>处放自定义函数来选取比较的参数, <code>reverse</code> 处设定是否反向</p>
<p><code>d.items()</code>返回可遍历的(键, 值) 元组数组, <code>key=lambda i: i[1]</code>即此处参与比较的参数是d的值</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Vim使用杂记</title>
    <url>/zh-CN/2019/07/10/vim%E4%BD%BF%E7%94%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>使用vim开发也有半年多啦, 不过配置vim也是个漫长的过程. 记录一下常用快捷键和用法和配置过程.</p>
<a id="more"></a>
<blockquote>
<p>更新: 我做了一个🔗 <a href="https://leojhonsong.github.io/zh-CN/2020/04/20/2020年4月12日vim经验分享/">关于vim的分享</a>, 希望能帮到大家</p>
</blockquote>
<p>🌟首先放上我的<a href="https://github.com/LeoJhonSong/vimrc" target="_blank" rel="noopener">vimrc链接</a></p>
<p>❗️没有特别说明本文中的代码都是放在 <code>.vimrc</code> 中的.</p>
<h1 id="很有帮助的命令">很有帮助的命令</h1>
<p>在vim使用过程中自行查阅帮助文件以及阅读调试信息是很重要的, 利用<code>:h [keyword]</code>可以按关键词查看帮助文档.</p>
<p><code>:checkhealth</code> 查看模块, 插件状态.</p>
<p><code>:file [file name]</code> 在vim中创建文件.</p>
<p><code>:edit</code> 可以在外部改动了文件时刷新当前文件.</p>
<h1 id="阅读代码">阅读代码</h1>
<h2 id="翻页">翻页</h2>
<p><kbd>Ctrl f</kbd> 下翻一页<br>
<kbd>Ctrl b</kbd> 上翻一页<br>
<kbd>Ctrl d</kbd> 下翻半页<br>
<kbd>Ctrl u</kbd> 上翻半页</p>
<h2 id="代码折叠">代码折叠</h2>
<p>原本展开代码和折叠代码是绑定在了 <code>zo</code> (z open) 和 <code>zc</code> (z close), 不过我重新映射到了空格键, normal模式下按一次展开, 再按一次折叠, 感觉更方便一些.</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;space&gt;</span> @=((<span class="built_in">foldclosed</span>(<span class="built_in">line</span>(<span class="string">'.'</span>)) &lt; <span class="number">0</span>) ? <span class="string">'zc'</span> : <span class="string">'zo'</span>)<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>另外 <code>zn</code> 为全部展开, <code>zN</code> 为全部折叠.</p>
<h2 id="拼写检查">拼写检查</h2>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spell</span><br><span class="line"><span class="keyword">set</span> spellfile=~/.<span class="keyword">vim</span>/spell/<span class="keyword">en</span>.utf-<span class="number">8</span>.<span class="built_in">add</span></span><br></pre></td></tr></tbody></table></figure>
<p>按 <code>]s</code> 跳往下一错误拼写, <code>[s</code> 往前跳.</p>
<p>按 <code>zg</code> 将当前光标所在单词记录到字典 (指出当前word 是 good word), <code>zw</code> 将当前单词从字典删除 (指出当前word为wrong word)</p>
<p>vim允许同时使用多个字典, 通过输入 <code>:set spellfile+=path/to/dic/en.utf-8.add</code> 来添加, 但要注意这个文件后缀名一定是 <strong>.[encoding].add</strong></p>
<p>这之后你可以输入 <code>set spellfile?</code> 来查看当前在使用哪些字典, 要将单词添加到第一个字典就按 <code>1zg</code> , 添加到第二个就按 <code>2zg</code> . 很好的一点是spellfile这个变量只在当前缓冲区有效, 即每个文件可以使用不同的spellfile值. 这给保存单词到当前工作区带来了可能. 因此我设置了一个快捷键:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;C-z&gt;</span> :<span class="keyword">exe</span> <span class="string">"setlocal spellfile+="</span> . <span class="symbol">&lt;C-r&gt;</span>=<span class="built_in">shellescape</span>(<span class="built_in">fnamemodify</span>(<span class="string">"en.utf-8.add"</span>, <span class="string">":p"</span>), <span class="number">1</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>这样每次按<kbd>Ctrl , z</kbd>就会添加一个当前文件所在文件夹的字典到spellfile</p>
<h1 id="调整窗口">调整窗口</h1>
<p>在vim中, 多文件编辑主要涉及三个概念: <strong>窗口</strong>, <strong>标签页</strong>, <strong>缓冲区</strong></p>
<p>相关参考:</p>
<p>🔗 <a href="https://harttle.land/2015/11/14/vim-window.html" target="_blank" rel="noopener">Vim 多文件编辑：窗口</a><br>
🔗 <a href="https://harttle.land/2015/11/12/vim-tabpage.html" target="_blank" rel="noopener">Vim 多文件编辑：标签页</a><br>
🔗 <a href="https://harttle.land/2015/11/17/vim-buffer.html" target="_blank" rel="noopener">Vim 多文件编辑：缓冲区</a></p>
<p>💡 <kbd>Ctrl w</kbd> 开头的都是与窗口有关的快捷键, w指window</p>
<h2 id="在窗口间移动">在窗口间移动</h2>
<p><kbd>Ctrl w</kbd> 接 hjkl上下左右在各窗口间移动光标<br>
<kbd>Ctrl w t</kbd> 移动光标至最左上窗口<br>
<kbd>Ctrl w b</kbd> 移动光标至最右下窗口</p>
<h2 id="调整大小">调整大小</h2>
<p>宽度调整:</p>
<p><kbd>Ctrl w [n] &gt;</kbd> 右移边界<br>
<kbd>Ctrl w [n] &lt;</kbd> 左移边界</p>
<p>💡默认增减1个字符宽度, 可以在Ctrl w和+/-间加数字来指定增减宽度. 不是最右边的窗口调整的是右边界, 最右边的窗口调整的是左边界.</p>
<p>高度调整:</p>
<p><kbd>Ctrl w [n] +</kbd> 增加高度<br>
<kbd>Ctrl w [n] -</kbd> 减小高度</p>
<p>通过设置以下几个键映射我可以十分方便地调整窗口大小</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F2&gt;</span> <span class="symbol">&lt;C-w&gt;</span>+</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F3&gt;</span> <span class="symbol">&lt;C-w&gt;</span>-</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F4&gt;</span> <span class="symbol">&lt;C-w&gt;</span>&lt;</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F5&gt;</span> <span class="symbol">&lt;C-w&gt;</span>&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="调整位置">调整位置</h2>
<p><kbd>Ctrl w</kbd> 接HJKL移动窗口至最上下左右并且宽度或高度为最大. <kbd>Ctrl w r</kbd> 顺时针移动窗口<br>
<kbd>Ctrl w R</kbd> 逆时针移动窗口</p>
<h1 id="键映射">键映射</h1>
<p>vim是能够进行高度个性化的编辑器, 因此每个人肯定都会添加一些自己顺手的快捷键, 因为我是从VSCode转来vim的, 因此我的快捷键设置一定程度上参考了VSC的快捷键设置. 用以在 <strong>.vimrc</strong> 中设定快捷键的命令有好几个, 我的vimrc里比较常用的是 <code>nnoremap</code> 和 <code>map</code> . 以下是我常用的命令及其含义.</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>:noremap</td>
<td>nonrecursive map, 不可递归的映射</td>
</tr>
<tr class="even">
<td>:nnoremap</td>
<td>normal nonrecursive map, 只在normal模式有效的noremap</td>
</tr>
<tr class="odd">
<td>:inoremap</td>
<td>insert nonrecursive map, 只在insert模式有效的noremap</td>
</tr>
<tr class="even">
<td>:vnoremap</td>
<td>visual nonrecursive map, 只在visual模式有效的noremap</td>
</tr>
<tr class="odd">
<td>:map</td>
<td>可递归的映射</td>
</tr>
<tr class="even">
<td>:nmap</td>
<td>normal map, 只在normal模式有效的map</td>
</tr>
</tbody>
</table>
<p>以下是各种映射命令对应有效的模式. 具体解释可以在vim里用 <code>:help</code> 命令查看.</p>
<p>💡顺带一提是可以把<a href="https://www.liuhaolin.com/vim/272.html" target="_blank" rel="noopener">vim的帮助文档设为中文</a>的</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>:map :noremap :unmap</td>
<td>Normal, Visual, Select, Operator-pending</td>
</tr>
<tr class="even">
<td>:nmap :nnoremap :nunmap</td>
<td>Normal</td>
</tr>
<tr class="odd">
<td>:vmap :vnoremap :vunmap</td>
<td>Visual and Select</td>
</tr>
<tr class="even">
<td>:smap :snoremap :sunmap</td>
<td>Select</td>
</tr>
<tr class="odd">
<td>:xmap :xnoremap :xunmap</td>
<td>Visual</td>
</tr>
<tr class="even">
<td>:omap :onoremap :ounmap</td>
<td>Operator-pending</td>
</tr>
<tr class="odd">
<td>:map! :noremap! :unmap!</td>
<td>Insert and Command-line</td>
</tr>
<tr class="even">
<td>:imap :inoremap :iunmap</td>
<td>Insert</td>
</tr>
<tr class="odd">
<td>:lmap :lnoremap :lunmap</td>
<td>Insert, Command-line, Lang-Arg</td>
</tr>
<tr class="even">
<td>:cmap :cnoremap :cunmap</td>
<td>Command-line</td>
</tr>
<tr class="odd">
<td>:tmap :tnoremap :tunmap</td>
<td>Terminal-Job</td>
</tr>
</tbody>
</table>
<p>💡 关于应当避免使用 <code>map</code> 的具体原因可以参考<a href="http://learnvimscriptthehardway.stevelosh.com/chapters/05.html#nonrecursive-mapping" target="_blank" rel="noopener">这里</a></p>
<h1 id="插件">插件</h1>
<h2 id="vim-plug">vim-plug</h2>
<p>我用<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>来管理我的vim插件, 使用很简单, 写法可以参照我的vimrc. 每次要下载插件时在vim中输入 <code>:PlugInstall</code> 即可. 超好用😆</p>
<h2 id="nerdtree">NERDtree</h2>
<p>NERDtree是一个不错的文件资源管理器, 体验和VSC的explorer差不多. 觉得每次输 <code>:NERDTreeToggle</code> 太麻烦的话可以键绑定一下:</p>
<figure class="highlight vim"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;C-e&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>我绑定到了<kbd>Ctrl , e</kbd>, 和本来想绑的VSC里的<kbd>Ctrl shift e</kbd>不同. 因为在终端中<kbd>Ctrl shift 字母</kbd>和<kbd>Ctrl 字母</kbd>的输出没有区别.</p>
<p>以下是几个我比较常用的NREDtree命令</p>
<table>
<tbody>
<tr class="odd">
<td>C</td>
<td>切换NERDtree根目录到光标所在文件夹</td>
</tr>
<tr class="even">
<td>R</td>
<td>刷新根目录</td>
</tr>
<tr class="odd">
<td>r</td>
<td>刷新光标所在目录</td>
</tr>
<tr class="even">
<td>s</td>
<td>水平分屏打开</td>
</tr>
<tr class="odd">
<td>i</td>
<td>竖直分屏打开</td>
</tr>
</tbody>
</table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>vim</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/zh-CN/2019/08/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>... 前几天刚说最近没有用C的需求我就开始要写C++了 🤦</p>
<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
        <category>语言</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>MATLAB杂记</title>
    <url>/zh-CN/2019/08/05/MATLAB%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>再开学的课程就要用MATLAB了, 而且了解很多机械系唯一要求学的编程语言就是MATLAB, 我决定还是稍微了解下.</p>
<a id="more"></a>
<p>首先, <a href="https://www.zhihu.com/question/37824202/answer/767114071" target="_blank" rel="noopener">MATLAB到底是不是编程语言?</a></p>
<p>从<strong>TIOBE</strong>上有MATLAB而且MATLAB排名还不低可以看出MATLAB确实是一门编程语言, 但从上面链接可以看出MATLAB算是<strong>残疾</strong>的编程语言, 很多特性没有, 更多的是<strong>用来验证算法可行性</strong>.但我又想验证算法可行性为啥不用Python什么的, 语法也不麻烦呀? 然后我发现原本用<strong>Octave</strong>教深度学习的吴恩达现在改用<strong>Python</strong>了 😁</p>
<p>💡 (这条是后来补的) 但其实随着使用我发现在<strong>矩阵计算方面</strong>MATLAB的语法还是比python简单很多.</p>
<p>因此我觉得MATLAB的优势主要就在:</p>
<ul>
<li>语法简单, 没有编程基础的工科生也能快速掌握, 尤其计算方面的语法比Python简单太多</li>
<li>集成度特别高, 各种工具都能轻松快速配置好</li>
<li>能和多种语言交互, 编写界面简单</li>
<li>很多工具都有图形界面, 操作简单, 按按键就可以, 不用写那么多代码.</li>
</ul>
<p>总而言之, 虽然缺点多多, MATLAB还是很值得一学的</p>
<h1 id="matlab软件个性化设置">MATLAB软件个性化设置</h1>
<h2 id="设置初始工作文件夹">设置初始工作文件夹</h2>
<p>使用HOME目录作为起始工作文件夹我觉得不是什么好事, 所以最好自己指定一个合适的目录. 我使用的是MATLAB默认的<code>userpath</code>, 即<strong>Documents/MATLAB</strong>文件夹. 一方面这个文件夹看着比较合理, 一方面MATLAB说<a href="https://ww2.mathworks.cn/help/matlab/matlab_env/matlab-startup-folder.html#bujzf43" target="_blank" rel="noopener">使用userpath作为初始工作文件夹有一定好处</a>.</p>
<p>Linux下设置MATLAB的初始工作文件夹方法和在Windows下改快捷方式的起始位置这种方法不一样, 要达到这个目的有两种方式:</p>
<ol type="1">
<li>在终端输入 <code>matlab -useStartupFolderPref</code> 打开MATLAB. -useStartupFolderPref选项指定初始工作文件夹为在<strong>Preference</strong>中<strong>Initial working folder option</strong>的指定文件夹.</li>
<li>在终端输入 <code>matlab -sd [folder]</code> 打开MATLAB. -sd选项指定初始工作文件夹为[folder]文件夹.</li>
</ol>
<h2 id="更改编辑界面颜色主题">更改编辑界面颜色主题</h2>
<p>在vim, VSC, VS, CLION, Pycharm等工具用惯了黑暗主题以后拿到啥都想先换个黑暗主题. 但是找了半天也只找到了设置编辑界面颜色主题的方式, 普通操作似乎并不能自定义丑陋的灰色工具栏.</p>
<p>最终我把界面变成了这样 👇</p>
<figure>
<img alt="界面" data-src="MATLAB杂记/appearance.png"><figcaption>界面</figcaption>
</figure>
<ul>
<li>颜色主题是通过<a href="https://github.com/scottclowe/matlab-schemer" target="_blank" rel="noopener">MATLAB Schemer</a>里的脚本更换的, 一键更换好评👍 因为我比较喜欢糖果色的颜色主题然后又不喜欢注释是灰色 (不管在黑色背景还是白色背景里辨析度都很低), 于是选择的主题是<a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes#dark-steel" target="_blank" rel="noopener">Dark Steel</a>.</li>
<li>字体用的是<a href="https://github.com/powerline/fonts/tree/master/DejaVuSansMono" target="_blank" rel="noopener">DejaVu Sans Mono for Powerline</a>, 大小是11, 不过不知道为什么MATLAB显示不带效果的字体看着很粗糙, <strong>边缘锯齿状过于明显</strong>, 效果设置为了 <strong>bold</strong>, 这回好多了!</li>
<li>布局改成了和我常用的vim, VSC差不多的布局: 资源管理器在左上, 细节信息在左下, 编辑窗口在右</li>
</ul>
<h1 id="matlab语法和工具">MATLAB语法和工具</h1>
<h2 id="在终端运行">在终端运行</h2>
<p>曾经我因为嫌MATLAB界面太丑又不能个性化想过在终端像用交互式Python一样用交互式 MATLAB以及运行脚本. 我发现这是可行的:</p>
<p>在终端启动交互式MATLAB:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">matlab -nojvm</span><br></pre></td></tr></tbody></table></figure>
<p><code>-nojvm</code>选项本身是<strong>不启动Java虚拟机</strong>的意思, 但因为Matlab的GUI都是用Java写的 (听网上说的), 所以也有<code>-nosplash</code> (<strong>不显示启动画面</strong>), <code>-nodesktop</code> (<strong>不启动图形界面</strong>) 的功能. 另外因为没有启动jvm这样启动MATLAB十分迅速.</p>
<p>💡 要注意用<code>-nojvm</code>选项时会创建图形界面的命令会报错.</p>
<p>在终端运行MATLAB脚本:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">matlab -batch [MATLAB_command]</span><br></pre></td></tr></tbody></table></figure>
<p><code>-batch</code>选项和<code>-r</code>选项的区别在于前者不会启动图形界面而后者会. 另外如果脚本中没有与图形界面有关的语句同样可以加上<code>-nojvm</code>选项.</p>
<p><strong>但是啊!</strong></p>
<p>我后来发现这样就<strong>本末倒置</strong>了! MATLAB的亮点我觉得一是所有变量都是全局变量, 能迅速可视化变量, 工具集成度非常高, 适合迅速验证各种算法, 二是社区非常完善, 提供了很多工具能轻松仿真很多模型.</p>
<p>因此只在终端的MATLAB是没有灵魂的MATLAB. <strong>如果终端里的MATLAB就能解决你的需求的话为什么不用Python?</strong> 🤤</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>杂记</category>
        <category>语言</category>
        <category>MATLAB</category>
      </categories>
  </entry>
  <entry>
    <title>初学Socket通信</title>
    <url>/zh-CN/2019/08/07/%E5%88%9D%E5%AD%A6socket%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>TODO</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>记大二暑假北航实习</title>
    <url>/zh-CN/2019/08/05/%E8%AE%B0%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E5%8C%97%E8%88%AA%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<p>这个暑假我来到了北航<a href="http://softrobotics.buaa.edu.cn/peoples/peoples_ch/index.htm" target="_blank" rel="noopener">仿生软体机器人实验室</a>学习, 收获颇多. 结实了一群有趣的人, 得到了一些答案, 看到了更明确的方向, 坚定了我研究软体机器人的信念💪</p>
<a id="more"></a>
<p>如今我愈发觉得玄幻小说里一种很玄的情节其实很现实: <strong>历练总是能有些机缘!</strong></p>
<p>有些事情在事前真的无法预测, 比如在我这次前往北京学习一个半月之前, 我是完全想不到我能有什么收获的, 而最终的收获多到一两句说不清. <strong>如果在家仔细思考, 总会觉得一个半月那样短, 去了又能怎样?</strong> 再引用一句玄幻小说里的话:</p>
<blockquote>
<p>我辈修士, 当与天争命!</p>
</blockquote>
<p>事实证明, 只要自己主动抓住各种机会一个半月并不那样短暂.</p>
<p>这一个半月我干了许多事: 我浇筑了一套软体臂, 软体爪, 我试着帮实验室的学长解决实验面临的困难, 我每天站着巨久调试了半个月机器人, 我随实验室的队伍到大连参加了一个难度很高的比赛, 我在大连每天白嫖各种海鲜, 我和在中科院中关村学生公寓的室友相处不错还一块深夜吃了烧烤, 我给好几人上了家教课, 我经常和在北京的亲属玩,我, 我试图减肥并失败 🤦‍</p>
<h2 id="关于学习收获">关于学习收获</h2>
<h3 id="在实验室的体会">在实验室的体会</h3>
<p>实际上在前往文老师的实验室前我并没有真正接触到软体机器人: 只能自己看看资料算什么? 但我也很无奈啊, 想做的实验材料就动辄几千, 而花销小的实验一般是真-实验室阶段, 我一时半会研究不出什么名堂. 更何况我在电子科大并没有找到相关团队. 而到文老师实验室这段时间我不仅是更正了一些对软体机器人的理解, 更是对科研有了一些概念.</p>
<p>很幸运的是实验室所有人人都很好, 我很快就融入其中, 也有幸和几位学长探讨了他们的工作. 谢博士的废寝忘食令我记忆犹新. 好几次谢博因为想解决问题而晚去吃饭. 谢博也很虚心, 因为并不是电气专业出身, 实验遇到电气方面问题还拉我一起研究. 辉哥则和我聊了很多过来人的经验, 他建议说在国外科研更加自由, 能支持更基础的研究方向, 杂事更少, 老师和学生的关系更像合作伙伴, 而最后如果能留在国外就不用按国内五年一个职位的累死累活竞争等等. 结对调试机器人的同样来自四川的陈学长则和我分享了许多学习经验, 在我看来他的学习经历实在是一次逆袭. 而见到文老师前我同样没想到是这样一位爱夸人的总是在笑的老师. 这一个半月我更多的时间是和刘学长在一起, 他也教了我很多, 比如如何浇筑 (我一个学电气的是完全没做过这种事的), 而来实验室前的许多疑问我也从他那得到了解答 .</p>
<p>亲身站在实验室里我更直观的体会到了软体机器人是怎样的一个领域. 虽然刘学长觉得软体机器人现在发展趋势缓下来了, 但我觉得这个领域仍在萌芽阶段. 从我了解到的成果和在实验室近距离看学长们的工作来看, 除了软体抓手现在已经商业化了其他成果仍离走出实验室差很远, 有些甚至只是证明了一些结构的潜力, 说白了目前基本是空架子. 就比如实验室花了好几万买的液态金属打印机, 不光墨水贵, 还经常不出墨, 出墨也不够理想, 和谢博一起做实验的袁学长说某些方面甚至可能比不上以前手工浇筑的效果. 不过最近清华大学刚研发出了类似喷墨打印机原理的液态金属打印方式, 看论文效果很不错, 期待能尽早推出产品. 目前的成果之所以离投入应用还远一方面是因为目前的软体机器人因为使用的驱动方式, 能提供的驱动力普遍很小, 基本没有应用场景, 另一方面是因为目前软体机器人的控制基本是黑暗一片, 就算是一段较早出现的软体臂也没有一个称得上很好的闭环控制方法. 而针对非结构性环境的软体机器人如果连闭环都做不到还有何用? 虽然目前也有好几项人来控制, 机器人负责在人类很难触及的环境 (比如人体内, 十分狭窄的缝隙, 20m深的海底) 执行的成果, 但我认为自主始终是趋势.</p>
<p>另外一点在实验室学到的, 觉得很有意思的是如何记<strong>组会记录</strong>. 首先记肯定是要记的, 不然如果讨论的不是自己在参与的项目时岂不是在浪费时间? 我认为组会本就是集思广益大家相互交流经验的地方 (这点在我们组里也很明显, 每个人讲完自己的项目进度后老师会问大家的看法和建议), 因此如果在组会中只注意讲好自己的项目就本末倒置了. 记组会记录一方面帮助自己整理思路, 看看能给正在讲的同学什么帮助, 另一方面讲大家的经验记录下来,这样以后自己遇到类似问题就能有突破口, 另外老师有时候也会给一些写论文方面的指导,也值得记录. 我觉得记组会记录最好用OneNote这种手写的电子档, 自由度高, 适合写写画画整理思路, 电子档也更利于保存.</p>
<h3 id="对c的体会">对C++的体会</h3>
<p>再有就是我学习C++的速度还是令我觉得值得表扬的😆 实际上在这个暑假之前我是不会C++ 的,顶多是大一上的时候学了最基础的C. 我是这个暑假开始时从学长那里继承了本紫色的<strong> 算法竞赛入门经典</strong>巩固了下C语言, 了解了一些C++. 而到了实验室先是照着网上的模板写了个C++的TCP server, 然后和中科院的学长一起负责ROV的控制代码 (纯C++). 说实话一方面是大一上扎实的C基础帮了大忙 (我明明每一科都能很好地应用可我就是考不好真的好气), 另一方面则是我浏览器程序员的特长: 上网查资料发挥了巨大作用😁 这真的是现学现卖.好在学长把核心代码都写好了, 我就写了写语法很简单的控制流程什么的. 期间也因为不熟悉C++遇到了很多奇葩问题, 比如就因为在<strong>多线程C++程序</strong>中用错了计时函数导致了计时不准, 程序崩溃等各种迷之错误... 反正一波C++速成后我对C++的印象极差, 标准库很落后, 坑很多, 语法很啰嗦 (和我最爱的Python比), 环境配置也比Python开发麻烦等等...</p>
<p>以后我自己写程序用到C/C++顶多是要求算力部分用C/C++来加速, 或者用到的工具只有 C/C++接口时.其他部分全部用Python糊!</p>
<h3 id="其他">其他</h3>
<p>最后想发表一番感慨: 虽然这只是我的大二暑假, 但实际上我在高三暑假就决定了以后研究机器人, 为此学习了许多, 做着各种各样的准备. 比如我学习了Python, 也针对机器人中很常用到的机器学习和CV分别做了一个小项目 (<a href="https://github.com/LeoJhonSong/SVM-Learning-Sample" target="_blank" rel="noopener">我的机器学习小项目</a>, <a href="https://github.com/LeoJhonSong/Fingertip-Drawboard" target="_blank" rel="noopener">我的CV小项目</a>)来学习了解, 比如我查阅了许多软体机器人的文献, 也曾自己试着<a href="https://leojhonsong.github.io/zh-CN/2018/12/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/">用仿真软件仿真软体机器人</a>, 以及即便曾经的我<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/为什么我用Linux而不是Windows/">曾找各种理由来说服自己用Linux</a> (当然后来就离不开Linux了)... 总之我曾努力学习过的东西都确实地派上了用场, 我感到自己的努力没有白费💪 我会再接再厉!</p>
<h2 id="关于家教">关于家教</h2>
<p>另外我在北京这段时间在一个叫<strong>易教网</strong>的平台接了几份家教的工作. 经过了这一段时间的体验我觉得当家教是一件既有趣又促进自己学习还赚钱的事.</p>
<h2 id="关于北京">关于北京</h2>
<p>第一次在北京待一个半月, 见识到了首都的另一面. 以前我是个京黑, 这次在北京的体验改变了我的印象, 让我变成了真*京黑😁 是的印象一点也没有变好! 或者说见到了好的一面, 但也加深了负面印象.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Linux终端呈现彩色输出</title>
    <url>/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: <strong>让特定类型的输出显示为特定的颜色</strong>!</p>
<a id="more"></a>
<p>比如这样:</p>
<p style="color:purple">
[MESSAGE] Turning left
</p>
<p style="color:yellow">
[DEBUG] target: 4
</p>
<p style="color:red">
[Error] target not found
</p>
<p style="color:purple">
[MESSAGE] Turning left
</p>
<p style="color:purple">
[MESSAGE] Diving
</p>
<p style="color:green">
[INFO] depth: 9m
</p>
<p style="color:purple">
[MESSAGE] Diving
</p>
<p style="color:green">
[INFO] depth: 10m
</p>
<p style="color:purple">
[MESSAGE] Forward
</p>
<p style="color:purple">
[MESSAGE] Turing right
</p>
<p>能极大的增强终端信息的可读性!😆</p>
<p>这应该是Linux终端的特性, (我并不清楚是否兼容Windows命令行), shell, python, C++的彩色文字语法几乎是一样的.</p>
<h2 id="颜色表">颜色表</h2>
<p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" target="_blank" rel="noopener">维基的表</a></p>
<table>
<thead>
<tr class="header">
<th>前景色 (字体颜色) 代码</th>
<th>背景色代码</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>30</td>
<td>40</td>
<td>黑色</td>
</tr>
<tr class="even">
<td>31</td>
<td>41</td>
<td>紅色</td>
</tr>
<tr class="odd">
<td>32</td>
<td>42</td>
<td>綠色</td>
</tr>
<tr class="even">
<td>33</td>
<td>43</td>
<td>黃色</td>
</tr>
<tr class="odd">
<td>34</td>
<td>44</td>
<td>藍色</td>
</tr>
<tr class="even">
<td>35</td>
<td>45</td>
<td>紫紅色</td>
</tr>
<tr class="odd">
<td>36</td>
<td>46</td>
<td>青藍色</td>
</tr>
<tr class="even">
<td>37</td>
<td>47</td>
<td>白色</td>
</tr>
</tbody>
</table>
<h2 id="字体效果表">字体效果表</h2>
<table>
<thead>
<tr class="header">
<th>代码</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>默认</td>
</tr>
<tr class="even">
<td>1</td>
<td>高亮(加粗)</td>
</tr>
<tr class="odd">
<td>4</td>
<td>下划线</td>
</tr>
<tr class="even">
<td>5</td>
<td>闪烁</td>
</tr>
<tr class="odd">
<td>7</td>
<td>反色</td>
</tr>
<tr class="even">
<td>8</td>
<td>不可见</td>
</tr>
</tbody>
</table>
<h2 id="常见问题">常见问题</h2>
<ul>
<li><a href="https://stackoverflow.com/a/55773513/10088906" target="_blank" rel="noopener">readline的提示符误将不可见字符认为可见</a></li>
</ul>
<h2 id="语法">语法</h2>
<h3 id="shell语法">shell语法</h3>
<p>举例:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo "\e[31;43;1mError\!\e[0m"</span><br></pre></td></tr></tbody></table></figure>
<p>💡 如果上面这条命令不是彩色的, 执行<code>echo -e "\e[31;43;1mError\!\e[0m"</code></p>
<p>运行上面这条命令会输出一个黄底红色粗体字的"Error!". 前景色, 背景色和字体效果的代码没有先后顺序之分. 建议每个<code>\e[a;b;c</code>都接一个<code>\e[0m</code>将字体效果恢复默认, 不然后续输出还是带特殊效果的.</p>
<h3 id="python语法">python语法</h3>
<p>在<code>print()</code>中使用的示例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">"\033[31;43;1mError!\033[0m"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>或者可以通过python执行shell命令:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">'echo "\e[31;43;1mError!\e[0m"'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="c语法">C++语法</h3>
<p>在C++中使用的语法和在python中是一样的:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[31;43;1m"</span> &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; <span class="string">"\033[0m"</span> &lt;&lt; <span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>一个小技巧是可以单独写一个<code>color_print.h</code>, 内容示例:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET   <span class="meta-string">"\033[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK   <span class="meta-string">"\033[30m"</span>      <span class="comment">/* Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED     <span class="meta-string">"\033[31m"</span>      <span class="comment">/* Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN   <span class="meta-string">"\033[32m"</span>      <span class="comment">/* Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW  <span class="meta-string">"\033[33m"</span>      <span class="comment">/* Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE    <span class="meta-string">"\033[34m"</span>      <span class="comment">/* Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGENTA <span class="meta-string">"\033[35m"</span>      <span class="comment">/* Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN    <span class="meta-string">"\033[36m"</span>      <span class="comment">/* Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE   <span class="meta-string">"\033[37m"</span>      <span class="comment">/* White */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLACK   <span class="meta-string">"\033[1m\033[30m"</span>      <span class="comment">/* Bold Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDRED     <span class="meta-string">"\033[1m\033[31m"</span>      <span class="comment">/* Bold Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDGREEN   <span class="meta-string">"\033[1m\033[32m"</span>      <span class="comment">/* Bold Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDYELLOW  <span class="meta-string">"\033[1m\033[33m"</span>      <span class="comment">/* Bold Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLUE    <span class="meta-string">"\033[1m\033[34m"</span>      <span class="comment">/* Bold Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDMAGENTA <span class="meta-string">"\033[1m\033[35m"</span>      <span class="comment">/* Bold Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDCYAN    <span class="meta-string">"\033[1m\033[36m"</span>      <span class="comment">/* Bold Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDWHITE   <span class="meta-string">"\033[1m\033[37m"</span>      <span class="comment">/* Bold White */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(color, context) std::cout &lt;&lt; color &lt;&lt; context &lt;&lt; RESET &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>然后在要显示彩色输出的cpp文件中引用这个头文件, 打印语句示例:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">print(BOLDRED, <span class="string">"Error!"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>因为是宏替换因此<code>context</code>字段其实可以随意填, 比如有一个变量<code>depth</code>, 用下面语句来打印深度是可以的:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">print(BOLDGREEN, <span class="string">"depth: "</span> &lt;&lt; depth &lt;&lt; <span class="string">"m"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>超好用!😆</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>操作系统</category>
        <category>技巧</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown安利&amp;Typora简要使用教程</title>
    <url>/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>在此我来安利一下<strong>Markdown</strong>和<strong>Typora</strong>.</p>
<a id="more"></a>
<h2 id="markdown安利">Markdown安利</h2>
<h3 id="什么是markdown">什么是Markdown</h3>
<p>Markdown是一门语言, 一门轻量级的<strong>标记语言</strong> (Markup Language). 有没有觉得这个词很眼熟? 是的, HTML全称<strong>HyperText Markup Language</strong>. Markdown和HTML同属于Markup Language(Markdown是一门Markup Language是Markdown作者的恶趣味), 它们与C, Python等编程语言并不是一类东西. <strong>Markup</strong>这个词源自<strong>印刷业</strong>, 指的是在电子排版技术出现之前人们对印刷物内容的排版进行标记的方式. 比如一段文字应当是<strong>粗体</strong>, <em>斜体</em>, <u>有下划线</u>还是<del>有删除线</del>, 使用什么字体, 字体大小, 左页边距应当是多少, 一张图片该放在哪里, 多大等等...</p>
<p>💡 也就是说以前的人们在将原稿最终印刷出来前想知道会印成什么样基本靠脑补, 而现在我们称这个由标记语言文件得到最终效果的过程为<strong>渲染</strong> (render).</p>
<p>而之所以我们说Markdown是一门<strong>轻量级</strong>的标记语言是因为在Markdown的语法比HTML等标记语言要简洁太多😆</p>
<ul>
<li>一</li>
<li>二</li>
</ul>
<p>比如👆 上面这个列表的Markdown实现代码为</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>一</span><br><span class="line"><span class="bullet">- </span>二</span><br></pre></td></tr></tbody></table></figure>
<p>而HTML实现代码为</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>但Markdown有时候也会让人觉得太过轻量级以至于缺少一些语法, 比如这个<u>下划线</u> 其实是用HTML标签实现的. 好在你也可以在Markdown文件中写HTML, 如今的Markdown渲染工具基本都支持这个功能.</p>
<p>也是由于上面这个原因, 在Markdown作者们推出的 <a href="https://commonmark.org/" target="_blank" rel="noopener"><strong>CommonMark</strong></a>的基础上有了添加了更多语法的各种 Markdown超集, 比如GitHub发布的<a href="https://github.github.com/gfm/" target="_blank" rel="noopener"><strong>GitHub Flavored Markdown</strong></a>.</p>
<h3 id="markdown应用广泛吗">Markdown应用广泛吗</h3>
<p>实际上如今Markdown的使用相当广泛, 只要是支持所谓<strong>富文本</strong>的社区/论坛等, 比如说 <strong>GitHub</strong>, <strong>知乎</strong>, <strong>Stack OverFlow</strong>, <strong>CSDN博客</strong>, <strong>Wikipedia</strong>都是使用的 Markdown. 另外因为Markdown和HTML的转换十分容易, 目前大多个人博客都是编辑Markdown 格式的文章再生成HTML页面, 比如我正在码的也是Markdown文件.</p>
<p>再有就是目前大多数项目根目录的<strong>README</strong>文档都是Markdown格式, 而在线查看项目代码时 GitHub等代码托管网站都会自动将项目中所有Markdown文件渲染出来.</p>
<h3 id="为什么我们使用markdown">为什么我们使用Markdown</h3>
<p>以下是网上的一些总结和我个人的体会.</p>
<ol type="1">
<li>Markdown的设计理念是易读易写, 因此<strong>即便不渲染Markdown文件的可读性也很高</strong>, 这让没有Markdown渲染工具的人也能很好地阅读, 而如果要脑力渲染HTML, 一会就眼晕了.</li>
<li>这种格式能让文档很方便的排列为很简洁好看的排版, <strong>能让人专注于书写内容</strong>, 不必费神排版</li>
<li>支持代码按语言的语法高亮</li>
<li><strong>能很方便的进行版本管理</strong>. 在要进行版本管理的项目中的Word文件简直是毒瘤, 不操作一番的话版本管理工具比如git并不能识别word文件具体变化, 而使用纯文本的 Markdown能让每次的更改被体现出来!</li>
<li><strong>占用空间小</strong> (可以想一想一个word文档的大小)</li>
<li><strong>能很容易地转为多种格式</strong>. Markdown和HTML是兄弟关系,因此Markdown文件能轻松转换成 <strong>HTML</strong>文件格式以及HTML文件能轻易转换为的格式(<strong>PDF</strong>, <strong>jpg</strong>, <strong>Epub</strong>等) 是显而易见的. 通过一些额外工具(比如<a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>)的帮助, Markdown文件还能一键转化为更多文件格式,比如<strong>LaTeX</strong>, <strong>Word</strong>, <strong>OpenOffice</strong>, <strong>Media Wiki</strong>等.</li>
<li>能方便的插入图片, 表格, 超链接等</li>
<li>兼容HTML语法, 因此我们想让页面显示成什么样就可以显示成什么样</li>
<li>可以兼容LaTeX语法, 可以很方便的显示复杂公式</li>
<li>还可以兼容<strong>Graphviz</strong>, <strong>Mermaid</strong>等流程图工具等等...</li>
</ol>
<h3 id="markdown简明语法">Markdown简明语法</h3>
<ul>
<li><p>一个标题以几个<code>#</code>开头, 空格后是文字. 以#的个数来表示第几级标题</p></li>
<li><p>以 - 开头接一个空格开始一个子弹列表, 以 1. 接空格开始一个有序列表</p></li>
<li><p>在要加粗的词两侧加 ** 来加粗. 如果要打出 ** 等特殊字符要在星号前加 &nbsp;来转义</p></li>
<li><p>在<strong>行内代码</strong>两侧加 ` . 注意这不是单引号, 在我键盘上在<kbd>Esc</kbd> 键下面. 当然这个不只是用来放行内代码的, 也可以放别的.</p></li>
<li><p>在代码块上下行加 ``` , 第一个```后写代码的语言.</p></li>
<li><p>在Typora这个软件里插入图片很容易, 直接<code>Ctrl V</code>粘贴就好了, 或者右键, 里面有插入图片的按键. 插入图片的markdown语法是</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">![<span class="string">当图片失效时此处显示的文字</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>插入超链接的语法和插入图片的语法很像, 此处举例说明. 这是点击进入百度的链接👉 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>表格用<code>|</code>分隔每个元素, 第一行是各列的名字, 第二行的 <code>|</code>间是<code>-</code>, 分隔列名和值. 以下是一个例子</p></li>
</ul>
<table>
<thead>
<tr class="header">
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
</tbody>
</table>
<ul>
<li>更详细的语法说明在Typora内可以查看Typora自带的Markdown语法参考手册</li>
</ul>
<figure>
<img alt="1569274096465" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569274096465.png"><figcaption>1569274096465</figcaption>
</figure>
<h2 id="typora安利">Typora安利</h2>
<p>那么用什么软件来写Markdown呢? 认准<a href="https://typora.io/#download" target="_blank" rel="noopener"><strong>Typora</strong></a>!</p>
<p>Typora的优点多到我不想写 (不其实是单纯不想写了), 最突出的优点我觉得是它的<strong>颜值</strong>, 以及<strong>能直接将图片粘贴到文件中</strong>.</p>
<h3 id="typora快速入门">Typora快速入门</h3>
<h4 id="主题">主题</h4>
<p>在<strong>Themes</strong>一栏可以切换软件的主题</p>
<figure>
<img alt="1569271897771" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569271897771.png"><figcaption>1569271897771</figcaption>
</figure>
<h4 id="大纲视图">大纲视图</h4>
<p>可以按这个<strong>OutLine</strong>或者按左下角的小圆圈触发大纲视图, 点击大纲视图里的标题可以快速跳转.</p>
<figure>
<img alt="1569272130639" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272130639.png"><figcaption>1569272130639</figcaption>
</figure>
<h4 id="源代码视图">源代码视图</h4>
<p>按左下角这个<kbd>&lt;/&gt;</kbd>可以切换到源代码视图</p>
<figure>
<img alt="1569272534032" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272534032.png"><figcaption>1569272534032</figcaption>
</figure>
<h4 id="拼写检查">拼写检查</h4>
<p>右下角这里可以选择进行拼写检查的语言或者关闭这个功能.</p>
<figure>
<img alt="1569272445049" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272445049.png"><figcaption>1569272445049</figcaption>
</figure>
<h4 id="更多设置">更多设置</h4>
<p>按这个<strong>Preference</strong>可以进行更多偏好设置.</p>
<figure>
<img alt="1569272312746" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272312746.png"><figcaption>1569272312746</figcaption>
</figure>
<p>以下是我的推荐设置</p>
<p><img data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051240.png"></p>
<figure>
<img alt="image-20200227124912356" data-src="Markdown安利-Typora简要使用教程/image-20200227124912356.png"><figcaption>image-20200227124912356</figcaption>
</figure>
<p>勾选<strong>对网络图片应用上述规则</strong>那直接粘贴从浏览器复制的图片时Typora会自动将该图片下载到这个指定文件夹.</p>
<p>忽略单个换行让Typora遵循GFM: 单个换行不渲染为换行, 两个换行才渲染为换行</p>
<p><img data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051204.png"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>杂记</category>
        <category>语言</category>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础语法</title>
    <url>/zh-CN/2019/09/12/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇</p>
<a id="more"></a>
<h2 id="python解释器">Python解释器</h2>
<h2 id="实现">实现</h2>
<table>
<thead>
<tr class="header">
<th>版本</th>
<th>实现方式</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CPython</td>
<td>C语言写的Python</td>
<td>速度快</td>
</tr>
<tr class="even">
<td>JPython</td>
<td>由Java编写的Python</td>
<td>可以直接调用Java的各种函数库</td>
</tr>
<tr class="odd">
<td>PyPy</td>
<td>由rPython编写的Python</td>
<td>更灵活, 易于使用和试验</td>
</tr>
<tr class="even">
<td>IronPython</td>
<td>以. NET和Mono实现的Python</td>
<td>面向NET和ECMA CLI的Python实现</td>
</tr>
<tr class="odd">
<td>ZhPy</td>
<td>只是把Python翻译了一遍而已</td>
<td>又称中蟒, 可以完全用中文编程. 但中蟒目前已经停止更新了.</td>
</tr>
</tbody>
</table>
<p>我们通常所说的Python是<strong>CPython</strong>, 👇Python官方页面提供的是CPython</p>
<figure>
<img alt="1565579206457" data-src="Python基础语法/1565579206457.png"><figcaption>1565579206457</figcaption>
</figure>
<h2 id="版本">版本</h2>
<p>Python这种语言有<strong>Python2</strong>和<strong>Python3</strong>两个版本, 两者语法有少许不同, 比如Python2和Python3中<code>print()</code>的使用有区别, Python2和Python3中<code>input()</code>接受的数据类型有区别等.</p>
<p>最新的Python2对大部分Python2, 3不同的语法做了兼容, 而在Python3对Python2的语法兼容性很差, 但是提供了一个叫<a href="https://docs.python.org/zh-cn/3.7/library/2to3.html" target="_blank" rel="noopener">2to3</a>的脚本帮助我们将Python2的程序转换为Python3的程序.</p>
<h2 id="哲学">哲学</h2>
<p><strong>万物皆对象</strong></p>
<p>python在设计初始是一种<strong>面向对象</strong>语言.</p>
<p>💡 面向对象是一种<strong>编程范式</strong></p>
<h2 id="数据类型">数据类型</h2>
<p>Python是一门<strong>动态类型</strong>语言</p>
<h3 id="类型注解">类型注解</h3>
<p>在Python3中有了一个新特性: <strong>类型注解</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure>
<p>正如其名, 注解只是标注一下, 有了类型注解的程序和没有类型注解的程序运行起来没有区别, 但它能帮助程序员更好的发现问题, 也能让IDE提供更准确的代码补全和语法检查.</p>
<h3 id="类型检查">类型检查</h3>
<p>有时候为了保证程序的严谨性我们会检查一下变量是不是我们设想它应该是的类型, 这个时候我们用 <code>isinstance()</code></p>
<p>之所以不使用 <code>type()</code> 是因为 <code>type()</code> 不会认为子类是一种父类类型, 不考虑继承关系. 举例说明:</p>
<figure>
<img alt="1571027624789" data-src="Python基础语法/1571027624789.png"><figcaption>1571027624789</figcaption>
</figure>
<h3 id="不可变对象">不可变对象</h3>
<p>❗️ <strong>我们可以给不可变对象重新赋值, 但其内存地址会改变</strong>. 以下是体现给可变对象/不可变对象重新赋值时它们的内存地址变化的例子.</p>
<p>💡 <code>id()</code>能获取一个变量的内存地址</p>
<figure>
<img alt="1571022411897" data-src="Python基础语法/1571022411897.png"><figcaption>1571022411897</figcaption>
</figure>
<h4 id="number-数字">Number (数字)</h4>
<ul>
<li>int (整数)</li>
<li>long (长整数)</li>
<li>float (浮点数, 即小数)</li>
<li>bool (布尔值, 即 <code>True</code> 和 <code>False</code> )</li>
</ul>
<p>Python中的Number我认为是比较特殊的, 因为它<strong>在内存中占用的空间大小是变动</strong>的.(在CPython中是如此, 但不知道为什么在IronPython下不是)</p>
<p>💡 用<code>sys.getsizeof()</code>可以知道一个变量的占用的内存大小</p>
<figure>
<img alt="1571022628668" data-src="Python基础语法/1571022628668.png"><figcaption>1571022628668</figcaption>
</figure>
<h4 id="string-字符串">String (字符串)</h4>
<h4 id="tuple-元组">Tuple (元组)</h4>
<h3 id="可变对象">可变对象</h3>
<p>可变对象可能带来的危险举例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(l = [])</span>:</span></span><br><span class="line">    l.append(<span class="string">'add'</span>)</span><br><span class="line">    print(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="list-列表">List (列表)</h4>
<p>💡 <strong>string</strong>和<strong>tuple</strong>都是特殊的<strong>list</strong></p>
<h4 id="set-集合">Set (集合)</h4>
<h4 id="dictionary-字典">Dictionary (字典)</h4>
<p>👇 在网上偷的<strong>string, tuple, list, dictionary的突出区别比较</strong>.</p>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>是否可变</th>
<th>是否可迭代</th>
<th>是否可切片</th>
<th>访问方式</th>
<th>写法举例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>string</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>下标索引</td>
<td>“abcd”</td>
</tr>
<tr class="even">
<td>tuple</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>下标索引</td>
<td>(‘a’,‘b’,‘c’,‘d’,‘abcd’)</td>
</tr>
<tr class="odd">
<td>list</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>下标索引</td>
<td>[‘a’,‘b’,‘c’,‘d’,‘abcd’]</td>
</tr>
<tr class="even">
<td>dictionary</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>关键字索引</td>
<td>{‘1’:‘a’,‘2’:‘b’}</td>
</tr>
</tbody>
</table>
<h3 id="python中有关对象需要注意的问题">Python中有关对象需要注意的问题</h3>
<p>python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响引用的这个变量, 而不可变对象不会. 在向类传递参数时也是如此.</p>
<figure>
<img alt="1571033275137" data-src="Python基础语法/1571033275137.png"><figcaption>1571033275137</figcaption>
</figure>
<h2 id="基础语法">基础语法</h2>
<h3 id="python内置帮助文档">Python内置帮助文档</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">help()</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>help()</code>后就会进入Python内置帮助文档, 然后输入想查的类名/函数名/属性名就可以看到对应的帮助文档.</p>
<p>:bulb: 要注意输入的只有名字, 不带括号什么的, 以及要看一个包里的函数文档时需要先引用该包. 比如如果想查看<strong>time.time()</strong>的帮助文档, 首先<code>import time</code>, 然后输入<code>help()</code>进入帮助文档, 然后输入<code>time.time</code>, 就会看到<strong>time.time()</strong>函数的帮助文档. 按一次<kbd>q</kbd>退出<strong>time.time()</strong>的文档, 再按一次<kbd>q</kbd>退出帮助文档返回交互式Python界面.</p>
<h3 id="注释">注释</h3>
<p>在Python中 <code>#</code> 开头的为注释</p>
<h4 id="特殊注释">特殊注释</h4>
<h5 id="shebang">shebang</h5>
<p>shenbang (hashbang) 指的是以 <code>#!</code> 开头的语句. Linux操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数. 因为在很多语言中以 <code>#</code> 开头的是注释, 所以不会影响程序.</p>
<h5 id="编码格式">编码格式</h5>
<p>有的python文件是这么开头的:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一行是给<strong>Linux系统</strong>的程序加载器看的, 因此在Windows下不需要这句, 第二句是指定文件的编码格式为<strong>UTF-8</strong>, 避免文件中的<strong>非ASCII字符</strong>被识别为乱码.</p>
<h5 id="docstring">docstring</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(int x, int y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这里是docstring, 是特殊的注释, 能让IDE, 编辑器在鼠标移动到有docstring的函数, 类上时显示这段docstring</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = func(i)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="条件语句及循环">条件语句及循环</h3>
<h4 id="if-elif-else">if, elif, else</h4>
<p>下面是按a &lt; 10, 10 &lt; a &lt; 20, 20 &lt; a &lt; 30, a &gt; 30分类的举例.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">20</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">30</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>另外有一种one liner会很喜欢的用法:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="number">2</span> <span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面这句与下面这句等效.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="生成器-迭代器range">生成器 ·迭代器·range</h4>
<p>语法类似于<a href="#切片">切片</a></p>
<h3 id="推导式">推导式</h3>
<p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性.<strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持:</p>
<ul>
<li>列表推导式</li>
<li>字典推导式</li>
<li>集合推导式</li>
</ul>
<p>列表推导式的语法:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">l = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure>
<p>使用举例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="切片">切片</h3>
<p>因为tuple, string其实都是特殊的列表, 所以列表, 字符串, 元组都可以进行切片.</p>
<p>语法: l_sliced = a[begin : end : step]</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">l_sliced = l[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>在没有<strong>numpy</strong>库的情况下<strong>多维切片</strong>是通过推导式实现的:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">b = [a[i][:<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数">函数</h3>
<p>💡 要注意函数名后的 <code>()</code> 也是一种运算符, 称为<strong>函数调用运算符</strong>. 如果调用函数的时候不加()只会创建一个该函数的对象而不会调用它.</p>
<h4 id="定义函数">定义函数</h4>
<p>python中以 <code>def</code> 关键字定义函数, 结构如下:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数主体</span><br></pre></td></tr></tbody></table></figure>
<p>python中的函数可以有返回值也可以没有返回值</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.appeend(<span class="string">'add'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure>
<h3 id="用字典来实现case">用字典来实现case</h3>
<p>示例:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printDefault</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switch = {</span><br><span class="line">    <span class="number">1</span>: print1,</span><br><span class="line">    <span class="number">2</span>: print2,</span><br><span class="line">    <span class="string">'default'</span>: printDefault</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">case = int(input(<span class="string">'input: '</span>))</span><br><span class="line">switch[case <span class="keyword">if</span> (case <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)) <span class="keyword">else</span> <span class="string">'default'</span>]()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="编码格式-1">编码格式</h3>
<p>字符串经过<strong>编码（encode）</strong> 就成为了一堆数据, 反过来, 数据经过<strong>解码（decode）</strong> 就变回我们认识的字符串.</p>
<figure>
<img alt="img" data-src="Python基础语法/encode_decode.png"><figcaption>img</figcaption>
</figure>
<p>指定文件编码格式为 <code>utf-8</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">💡</span> 如果不指定文件编码格式在有的Python2版本中无法识别中文, 即便是中文注释也会报错.</p>
<figure>
<img alt="Unicode Decoding and Encoding" data-src="Python基础语法/Unicode_Decoding_and_Encoding.png"><figcaption>Unicode Decoding and Encoding</figcaption>
</figure>
<p>Linux系统默认编码格式是<strong>UTF-8</strong>, 系统语言是简体中文时Windows10的编码格式是<strong>GB2312</strong> (也称GBK, 国标扩展, cp936)</p>
<p>在python中 <code>str</code> 类型数据都以Unicode码点格式储存, 因此直接打印字符串会看到字符为'开头</p>
<h3 id="基本读写">基本读写</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.write(<span class="string">"text"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br><span class="line">    f.write(<span class="string">"test"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>💡 <strong>使用with语句打开文件是最推荐的方式</strong>, 原因见<a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html" target="_blank" rel="noopener">这里</a></p>
<p>下表是open时要指定的读写模式的比较.</p>
<table>
<thead>
<tr class="header">
<th>读写模式</th>
<th>是否可读</th>
<th>是否可写</th>
<th>文件指针位置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>是</td>
<td>否</td>
<td>文件开头</td>
<td>读取文件, 如果文件不存在则报错</td>
</tr>
<tr class="even">
<td>r+</td>
<td>是</td>
<td>是</td>
<td>文件开头</td>
<td>读取并写入文件, 如果文件不存在则报错</td>
</tr>
<tr class="odd">
<td>w</td>
<td>否</td>
<td>是</td>
<td>文件开头</td>
<td>覆写原文件, 如果文件不存在则创建</td>
</tr>
<tr class="even">
<td>w+</td>
<td>是</td>
<td>是</td>
<td>文件开头</td>
<td>读取并覆盖写原内容, 如果文件不存在则创建</td>
</tr>
<tr class="odd">
<td>a</td>
<td>否</td>
<td>是</td>
<td>文件末尾</td>
<td>追加文件内容, 如果文件不存在则报错</td>
</tr>
<tr class="even">
<td>a+</td>
<td>是</td>
<td>是</td>
<td>文件末尾</td>
<td>追加文件内容并且可读, 如果文件不存在则报错</td>
</tr>
</tbody>
</table>
<p>另外还有<code>b</code>模式, 以二进制打开, 允许我们对二进制文件进行编辑, <code>b</code>可以与其他模式组合使用, 比如 <code>rb</code></p>
<p>🔗 <a href="https://www.cnblogs.com/nulige/p/6128948.html" target="_blank" rel="noopener">python基础-文件读写'r' 和 'rb'区别</a></p>
<h2 id="脚本和普通程序的区别">脚本和普通程序的区别</h2>
<p>脚本这个词来源于戏剧, 能用于舞台演出的戏剧文本就称为<strong>脚本</strong>. 在编程中的脚本是解释执行的程序, 通常只用来做简单的处理, 做自动化处理</p>
<h2 id="解释器的使用技巧">解释器的使用技巧</h2>
<p>在解释器中交互式编程时要注意缩进不要错</p>
<h3 id="清屏">清屏</h3>
<p>python解释器本身没有清屏命令, 只能通过调用命令行的清屏命令来达到效果</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># Windows下</span></span><br><span class="line">os.system(<span class="string">'cls'</span>)</span><br><span class="line"><span class="comment"># Linux下</span></span><br><span class="line">os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="代码风格">代码风格</h2>
<p>我推荐遵从<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a>. 当然一行一行看完这个规范不是一件令人愉快的事, 最简单的时刻遵守PEP8的方式是在代码工具里安一个<strong>代码风格检查器</strong> (linter). 检查你的代码是否符合PEP8的linter是<a href="http://pycodestyle.pycqa.org/en/latest/intro.html" target="_blank" rel="noopener">pycodestyle</a></p>
<p>💡 在VSC中可以在设置中搜索<strong>python.linting.pycodestyle</strong>, 勾选<strong>Pycodestyle Enabled</strong>, 这样在VSC中编写Python代码时使用的linter就是pycodestyle啦</p>
<figure>
<img alt="1571142193232" data-src="Python基础语法/1571142193232.png"><figcaption>1571142193232</figcaption>
</figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
        <category>语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>意识到了我的中文有多差</title>
    <url>/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/</url>
    <content><![CDATA[<p>前阵子别人给我分享了<a href="https://www.byvoid.com/" target="_blank" rel="noopener">这个博客</a>, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!</p>
<a id="more"></a>
<p>先不提这个博主喜爱音韵学, 单说同样是理工科出身的博主, 我的表达能力和思想深度比他差了太多.</p>
<p>通常在解释一段程序时我会想好一会来组织语言, <strong>将我使用这段代码的意图尽可能体现出来, 描述尽可能准确, 有条理</strong>. 我对此体会良多: 当我刚开始接触一个领域, 在网上看资料时常常无法确定我理解得对不对, 需要结合多篇文章才能确定. 这是因为<strong>作者们自身接触这些许久, 无意识的省略了一些话</strong>. 但我认为文章既然要写出来就应该能让所有人无障碍的看懂, 不然只给自己看的话何不就放到自己github仓库?</p>
<p><a href="https://akaedu.github.io/book/index.html" target="_blank" rel="noopener">Linux C编程一站式学习</a>和 <a href="https://www.pyimagesearch.com" target="_blank" rel="noopener">pyimagesearch</a>的文章就让人觉得文章读起来很流畅很易懂, 不会浪费时间在理解文章上. 比如<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" target="_blank" rel="noopener">这篇文章</a> 曾带我轻松完成了困扰了我好几天的如何在树莓派上安装OpenCV的问题. 这个问题现在当然不会像前年那样困扰我, 但能有这样一篇好懂的文章指导我迅速完成我当然是十分乐意的.</p>
<p>因此我总是试图让我的文章能达到同样水准. 但我发现这很难. 说来可笑, 很多时候我甚至不知道怎么样去描述我的操作🤦‍ 而让文章有条理同样不是一件容易的事. 我感觉这和写一篇议论文围绕一个中心套用总分总的文章结构就可以写不一样, 我总是喜欢把一个主题的东西一股脑放到一篇文章里, 但我发现一方面<strong>文章太长会让人失去读下去的兴趣</strong>, 另一方面<strong>什么东西都往一篇文章里放会让文章失其重点</strong>. 我又不是在写书, 不如将一个主题的内容再按照几个重点分成几篇文章. 可<strong>将一篇文章分割为主题更明确的多篇文章</strong>对我来说并不是易事...</p>
<p>至于说<strong>byvoid</strong>的文章有思想深度, 从<a href="https://www.byvoid.com/zht/blog/why-the-usa-is-so-boring-1" target="_blank" rel="noopener">这篇文章</a>可见一斑. 我也喜欢旅游, 并且因为我小时候见了许多很美的自然景观, 我更倾向于体验一处的文化. 到一处游览后能有像<strong>byvoid</strong>这种深度的心得正是我所想努力做到的. 但一是我的文笔不够好, 二是我并没有做功课去研究旅游地的文化.</p>
<p>从<strong>byvoid</strong>的文章能体会到中文的魅力: 用得好了读起来十分流畅, 四字成语言简意赅地表达出了意思, 很多用以佐证的诗句更是回味无穷... 这只是我个人的体会, 我也知道很粗浅. 当然我并不后悔初高中没有投入大量精力背诵各种诗句, 品鉴各大文豪的文章: 体会不到这些的魅力时我背下来又有什么用呢?</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>我将Shell换为了zsh</title>
    <url>/zh-CN/2019/09/02/%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/</url>
    <content><![CDATA[<p>我把shell从<strong>bash</strong>换到<strong>zsh</strong>了. 原本我是根本没动过换shell的念头的, 但因为这段时间用的笔记本被别人装好了zsh, 我就将就着用了, 谁知真香...</p>
<a id="more"></a>
<p>不得不说zsh比bash确实好了许多:</p>
<ul>
<li>补全智能了太多! 比如切换路径时的补全不必区分大小写, 比如会根据历史命令给出建议, 比如如果命令里有<code>$(pwd)</code>这样的取值操作, 按一下<kbd>Tab</kbd>zsh会将其补全为对应的值.</li>
<li>支持一次输入多行命令再执行. 不像bash只能一行一行运行, 如果其中有命令是需要输入确认的, 那么下一条命令就会被当做这条命令的确认用输入中, 然后就会报错 🤷</li>
<li>Powerlevel9k这个主题很好看很强大, 能显示出包括<strong>git状态</strong>, <strong>当前Python环境</strong>, <strong>命令执行时间</strong>, <strong>后台任务数量</strong>, <strong>当前时间</strong>在内的许多有用信息</li>
<li>zsh有许多很有用的插件</li>
</ul>
<p>总之我要到zsh去了, bash再见👋</p>
<p>下面是部分功能的展示</p>
<p><img data-src="我将shell换为了zsh/screencast.gif"></p>
<p>下面我大致说一下我的zsh配置</p>
<ul>
<li>zsh配置管理工具: <a href="https://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh</a></li>
<li>zsh插件管理工具: <a href="https://github.com/zsh-users/antigen" target="_blank" rel="noopener">Antigen</a></li>
<li>zsh主题: <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">Nerd-Fonts</a>字体(具体来说是<a href="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/DejaVuSansMono" target="_blank" rel="noopener">DejaVuSansMono Nerd</a>)的<a href="https://github.com/Powerlevel9k/powerlevel9k" target="_blank" rel="noopener">Powerlevel9k</a>主题</li>
</ul>
<p>以下是我的<code>~/.zshrc</code>中部分代码.</p>
<p>有关Powerlevel9k:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">POWERLEVEL9K_MODE='nerdfont-complete'</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND="black"</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND="blue"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON="echo   $(whoami) "</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_BACKGROUND="purple"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_FOREGROUND="white"</span><br><span class="line">POWERLEVEL9K_ANACONDA_BACKGROUND="chartreuse3"</span><br><span class="line">POWERLEVEL9K_ANACONDA_LEFT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_DIR_HOME_BACKGROUND='123'</span><br><span class="line">POWERLEVEL9K_DIR_HOME_SUBFOLDER_BACKGROUND='123'</span><br><span class="line"><span class="meta">#</span><span class="bash"> POWERLEVEL9K_DIR_ETC_BACKGROUND=<span class="string">'123'</span></span></span><br><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(custom_os_icon ssh anaconda root_indicator dir dir_writable vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(command_execution_time status background_jobs time)</span><br><span class="line">ZSH_THEME="powerlevel9k/powerlevel9k"</span><br></pre></td></tr></tbody></table></figure>
<p>有关zsh插件:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Which plugins would you like to load?</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Standard plugins can be found <span class="keyword">in</span> ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">source ~/Desktop/backup/zsh/antigen.zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the oh-my-zsh<span class="string">'s library.</span></span></span><br><span class="line">antigen use oh-my-zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Bundles from the default repo (robbyrussell<span class="string">'s oh-my-zsh).</span></span></span><br><span class="line">antigen bundle git</span><br><span class="line">antigen bundle pip</span><br><span class="line">antigen bundle command-not-found</span><br><span class="line"><span class="meta">#</span><span class="bash"> custom plugins</span></span><br><span class="line">antigen bundle zsh-users/zsh-syntax-highlighting</span><br><span class="line">antigen bundle zsh-users/zsh-autosuggestions</span><br><span class="line">antigen bundle sobolevn/wakatime-zsh-plugin</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the theme.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> antigen theme powerlevel9k/powerlevel9k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell Antigen that you<span class="string">'re done.</span></span></span><br><span class="line">antigen apply</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>更好的Shebang使用方式</title>
    <url>/zh-CN/2019/09/13/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在Linux系统的脚本第一行我们通常用 <a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang</a>语句来指明解释器路径, 一方面有的脚本没有文件后缀名, 需要通过shebang语句指明系统才知道要用什么解释器运行. 另一方面有时候为了兼容性我们会指明使用标准位置的系统安装版本解释器.</p>
<p>但我发现有时候我们并不能确定使用者把我们需要类型的解释器装到了地方, 如果我们只想指出<strong>使用的解释器类型</strong>而不是具体路径, 可以使用<code>/usr/bin/env</code>命令. 比如如果我们想用Python3解释器执行一个脚本, 可以在第一行加:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>env</code>会调用用户<strong>$PATH</strong>中首先出现的解释器版本.</p>
<p>当然对于更复杂的情况更建议专门写一段程序来决定用哪个解释器.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>操作系统</category>
        <category>技巧</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>我开始用集成开发工具部署我的博客</title>
    <url>/zh-CN/2019/10/06/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这几天分别尝试了用<strong>Travis CI</strong>和<strong>GitHub Action</strong>部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢<strong>GitHub Action</strong>, 因为它就是Github的, 集成度更高. 而且<strong>Github Action</strong>支持的触发条件更多样一些.</p>
<a id="more"></a>
<p>先分别放上我使用Travis和GitHub Action时的配置文件</p>
<p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/blob/02ce864f1cbe09d82c0dfe6f617b36737344d41e/.travis.yml" target="_blank" rel="noopener">Travis配置文件</a></p>
<p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/tree/Root/.github/workflows" target="_blank" rel="noopener">GitHub Action配置文件</a></p>
<h2 id="github-action的缺点">GitHub Action的缺点</h2>
<p>可以看出Travis要更<strong>成熟</strong>一些, 提供了一些很方便的功能, 比如要添加ssh known hosts, travis只需要</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">addons:</span></span><br><span class="line">  <span class="attr">ssh_known_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">github.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ssh.github.com</span></span><br></pre></td></tr></tbody></table></figure>
<p>而在GitHub Action中需要</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">login</span> <span class="string">ssh</span> <span class="string">and</span> <span class="string">git</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">~/.ssh</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">-e</span> <span class="string">"Host github.com\nStrictHostKeyChecking no\nIdentityFile ~/.ssh/id_rsa_github_action"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/config</span></span><br></pre></td></tr></tbody></table></figure>
<p>看起来GitHub Action的配置更短, 但这句是强行不验证github.com的服务器, 并没有Travis中的配置直观, 合理.</p>
<p>另外GitHub Action暂时还不支持<strong>缓存</strong>, 照<a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts" target="_blank" rel="noopener">这个样子</a>即便实现了也是很别扭的东西... 我觉得缓存还是一个很重要的功能. 一个最简单的例子: 没有缓存的public文件夹导致刚换到GitHub Action时我的每篇博客<strong>更新时间与我的最后一次上传时间相同</strong> (hexo通过对比source文件夹和public文件夹的时间戳来判断更新时间). 目前我是通过将master分支下载到public文件夹来蛮力解决的.</p>
<h2 id="github-action的优点">GitHub Action的优点</h2>
<p>当然GitHub Action的优点也是明显的, 比如我的代码的<strong>托管平台和持续集成平台合二为一</strong>, 不说管理起来方便了多少至少内心通达了😆</p>
<p>另外GitHub Action的支持的触发条件更加丰富, 比如用下面代码可以指定只有<code>Root</code>分支有推送且有<strong>source/en</strong>文件夹以外的文件变动时才运行. 换句话说只有配置文件或者中文博客内容发生变动时才运行.</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Root</span></span><br><span class="line">    <span class="attr">paths-ignore:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'source/en/**'</span></span><br></pre></td></tr></tbody></table></figure>
<p>在<a href="https://docs.travis-ci.com/user/conditional-builds-stages-jobs/" target="_blank" rel="noopener">Travis的文档</a>中我并没有看到可以这么操作.</p>
<p>再有就是GitHub Action支持一个项目有<strong>多个</strong>workflow, 比如我的博客就同时在运行两个工作流: 一个生成并部署中文博客, 一个生成并部署英文博客. 这是一个十分吸引人的功能! 并且GitHub正试图将workflow打造成能<strong>轻松分享, 引用</strong>的东西, 这能极大减少人们写这些繁琐低级的配置文件的时间. 实际上GitHub已经<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">初步成功了</a>. 在我的配置中就引用了两个GitHub官方发布的action.</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">8.10</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="number">8.10</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>目前来说GitHub Action体验着很不错!</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>CI/CD</category>
      </categories>
  </entry>
  <entry>
    <title>广受好评的机器人相关 (数学/物理/控制/计算机类) 网课列表</title>
    <url>/zh-CN/2020/02/22/%E5%B9%BF%E5%8F%97%E5%A5%BD%E8%AF%84%E7%9A%84%E6%95%B0%E5%AD%A6-IT%E7%B1%BB%E7%BD%91%E8%AF%BE%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>最近很多国内学校因为疫情开始在网上上课, 不过我们学校的网课体验很差... 网络问题暂且不说, 既然都是网课何不去学习那些广受好评的版本? 列出一些广受好评的课程链接, 希望能帮到一些同样在被迫害的同学们 (也方便我以后极速复习) 💩</p>
<a id="more"></a>
<p>❗️ 好的学习资料有很多, 种类也很多 (网课, 书, 网站, 习题集, 项目...) 为了避免内容太过杂乱此处只讨论网课.</p>
<p>P.S. 我觉得网课的好处是有老师的讲解十分易懂, 同时通过倍速播放可以极速学习 😏</p>
<p>💡 为达到最好效果, 我的做法是把网课视频都下载下来, 在vlc中<strong>设置播放时显示当前文件名及时间</strong>并倍速播放. 到关键点, 或者想要记笔记的地方就暂停并截屏保存到一个文件夹 (截屏软件Windows下推荐snipaste, Linux下推荐Flameshot)</p>
<h2 id="数学">数学</h2>
<h3 id="mit-线性代数">MIT-线性代数</h3>
<p>特点: 教授的粉笔巨大无比 😂</p>
<p>相较于国内老师从行列式入手, 这门课<strong>从几何空间的角度更加直观揭示线代的内核</strong>.</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1zx411g7gq" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">网易公开课链接</a></p>
<h3 id="mit-概率论">MIT-概率论</h3>
<p>🔗<a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">b站链接</a></p>
<h3 id="张宇考研-数学-微积分-线性代数-概率论">张宇考研-数学 (微积分, 线性代数, 概率论)</h3>
<p>🔗<a href="https://www.youtube.com/watch?v=ghNtuabD6Ss&amp;list=PLRMOX8QaZK8z4yLzXRkiPO38R911V7TQE" target="_blank" rel="noopener">YouTube链接</a></p>
<h2 id="物理">物理</h2>
<h3 id="北航-理论力学">北航-理论力学</h3>
<p>王琪老师讲得特别贴合实际, 有许多很生动的例子 👍</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1k7411T7QU" target="_blank" rel="noopener">b站链接</a></p>
<h2 id="信号处理">信号处理</h2>
<h3 id="mit-信号与系统">MIT-信号与系统</h3>
<p><strong>奥本海姆亲授版!</strong> 相信国内大部分学信号与系统这门课的同学的课本都是奥本海姆编写的. 虽然这个是二十多年前录制的课程了, 演示时使用的是很古老的覆盖片和只有绿色荧光的电脑屏幕, 但是奥本海姆教授讲解得十分清晰, 处理信号的核心思想贯穿始终, 让人学得十分系统性.</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1xy4y167DD" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/free?pid=M8AROL7GG&amp;mid=M8AROOU9F" target="_blank" rel="noopener">网易公开课链接</a></p>
<h3 id="mit-数字信号处理">MIT-数字信号处理</h3>
<p>认准奥本海姆教授 👍</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1uk4y1R771" target="_blank" rel="noopener">b站链接</a></p>
<h2 id="计算机">计算机</h2>
<h3 id="mit-计算机科学及编程导论">MIT-计算机科学及编程导论</h3>
<p>这门课主要针对<strong>从未接触过计算机科学或编程的人</strong>. 基于<strong>python</strong>讲解了基础的程序编写, 调试, 算法, 数据结构, 面向对象等内容, 比起知识的深度更注重知识的广度 (内容较为简单).</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1m4411U7gs" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fbianchengdaolun.html" target="_blank" rel="noopener">网易公开课链接</a></p>
<h3 id="翁恺-c语言程序设计">翁恺-C语言程序设计</h3>
<p>C语言入门课.</p>
<p>🔗<a href="https://www.bilibili.com/video/BV1sJ411E7St" target="_blank" rel="noopener">b站链接</a> 🔗<a href="https://www.icourse163.org/course/ZJU-9001" target="_blank" rel="noopener">中国大学MOOC链接</a></p>
<h3 id="清华-数据结构与算法">清华-数据结构与算法</h3>
<p>🔗<a href="https://www.bilibili.com/video/BV1jt4y117KR" target="_blank" rel="noopener">b站链接</a></p>
<h3 id="mit-计算机教育中缺失的一课">MIT-计算机教育中缺失的一课</h3>
<p>这门课主要对一些非常常用但是大多数人不怎么了解的强大开发工具, 或者说常见操作进行了讲解. 比如说怎么洗数据, 怎么用shell脚本偷懒, 版本控制该怎么做, etc. 每一个部分视频时长基本只有1h, 但是已经覆盖了这些工具最有价值的部分, 可以说是性价比很高了 👍</p>
<p>🔗<a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">英文版</a> 🔗<a href="https://missing-semester-cn.github.io/" target="_blank" rel="noopener">中文版</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>文件命名规则总结</title>
    <url>/zh-CN/2020/02/06/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>如果待处理文件的文件名中含有一些特殊字符, 有许多程序会因为考虑不完善 (或者说程序员偷懒) 而出现识别不到文件, 文件处理出错, 结果不符合意图, 甚至程序崩溃的问题. 而为了方便自己偷懒, 我总结了一些命名文件的规则.</p>
<a id="more"></a>
<p>💡 我并不是说文件名命名必须遵循这些准则, 只是在程序设计/输入不够严谨 (也就是想偷懒的情况下) 这样的命名准则是最不容易导致错误的👍</p>
<h2 id="文件名中只应该包含数字-字母-汉字-下划线-连字符-句点">文件名中只应该包含数字, 字母, 汉字, 下划线, 连字符, 句点</h2>
<p>许多特殊字符会让程序出错, 下面举几个例子:</p>
<ul>
<li><code>文件名里 有空格.jpg</code> 这样的文件名很可能让程序以为要处理的文件的名字是<code>文件名里</code>, 因而找不到文件或者处理了错误的文件. 而<code>有空格.jpg</code>会被当成无效参数, 多余字符.</li>
<li><code>文件名里/有左斜杠.avi</code> 这样的文件名在很多程序里会被认为是一个名为<code>文件名里</code>的文件夹下的<code>有左斜杠.avi</code>文件, 因此可能得到<strong>没有<code>文件名里</code>这个文件夹</strong>的报错</li>
<li><code>文件名里(有)括号.gif</code> 比如在markdown文档中用<code>![](文件名里(有)括号.gif)</code>来引用这个gif, 在有的markdown渲染器会被渲染为<strong>)括号.gif</strong>. 因为前一个)被认为是markdown引用图片的<code>![]()</code>语法的结束符了.</li>
<li>在一些较老的程序中汉字也算是一种特殊字符. 比如在python2中如果不特意注意编码格式转换问题的话中文很容易被读取为乱码. 当然现在的程序大多是兼容汉字的. (Python2在已经终止维护了🕯)</li>
</ul>
<blockquote>
<p>空格用下划线代替, 其他字符用连字符代替</p>
</blockquote>
<p>如果你原本想要包含这些特殊字符在文件名中来表达一些逻辑关系, 我的做法是用_来代替空格, 用-来代替其他字符.</p>
<h2 id="当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字-并且位数不足的用0在左侧占位">当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</h2>
<p>曾经我很困惑下面这两种情况的文件夹排序为什么不是从小到大的, 后来我发现前者是因为文件系统<strong>不把汉字数字作为排序用的数字</strong> (有意思的是我Ubuntu系统和Windows系统里图一情况排序不一样), 后一个是因为文件系统是<strong>逐字比较</strong>而不是把一串数字作为一个数 (windows系统和Ubuntu系统排序图2情况时都能正常排序)</p>
<blockquote>
<p>图一 Ubuntu系统下含汉字数字文件名排序</p>
</blockquote>
<p><img data-src="文件命名规则总结/image-20200207181027438.png"></p>
<blockquote>
<p>图二 百度云里含数字文件名排序</p>
</blockquote>
<p><img data-src="文件命名规则总结/Screenshot_20200207_181843.jpg"></p>
<p>因此如果想在文件名中包含有排序功能的数字, 或者表达顺序之意时应当<strong>用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</strong>.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>Graphviz简要语法</title>
    <url>/zh-CN/2020/03/12/Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://emden.github.io/" target="_blank" rel="noopener">Graphviz</a>是一个很强大的<strong>图形可视化工具</strong>. 它使用<strong>DOT</strong>语言来描述图形, 但它并不单纯是个绘图软件, 而是能接入程序, 进行函数调用流程, 决策树, 数据结构, 日志系统等图形关系生成, 而且可以是<strong>交互式</strong>的 (不过我暂时没研究过所以不太了解). 暂且不提这些扩展功能, graphviz的语法允许我们仅通过文字描述能绘制出样式极其丰富的图形, 这大大方便了对图形的改动的跟踪.</p>
<a id="more"></a>
<h2 id="有关官方文档">有关官方文档</h2>
<p>graphviz.org这个网站也不知道是不是停止维护了, 所有除了指向其他人的项目的链接都是无效链接了... 我在上面放的graphviz的官网链接是<a href="https://gitlab.com/graphviz/graphviz" target="_blank" rel="noopener">graphviz的GitLab repo</a>提供的地址. (实际上我觉得这个项目对文档的维护<strong>很烂</strong>, 描述得很不清楚, 有些地方甚至有错误. 这也是为什么我要自己总结一篇常用语法).</p>
<p>官方给出的有助于编写DOT文件的文档我觉得就这几个:</p>
<ul>
<li><a href="https://emden.github.io/_pages/doc/info/lang.html" target="_blank" rel="noopener">DOT语言概述</a></li>
<li><a href="https://emden.github.io/_pages/doc/info/attrs.html" target="_blank" rel="noopener">节点, 边线, 图形的属性列表</a></li>
<li><a href="https://emden.github.io/_pages/doc/info/shapes.html" target="_blank" rel="noopener">节点的三种形状设定方式及节点的样式详解</a> (此处又不得不吐槽graphviz开发组的文档组织真的差)</li>
<li><a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">箭头的头部形状参数详解</a></li>
<li><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">graphviz中可用颜色及颜色主题列表</a></li>
</ul>
<p>但其实给我帮助最大的是<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener"><strong>被graphviz开发组嫌弃的旧版文档 (dot布局版)</strong></a></p>
<p>❗️ 因为我最常使用的是<strong>dot</strong>布局所以此处涉及的内容大部分为dot布局下的情况.</p>
<h2 id="基础语法">基础语法</h2>
<h3 id="hello-world">Hello World</h3>
<p>还是先来个Hello World 😏</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G{</span><br><span class="line">    Hello -&gt; World;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><embed src="Graphviz简要语法/helloworld.svg?20"></p>
<h3 id="常见用法">常见用法</h3>
<p>因为graphviz许多概念解释起来会套娃, 要理解概念A要先理解概念B, 要理解概念B则需要先知道什么是概念A 🤤 因此这里先放上一些常用属性来快速入门.</p>
<p>🌟 不明白到底如何使用属性的话点<a href="#属性">这里</a>快速跳转后文的实例.</p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 12%">
<col style="width: 33%">
<col style="width: 10%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>用途</th>
<th>属性名</th>
<th>可选值</th>
<th>作用对象</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>轮廓颜色</td>
<td><code>color</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>节点, 边线, 簇</td>
<td></td>
</tr>
<tr class="even">
<td>填充颜色</td>
<td><code>bgcolor</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>簇, 图</td>
<td><code>fillcolor</code>会覆盖<code>bgcolor</code></td>
</tr>
<tr class="odd">
<td>填充颜色</td>
<td><code>fillcolor</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>节点, 边线, 簇</td>
<td>需要与<code>style=filled</code>一起使用. 如果设置了<code>style=filled</code>但没有设置<code>fillcolor</code>那么<code>color</code>的值将被同时用于轮廓和填充</td>
</tr>
<tr class="even">
<td>字体颜色</td>
<td><code>fontcolor</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td>
<td>节点, 边线, 簇, 图</td>
<td></td>
</tr>
<tr class="odd">
<td>箭头方向</td>
<td><code>dir</code></td>
<td>"forward", "back", "both", "none"</td>
<td>边线</td>
<td>正向/反向/双向/无箭头</td>
</tr>
<tr class="even">
<td>箭头形状</td>
<td><code>arrowhead</code> <code>arrortail</code></td>
<td>见备注</td>
<td>边线</td>
<td>graphviz提供了极其丰富的箭头形状值, 常用值参见<a href="https://emden.github.io/_pages/doc/info/attrs.html#k:arrowType" target="_blank" rel="noopener">这里</a>, 箭头形状值的完整说明见<a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">这里</a></td>
</tr>
<tr class="odd">
<td>样式</td>
<td><code>style</code></td>
<td><a href="https://emden.github.io/_pages/doc/info/attrs.html#k:style" target="_blank" rel="noopener">各对象样式说明</a></td>
<td>节点, 边线, 簇, 图</td>
<td>emmm这个style很难准确地翻译为中文, 因为这个属性被很笼统地赋予了四种对象...总的来说是在描述这个对象长什么样, 是虚线的还是加粗的又或是点点的</td>
</tr>
<tr class="even">
<td>边线风格</td>
<td><code>splines</code></td>
<td>none, line, polyline, curved, ortho, spline</td>
<td>图</td>
<td>不显示边线/线段 (false)/线段 (true)/弧线/直角折线/常规. 到底什么样详见<a href="https://emden.github.io/_pages/doc/info/attrs.html#d:splines" target="_blank" rel="noopener">splines说明</a> emmmm我感觉<strong>polyline</strong>和<strong>spline</strong>并没有区别...再次吐槽graphviz开发组的混乱逻辑 😩</td>
</tr>
<tr class="odd">
<td>label水平对齐方式</td>
<td><code>labeljust</code></td>
<td>"l", "r"</td>
<td>图, 簇</td>
<td>"l"就是和图/簇的左边界对齐, "r"就是和图/簇的右边界对齐. 如果父级显性设置了这一属性, 子图会继承这一属性. <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 实际上还有一个可选值, 就是不设置这个属性, 那么label就会居中对齐.</td>
</tr>
<tr class="even">
<td>label垂直对齐方式</td>
<td><code>labelloc</code></td>
<td>"t", "b", "c"</td>
<td>节点, 图, 簇</td>
<td>对于图和簇只有"t"和"b"是可用的, 即标签只能设置在图/簇的顶部或者底部. 如果父级显性设置了这一属性, 子图会继承这一属性. 而对于一个节点, 只有当它的高度大于label这个属性才是可用的.</td>
</tr>
<tr class="odd">
<td>节点排布方向</td>
<td>rankdir</td>
<td>TB, BT, LR, RL</td>
<td>图</td>
<td>从上到下/从下到上/从左到右/从右到左</td>
</tr>
</tbody>
</table>
<h3 id="layout-布局">Layout (布局)</h3>
<p>💡 graphviz有一点不好的是节点在画布上的位置是<strong>由算法决定</strong>的, 不能<strong>完全</strong>自己设定, 因此有时候无法让图变得那么美观.</p>
<p>graphviz提供了多种<strong>用于排布节点, 边线箭头头部, 边线标签位置</strong>的布局算法.</p>
<p>因为了解graphviz的布局算法有助于我们更好的布局, 此处简单翻译一下<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener">被现在graphviz开发组嫌弃的旧版文档 (dot布局版)</a>描述的<strong>dot布局</strong>的图形绘制主要的四步:</p>
<ol type="1">
<li>通过反转一些边线的指向来打破输入图形 (我猜这个输入图形说的是.dot文件) 中出现的所有循环 (因为dot布局算法是基于非循环图形的)</li>
<li><p>给各节点赋予不同的等级 (<code>rank</code>). (比如在一个top-to-bottom方向的图中等级决定了节点的纵坐标) 连接跨度超过一个等级的节点的边线会被分割成一串"虚拟"节点以及单位长度的边线</p>
<p>💡 后文会提及对节点的rank是可以进行一些设置的.</p></li>
<li>给同等级的节点排序, 避免绘图时出现边线的交叉 (估计只是减少交叉?)</li>
<li><p>在让边线尽可能短的情况下设定节点的横坐标, 然后绘制边线 (同样是假设是top-to-bottom方向的图)</p></li>
</ol>
<p>下面给出一些主要布局算法的简单说明和图例.</p>
<p>💡 以下布局的图例除了最后一个都来自<a href="https://emden.github.io/gallery/" target="_blank" rel="noopener">graphviz-gallary</a></p>
<h4 id="dot">dot</h4>
<p>用于绘制<strong>有向图</strong>, 他的布局算法原理上面已经说了, 特点是绘制出的图<strong>很有层次</strong>.</p>
<p>❗️ 注意dot布局和DOT语言不是一个东西.</p>
<figure>
<embed src="Graphviz简要语法/cluster.png?20"><figcaption>img</figcaption>
</figure>
<h4 id="neato">neato</h4>
<p>用于绘制<strong>无向图</strong>. neato布局算法的原理是构建一个虚拟物理模型并不断对其迭代最终得到一个<strong>最低总能量排布</strong> (low-energy configuration). 这个虚拟物理模型具体指的是在每个节点间放置一个<strong>理想弹簧</strong>, 这样得到的布局通常很合理. (在统计学中这种算法也被称作<strong>多维缩放</strong>). neato布局很适合用于<strong>通信网络</strong>及<strong>计算机程序</strong>的绘制.</p>
<p>💡 当图较大 (超过100个节点)时就该考虑换成fdp或者sfdp布局了</p>
<figure>
<embed src="Graphviz简要语法/ER.png?30"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="fdp">fdp</h4>
<p>同样是基于弹簧模型. 区别在于fdp算法的迭代是在试图减小节点间弹簧的力的大小而不是弹簧能量大小.</p>
<figure>
<embed src="Graphviz简要语法/fdpclust.png?40"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="sfdp">sfdp</h4>
<p>为大规模图而生的多尺度版fdp</p>
<figure>
<embed src="Graphviz简要语法/JGD_BIBD@bibd_17_3.gif?40"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>上面这个图得自🔗 <a href="http://yifanhu.net/GALLERY/GRAPHS/index.html" target="_blank" rel="noopener">A Gallery of Large Graphs</a>. 这个网站还有<strong>很多</strong>很壮观的图😳</p>
<h4 id="twopi">twopi</h4>
<p>径向布局.</p>
<figure>
<embed src="Graphviz简要语法/twopi2.png?50"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="circo">circo</h4>
<p>圆形布局. 很适合有许多环路结构的图, 比如电信网络.</p>
<figure>
<embed src="Graphviz简要语法/circo.png?30"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="有关三种主要描述对象">有关三种主要描述对象</h3>
<p>DOT语言主要描述三种对象: <strong>graph</strong>, <strong>node</strong>, <strong>edge</strong>. 这里分别翻译为<strong>图</strong>, <strong>节点</strong>, <strong>边线</strong>. 每一种对象有各自可以设置的一组属性.</p>
<h4 id="graph-图">Graph (图)</h4>
<p>最外层的graph (main graph)可以被设定为<strong>有向图</strong><code>digraph</code>(directed graph)或是<strong>无向图</strong><code>graph</code>(undirected graph). main graph内可以用<code>subgraph</code>来定义一个节点和边线的集合. 也可以通过设定最外层图为<code>strict digraph</code>或者<code>strict graph</code>来禁用<strong>multi-edges</strong>. 也就是说<code>strict digraph</code>会让有向图中一个指向节点和一个被指向节点间只能有一条边线 (不过反过来还可以有一条, 也就是两节点间最多两条边线), <code>strict graph</code>则会让无向图中两节点间只能有一条边线.</p>
<p>最外层的图又称top-level graph, root graph (反正开发组文档都没能统一这东西的叫法). 图可以有子图 (subgraph), 子图会继承父级的显式设置的大部分属性. 有一种特殊的子图被称为<a href="#Cluster-簇"><strong>簇</strong></a>.</p>
<h4 id="node-节点">Node (节点)</h4>
<p>一个节点会<strong>在第一次在DOT文件中出现时被创建</strong>.</p>
<h4 id="edge-边线">Edge (边线)</h4>
<p>一条边线会在几个节点被用<code>-&gt;</code>边线操作符连接时被创建.</p>
<p>💡 <strong>在graphviz中可以直接用中文作为节点名.</strong></p>
<h3 id="label-标签">Label (标签)</h3>
<p>如果你想要显示的标签中有空格, 那通过把节点名用<code>""</code>括起来可以实现, 当然显式声明标签内容是更好的选择. 而<strong>如果你想让一些节点显示相同的标签那就必须显式声明节点的标签了</strong>, 因为节点名不能重复.</p>
<p>💡 label中可以使用转义字符比如<code>\n</code>来实现多行标签.</p>
<h4 id="html-like-label">HTML-like Label</h4>
<p>为了能提供更丰富的样式, dot布局支持使用HTML语法的HTML-like标签 (看了下似乎其他布局不支持这种东西).</p>
<p>具体可用语法格式参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 总结下来就是目前支持以下几种类HTML元素:</p>
<ul>
<li>斜体 &lt;i&gt;</li>
<li>粗体 &lt;b&gt;</li>
<li>下划线 &lt;u&gt;</li>
<li>上划线 &lt;o&gt;</li>
<li>删除线 &lt;s&gt;</li>
<li>下角标 &lt;sub&gt;</li>
<li>上角标 &lt;sup&gt;</li>
<li>指定字体 &lt;font&gt;</li>
<li>换行符 &lt;br /&gt;</li>
<li>表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;</li>
<li>图片 &lt;img&gt;</li>
<li>水平/竖直分割线 &lt;hr&gt; &lt;vr&gt;</li>
</ul>
<p>❗️ 要注意这种类HTML标签只是<strong>借鉴自HTML</strong>, 和HTML元素并不完全一样, 因此<strong>并不支持html中其他写法和属性</strong>. 再比如HTML中是没有上面这个<code>&lt;vr&gt;</code>tag的😅</p>
<p>不得不说类HTML标签确实极大地提升了灵活性, 让我们能写出奇形怪状的节点形状, 能在标签中嵌入图片等, 详情参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 不过这东西写起来确实麻烦一些...</p>
<blockquote>
<p>一个展示类HTML标签能带来的丰富样式的例子</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">  rankdir=LR</span><br><span class="line">  node [shape=plaintext]</span><br><span class="line">  a [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD ROWSPAN="3" BGCOLOR="yellow"&gt;class&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD PORT="here" BGCOLOR="lightblue"&gt;qualifier&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  b [shape=ellipse style=filled</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BGCOLOR="bisque"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="3"&gt;elephant&lt;/TD&gt;</span><br><span class="line">          &lt;TD ROWSPAN="2" BGCOLOR="chartreuse" VALIGN="bottom" ALIGN="right"&gt;two&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" ROWSPAN="2"&gt;</span><br><span class="line">            &lt;TABLE BGCOLOR="grey"&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;corn&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD BGCOLOR="yellow"&gt;c&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;f&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">            &lt;/TABLE&gt;</span><br><span class="line">          &lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="white"&gt;penguin&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" BORDER="4" ALIGN="right" PORT="there"&gt;4&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  c [</span><br><span class="line">    label=&lt;long line 1&lt;BR/&gt;line 2&lt;BR ALIGN="LEFT"/&gt;line 3&lt;BR ALIGN="RIGHT"/&gt;&gt;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  subgraph { rank=same b c }</span><br><span class="line">  a:here -&gt; b:there [dir=both arrowtail=diamond]</span><br><span class="line">  c -&gt; b</span><br><span class="line">  d [shape=triangle]</span><br><span class="line">  d -&gt; c [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD BGCOLOR="red" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">          &lt;TD&gt;Edge labels&lt;BR/&gt;also&lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="blue" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><embed src="Graphviz简要语法/html-like_label.svg?60"></p>
<h3 id="属性">属性</h3>
<p>属性是通过<code>name=value</code>形式来设置的. 节点与边线的属性需要放在<code>[]</code>方括号中.</p>
<blockquote>
<p>一个展示属性写法以及属性能做些什么的例子</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    size ="4,4"; //设置图形尺寸为4英寸长宽</span><br><span class="line">    方形节点 [shape=box];  /*这是一种注释写法*/</span><br><span class="line">    方形节点 -&gt; 上面是加粗线 [style=bold];</span><br><span class="line">    上面是加粗线 -&gt; 和下面的对比;</span><br><span class="line">    方形节点 -&gt; 上面是虚线 [style=dotted];</span><br><span class="line">    方形节点 -&gt; 重量更大导致垂直指下的节点[weight=4];</span><br><span class="line">    "和下面的对比" -&gt; { make_string; 上面是有标签的红线}  //可以一次连接多个节点</span><br><span class="line">    上面是虚线 -&gt; make_string;</span><br><span class="line">    edge [color=red];  // 这是另一种注释写法</span><br><span class="line">    方形节点 -&gt; 上面是有标签的红线 [label="100 times"];</span><br><span class="line">    make_string [label="多行\n标签"];</span><br><span class="line">    node [shape=box,style=filled,color=".7 .3 1.0"];</span><br><span class="line">    和下面的对比 -&gt; 在节点默认属性改变后才创建的节点;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="Graphviz简要语法/attr.svg"></p>
<h4 id="常用属性的默认值">常用属性的默认值</h4>
<p><strong>图</strong>的默认属性:</p>
<ul>
<li>labeljust="c"</li>
<li>labelloc="b" (簇的默认值为"t")</li>
<li>clusterrank="local"</li>
<li>compound=false</li>
<li>rankdir=TB</li>
</ul>
<p><strong>节点</strong>的默认属性是:</p>
<ul>
<li>shape=ellipse</li>
<li>width=0.75</li>
<li>height=0.5</li>
<li>标签为节点名</li>
<li>labelloc="c"</li>
</ul>
<h3 id="cluster-簇">Cluster (簇)</h3>
<p>簇是一种会将属于这个子图的元素都<strong>框在一个长方形里</strong>的特殊子图. 如果一个子图的名字以<strong>cluster</strong>开头那么这个子图就会被认为是一个簇 (这个判定方式好暴力😅). 但是如果在根图中设置了<code>clusterrank=none</code>那么簇这种特殊的子图会被禁用.</p>
<p>这里我又要来吐槽graphviz开发组了! 看看他们是怎么<a href="https://emden.github.io/_pages/doc/info/attrs.html#a:clusterrank" target="_blank" rel="noopener">说明clusterrank这个属性</a>的:</p>
<blockquote>
<p>the modes "global" and "none" <strong>appear</strong> to be identical, both turning off the special cluster processing.</p>
</blockquote>
<p>为什么官方开发组都在用这种表推测的语气啊... 🙃这也太迷惑了</p>
<p>如果根图中设置了<code>compound=true</code>, 那么dot布局允许用边线连接节点和簇的边框. 这是通过设置边线的<code>lhead</code>和<code>ltail</code>属性来实现的. 这样以来, 虽然边线仍然是从一个节点指向另一个节点的, 但是设置了<code>lhead</code>或者<code>ltail</code>的一侧<strong>会看起来像是被簇的边框盖住了</strong>.</p>
<blockquote>
<p>一个使用簇, 并且有连接节点与簇的边线的例子</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    compound=true;</span><br><span class="line">    subgraph cluster0 {</span><br><span class="line">        a -&gt; b;</span><br><span class="line">        a -&gt; c;</span><br><span class="line">        b -&gt; d;</span><br><span class="line">        c -&gt; d;</span><br><span class="line">    }</span><br><span class="line">    subgraph cluster1 {</span><br><span class="line">        e -&gt; g;</span><br><span class="line">        e -&gt; f;</span><br><span class="line">    }</span><br><span class="line">    b -&gt; f [lhead=cluster1];</span><br><span class="line">    d -&gt; e;</span><br><span class="line">    c -&gt; g [ltail=cluster0,lhead=cluster1];</span><br><span class="line">    c -&gt; e [ltail=cluster0];</span><br><span class="line">    d -&gt; h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><embed src="Graphviz简要语法/cluster.svg?20"></p>
<h2 id="高级语法">高级语法</h2>
<p>以下是几条我认为<strong>用来提示图的美观程度</strong>的语法.</p>
<h3 id="优化布局">优化布局</h3>
<p>知道了上面提到的<a href="#Layout-布局">布局的原理</a>我们就可以进行一些更个性化的布局, 比如设置<code>rankdir</code>可以设置节点的排布方向, 默认为<strong>TB</strong>, top to bottom, 也就是从上到下. 可选值有<strong>TB</strong>, <strong>BT</strong>, <strong>LR</strong>, <strong>RL</strong>.</p>
<p>再比如设置节点的<code>rank</code>属性我们可以改变节点的布局. <code>rank</code>的可选值有: <strong>same</strong>, <strong>min</strong>, <strong>source</strong>, <strong>max</strong>, <strong>sink</strong>.</p>
<blockquote>
<p>一个展示设置rank属性能达到什么效果的例子 (代码和图形都截自旧版文档, 因为代码没给全我也懒得写, 就这么放着吧👍)</p>
</blockquote>
<figure>
<embed src="Graphviz简要语法/image-20200313010630547.png?60"><figcaption>image-20200313010630547</figcaption>
</figure>
<figure>
<embed src="Graphviz简要语法/image-20200313010749024.png?80"><figcaption>image-20200313010749024</figcaption>
</figure>
<h3 id="node-port-节点端口">Node Port (节点端口)</h3>
<p>Graphviz提供了节点端口来指定边线应连接到节点的什么位置. 这提供了更高的个性化. 当没有被指定节点端口时边线是指向节点中心并在节点边界处被截断的.</p>
<p>一共有两种节点端口:</p>
<ul>
<li>基于方位的8个端口: n,ne, e, se, s, sw, w, nw</li>
<li>基<code>record</code>结构的端口: <code>shape=record</code>的节点可以以记录结构来定义端口. 而因为有&lt;TABLE&gt;元素的<a href="#html-like-label">HTML-like标签</a>与可以作为<code>shape=record</code>的扩展甚至替代品, 每个&lt;TD&gt;元素的<strong>PORT</strong>属性也都提供了一个到该单元格的端口名.</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    node [shape = box]</span><br><span class="line">    node0:n -&gt; node1:n [label = "n"]</span><br><span class="line">    node2:ne -&gt; node3:ne [label = "ne"]</span><br><span class="line">    node4:e -&gt; node5:e [label = "e"]</span><br><span class="line">    node6:se -&gt; node7:se [label = "se"]</span><br><span class="line">    node8:s -&gt; node9:s [label = "s"]</span><br><span class="line">    node10:sw -&gt; node11:sw [label = "sw"]</span><br><span class="line">    node12:w -&gt; node13:w [label = "w"]</span><br><span class="line">    node14:nw -&gt; node15:nw [label = "nw"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="Graphviz简要语法/node_port.svg"></p>
<h3 id="concentrators-边线合并">Concentrators (边线合并)</h3>
<p>在根图中设置<code>concentrate=true</code>将允许边线融合来避免图变得一团乱麻.</p>
<p>边线合并的条件是:</p>
<ul>
<li>他们的方向相同</li>
<li>他们有相同的起点或终点</li>
<li>他们的长度大于1</li>
</ul>
<h2 id="相关工具">相关工具</h2>
<h3 id="vsc的dot语言支持插件">VSC的dot语言支持插件</h3>
<p>我最喜欢的画graphviz图的工具是VSC里的<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz" target="_blank" rel="noopener">Graphviz(dot)语言支持插件</a>, 是的它<strong>只支持dot布局</strong>. 虽然也可以用graph来声明顶层图, 但绘制出来的仍然是有向图🤦‍♂ 不过无伤大雅, 我基本只画dot布局的图.</p>
<p>VSC里也有提供直接在markdown文档中渲染graphviz的dot布局图的插件, 不过我觉得这样的兼容性太低, 没有这个插件的人只会看到一串代码, 因此我选择的是一个能提供<strong>DOT语法高亮</strong>, 能提供<strong>自动刷新</strong>的预览图, <strong>能生成svg图</strong>的插件. 只要把这个svg插入markdown就能在文档看到graphviz图了, 而每次更改图片后只需要覆盖原本的svg即可更新md文档中的图, 也很方便的👍</p>
<h3 id="在线编辑器">在线编辑器</h3>
<p>也有很多在线网站提供在线绘制graphviz图的服务, 上网一搜就有, 不过我感觉做得都半斤八两, 体验不算好, 我认为只能拿来救急用, 因此也不给出推荐了.</p>
<p>💡 实际上有些工具绘制出的图都有细微风格差异, 你可以挨个体验出一个最喜欢的风格的工具.</p>
<p>不过比较有意思的是这个<a href="https://sketchviz.com/new" target="_blank" rel="noopener">sketchviz</a>, 绘制出的是<strong>手绘风</strong>的图.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
        <category>语言</category>
        <category>Graphviz</category>
      </categories>
  </entry>
  <entry>
    <title>2020年4月12日 Vim经验分享</title>
    <url>/zh-CN/2020/04/20/2020%E5%B9%B44%E6%9C%8812%E6%97%A5vim%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p><span></span></p>
<a id="more"></a>
<p>最近在<a href="https://uestc-msc.github.io/" target="_blank" rel="noopener">电子科大微软学生俱乐部</a>做了一次vim经验分享, 下面是当时的录像. 这个录像是用zoom的会议录制功能得到的. 顺带一提zoom是有Linux平台的目前为止体验最好的视频会议软件, zoom录制的会议视频似乎本身就会进行压缩, 不像用其他软件得到的会议录制我还要自己压缩一下. zoom要是再有网页端就更好了😆</p>
<iframe src="//player.bilibili.com/player.html?aid=710237273&amp;bvid=BV18Q4y1K744&amp;cid=177852832&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>然后因为当时准备得有些仓促导致有几个地方演示得不充分有的地方说串了, 所以我补全了幻灯片. 👇下面这个就是我的幻灯片, 使用<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">Markdown Preview Enhanced</a>制作的markdown幻灯片. 屏幕gif录制工具为<a href="https://github.com/phw/peek" target="_blank" rel="noopener">peek</a>, 键盘按键可视化工具为<a href="https://gitlab.com/screenkey/screenkey" target="_blank" rel="noopener">screenkey</a></p>
<div style="width:100%; padding-bottom:56.25%; position:relative;">
<p><iframe src="https://leojhonsong.github.io/vim-share/vim.html" style="width:94%; height:94%; position:absolute; transform: translate(3%,3%); box-shadow: 0 0 6px 7px black;"></iframe></p>
</div>
<p>🔗 你也可以点击<a href="https://leojhonsong.github.io/vim-share/vim.html">这个链接</a>全屏观看. 这个幻灯片的源代码在<a href="https://github.com/LeoJhonSong/vim-share/blob/master/vim.md" target="_blank" rel="noopener">这里</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>杂记</category>
        <category>vim</category>
      </categories>
  </entry>
  <entry>
    <title>单硬盘三系统安装记录</title>
    <url>/zh-CN/2020/04/04/%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>分享一下我在同一个SSD里同时安装Ubuntu, Windows, macOS三个系统并以GRUB作为开机引导的经验. 说实话过程并不复杂.</p>
<a id="more"></a>
<p>也不知道最近自己时间都浪费哪里去了😑 3月7号弄好的东西现在才得以闲下来记录一番. 先秀一张GRUB界面😏</p>
<p><img data-src="单硬盘三系统安装记录/grub.jpg"></p>
<h2 id="动机">动机</h2>
<p>说说我的心路历程😏</p>
<p>直到上大学我都对电脑了解甚少, <strong>只知道有Windows系统</strong>, 并不知道还可以有其他系统, 更别说在这之上的骚操作了😂 上大学后<strong>我逐渐熟悉了Windows系统</strong>并且喜欢上了这个很有现代感的系统. 但随着我对编程的学习逐渐深入, 以及我为了尽早熟悉机器人相关知识而想要了解Linux系统, 在听人介绍后我费了些力气<strong>在虚拟机里装上了Ubuntu16.04</strong>, 不过那时候了解的还是太少, 只是跟着网上的教程将这个东西装好了, 没什么收获. 装好后因为那时也没什么夸张到要开虚拟机在Ubuntu里编程的项目, 所以就体验了几下就束之高阁了. 毕竟那时对于编程, 甚至查找资料的经验都太少了, 只看到一些令人头大的辣鸡资料, 因此并没能学到什么.</p>
<p>大一下的时候我选了一门叫智能嵌入式的课, 其中有个课题是要编写一个能手势识别的程序并移植到树莓派上. 因此我就买了一个树莓派3b+. 不过那时懵懂的我对于怎么给一个SD卡安装系统手足无措, 就在网上搜资料给树莓派依次装了Ubuntu Mate, ArchLinux, 最后才是Raspbian😂 (我记得Mate是因为我当时没有找到arm架构的国内源就抛弃了, 而ArchLinux我就根本没装上...) 费劲心力我最后总算是把那个课题做完了, 但一方面我写得很差, 再加上树莓派3b+对图像处理的性能很一般, 所以我的手势识别程序移植到树莓派后十分卡顿😅 那是我<strong>第一次将程序移植到Linux平台, 也是第一次接触Linux嵌入式</strong></p>
<p>后来在一个实验室学习时接触到了ROS, 而那时Ubuntu18.04已经较为成熟了, 我就安装了个Ubuntu18.04的虚拟机在里面跟着刷了一遍ROS基础教程, 这回算是<strong>对Ubuntu的基本使用比较了解了</strong>. 不过那时其实并完全不了解ROS的最大作用是什么, 只是知道很牛逼, 跟着教程做了一遍, 没多久就忘了, 只是了解到有那么些概念😁 那时我以为Linux系统也就那样, 我在虚拟机体验到的就是它的全部了. 因此那时有同学和我讨论装Linux虚拟机好还是Windows, Linux双系统好时, 我的想法就是这系统又没那么便利, 误操作带来的危险性又那么大, 当然是装在虚拟机好.</p>
<p>而我装Windows, Ubuntu双系统的契机应该是<a href="/zh-CN/2019/03/30/我打算换电脑了/">我电脑的机械硬盘开始老化</a>, 速度变得极慢. 那应该是我大二下刚开学的时候, 我实在忍受不了在机械硬盘运行本身就很耗资源的Windows系统了, 而那时我的编程活动也开始多起来, 再加上我偶然得知Ubuntu能识别到已经存在的Windows系统并傻瓜式安装, 我就给自己<strong>装了个Windows, Ubuntu双系统</strong>. 不久后我的机械硬盘彻底不行了就买个一个1T的SSD. 不过换了硬盘后我也还是装的双系统, 因为我<strong>逐渐尝到了Linux系统的甜头</strong>.</p>
<blockquote>
<p>我在<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/">另一篇文章</a>写了自己对Linux和Windows的对比</p>
</blockquote>
<p>而随着我逐渐熟悉Ubuntu, 我开始像大多数Linux用户那样折腾自己的配置, 美化环境😏 期间也尝试了挺多东西, 到现在也形成了自己的使用习惯. 不过很尴尬的是在美化方面, 我经常看到这个好康的在Linux没有但macOS有的字眼. 所以<strong>我开始眼馋macOS</strong>. 不过那时我也就是眼馋, 因为我对比了一番, 发现macOS从接口, 生态等角度都不太适合做嵌入式开发就没有想过安一个试试. (我也在VMware里折腾过macOS虚拟机, 但和Ubuntu虚拟机一样装了没多久就删了)</p>
<p>而直到最近, 我看到了很详细的黑苹果安装教程, 加上我一个同学根据那份教程成功安上了黑苹果, 我也蠢蠢欲动了. 毕竟疫情期间闲着也是闲着+都用双系统了再多一个也不多. 于是我折腾一番<strong>给单硬盘安装了三个系统</strong>😁</p>
<p>P.S. 第一次体验macOS的本土包一开始连怎么删除文件都没搞懂, 还是现查的😅 使用逻辑与Windows/Linux差得真的太多了! 甚至因为别扭一度弃用了几天. 不过光是macOS下终端的美观程度就把俺勾回来了🤤</p>
<p>之前也看到网上有人装三系统的文章, 但基本都用了些杂牌子工具一通瞎操作... 所以我分享一下自己较为<strong>清爽</strong>的安装方法.</p>
<p>❗️ 我的电脑是真的一点不矫情, 安装很顺利, 不保证你的电脑上同样的不会出幺蛾子.</p>
<h2 id="关于镜像烧录">关于镜像烧录</h2>
<h3 id="镜像烧录工具">镜像烧录工具</h3>
<p>镜像烧录工具是唯一需要的第三方工具了. 强烈推荐使用<a href="https://www.ventoy.net/cn/doc_start.html" target="_blank" rel="noopener">Ventoy</a>! 这个软件可以将你的U盘创建为一个启动盘, 之后只需要将各种系统镜像放进这个U盘, 到时候以这个U盘启动时会进入一个GRUB界面, 在这个页面再来选择到底进入哪个镜像 👍 有了Ventoy, 装三系统的操作简单了很多!</p>
<h3 id="下载镜像">下载镜像</h3>
<p>因此将U盘创建为启动盘后就把要用到的三个镜像都放进U盘的<strong>Ventoy</strong>这个分区就完事.</p>
<ul>
<li>MacOS镜像: <a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html" target="_blank" rel="noopener">这个文章最后的百度云链接</a></li>
<li>Windows10镜像: 微软现在提供了<a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO" target="_blank" rel="noopener">官方的镜像下载网站</a> 👍 当然要激活的话还是需要激活码的. 而激活码在淘宝就可以买到, 只是需要巧妙措辞 😏</li>
<li><a href="https://cn.ubuntu.com/download" target="_blank" rel="noopener">Ubuntu镜像</a></li>
</ul>
<p>安装每个系统平均下来十五分钟, 因此全过程<strong>一个小时内</strong>就能搞定.</p>
<h2 id="系统安装">系统安装</h2>
<p>我安装系统的顺序是:</p>
<ol type="1">
<li>macOS10.15.4</li>
<li>Windows10</li>
<li>Ubuntu18.04</li>
</ol>
<p>之所以是先安装macOS是因为看网上都说<strong>macOS要求EFI分区不小于200MB</strong>, 否则在安装时会提示无法安装. 然后我搜了搜EFI分区扩容, 似乎并没什么清爽的办法. 因此时刻准备着重装系统的我判定<strong>还是直接格式化硬盘来得清爽</strong>. 然后在安装的时候先安装macOS那它自己就会处理好这个事情, 不需要我担心😁</p>
<p>(不过我把三个系统都装完这个EFI分区也才用了120MB, 也不知道它要那么大干嘛)</p>
<p>而最后才安装Ubuntu是基于两方面考虑:</p>
<ol type="1">
<li>如果先装Ubuntu就意味着得给Windows系统留下一定空间. 那么就需要在安装Ubuntu过程中"Installation Type"这一页选择<code>Something else</code>来<strong>自己给Linux系统分区</strong> (如果不选这种方式, 另外两种方式都会使用硬盘剩余的所有空间). 然而麻烦的是你不光需要给Ubuntu系统分一个主分区, 你还需要讲这个主分区分成几个逻辑分区, 而且每个逻辑分区的大小有一定的讲究. 我目前没有研究过这里的门道并且我对Ubuntu安装程序帮我规划的各个分区的大小没有不满. 因此我决定不去管这种事, <strong>我选择最后来安装Ubuntu, 让安装程序用我给它剩下的空间自己看着办</strong>😏</li>
<li>Ubuntu安装程序能识别电脑里已经安装的Windows系统 (识别不到我的黑苹果系统), 并<strong>自动处理好与Windows系统共存的配置</strong>, 将Windows添加到GRUB引导项中. 因为我的主力系统是Ubuntu而且我也很喜欢使用GRUB作为开机引导程序, 因此这帮我省了一些事.</li>
</ol>
<h3 id="macos安装">macOS安装</h3>
<p>我使用的黑苹果镜像是<a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html" target="_blank" rel="noopener">在这个文章最后的百度云链接</a></p>
<p>❗️ 我安装完之后才从使用苹果系统的同学们那得知macOS10.15, 也就是Catalina目前bug还比较多, 外观上和10.14也没什么区别, 因此建议安装macOS<strong>10.14</strong>, 而不是10.15.</p>
<p>这个镜像很棒的一点是它不止包含一个macOS系统安装程序, <strong>还有一个Windows PE</strong>, 也就是一个可以从U盘启动的专门魔改过, 用于修复系统的Windows系统. 这个Windows PE中包含了大多数你在网上教你修复系统发中文教程中提到的各种看起来有点不靠谱的工具 😂</p>
<p>我安装macOS使用的是<a href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" target="_blank" rel="noopener">这个教程</a>. 跟着一步步操作就可以了. 安装好后发现有驱动问题等先放着不管, 把三个系统都装好再来看上面那个镜像的链接里提供的问题解决方案好了, 不然容易心情变得焦躁的 🤗</p>
<h4 id="更改efi分区文件">更改EFI分区文件</h4>
<p>看到网上说装黑苹果最重要的就是要有对应自己电脑型号的EFI文件, 过了这一关就八九不离十了.</p>
<p><a href="https://github.com/daliansky/Hackintosh#%E9%BB%91%E8%8B%B9%E6%9E%9C%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4%E6%9C%BA%E5%9E%8B%E6%95%B4%E7%90%86-by-%E6%88%91%E6%84%8F" target="_blank" rel="noopener">这里</a>是一份黑苹果爱好者们提供了EFI分区文件的笔记本和台式机的型号列表, 也有他们自己的安装过程分享. 我使用的是其中的<a href="https://github.com/YGQ8988/dell-3568" target="_blank" rel="noopener">Dell Inspiron 3568</a></p>
<p>💡 在安装前我也曾担心后续两个系统的安装会不会破坏已经安装好的macOS的EFI文件, 实验表明他们是互不干扰的, 不会看对方不顺眼就删掉对方 😏</p>
<h4 id="网卡问题">网卡问题</h4>
<p>这似乎是在实体机安装黑苹果一定会有的问题, 有人是直接买了一个苹果能识别的网卡换上, 而我懒一点, 我买了一个有macOS驱动的外置网卡, Comfast的<strong>CF-811 AC</strong>, 很小一个, 不贵, 速度也很不错. macOS在使用这个外置网卡时不会认为在使用WiFi, 而是认为是接入了一个以太网. 唯一缺点是我还没有搞清如何让使用这样外置网卡的macOS连接上星巴克WiFi这样需要等它弹出登录页面才能用的公共WiFi--并不会有什么页面弹出 😓</p>
<h3 id="windows安装">Windows安装</h3>
<p>在安装系统的第一步就会要你选择安装在哪里, 在此时创建一个想要的大小的分区选中就可以进行安装了. 因为我的硬盘是1TSSD, 所以我分了一个274G的分区给Windows, 绰绰有余. 如果我真用满了也意味着我该重装了.</p>
<h4 id="system-reserved分区">System Reserved分区</h4>
<p>当你安好Windows系统后会发现在给Windows划分的分区前后多了两个分区, 一个叫<strong>System Reserved</strong>, 一个叫<strong>Microsoft Windows Recovery Environment</strong>如果你断定自己不会用到安装在硬盘的Windows系统的恢复模式 (实际上Windows安装盘的恢复模式或者Windows PE盘可能会是你遇到麻烦时的更好选择), 那么<strong>Microsoft Windows Recovery Environment</strong>这个分区可以随便删. 而<strong>System Reserved</strong>这个分区<strong>绝对不能随便删, 最好是别动</strong>. 血泪教训啊! 一次我看这分区不爽一气之下删掉了, 然后就因为缺少文件而无法启动Windows了...</p>
<p>🔗 <a href="https://www.zhihu.com/question/60154583" target="_blank" rel="noopener">Windows的System Reserved分区是什么以及能否删除</a></p>
<p>我找到了这个<a href="http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf" target="_blank" rel="noopener">Windows Boot Environment - Murali Ravirala (Microsoft)</a>, 里面讲述了Windows系统的启动过程, 提到了这个分区的作用.</p>
<p>总结下来意思就是<strong>System Reserved</strong>这个分区不能随便删, 要删还要不会出错操作很麻烦, 因此就别动它了 🤦‍♂</p>
<p>💡 值得一提的是Windows现在有了<strong>开发人员模式</strong>, 开启这个模式后在Windows开发的体验会好很多, 不会经常弄出些乱七八糟的错误.</p>
<h3 id="ubuntu安装">Ubuntu安装</h3>
<p>Ubuntu系统的安装就跟着<a href="https://ubuntu.com/tutorials/tutorial-install-ubuntu-desktop#1-overview" target="_blank" rel="noopener">官网安装教程</a>来是最简洁正确的. 唯一需要注意的是在官网教程第六步时, 因为之前安装了Windows系统, Ubuntu安装程序会检测到已安装的Windows系统, 并给出一个<strong>Install Ubuntu alongside Windows 10</strong>的选项. 选择这个是这种情况下最简单的安装方式. 另外选择这个的话Ubuntu安装程序会自动把Windows系统加入到GRUB中, 属实舒服.</p>
<p><strong>系统安装就全部完成了!</strong> 🎉</p>
<h2 id="grub配置及开机美化">GRUB配置及开机美化</h2>
<p>然后是我在这次重装前一直不确定的事: 是否能把macOS引导项也加入GRUB? 经过我的尝试答案是可以!</p>
<p>在网上搜索后我知道了怎么样来配置GRUB的引导项, 其实真心不难.</p>
<h3 id="引导项设置">引导项设置</h3>
<p>第一步是进入<code>/etc/grub.d/</code>, 添加/编辑引导项. ❗️ 建议在先备份这个路径下的文件, 等确认改动成功了再删除备份也不迟.</p>
<p>在我的这个路径下有这样一些文件. 是的这里甚至有一个README 😂</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">00_header</span><br><span class="line">05_debian_theme</span><br><span class="line">10_linux</span><br><span class="line">20_linux_xen</span><br><span class="line">20_memtest86+</span><br><span class="line">30_os-prober</span><br><span class="line">30_uefi-firmware</span><br><span class="line">40_custom</span><br><span class="line">41_custom</span><br><span class="line">README</span><br></pre></td></tr></tbody></table></figure>
<p>这个README的内容是这样的:</p>
<blockquote>
<p>All executable files in this directory are processed in shell expansion order.</p>
<p>00_<em>: Reserved for 00_header.<br>
10_</em>: Native boot entries.<br>
20_*: Third party apps (e.g. memtest86+).</p>
<p>The number namespace in-between is configurable by system installer and/or administrator. For example, you can add an entry to boot another OS as 01_otheros, 11_otheros, etc, depending on the position you want it to occupy in the menu; and then adjust the default setting via /etc/default/grub.</p>
</blockquote>
<p>也就是说: - <strong>00_</strong>开头的是为<code>00_header</code>这个文件保留的, <strong>10_</strong>开头的是系统自带的引导项, 这个稍后解释. <strong>20_</strong>开头的是一些第三方软件的东西, 比如<code>20_memtest86+</code>是一个叫memtest86+的内存测试软件 (虽然不知道是干啥的). - 除了上面这三个前缀的文件名是可以自由改动的, 要把数字改成多少取决于你想让这个文件代表的引导项出现代GRUB引导菜单的第几个. (这个文件的顺序看起来就是最后生成出的<code>/boot/grub/grub.cfg</code>这个文件里引导项的顺序) - 这些文件写好之后在<code>/etc/default/grub</code>这个文件可以调一调设置.</p>
<p>一个引导项文件的写法示例 (也就是我的macOS的引导项文件):</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">exec tail -n +3 $0</span><br><span class="line"># This file provides an easy way to add custom menu entries.  Simply type the</span><br><span class="line"># menu entries you want to add after this comment.  Be careful not to change</span><br><span class="line"># the 'exec tail' line above.</span><br><span class="line"></span><br><span class="line">menuentry 'macOS Catalina 10.15.3' --class macosx {</span><br><span class="line">    insmod part_gpt</span><br><span class="line">    insmod fat</span><br><span class="line">    search --no-floppy --fs-uuid --set=root 67E3-17ED</span><br><span class="line">    chainloader /EFI/CLOVER/CLOVERX64.efi</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中前5行是<code>40_custom</code>中给出的注释, 我就抄过来了. 然后由<code>menuentry</code>起头声明一个引导项. 然后<code>--class</code>用来设置这个引导项的类型, 直观来说就是在GRUB界面里图标的名字. 此处的类型为<strong>macosx</strong>, 也就是说在我使用的GRUB主题的<code>icons</code>文件夹中有同名 (除了后缀名) 图标的话到时候这个引导项在GRUB界面里的文字前面的图标就是这个叫<code>macosx.png</code>的图标.</p>
<p>在这个引导项大括号里的内容是和在GRUB命令行进入一个系统需要输入的命令是一样的, 我感觉算是一种脚本? 我也不太懂, 只能说说大概理解: - 第一行指定硬盘分区表的格式 - 第二行指定文件系统 - 第三行指定在uuid为<strong>67E3-17ED</strong>的分区搜索引导项的启动文件 - 第四行指定这个引导项使用的启动文件 (因为黑苹果实际是有Clover启动的, 因此macOS引导项的指定启动文件为Clover的启动文件)</p>
<p>💡 其中<code>insmod</code>是<strong>ins</strong>ert <strong>mod</strong>e的缩写.</p>
<h3 id="grub-tone">Grub tone</h3>
<p>在<code>/etc/default/grub</code>这个文件里可以进行的设置有<code>GRUB_CMDLINE_LINUX_DEFAULT</code>, 这个在显卡不兼容时常用到的设置, 也有<code>GRUB_THEME</code>这个设置GRUB图形界面的主题的, 甚至可以通过<code>GRUB_INIT_TUNE</code>可以设置开机彩铃 😂</p>
<p>GRUB tone的值是什么意思以及可以看<a href="https://breadmaker.github.io/grub-tune-tester/" target="_blank" rel="noopener">GRUB_INIT_TUNE tester</a>, 这里也提供了一些好听的铃声. 我用过这个超级马里奥音效:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">GRUB_INIT_TUNE="1750 523 1 392 1 523 1 659 1 784 1 1047 1 784 1 415 1 523 1 622 1 831 1 622 1 831 1 1046 1 1244 1 1661 1 1244 1 466 1 587 1 698 1 932 1 1175 1 1397 1 1865 1 1397 1"</span><br></pre></td></tr></tbody></table></figure>
<p>但是这个音效声音大小无法调节, 只能是最大声, 真的很大声那种😏 所以虽然很好玩, 我后来还是取消了这个设置.</p>
<h3 id="grub图形界面分辨率">GRUB图形界面分辨率</h3>
<p>如果你像我这样是4k屏幕, 那么当<code>/etc/default/grub</code>中分辨率参数为<strong>GRUB_GFXMODE=auto</strong>, 那么GRUB会是4k分辨率, 字会比较小, 然后画面刷新率很低, 导致有点卡, 于是我换成了<code>GRUB_GFXMODE=1920x1440x32</code> (32表示32位色深). 要注意这个分辨率必须是在GRUB图形化界面中按<kbd>c</kbd>进入命令行模式, 输入<code>videoinfo</code>后所列出的分辨率, 不然对分辨率的指定无效.</p>
<h3 id="最后微调">最后微调</h3>
<p>调整完上面三个后运行<code>update-grub</code>来更新<code>/boot/grub/grub.cfg</code>. 最后可以到<code>/boot/grub/grub.cfg</code>进行最后微调 (如果需要的话).</p>
<h3 id="开机美化">开机美化</h3>
<blockquote>
<p>因为最开始写这篇文章时我还没体验过Manjaro, 因此这部分就保留好了, 但我要说Manjaro真的比Ubuntu容易个性化太多了!!! (<a href="/zh-CN/2020/07/26/我从Ubuntu换到了Manjaro/">安利文</a>)</p>
</blockquote>
<p>Ubuntu开机过程中一共有三处可以美化:</p>
<ul>
<li>GRUB theme</li>
<li><a href="https://wiki.archlinux.org/index.php/plymouth" target="_blank" rel="noopener">Plymouth</a> theme</li>
<li><a href="https://wiki.archlinux.org/index.php/GDM" target="_blank" rel="noopener">GDM</a> theme</li>
</ul>
<p>我的GRUB主题是<a href="https://www.gnome-look.org/p/1009533/" target="_blank" rel="noopener">Aurora Penguinis GRUB2 Theme</a>, Plymouth主题是<a href="https://www.gnome-look.org/p/1009239/" target="_blank" rel="noopener">Aurora Penguinis Plymouth 2 Theme</a>. 而Gnome能使用的GDM主题我没看到什么我中意的, 就自行改动了一下<code>/usr/share/gnome-shell/theme/ubuntu.css</code>里的样式, 给登录界面加了个背景图片.</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-id">#lockDialogGroup</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#2c001e</span> <span class="built_in">url</span>(file:///home/leo/Pictures/login-screen/custom.jpg);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center; }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="关于启动">关于启动</h2>
<p>最后放上几个在搜索资料过程中看到的好资料:</p>
<ul>
<li><a href="https://help.ubuntu.com/community/Installation?_ga=2.230386906.774703488.1586350910-773002345.1585209571" target="_blank" rel="noopener">Ubuntu系统安装教程考古</a> 在<strong>Either Shrink the Windows C: Drive to Make Room for Linux OR Turn off Windows Updating</strong>这部分可以找到有人遇到的Windows系统更新却破坏了Ubuntu系统是怎么回事. (也很明显我这不会出现这问题)</li>
<li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">阮一峰-计算机是如何启动的？</a> 在这里可以看到启动为什么叫<strong>boot</strong>, 也可以对启动过程中发生了什么有个大概了解.</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>操作系统</category>
        <category>Linux</category>
        <category>macOS</category>
        <category>Windows</category>
        <category>启动</category>
        <category>GRUB</category>
      </categories>
  </entry>
  <entry>
    <title>笔记本电脑性能提升/选购指南</title>
    <url>/zh-CN/2020/05/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>自去年三月多开始有意识了解电脑配件至今已有一年多, 对这些乱七八糟的了解多了许多, 整理一下我对<strong>笔记本</strong>性能提升的经验以及选购指南. 因为我很了解在不了解这些时听到这些陌生概念的望而畏怯以及半信半疑, 我尽量解释得小白些.</p>
<p>❗️ 因为我自己没有台式机所以这里只谈笔记本相关.</p>
<a id="more"></a>
<!-- TODO -->
<h2 id="性能提升">性能提升</h2>
<p>不同于台式机里什么配件都可以换, 比如很多笔记本的CPU, 显卡是焊死在主板上的. 即便你的笔记本支持更换这两样, 这也不是容易事. 因为笔记本的散热是精打细算设计好的, 更换了更好的CPU或者显卡通常以为着更大的发热量, 很容易导致过热然后出奇奇怪怪的问题.</p>
<p>因此为了提升笔记本性能常见的操作是<strong>更换硬盘和内存</strong>.</p>
<h3 id="更换硬盘">更换硬盘</h3>
<h3 id="更换内存">更换内存</h3>
<h2 id="选购指南">选购指南</h2>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>硬件</category>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下各用途我最认可的工具推荐</title>
    <url>/zh-CN/2020/07/26/Linux%E4%B8%8B%E5%90%84%E7%94%A8%E9%80%94%E6%88%91%E6%9C%80%E8%AE%A4%E5%8F%AF%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<div class="note warning">
            <p>因为各种好用软件层出不穷, 提到的软件也可能在快速更新, 因此这篇文章时效性会很短, 请注意☝更新时间.</p>
          </div>
<p>用Linux的时间已经比用Windows的时间还长了, 随着使用逐渐找到了各用途我最认可的工具, 或从软件源安装, 或在线使用. 在此整理一份我的Linux下各用途好用工具推荐. (出于私心将从一个<strong>Manjaro-KDE</strong>用户角度介绍)</p>
<p>💡各位如果有什么推荐的软件也可以底下评论, 我觉得好用会加进去的.</p>
<a id="more"></a>
<blockquote>
<p>首先, 不得不吹一下Manjaro是一个多么贴心的系统. Manjaro自带了一个叫<strong>Manjaro Hello</strong>的入门程序, 点进这个程序的<code>Applications</code>入口能看到Manjaro社区为各常见用途已经提供了一些推荐, 勾选就可以安装. 可以说没有更贴心的系统了!</p>
<p><embed src="Linux下各用途我最认可的工具推荐/Manjaro_Hello.jpg?70"></p>
</blockquote>
<h2 id="日常使用">日常使用</h2>
<h3 id="中文输入法">中文输入法</h3>
<p>随着fcitx5日渐成熟, 现在有了两种我推荐的中文输入法方案:</p>
<h4 id="fcitx5框架配套中文输入法">fcitx5框架+配套中文输入法</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S fcitx5-im</span><br><span class="line">yay -S fcitx5-chinese-addons</span><br><span class="line">yay -S fcitx5-material-color</span><br></pre></td></tr></tbody></table></figure>
<p>这个<strong>fcitx5-material-color</strong>是一个模仿win10的中文输入法的皮肤, 在fcitx5的设置中可以更换皮肤, 可以做到下面这样的效果 👇 <embed src="Linux下各用途我最认可的工具推荐/inputMethod.gif?80"></p>
<h4 id="fcitx4框架搜狗输入法">fcitx4框架+搜狗输入法</h4>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S fcitx-im fcitx-configtool</span><br><span class="line">yay -S fcitx-sogoupinyin</span><br></pre></td></tr></tbody></table></figure>
<hr>
<p>安装完输入法框架和中文输入法后还需要在配置文件中设置几个环境变量. 因为有很多配置文件会在用户登录过程中被加载, 所以这里的设置方式其实不唯一. 我是在<code>~/.pam_environment</code>中写了这几行:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE DEFAULT=fcitx</span><br><span class="line">XMODIFIERS DEFAULT=@im=fcitx</span><br></pre></td></tr></tbody></table></figure>
<p>我目前使用的是fcitx5的方案. 我一个同学体验后觉得搜狗的词库做得更好, 能提供更精确的联想. 这点我倒是没什么感觉, fcitx5这个方案完全满足我的使用. 但另一方面fcitx5配套的中文输入法的优势非常明显:</p>
<ul>
<li>有一个Quick Phrase功能, 支持类似snippets一样根据关键词插入设定好的内容的功能. 默认提供了一些颜文字, emoji, LeTaX片段, 也可以自己加</li>
<li>整个方案成体系, 使用体验非常好! fcitx4+搜狗输入法这个方案始终是缝合怪, 很容易有点小问题. 比如我之前用的时候每次从英文输入法切换回搜狗输入法, 我对搜狗输入法的一些设置 (比如使用半角标点符号) 都会恢复默认值</li>
<li>支持云拼音联想</li>
<li>配置起来很简单直观</li>
<li>支持导入搜狗细胞词库 (我没试过), 可以导入许多专业词汇的词库</li>
</ul>
<p><strong>总的来说我是推荐试试fcitx5框架+配套中文输入法这个方案的</strong></p>
<h3 id="截图">截图</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S flameshot</span><br></pre></td></tr></tbody></table></figure>
<p>很遗憾我没有找到一个像Windows平台的snipaste那样功能非常齐全的截图/贴图软件. 我试了Manjaro-KDE自带的spectacle, flameshot, deepin的deepin-screen-recorder, flameshot的体验最好, 最贴近snipaste, <strong>甚至也支持贴屏</strong>.</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 42%">
<col style="width: 42%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Flameshot</td>
<td>支持像snipaste一样将截图贴在屏幕最上层</td>
<td>1. 在KDE上无法设置截图质量, 只能是原画质; 2. 无法自动贴靠屏幕上的窗口</td>
</tr>
<tr class="even">
<td>Spectacle</td>
<td>作为KDE官方开发的截图软件, 全屏截图, 选定窗口截图, 选定矩形截图, 截图后做一些编辑这些功能都是全的. 是这三款软件里<strong>唯一可以设置存储图片的压缩质量</strong>的.</td>
<td>使用逻辑有点别扭, 是先截图然后在软件里进一步选择是进行编辑或者存到什么地方之类. 我更喜欢flameshot那样在截图的时候就能编辑, 选择存到剪贴板还是本地的方式.</td>
</tr>
<tr class="odd">
<td>Deepin Screen Recoder</td>
<td>Deepin这个其实不单单是截图软件了, 同时可以录屏, 看起来功能很全面, 也能贴屏.</td>
<td>很遗憾目前为止在Manjaro-KDE上根本没法用, 有好几个bug.</td>
</tr>
</tbody>
</table>
<h3 id="录屏">录屏</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S simplescreenrecorder</span><br><span class="line">yay -S peek</span><br></pre></td></tr></tbody></table></figure>
<p>SimpleScreenRecorder名字里虽然有simple, 但是实际上关于录屏的功能非常全, 有好几屏的设置项, 可以设置帧率, 视频源可以来自屏幕, 摄像头, 也可以设置音频源, 支持录制成<code>mkv</code>, <code>mp4</code>, <code>mp3</code>等多种格式, 视频编码参数, etc... 可以说功能非常全面了 (但不支持录制成<code>gif</code>).</p>
<p>而如果只是想随手录一个gif, 那使用<strong>peek</strong>还是很好的.</p>
<h3 id="显示按键">显示按键</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S screenkey</span><br></pre></td></tr></tbody></table></figure>
<p>这个可以在屏幕上显示按下了的键盘按键, 鼠标按键. 在演示, 示教时很好用 👍</p>
<h2 id="驱动">驱动</h2>
<h3 id="显卡驱动">显卡驱动</h3>
<p>这里又不得不点名表扬一下Manjaro, 在装机时勾选了安装<strong>Proprietary Driver</strong> (非自由驱动)的话会自动装好闭源N卡驱动! 比如我的笔记本有一个intel UHD Graphics (集显) 和一个Nvidia RTX2070 (独显), 安装好系统后已经自动安装了采用最新的intel集显与Nvidia独显共存的<a href="https://wiki.archlinux.org/index.php/PRIME" target="_blank" rel="noopener">Prime方案</a>的混合驱动<strong>video-hybrid-intel-nvidia-prime</strong> 🎉</p>
<p>我也没有细看Prime方案和Bumblebee方案的具体差异, 看起来大概意思就是Bumblebee是软件实现, 有一定性能损失, 而Prime方案是更为推荐的新一代方案.</p>
<p>Prime技术让我们能够同时使用两个显卡: 以intel核显渲染画面, 以独显运行高负荷任务. <del>但是目前无论Prime方案还是Bumblebee方案都有个缺陷: 同时使用两个显卡时N卡无法输出画面, 即从直连N卡的HDMI接口无法输出画面, 但仅使用N卡的话可以从N卡输出画面. 仅使用N卡从性能方面没什么问题, 但是耗电, 发热会很夸张, 这对日常使用来说很不划算. 因此我们还是需要一个方法让我们能在需要N卡输出画面时能切换到仅N卡模式.</del></p>
<blockquote>
<p><del>至于外接屏幕, 我的解决办法是买一个有雷电接口 (雷电接口是直连CPU的, 其视频输出由intel核显承担) 的电脑, 这样一来在混合模式也能从雷电接口输出视频信号 😅</del></p>
</blockquote>
<p>卧槽我前几天试了一下现在在混合显卡模式也能从直连N卡的HDMI接口输出视频信号了! 😲</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S optimus-manager-qt</span><br></pre></td></tr></tbody></table></figure>
<p>💡 Manjaro KDE用户<a href="https://github.com/Askannz/optimus-manager#important--manjaro-kde-users" target="_blank" rel="noopener">需要编辑一下/etc/sddm.conf</a></p>
<p><a href="https://github.com/Askannz/optimus-manager" target="_blank" rel="noopener">optimus-manager</a>允许我们在<strong>仅intel显卡模式</strong>, <strong>仅N卡模式</strong>, <strong>混合模式</strong>三种模式间切换. 而optimus-manager-qt则为我们提供了一个GUI界面来进行设置, 一个系统托盘小图标来进行快速切换 (和装饰)</p>
<p>因为各种显卡模式切换方案基本带有对独显的电源管理方案, 因此在optimus-manager-qt也可以根据自己的情况选择适合的独显电源管理方案. 我的笔记本满足 "N卡为Turing架构及以上, intel CPU为CoffeeLake架构及以上" 的条件, 因此<a href="https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options#configuration-1--dynamic-power-management-inside-the-nvidia-driver-runtime-d3-power-management" target="_blank" rel="noopener">可以用N卡自带的动态电源管理</a>, Runtime D3 Power Management, 省心又省电 👍 不用时我的N卡功耗可以低到<strong>4W</strong> (是的用这个方案即便完全没有在使用N卡, 仍然会稍微消耗一点能量), 整个电脑的功耗最低到过9W (虽然长时间使用还是被长续航轻薄本吊打, 追求游戏本的续航是不现实的)</p>
<h3 id="oled屏幕亮度调节">OLED屏幕亮度调节</h3>
<p><a href="https://github.com/LeoJhonSong/oled-brightness/blob/master/oled-brightness" target="_blank" rel="noopener">我自己写的脚本</a> 😏</p>
<p>目前Linux对OLED屏幕支持很差, 似乎还没有发行版默认支持OLED屏幕亮度调节. 普通LCD屏幕的亮度调节是通过调整屏幕背光板的电压, 即背光板亮度来实现的. 当你在滑动你的Linux系统提供的亮度调节滑条时, <code>/sys/class/backlight/intel_backlight/brightness</code>的值会被改动, 然后系统会根据这个值和<code>/sys/class/backlight/intel_backlight/max_brightness</code>所记录的亮度最大值来调节背光板电压. 然而OLED屏幕根本没有背光板, 每个LED的亮度是可以单独调节的. 因此目前调节OLED屏幕亮度的方案是调整画面的Gamma值. 于是我写了这个基于<code>xrandr</code>的脚本, 这个脚本会监控<code>/sys/class/backlight/intel_backlight/brightness</code>值的变化并据此改变指定屏幕 (默认为主屏幕) 画面的gamma值.</p>
<p>顺带一提<code>xrandr</code>是一个功能很强大的设置屏幕画面的分辨率, 方向, 位置等参数的强大工具.</p>
<h3 id="镜像烧录">镜像烧录</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S ventoy-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用的时候用:</span></span><br><span class="line">sudo ventoyweb</span><br></pre></td></tr></tbody></table></figure>
<p>有了<a href="https://www.ventoy.net/cn/index.html" target="_blank" rel="noopener">Ventoy</a>这个项目, balenaEtcher, rufus这些传统意义上的镜像烧录软件就可以丢弃了! Ventoy支持一个U盘里放多个镜像, 在以这个U盘启动时会进入一个GRUB界面, 在这个页面再选择到底进入哪个镜像 🐮 我在我U盘里放了Windows镜像, Manjaro-KDE, Ubuntu20.04, 还有一个可以用来修复分区的<a href="https://gparted.org/download.php" target="_blank" rel="noopener">GParted</a>镜像, 还换了个GRUB主题, 爽到.</p>
<h2 id="系统工具">系统工具</h2>
<h3 id="资源管理器">资源管理器</h3>
<p><strong>Dolphin</strong>绝对是最好用的资源管理器! 多标签页, 显示预览等功能不在话下. Dolphin的右键菜单很贴心, Gnome自带资源管理器所没有的右键新建文件功能 (就离谱) 当然是有的, 也有创建快捷方式, 解压 (不论是rar还是zip还是tar都是同一个按键), 也可以很方便地自己创建脚本添加右键菜单的功能.</p>
<p>而Dolphin最突出的功能是按<kbd>F4</kbd>可以直接打开一个<strong>Dolphin内嵌终端</strong>. 这个终端的路径会随着在资源管理器里点击自动切换 (除非已经打开类似vim这样的程序), 使用起来超方便, 结合了终端的便捷和GUI的可视化等优势.</p>
<p><embed src="Linux下各用途我最认可的工具推荐/Dolphin.png?70"></p>
<h3 id="任务管理器">任务管理器</h3>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">yay -S htop</span><br></pre></td></tr></tbody></table></figure>
<p><strong>htop</strong>是升级版的top. 一是交互人性化很多, 支持鼠标交互, 设置页面分了页, 直观很多. 二是能以列表或者树的样式显示丰富得多的值, 比如该进程的线程数等, 还支持以关键词过滤显示的进程等功能.</p>
<h3 id="磁盘管理器">磁盘管理器</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S filelight</span><br><span class="line">yay -S partitionmanager</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Filelight</strong>是KDE的图形化磁盘空间使用情况分析工具, 能以很多环同心扇形的形式直观地显示出哪里有大文件. <strong>partitionmanager</strong>是KDE的磁盘管理工具, 就类似Windows的磁盘管理器. 这两个应用Gnome社区也有类似的, 但感觉还是KDE的做得更人性化一些.</p>
<p>💡 用<code>du -sh /path/to/check/* | sort -hr</code>可以在命令行列出指定文件夹下按大小降序列出各文件夹/文件</p>
<h3 id="电脑管家">"电脑管家"</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S stacer</span><br></pre></td></tr></tbody></table></figure>
<p>虽然很多Linux老哥们认为Linux用户不需要这种东西, 但如果是习惯了在各种电脑管家打卡的Windows用户, 我推荐<strong>Stacer</strong>. 这是一个系统优化与监控软件 (和CCleaner等电脑管家画风很像), 可以看系统资源使用该要, 有任务管理器一栏, 可以清理垃圾, 可以管理开机自启项, 卸载已安装软件等... (是个很Windows画风的东西😅)</p>
<h3 id="tcp调试助手">TCP调试助手</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S nmap</span><br></pre></td></tr></tbody></table></figure>
<p>netcat被称为网络编程的瑞士军刀, 功能属实很多👍 要注意netcat有好几个版本, 给的参数略有区别. <strong>ncat</strong>是为Nmap项目写的netcat, 包含在nmap包中. 在其man中自称是诸多netcat版本中的巅峰之作 (水平有限俺也不知道是不是). <strong>nmap</strong>本身同样是一个用法很多的网络编程工具, 我主要用来扫端口.</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># ncat监听本地8080端口</span></span><br><span class="line">ncat -l 8080</span><br><span class="line"><span class="comment"># ncat连接本地8080端口</span></span><br><span class="line">ncat 127.0.0.1 8080</span><br><span class="line"><span class="comment"># ncat监听本地8080端口, 发送一串16进制数据 (socket一个字节的内容为两位16进制数)过去并以双字节16进制显示输出</span></span><br><span class="line"><span class="comment"># 如果不满意显示格式的话可以换用hexdump -C然后加参数设置显示格式. hexdump支持的显示格式比xxd要丰富些. 注意不加-C参数的话hexdump默认按双字节小端转换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'0006303030304e43'</span> | xxd -r -p | ncat -l 8080 | xxd</span><br><span class="line"><span class="comment"># nmap扫描当前路由器192.168.1.1下所有设备的端口 (找树莓派之类设备IP时很方便)</span></span><br><span class="line">nmap 192.168.1.1/24</span><br></pre></td></tr></tbody></table></figure>
<h2 id="通讯">通讯</h2>
<h3 id="qq微信">QQ/微信</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S deepin-wine-tim  # 比起QQ我更喜欢简洁的TIM (夹带私货)</span><br><span class="line">yay -S deepin-wine-wechat</span><br></pre></td></tr></tbody></table></figure>
<p>这两个软件在国内基本是必备了吧 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8">🤷♂</span>. 在Linux上我体验下来最推荐的版本是以deepin-wine版. <a href="https://github.com/vufa/deepin-wine-wechat-arch#%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E6%98%BE%E7%A4%BA%E4%B8%BA%E6%96%B9%E6%A1%86%E6%98%BE%E7%A4%BA%E6%A8%A1%E7%B3%8A" target="_blank" rel="noopener">这里</a>是微信中中文字体显示为方框的解决方案. 如果使用的是4k高清屏, deepin-wine系软件显示得很小, 可以在<strong>deepin-wine5中</strong>设置分辨率. 比如设置TIM的分辨率:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">env WINEPREFIX=$HOME/.deepinwine/Deepin-TIM deepin-wine5 winecfg</span><br></pre></td></tr></tbody></table></figure>
<p>然后会打开一个设置界面. 调节其中的<code>Graphics &gt; Screen resolution</code>一项. 我是4k屏幕, 感觉设成<strong>192dpi</strong>比较OK.</p>
<h3 id="会议">会议</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S wemeet-bin</span><br><span class="line">yay -S zoom</span><br><span class="line">yay -S teams</span><br></pre></td></tr></tbody></table></figure>
<p>我在Linux目前体验能用的视频会议软件有三个:</p>
<ul>
<li><strong>腾讯会议</strong>: deepin是真的nb. 这个腾讯会议我用起来似乎没有任何问题, 屏幕共享, 摄像头, 语音这些都没有问题 🐮🍺</li>
<li><strong>zoom</strong>: zoom看起来是会根据<code>QT_SCREEN_SCALE_FACTORS</code>环境变量设置界面缩放.我在系统设置中设置了1.75倍的全局缩放, 因此从终端, desktop entries打开应用的环境中都有这个环境变量. 在这种情况下打开zoom会看到一个巨大无比的zoom界面😂 解决方案有二:
<ol type="1">
<li>修改zoom的desktop entry的Exec这行, 在<code>/usr/bin/zoom</code>前面加<code>env QT_SCREEN_SCALE_FACTORS=1</code>来改变QT的缩放大小.</li>
<li>修改zoom的配置文件<em>~/.config/zoomus.conf</em>, 把<code>autoscale</code>设置为<strong>false</strong></li>
</ol></li>
<li><strong>Microsoft Teams</strong>: teams不是专门的视频会议软件, 是微软Office中的办公聊天软件, 不过它的视频会议版块功能丝毫不比zoom少, 甚至得益于Office套件间的联动使用体验非常流畅, 有很多类似到时间提醒参会成员, 自动生成会议云录制的字幕等很贴心的功能. 其界面非常现代, 功能也很多 (有很多插件). 其实这个也支持在网页参加会议, 体验很好的.</li>
</ul>
<h2 id="下载云盘">下载/云盘</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S baidunetdisk-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> yay -S xunlei-bin</span></span><br><span class="line">yay -S aria2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台运行启用了RPC, aria2</span></span><br><span class="line">nohup aria2c --enable-rpc --allow-piece-length-change &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> yay -S motrix-bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo motrix --no-sandbox  <span class="comment"># 然后右键系统托盘里的图标退出</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>下载大文件虽然还是经常避不开百度云, 但已经有越来越多人在用各种新出的网速还能拉满的网盘了, 比如阿里云盘, 夸克云盘. 前几天在淘宝买了个电影资源, 老板发给我个百度云链接, 我试了下3.1G被限速实在要下太久了, 搜了搜好像也没有很方便的解除限速的方式. 但其实解决方法很简单: 我问老板有没有其他云盘的下载方式, 然后老板给我了个夸克云盘的链接, 我就网速拉满地下完了. 这个baidunetdisk-bin就是有热心网友将百度云盘的官方的Linux版deb系安装包适配后发布到arch源里了, Linux版的和Windows版用起来并没有区别, <strong>仍然是有限速的</strong> 😁</p>
<p>磁力链和torrent我是用chrome插件<a href="https://chrome.google.com/webstore/detail/aria2-for-chrome/mpkodccbngfoacfalldjimigbofkhgjn" target="_blank" rel="noopener">Aria2 for Chrome</a>下的. 这个插件以aria2为后端, 能够自动拦截chrome中http, 磁力链, FTP等协议下载任务, 也支持torrent. 在插件的设置页面中设置触发自动拦截下载任务的文件大小为0MB的话torrent文件也会通过aria2下载, 而aria2默认开启了下载的是torrent文件时自动开始BT下载任务的选项, 体验会很好. 有点遗憾的是这个插件所使用的前端虽然可以对aria2进行设置, 但是这些设置在aria2重启后会丢失. 如果想要每次启动aria2后都能自动加载这些配置的话还是需要写一个aria2的配置文件<code>~/.config/aria2/aria2.conf</code>:</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 默认下载路径</span></span><br><span class="line">dir=/home/leo/Downloads</span><br><span class="line"><span class="comment"># 代理服务器</span></span><br><span class="line">all-proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line"><span class="built_in">continue</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 最大同时下载任务数</span></span><br><span class="line">max-concurrent-downloads=10</span><br><span class="line"><span class="comment"># 单服务器最大连接数</span></span><br><span class="line">max-connection-per-server=15</span><br><span class="line"><span class="comment"># 最小文件分片大小</span></span><br><span class="line">min-split-size=10M</span><br><span class="line"><span class="comment"># 允许所有来源</span></span><br><span class="line">rpc-allow-origin-all=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 允许非外部访问</span></span><br><span class="line">rpc-listen-all=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 最小做种时间. 当设置为0时在BT下载任务完成后不再做种</span></span><br><span class="line">seed-time=0</span><br></pre></td></tr></tbody></table></figure>
<p>然后可以运行来自<a href="https://github.com/P3TERX/aria2.conf/blob/master/tracker.md" target="_blank" rel="noopener">P3TERX/aria2.conf</a>的脚本<code>bash &lt;(curl -fsSL git.io/tracker.sh) "/home/leo/.config/aria2/aria2.conf"</code>添加一个Tracker列表给aria2配置文件, 提升torrent下载速度.</p>
<p>如果想用本地客户端下载磁力链和torrent的话强推<strong>motrix</strong>: 集成了每日自动更新的Tracker服务器列表的支持, 支持迅雷链接下载协议, 而且因为是electron做的所以界面非常美观! 不过除了Ubuntu镜像我能以30MB/s的速度下载我暂时还没下到过速度超过100Kb/s的... 这个软件在Arch系下似乎有bug, 安装好后需要用上面那条命令sudo启动然后关闭一次, 之后就能正常使用了.</p>
<p>💡据我同学说迅雷对一些资源有更快的速度, 我试了下还真是... 比用tracker的qbittorrent还要快很多 (是正经资源)</p>
<h2 id="图片视频处理">图片/视频处理</h2>
<h3 id="视频压缩">视频压缩</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S handbrake</span><br></pre></td></tr></tbody></table></figure>
<p>handbrake是一个支持非常丰富的视频格式转换/压缩工具. 视频编辑方面接触不多的人会意识不到一个录屏只需放进压缩软件简单<strong>无损压缩</strong>一下通常可以减小为原本体积的<strong>一半以下</strong>.而handbrake提供了许多直观的预设参数组. 我通常就用的<code>Offical&gt;General&gt;Very Fast 1080p30</code>这个预设. handbrake支持批量处理, 操作起来也很简单.</p>
<h3 id="图片压缩">图片压缩</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S jpegoptim</span><br><span class="line">yay -S optipng</span><br><span class="line">yay -S imagemagick</span><br></pre></td></tr></tbody></table></figure>
<p><strong>jpegoptim</strong>, <strong>optipng</strong>这两个终端程序可以分别对jpg/jpeg, png进行无损/有损压缩, 调用也很简单, 普通无损压缩的话跟的参数就图片名就可以.</p>
<p><strong>imagemagick</strong>是一套用于创建, 编辑, 显示图片的强大终端工具, 其中有一个<strong>magick</strong>终端程序可以实现jpg转png, 也可以压缩jpg, png等. 但是参数比上面两个复杂一些, 我反正记不住.</p>
<p>💡没有用到透明图层的png图片可以转为jpg, 能大幅压缩体积</p>
<h3 id="视频播放器">视频播放器</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S vlc</span><br></pre></td></tr></tbody></table></figure>
<p><strong>vlc是一个很神奇的播放器</strong>.</p>
<p>它不光支持非常多种视频文件格式, 还可以播放网络视频流, 比如RTSP视频流, IPTV网络电视, 还可以播放摄像头视频流... 加上它有截取视频一帧画面, 录制视频流, 高倍速播放, 在截取的画面上显示当前视频时间等功能, 他可以:</p>
<ul>
<li>当Linux上的相机软件</li>
<li>用来调试usb摄像头/IP摄像头</li>
<li>当网络电视 (顺便放一个非常全的<a href="https://github.com/iptv-org/iptv" target="_blank" rel="noopener">IPTV频道合集</a>)</li>
<li>看网课视频利器</li>
</ul>
<p>🐮🍺</p>
<h3 id="视频编辑器">视频编辑器</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S kdenlive</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Kdenlive</strong>是一个界面很像Adobe Premiere的软件, 现在是KDE旗下项目. Kdenlive的语言看起来是继承的系统语言, 支持中文 (汉化得还是比较全面的). Kdenlive操作起来还是很简单的, 零基础随便看一看教程也就会用个大概了. Kdenlive的效果我感觉还是涵盖了Pr中最主要的那些了, 定位应该是和Pr一样也是视频剪辑软件 (Linux平台也有对标Ae的软件, Natron). Kdenlive也有Windows版, 而且安装包只有80MB, 很值得尝试的 👍</p>
<h3 id="制图">制图</h3>
<h4 id="图片">图片</h4>
<p>因为我处理图片的需求不大, 因此普通一些的需求我就在WPS的PPT软件里处理的, 有稍微复杂一点的PS需求时都是使用的这个<a href="https://www.uupoop.com/#/old" target="_blank" rel="noopener">在线PS</a>, 支持PhotoShop的<strong>PSD</strong>, sketch的<strong>sketch</strong>格式, GIMP的<strong>XCF</strong>格式等, 覆盖了常见格式, 十分方便 😆</p>
<h4 id="uml图">UML图</h4>
<ul>
<li>Graphviz: 这是一个根据代码自动生成图形的程序, 有<a href="https://dreampuf.github.io/GraphvizOnline/" target="_blank" rel="noopener">在线版</a>, 也有<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz" target="_blank" rel="noopener">VSCode插件版本</a>什么的. (顺便<a href="/zh-CN/2020/03/12/Graphviz简要语法/">这里</a>是我写的介绍Graphviz语法的博客)</li>
<li><a href="https://www.diagrams.net/" target="_blank" rel="noopener"><strong>diagrams.net</strong></a>: 这个是全平台的, 有在线版, 也有各系统的安装包. 它有非常丰富的元素, 能画出很好看很复杂的UML图, 但是无法自动整理布局. 不过它<strong>可以打开Visio的.vsdx文件</strong> 👍</li>
<li><a href="">PlantUML</a>: 这个则是以代码生成UML图的强大工具, 后端其实也是Graphviz (Graphviz本身用起来真的有点阴间), 提供有很多种类的模板, 可以几行代码画出一个非常好看的UML图! <a href="https://www.planttext.com/" target="_blank" rel="noopener">在线编辑器</a>在此</li>
<li><a href="http://asciiflow.com/" target="_blank" rel="noopener">ASCIIFlow Infinity</a>: 这个在线绘图工具是用来绘制<strong>纯文本</strong>框图. 不过因为它开源了, 因此也可以在本地使用 <code>yay -S asciiflow2-git</code></li>
</ul>
<h4 id="其他">其他</h4>
<ul>
<li><a href="http://patorjk.com/software/taag/" target="_blank" rel="noopener">Text to ASCII Art Generator (TAAG)</a>: 是一个生成文本的ASCII Art的在线工具 (就是oh-my-zsh更新时会显示的那种文本拼出来的大logo)</li>
</ul>
<h2 id="办公">办公</h2>
<h3 id="文档">文档</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S typora</span><br><span class="line">yay -S okular</span><br><span class="line">yay -S google-chrome</span><br></pre></td></tr></tbody></table></figure>
<p>做文档我首推Markdown, Markdown编辑器我首推<strong>Typora</strong>. (我还写过<a href="/zh-CN/2019/09/23/Markdown安利-Typora简要使用教程/">Markdown安利&amp;Typora简要使用教程</a>)</p>
<p>普通看pdf的话KDE的<strong>okular</strong>和GNOME的<strong>evince</strong>我觉得界面还比较简洁而不简陋, 现代. 相比起来okular功能更多一些, 对触控笔/手写等操作支持好许多 (虽然我不怎么用). 看文章时我更喜欢在<strong>Chrome</strong>的<a href="https://saladict.crimx.com/" target="_blank" rel="noopener">沙拉查词</a>插件提供的pdf.js的pdf阅读器里看, 查单词, 搜索很方便. 如果要做笔记的话我是在我的Windows系统平板上看的.</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S ghostscript</span><br></pre></td></tr></tbody></table></figure>
<p>补充一个可以用来压缩pdf的小工具<code>ps2pdf</code>, 在ghostscript软件包中, 还是挺实用的. 用<code>ps2pdf -dPDFSETTINGS=/ebook input.pdf output.pdf</code>就可以将pdf压缩为150dpi的质量. <code>-dPDFSETTINGS=/prepress</code>参数的话能得到质量为300dpi的pdf, 完全满足打印的需求了.</p>
<h3 id="latex">latex</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S visual-studio-code-bin</span><br><span class="line">yay -S texlive-most texlive-lang biber</span><br></pre></td></tr></tbody></table></figure>
<p>TeX Live是很大一套软件, 嫌麻烦的话最好就直接把包含了绝大多数部件的<strong>texlive-most</strong>以及语言包<strong>texlive-lang</strong>下下来. 其中CTeX包含在<strong>texlive-langchinese</strong>这个包中. <strong>biber</strong>则是比biblatex更先进的引用处理工具. 顺带一提<a href="/zh-CN/2021/05/24/LaTeX杂记">这里</a>是我写的LaTeX语法笔记.</p>
<p>在Linux上使用LaTeX我只推荐两种方案:</p>
<ol type="1">
<li><p>在<a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a>中在线编辑</p>
<p>Overleaf以TeX Live作为后端, 开箱支持选择编译器, 支持基础的vim键映射, 提供看得过去的补全, 提供拼写和语法 (指LaTeX)检查... 点开Overleaf就有了一个还不错的LaTeX环境, 不需要担心缺少依赖, 不需要设置编译工具链, 编辑界面还算好看, 编译速度也很快, 是真的很省心了 👍 除此以外Overleaf支持git同步, 也支持多人协作编辑, 对于不想费心配置环境的人来说是真的很棒了</p></li>
<li><p>借助<a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop" target="_blank" rel="noopener">LaTeX Workshop</a>插件在VSCode中本地编辑</p>
<p>曾经看了<a href="https://zhuanlan.zhihu.com/p/60049290?utm_source=qq&amp;utm_medium=social&amp;utm_oi=911363543885045760" target="_blank" rel="noopener">这篇文章</a>我也一度想试试在vim中编辑TeX文件, 以Okular显示的方案, 但体验后发现用vim编辑富文本文档真是傻逼. 我原本是馋这样快捷的补全, 但事实证明装几个补全插件, 都还不需要自己添加snippet补全体验就已经很不错了 (毕竟我不是数学专业, 并不会频繁用到奇怪公式). 另一方面, 我试了好几个pdf软件, 反向搜索都只能具体到行, 不能让光标精确定位到我在pdf中点到的词/图上, 而LaTeX Worshop提供的VSC内置pdf阅读器支持精确的反向搜索. 另外我在VSC中装了<a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener">拼写检查</a>和<a href="https://marketplace.visualstudio.com/items?itemName=CodeInChinese.EnglishChineseDictionary" target="_blank" rel="noopener">查单词</a>的插件, (有拼写检查很重要!) 而我很久以前搜的时候并没有搜到好用的vim拼写检查插件. 其他方面vim倒是和VSC差不多.</p></li>
</ol>
<h3 id="office套件">Office套件</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S wps-office-cn  # wps套件国内版</span><br><span class="line">yay -S wps-office-mui-zh-cn  # wps中文语言包</span><br><span class="line">yay -S ttf-wps-fonts  # wps需要的字体和符号</span><br></pre></td></tr></tbody></table></figure>
<p>💡安装WPS遇到的问题都可以在<a href="https://wiki.archlinux.org/title/WPS_Office_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">ArchWiki-WPS Office</a>找到答案.</p>
<p>我体验了Office365 Online, LibreOffice, Google Docs, WPS后发现在Linux用Office套件只能是用WPS, 而且很好用. 其他软件简直是一坨💩</p>
<p>Office365 Online当然是格式兼容最好的, 但是必须在线使用, 而且打开一个本地文件时会先把这个文件上传到onedrive中然后从云端打开, 文件稍微大点那体验很差. 在线版Office表面看岁月静好, 其实功能阉割非常严重. Google Docs虽然可以安装为chrome插件离线使用, 但是功能更加简陋了! 而LibreOffice就很离谱了, 明明是一个本地使用的Office套件, 但支持的功能并不比前两者多多少, 同时界面还有点古老.</p>
<p>这三者的功能缺失到底有多严重呢? 我来举几个例子:</p>
<ol type="1">
<li>都没有内置插入富文本公式的功能</li>
<li>都不可以设置插入的矩形的透明度 (有时候我会用一个带透明度的矩形来作为图片蒙版)</li>
<li>Office365 Online和LibreOffice的PPT软件都不支持插入本地视频, Google Docs我就没试了. Office365 Onlineq其实是可以插入视频, 但是只支持来自于youtube等几个有限选择的联机视频... 而LibreOffice的PPT软件在编辑时可以插入本地视频, 但是保存为<code>.ppt</code>后这个视频不知道为什么没了... (我没试保存为它自己的格式的话能不能行, 因为那也没什么用)</li>
<li>...如果上面几个功能都不支持我不如写Markdown文档了所以不用试了</li>
</ol>
<p>而另一边, <strong>WPS出乎我意料的好!</strong> 以上功能WPS统统支持, 用起来和MS Office真的是区别不大了👍 目前注意到的也就是PPT里不支持3D模型 (但是也能显示成图片), 甚至平滑切换效果这个MS Office的特色功能都支持了! 另外选中一些对象右键另存为图片时好像不能另存为svg或其他矢量图格式, 无伤大雅. 格式不完全兼容这个问题当然还是存在, 但是在接受范围内. 而且, WPS现在还挺好看的🐮</p>
<p><img data-src="Linux下各用途我最认可的工具推荐/wps.png"></p>
<p>至于MS Office套件提供的其他我使用的软件:</p>
<ul>
<li><p>Outlook, 微软待办事项, 日历我使用的是网页版 (在Windows我也用的网页版, 因为可以和微软待办事项, 日历联动我觉得体验反而比Outlook本地客户端体验更加良好)</p></li>
<li><p>teams则是有官方Linux版本, 可以执行<code>yay -S teams</code>安装. 不过网页版也能获得完整的体验, 我感觉没什么差别</p></li>
<li><p>OneDrive的话虽然有人开发了<a href="https://abraunegg.github.io/" target="_blank" rel="noopener">OneDrive Linux客户端</a>, 但我并没有使用. 虽然我平时使用Linux系统, 但是我把我的Windows盘挂载在了我的Linux系统里, 可以访问并编辑OneDrive文件夹里的文件, 然后我对同步频率的要求没多高, 因此暂时没感觉不方便 (主要是很久以前试过这个客户端, 当时体验很一般). 比较有意思的是目前在企业版Office365 (学校给的) 的应用列表中直接有列出OneDrive Linux版的图标, 但链接到的是一个<a href="https://github.com/skilion/onedrive" target="_blank" rel="noopener">有很多bug功能很不全的版本</a>, 而且我的个人版Office365的应用列表并没有列出这个 😅<img data-src="Linux下各用途我最认可的工具推荐/onedrive.png"></p>
<p>在<a href="https://github.com/skilion/onedrive/issues/518" target="_blank" rel="noopener">这个issue</a>中可以看出skilion完全不想为社区开发, 但同时拒绝向abraunegg的版本引流或注明自己的版本的问题... 👎</p></li>
</ul>
<h2 id="工程">工程</h2>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S minicom  # 终端串口调试助手, 也有GUI版, cutecom</span><br><span class="line"><span class="meta">#</span><span class="bash"> 未完待续...</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="命令行工具">命令行工具</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S zsh</span><br><span class="line">chsh -s /usr/bin/zsh  # 切换默认shell为zsh, 要注意你的zsh也许不在/usr/bin/zsh</span><br><span class="line"></span><br><span class="line">yay -S tmux</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用gpakosz的tmux主题</span></span><br><span class="line">cd ~ &amp;&amp; git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s -f .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local .</span><br><span class="line"></span><br><span class="line">yay -S lsd</span><br><span class="line">git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br><span class="line">yay -S bat</span><br></pre></td></tr></tbody></table></figure>
<p>在这里我想先辨析一下<code>终端</code>, <code>shell</code>, <code>命令行</code>这三个词:</p>
<ul>
<li><p><strong>终端</strong> (terminal), 最开始指的是一种用来与计算机主机交互的输入输出设备, 是硬件, 而我们如今绝大多数情况下说的终端实际上是终端模拟器 (terminal emulator) 的简称, 是一类模拟终端这种提供与计算机交互界面的功能的软件. 有的终端模拟器不仅可以显示字符还可以显示图像. 我用的终端是KDE提供的<strong>Konsole</strong>. 去掉标题栏及边框后能达到👇这样的效果, 我感觉还挺好看😁 <img data-src="Linux下各用途我最认可的工具推荐/terminal.png"></p></li>
<li><p><strong>shell</strong>, 指的是一种让用户能够与操作系统内核进行交互的软件 (我们通常说的是命令行界面shell, 但实际上shell这个概念还包含了GUI的shell, 比如KDE). Ubuntu及Manjaro等系统自带的shell程序是bash, MacOS自带的shell则是zsh. 实际上zsh是比bash体验好很多的shell程序, 自身的补全更加智能, 有很丰富的插件选择, 有<a href="https://ohmyz.sh/" target="_blank" rel="noopener">Oh My Zsh</a>这样的便利shell配置管理框架... 反正谁用谁知道 👍 我也不清楚为什么大多数Linux系统仍将bash作为系统默认shell, 这点表扬MacOS. 用下面的命令来安装并切换默认shell为zsh.</p></li>
<li><p><strong>命令行</strong>, 看了前两者的描述能发现命令行指的只是相对于图形化界面操作的一种操作方式, 一般是纯文本界面, 少数命令行程序支持鼠标操作, 比如vim (需要设置), htop (命令行任务管理器), ranger (命令行资源管理器), w3m (命令行浏览器), tmux.</p></li>
</ul>
<p>然后我来介绍几个好用的命令行工具:</p>
<ul>
<li><p>tmux是一个终端复用器 (解释起来比较复杂, 建议自行搜索一下), 我主要用来在一个终端里开多个窗口 / 连服务器. tmux的设计使得与服务器交互时在服务器侧开一个tmux后即便丢失与服务器的连接, 服务器端tmux中的任务仍会正常执行下去, 并且下次连上服务器后进入tmux就可以回到这个工作现场. 推荐一下<a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">这个tmux主题</a>, 开箱就能有很不错的体验, 颜值很高, 配置也很容易个性化.</p></li>
<li><p>lsd是<code>ls</code>命令的替代品, 最主要的价值是让ls命令的输出变成彩色而且每种文件有对应图标显示的了 😁 要注意需要安装<a href="https://github.com/ryanoasis/nerd-fonts/blob/master/readme.md" target="_blank" rel="noopener">特定类型的字体</a> (Manjaro已经自带这种字体)</p></li>
<li><p><a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">fzf</a>是一个模糊查找器, 不止可以在zsh里用, vim, tmux中也有支持. 我主要喜欢用来在zsh中能模糊输入我设定了的几个命令, 结合<strong>bat</strong>, 这个升级版cat, 能获得很流畅的 (装逼) 体验. 之所以不从aur装fzf是因为从aur装的fzf不知为什么会缺少<code>.fzf.zsh</code>这个文件. 贴上我在<code>.zshrc</code>中对fzf的配置:</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> fzf config and initial</span></span><br><span class="line">if [ -f ~/.fzf.zsh ]; then</span><br><span class="line">    export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow"</span><br><span class="line">    # export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow --exclude $FD_EXCLUDES"</span><br><span class="line">    export FZF_COMPLETION_TRIGGER=']'</span><br><span class="line">    export FZF_DEFAULT_OPTS='--layout=reverse --info=hidden --marker="✔ " --prompt=" "'</span><br><span class="line">    # Use fd (https://github.com/sharkdp/fd) instead of the default find</span><br><span class="line">    # command for listing path candidates.</span><br><span class="line">    # - The first argument to the function ($1) is the base path to start traversal</span><br><span class="line">    # - See the source code (completion.{bash,zsh}) for the details.</span><br><span class="line">    _fzf_compgen_path() {</span><br><span class="line">        fd --type f --hidden --follow . "$1"</span><br><span class="line">    }</span><br><span class="line">    # Use fd to generate the list for directory completion</span><br><span class="line">    _fzf_compgen_dir() {</span><br><span class="line">        fd --type d --hidden --follow . "$1"</span><br><span class="line">    }</span><br><span class="line">    # (EXPERIMENTAL) Advanced customization of fzf options via _fzf_comprun function</span><br><span class="line">    # - The first argument to the function is the name of the command.</span><br><span class="line">    # - You should make sure to pass the rest of the arguments to fzf.</span><br><span class="line">    _fzf_comprun() {</span><br><span class="line">        local command=$1</span><br><span class="line">        shift</span><br><span class="line">        case "$command" in</span><br><span class="line">            cd)             fzf "$@" --preview 'lsd --tree {} | head -200' ;;</span><br><span class="line">            export|unset)   fzf "$@" --preview "eval 'echo \$'{}" ;;</span><br><span class="line">            ssh)            fzf "$@" --preview 'dig {}' ;;</span><br><span class="line">            vim)            fzf "$@" --preview 'bat --style=numbers --color=always --line-range :500 {}' ;;</span><br><span class="line">            *)              fzf "$@" ;;</span><br><span class="line">        esac</span><br><span class="line">    }</span><br><span class="line">    source ~/.fzf.zsh</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="远程服务器相关">远程/服务器相关</h3>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yay -S sshfs</span><br><span class="line">yay -S frp</span><br><span class="line">yay -S filezilla # 访问ftp/sftp等协议文件系统</span><br><span class="line">yay -S remmina # 支持多种协议的远程桌面</span><br><span class="line">yay -S freerdp # 为了让remmina支持rdp协议需要安装这个</span><br></pre></td></tr></tbody></table></figure>
<p>sshfs允许以SFTP将SSH服务器的指定路径挂载到本机, 在懒得配服务器的IDE/编辑器时可以用这种方式在本地编辑, 对不需要IDE/编辑器的高阶调试时还是挺方便的.</p>
<p>frp则是一种以反向代理的方式让我们能非常方便地ssh到一台内网服务器的方式! 使用非常简单, 在要访问的内网机器和作为跳板的公网服务器上分别放一个程序和配置文件就能用了👍 参见<a href="https://gofrp.org/docs/setup/" target="_blank" rel="noopener">frp文档</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>我从Ubuntu换到了Manjaro</title>
    <url>/zh-CN/2020/07/26/%E6%88%91%E4%BB%8EUbuntu%E6%8D%A2%E5%88%B0%E4%BA%86Manjaro/</url>
    <content><![CDATA[<p>前几天闲来无事下了一个听说了很久的Manjaro (KDE版), 在Live CD体验了一会果断装了实体机. 体验比Ubuntu好太多了!</p>
<a id="more"></a>
<!-- TODO -->
<h2 id="manjaro-kde比起ubuntu的优势">Manjaro-KDE比起Ubuntu的优势</h2>
<p>在实体机上使用快要有一个月了, 体验下来相比于Ubuntu, 以不是专业软件开发者, 而是机器人开发者的角度, Manjaro KDE最吸引我的三个关键词是: KDE, 不太激进的Arch系, MHWD. 当然两者还有些其他区别, 但我目前感触最深的就是这三个关键词.</p>
<h3 id="kde的好处">KDE的好处</h3>
<p>Manjaro有好几个版本, Architect, Gnome, KDE Plasma, XFCE四个官方版本, i3等九个社区版本, 这几个版本都是给x64/x86平台用的, 主要区别是窗口管理器不同. 确切的说: - Architect没有图形界面 - Gnome, KDE Plasma, XFCE是桌面环境, 有各自的窗口管理器 (比如Plasma的窗口管理器是KWin), 但他们提供的不只有窗口管理器, 这几个大社区各自开发了一套配套基础应用, 总的来说都很有用 - 9个社区版相当与Manjaro Architect+一个预装的窗口管理器, 据我观察没有提供什么配套的东西</p>
<p>而另外还有针对arm平台几款常见单板机的Manjaro, 每款都提供KDE Plasma和XFCE两个版本. Linux平台桌面环境有很多, 其中我认为最有价值的就是XFCE和KDE. XFCE以<strong>轻量级, 稳定的同时足够友好</strong>著称, 是在电脑性能不太好时的首选桌面. 而KDE Plasma以<strong>现代, 高度可定制, 友好</strong>著称. 至于Gnome... 自从体验过KDE后, 除了很多软件或多或少依赖Gnome这一点, 我找不出它比起XFCE或者KDE有什么优势...</p>
<p>值得一提的是, KDE的初衷只是开发一个桌面环境, <strong>K</strong>ool <strong>D</strong>esktop <strong>E</strong>nvironment, 但随着社区的发展, <strong>KDE现在代表的是一个软件社区</strong>, 而桌面环境被分离出来, 只作为其中的一个产品, KDE Plasma. 另外还有KDE Applications, KDE Framework. 这样以来许多KDE软件在Windows, OS X也能运行.</p>
<h4 id="能轻松高度个性化且稳定的plasma桌面环境">能轻松高度个性化且稳定的Plasma桌面环境</h4>
<p>在体验KDE前我用了许久Gnome, 还折腾了许多个性化, 把Grub界面, Plymouth界面, 登录界面, 窗口主题, gnome shell主题, 图标主题都以较为硬核, 需要输入一些网上看来的命令的方式换掉了. 但体验了KDE后觉得自己实在是愚蠢: 有那功夫折腾Gnome的个性化, 直接换到KDE在系统设置点几下鼠标进行个性化多好? 上面提到的几个除了GRUB界面系统设置没有提供设定入口, <strong>统统在系统设置就可以下载, 更换主题</strong>! KDE还提供了更多可以个性化的东西, 比如一堆桌面特效, 应用窗口切换动画, 一堆任务栏的挂件等等. 实在是现代, 友好, 高度可定制!</p>
<p>💡 值得一提的是在Manjaro KDE的系统设置的<code>Time and Date</code>一栏即可勾选<strong>Hardware clock in local time zone</strong>, 也就是说勾选上这个Manjaro就会将硬件时间作为当前时区时间!</p>
<p>当然, 功能如此丰富的Plasma桌面环境运行起来消耗的资源比XFCE多, 但仍比Gnome消耗的资源少, 是较新的电脑的首选桌面环境😆</p>
<h4 id="齐全而贴心的系统自带软件">齐全而贴心的系统自带软件</h4>
<p>KDE自带的软件的贴心程度震撼到我: - 虽然Ubuntu也有类似<strong>FileLight</strong>的磁盘空间分析工具, 但是我总觉得有些bug, 体验不是很好, 而FileLight没有这些毛病, 甚至在扫描时是有动画的, 很贴心. - KDE自带的图片查看器, pdf阅读器比Gnome自带的功能更加丰富, 但也不会杂乱. - KDE的硬件信息查看软件, 类似任务管理器的软件比Gnome的更加直观, 信息更加丰富. - Manjaro KDE这个软件商店 (叫Add/Remove Software, 我也不知道算不算是KDE的) 吊打Ubuntu应用商店. 我基本没有成功从UBuntu应用商店下下来过东西, 但Manjaro KDE这个软件商店体验很好, 可以图形化设置是否开启AUR, Snap, Flatpak的支持, 设置如何处理包的缓存文件等.</p>
<h3 id="kde的缺点">KDE的缺点</h3>
<p>KDE也不是没有缺点. KDE, Gnome均遵循GPL协议, Gnome采用的图形库GTK遵循GPL协议, 但<strong>KDE采用的图形库Qt不遵循GPL协议</strong>. 这导致Gnome获得的商业支持远多于KDE, 所以现在很多主流发行版的默认桌面环境是Gnome, 进一步导致很多软件或多或少依赖Gnome, 很多教程也是针对Gnome的.</p>
<p><del>比如deepin全系软件都对Gnome有一定依赖, 在Manjaro KDE直接安装AUR里打包好的tim是无法启动的, 需要<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/90#issuecomment-653921540" target="_blank" rel="noopener">再安装一个依赖, 编辑一段代码</a>.</del> <strong>2022年更新:</strong> <em>应该是从去年开始就基本没这问题了, 在Manjaro很久没遇到安装不是一行命令搞定的软件了. aur源里总会有一个热心网友解决好依赖问题的版本 😁 目前TIM我用的<a href="https://aur.archlinux.org/packages/com.qq.tim.spark/" target="_blank" rel="noopener">com.qq.tim.spark</a>, 微信用的<a href="https://aur.archlinux.org/packages/com.qq.weixin.deepin/" target="_blank" rel="noopener">com.qq.weixin.deepin</a>, 都是最新版, 体验也很流畅</em></p>
<p>这些其实不算大问题, 都能在网上较为容易地找到解决方案, 但确实不能算新手难度.</p>
<h3 id="manjaro与arch-linux">Manjaro与Arch Linux</h3>
<h4 id="manjaro不是arch-linux">Manjaro不是Arch Linux</h4>
<p>要注意Manjaro虽然是Arch系, 但又与Arch Linux不完全兼容. AUR (Arch User Repository) 更多是面向Arch Linux用户的, 社区主导的第三方仓库, 里面都是社区用户<strong>自行维护</strong>的软件包 (足够热门足够好的话也会被Arch Linux官方收入官方维护的community仓库). 而Manjaro官方则只会对Arch Linux官方仓库的更新进行测试, 兼容性适配等后以一两周的延迟同步到Manjaro自己的官方仓库 (不过我感觉Manjaro是一批一批同步的, 因此不像Arch用户每天都可以更新一点什么, Manjaro是几天更新一批). 这意味着如果AUR上的软件维护者只在Arch Linux上进行测试的话, Manjaro用户可能发现自己从AUR上下下来的软件有问题. 不过Manjaro与Arch Linux绝大部分是兼容的, 就我这一年多的使用经验来看 (这段内容是2022年更新的), 主流的软件都没有兼容性问题, 冷门一些的软件小概率会碰到兼容性问题. 我仅有几次遇到的AUR软件问题基本都是因为Manjaro仓库与Arch Linux仓库之间的更新延迟, 导致软件的依赖或者依赖的依赖只更新了一部分, 因此依赖关系断了, 出现的问题. 这种问题我还没碰到过影响很重要软件的时候, 不急的话稍等几天就自然修复了, 急用的话回滚一下版本就好.</p>
<p>总的来说要记住<strong>Manjaro不是Arch Linux</strong> 😏 去Arch社区提问的话记得先说自己是Manjaro用户, 不然一群Arch老哥怎么也不能复现你遇到的问题才发现你其实是Manjaro用户的话会骂人的.</p>
<p>那为什么不直接用Arch Linux? 因为设计理念不一样. Arch Linux的用户是一群凡事更情愿自己啃文档自己动手丰衣足食的极客, 对于只是把Linux系统当一个工具的人来说Arch Linux使用起来太麻烦了. 正相反, Manjaro, 尤其是Manjaro-KDE提供了很多非常人性化的功能, 界面也非常现代等... 是非常阳间的操作系统 ❤️</p>
<h4 id="坐靠aur的好处">坐靠AUR的好处</h4>
<p>虽然如前面提到, 在Manjaro系统使用AUR上的软件可能遇到兼容性的问题, 但AUR社区的软件之丰富, 版本之新, 使用之简便, 社区之活跃足够让我忽视那小概率弊端.</p>
<p>举个例子. 我有一台有N卡的电脑, 我现在需要运行一个开启了CUDA加速的基于OpenCV的图像识别C++程序. 如果支持用最新版本的CUDA和OpenCV运行, 那么运行<code>yay -S opencv-cuda</code>, 然后最新的CUDA, cuDNN, 开启了CUDA加速的OpenCV的C++, Python库就都装好了🎉 N卡驱动是装Manjaro系统时选安装闭源驱动然后Manjaro就会很省心配置好的, 当然装好后在系统设置也能一键装好闭源驱动. 非常省心. 即便是有版本要求, 比如需要CUDA10.1和OpenCV3.4, 那先<code>yay -S cuda-10.1 cudnn7-cuda10.1</code>, 然后OpenCV确实是需要手动下载源码编译的了, 不过至少可以参考<code>opencv-cuda</code>包的<strong>PKGBUILD</strong>的写法.</p>
<h3 id="manjaro-hardware-detection-mhwd">Manjaro Hardware Detection (MHWD)</h3>
<p>MHWD绝对是让Manjaro从众多Linux系统中脱颖而出的一个重要原因. 这个工具能自动检测你的硬件并安装驱动, 当然你也可以自己选. 他主要是解决了我N卡驱动装着麻烦的问题, 在系统安装的时候引导就会问你是否安装闭源驱动, 然后这个工具就会帮你安好闭源的N卡驱动.</p>
<h2 id="manjaro是否对linux新手友好">Manjaro是否对Linux新手友好</h2>
<p>从Manjaro提供的众多贴心功能来说他对任何用户都是友好的, 比如如果安装Manjaro之前已有Windows系统的话安装好Manjaro后 Windows盘就自动被挂载了, 在资源管理器能看到侧边栏有个Windows图标, 可以说非常贴心了.</p>
<p>但另一方面, 滚动更新让Manjaro相比Ubuntu更容易出现问题, 虽然也更容易解决, 但是需要对Linux有一点了解. 但是我体验下来基本就这一个毛病, 学一学就不是大问题了 👍</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>HPV与宫颈癌小知识</title>
    <url>/zh-CN/2021/01/11/HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>帮人查HPV疫苗的信息整理了一份资料出来, 就分享一下好了. ❗ 注意以下信息为截止2020年12月的信息.</p>
<a id="more"></a>
<h2 id="hpv">HPV</h2>
<p>HPV (human papilloma virus), 即<strong>人类乳头状瘤病毒</strong>. 和乳头没有关系, 是大部分类型得了会长出乳头状的瘤 (即疣, 皮肤上的粗糙, 坚硬颗粒), 有近200种类型. <strong>不论是一般身体部位或生殖器的皮肤, 只要有鳞状上皮, 就可以被人类乳突病毒感染的, 但每种HPV通常只能感染特定区域皮肤.</strong></p>
<h3 id="较常见hpv与疣的种类">较常见HPV与疣的种类</h3>
<p>❗ 大多数时候感染后没有任何临床症状, 也就是说连下面这些疣都不会有. 而出现了疣的话大致可以分以下几种情况.</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 39%">
<col style="width: 39%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>疣类型</th>
<th>说明</th>
<th>HPV类型</th>
<th>危害程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>普通疣 (瘊子)</td>
<td>有着粗糙的表面, 通常发生在手及脚部, 但亦有可能在身体其他区域发生</td>
<td>2, 4 (最常见), 1, 3, 26, 29, 57</td>
<td>良性</td>
</tr>
<tr class="even">
<td>扁平疣</td>
<td>扁平而光滑的疣, 呈现肉色, 可能一长就是许多个；最常发生在头、脸、颈部、手、手肘及膝盖</td>
<td>3, 10, 28</td>
<td>良性</td>
</tr>
<tr class="odd">
<td>丝状疣</td>
<td>呈螺丝或者指头状, 在颈部, 脸部, 尤其是嘴唇以及眼皮周围上发生, 常见于中老年, 孕妇等 (因为抵抗力下降). <strong>注意与皮赘区别</strong></td>
<td>1, 2, 4, 7, 26, 27, 28, 29</td>
<td>良性</td>
</tr>
<tr class="even">
<td>跖疣</td>
<td>发生在足底部. <strong>注意与鸡眼, 老茧区别</strong></td>
<td>1 (最常见), 2, 3, 4, 27, 28, 58</td>
<td>良性</td>
</tr>
<tr class="odd">
<td>肛门生殖器疣 (尖锐湿疣)</td>
<td>长在肛门/生殖器附近. <strong>注意与珍珠疹, 假性湿疣区别</strong></td>
<td><strong>6, 11</strong> (90%), 13, 40, 42, 43, 44, 54, 61, 72, 81, 89</td>
<td>低危</td>
</tr>
<tr class="even">
<td>(癌和子宫颈细胞化生不良)</td>
<td>与癌症有关, 特别是子宫颈癌, 并且还可能会导致一些外阴, 阴道, 阴茎, 肛门和口咽的癌. 男性也可能感染</td>
<td><strong>16, 18</strong> (70%宫颈癌, 90%肛门癌, 很大比例阴道癌), <strong>31, 33, 45, 52, 58</strong>(20%宫颈癌), 35, 39, 59</td>
<td>高危</td>
</tr>
</tbody>
</table>
<p>💡 高危/低危根据致癌性划分. 无论是高危类型的HPV还是低危类型的HPV, <strong>目前都没有明确有效的抗病毒治疗手段</strong>, 只能治疗HPV导致的病变</p>
<p>💡 <strong>由此可见只有四十余种HPV通过性行为传播且有危害性, 大部分HPV性质和脚气类似, 并非性传播</strong> (但是能通过疫苗预防的几种HPV确实只有与性相关的几种)</p>
<p>💡 从整体上看, 我国的感染型别与国际以及亚洲地区其他国家略有差异, 在细胞学正常人群中, 全球范围内最常见的HPV型别依次是 HPV 16/52/31/53, 而在我国排名前四的型别依次是HPV 16/18/58/52. <strong>除了广泛流行的 HPV 16/18 型, HPV 58/52 型在中国宫颈癌中占比为 14.7%, 明显高于全球占比 7.4%</strong>.</p>
<p>80%感染的HPV会在6-24个月内会被身体的免疫系统自动清除, 医学上称为<strong>一过性感染</strong>.</p>
<h3 id="感染hpv的常见途径">感染HPV的常见途径</h3>
<ol start="2" type="1">
<li>间接接触传播 (共用拖鞋, 共用毛巾, 共用剃须刀, 公用马桶, 私人衣物等)</li>
<li>性传播</li>
<li>母婴传播</li>
<li>医源性感染</li>
</ol>
<h2 id="宫颈癌">宫颈癌</h2>
<p>到目前为止, 宫颈癌是人类唯一一个找到病因且可预防的癌症种类. 中国女性 HPV 感染率按年龄呈[双峰] 分布：第一个高峰在[17-24 岁], 第二个高峰在[40-44 岁].</p>
<p>宫颈癌与hpv关联: 只有少数高危型的 HPV 持续感染才会有一定几率引发宫颈癌, 通常情况下持续感染经过 10-20 年的自然演化发展, 才可能会发展成为宫颈癌.</p>
<h3 id="中国子宫颈癌综合防控指南提出的三级预防策略">中国《子宫颈癌综合防控指南》提出的三级预防策略</h3>
<ol type="1">
<li><strong>一级预防 (治未病)</strong>: 开展健康教育和接种 HPV 预防性疫苗</li>
<li><strong>二级预防 (治初病)</strong>: 对所有适龄妇女定期开展宫颈癌筛查</li>
<li><strong>三级预防 (治已病)</strong>: 根据宫颈癌的临床分期, 开展适宜的手术、放疗、化疗及姑息疗法</li>
</ol>
<p>🌟 筛查比hpv疫苗重要得多</p>
<p><img data-src="HPV与宫颈癌小知识/screening.jpg"></p>
<h2 id="hpv疫苗">HPV疫苗</h2>
<h3 id="工作原理">工作原理</h3>
<p>以L1蛋白外壳模拟HPV病毒, 本身不是病毒, 不会造成感染</p>
<h3 id="意义">意义</h3>
<ul>
<li><p>预防大部分有致癌风险的HPV</p></li>
<li><p><strong>感染过HPV也仍有接种价值</strong>: HPV感染或由此引发的宫颈病变治愈后, 进行HPV疫苗接种可以减少疾病的复发率. 理论上认为, 人体自然感染HPV后, 抵抗病毒的体系是细胞免疫, 主要在宫颈局部起作用, 产生的抗体水平很低, 不足以对抗病毒的再次进攻. 而疫苗是肌肉注射, 会引发人体产生强烈有效的免疫反应, 产生的抗体的滴度是自然感染的40倍以上, 这样就可以防止病毒的感染.</p></li>
</ul>
<h3 id="接种条件及方式">接种条件及方式</h3>
<ul>
<li>对疫苗活性成分 (L1蛋白) 或任何辅料成分有超敏反应者禁用</li>
<li>目前大陆没有开放男性接种HPV疫苗 (国外可以)</li>
<li>肌肉注射 (首选上臂三角肌), 每次0.5ml</li>
</ul>
<h3 id="类型">类型</h3>
<p><img data-src="HPV与宫颈癌小知识/types.png"></p>
<p>共二, 四, 九价三种HPV疫苗, "价"指疫苗能预防的HPV亚种数. 目前全世界只有葛兰素史克 (英国), 默沙东 (美国), 万泰沧海 (中国) 三家能生产HPV疫苗, 其中四价, 九价疫苗目前只有默沙东能生产.</p>
<h3 id="性价比">性价比</h3>
<p><strong>万泰沧海二价 &gt; GSK二价 &gt; 默沙东九价 &gt; 默沙东四价</strong></p>
<ul>
<li><p>万泰沧海疫苗价格低的原因在于研发原理带来的低成本. 默沙东疫苗基于酒酿酵母表达体系, GSK 疫苗基于<strong>昆虫细胞</strong>表达系统, 万泰沧海疫苗基于<strong>大肠杆菌</strong>表达体系.</p></li>
<li>万泰对16/18型保护效力高于进口疫苗, 且不良反应小</li>
<li><p>四价只比二价多了对尖锐湿疣的预防, 但是尖锐湿疣看网上信息意思基本是良性的, 因此不如九价性价比高</p></li>
<li>国内目前都是自费接种, 因此其实大部分人还是选择等九价. 不过可能出现打完一针后缺货的情况.</li>
<li><p>打过了二价或四价, 也可以再接种九价, 不过要等完成接种的一年后才可以, 而且有点亏</p></li>
</ul>
<h3 id="周期">周期</h3>
<p>打疫苗要按周期, 一共打三次. 可以比建议时间晚几天, 但最好不要提前打. 这是为了产生最多的抗体. 提前打浪费. <strong>一年内完成三针产生的抗体量都是够的</strong>.</p>
<h3 id="保护能力持续时间">保护能力持续时间</h3>
<p>尚不清楚, 目前可以确保是10年以上. (因为这个疫苗一共出现才十多年)</p>
<h3 id="年龄限制">年龄限制</h3>
<p>九价建议注射年龄是16~26岁, 指第一针需要在26岁半前接种, 27岁前完成三针. 之所以国内对默沙东九价疫苗限制年龄段比国外窄是因为国内的默沙东九价疫苗临床数据目前只做了16-26岁女性的 (同时也有疫苗资源紧张的原因).也因为同样原因大陆没有开放男性接种HPV疫苗.</p>
<h3 id="供应量">供应量</h3>
<p>九价供应短缺原因:</p>
<ul>
<li>国内缺口大: 国家统计局最新数据显示, 九价HPV疫苗的适龄人群 (16-26岁) 约<strong>1.2亿</strong>. 而按照智飞生物2019年九价HPV疫苗批签发量332.4万计算, 能够接种到该疫苗的人数还<strong>不足总数的1%</strong>. (按照10%的核心人群渗透率算)</li>
<li>九价国内审批只用了八天, 默沙东产量预估不足, 并且增加产能决心不强烈</li>
<li>目前国外很多市场已经淘汰二价, 四价疫苗, 以售卖九价疫苗为主.</li>
</ul>
<p>现状:</p>
<ul>
<li><p>目前只有默沙东一家生产九价疫苗. 2023年默沙东新生产线将投产.</p></li>
<li><p>截至2020年7月国内HPV疫苗研发概况👇 (可以看到甚至十一, 十四价HPV疫苗也已经开始研发了), 但是我看网上消息的意思, 直到2026年估计不会有国产九价疫苗上市 🤦‍♂ ️</p></li>
</ul>
<p><img data-src="HPV与宫颈癌小知识/outline.jpeg"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>健康</category>
      </categories>
  </entry>
  <entry>
    <title>初级急救员笔记</title>
    <url>/zh-CN/2021/01/21/%E5%88%9D%E7%BA%A7%E6%80%A5%E6%95%91%E5%91%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>最近假期了, 把十八岁暑假去参加的初级急救员培训笔记拿出来写在这里好了. 望指正.</p>
<a id="more"></a>
<h2 id="关于红十字会的初级急救员培训">关于红十字会的初级急救员培训</h2>
<h3 id="为什么要学急救">为什么要学急救</h3>
<p>学急救对普通人来说并不是一件小题大做的事情, 所谓初级急救员培训, 一共只有16小时 (两天), 我当时报名所想要达到的目的也仅是在遇到突发情况时不至于茫然无措. 摘抄一段成都红会的课程介绍页面的话:</p>
<blockquote>
<p>通过现场初级急救知识的学习和实践, 使受训人员掌握基本救护理论和实践操作技能, 在遇到突发事件或意外伤害时能自救互救, 以减轻痛苦、减少伤残, 为挽救生命争取宝贵时间</p>
</blockquote>
<p>实际上这样的"突发事件或意外伤害"发生在身边, 甚至亲友身上的几率<strong>并不小</strong>. 实际上我已经有过<strong>两次</strong>我在场时亲人发生突发事件的经历了. 正是第一次遇到这种情况时的无助让我在高中结束时思考假期做什么第一个想到了学急救培训. 但即便我认真地做了笔记, 也不时地关注一些急救信息, 我第二次面临这样的情况时仍然完全没法沉着冷静. 虽然做了些调整体位, 等救护车等力所能及的事情, 但是我内心仍然是茫然无助的. 毕竟只是普通人, 又只学了些急救的皮毛, 非常容易遇到没有头绪的情况 (甚至可能因为经验太少而产生误判). 因此遇到突发事件我的经验是:</p>
<p><strong>第一要务是给120打电话, 说明情况并寻求帮助</strong></p>
<p>这是否意味着自己就没有学急救的意义了呢? 学习急救知识对于普通人来说仍然是十分必要的, 因为急救讲究争分夺秒, 在救护车赶来前, 如果我们能做一些应急措施, 那将是非常有意义的. 但是如果我们毫无相关常识 (甚至可能有错误的认知), 比如不知道<a href="#复苏体位">复苏体位</a>到底是怎样的, 不知道<a href="#标准心肺复苏">心肺复苏的要点</a>, 不清楚<a href="#误食强酸-强碱">喝了大量强酸</a>该马上找什么... 那么即便有120在旁电话指导我们仍然很难做出有效的应对措施. 身边人的健康是非常重要的事情, 学一学成本不大, 但价值极高 👍</p>
<h3 id="报名渠道">报名渠道</h3>
<p>在各地的红十字会官网上应当就能搜到报名方式.</p>
<p>🔗 <a href="http://www.scredcross.org.cn/htm/detail_6355.html" target="_blank" rel="noopener">四川红会的课程介绍</a> 🔗 <a href="http://www.chengduredcross.cn/list_wjpx.asp?ClassID=020501" target="_blank" rel="noopener">成都红会初级急救员培训报名渠道</a></p>
<p>这个培训要收个两百多的报名费, 但也不算贵, 毕竟会发一个培训用创伤训练包 👍 (说起来培训的氛围非常好, 老师特别亲和)</p>
<h2 id="笔记">笔记</h2>
<p>💡 这里有一份<a href="./初级急救员笔记/2011年国际急救与复苏指南.pdf">2011年国际急救与复苏指南</a>和<a href="./初级急救员笔记/日常急救手册.pdf">日常急救手册</a>可供下载. 以下<a href="#心肺复苏">心肺复苏</a>, <a href="#气道异物梗阻">气道异物梗阻</a>, <a href="#创伤">创伤</a>, <a href="#其他">其他</a>几个板块是急救培训老师着重讲的部分, 其实在前面这本急救与复苏指南里还有好一些内容.</p>
<div class="note warning">
            <p>这里会涉及到许多没有实际操作过就无法把握要点的技术, 这只是一份<strong>笔记</strong>.</p>
          </div>
<h3 id="心肺复苏">心肺复苏</h3>
<h4 id="判断是否进行心肺复苏">判断是否进行心肺复苏</h4>
<p>虽然人人都知道有个叫心肺复苏的技术能救命, 但实际上实施心肺复苏有一定的条件, 盲目进行心肺复苏反而容易出问题. 下面便是判断是否进行心肺复苏的流程.</p>
<p><embed src="./初级急救员笔记/判断是否进行心肺复苏流程图.svg?50"></p>
<p>❗是的<strong>对于非专业人士来说判断是否进行心肺复苏并不需要判断伤病员是否有脉搏</strong>. 另外要注意即便专业人士也只会判断是否有脉搏, 是<strong>不会判断是否心脏停跳</strong>的. (详见下文<a href="#AED的使用">AED的使用</a>)</p>
<h5 id="确认现场环境安全">确认现场环境安全</h5>
<p>举例: - 关闭受损汽车的发动机, 拉下手刹 - 在抢救触电者前切断电源 - 远离危险地带 (比如易塌墙) - 远离有毒有害气体 (比如开窗通风)</p>
<p>❗尽量不要移动伤员</p>
<h5 id="做好自我防护措施">做好自我防护措施</h5>
<p>随意接触伤员有一定可能染上病, 以下是一些可能的, 对彼此都有防护作用的措施: - 处理伤口前洗手, 尽量戴手套. 如果没有手套的话塑料袋也可以. - 戴口罩 - 处理大量出血的外伤时戴防护镜 - 做人工呼吸时隔一层布或纸</p>
<h5 id="判断有无意识">判断有无意识</h5>
<p>要判断有无意识, 对于成人, 拍打双肩, 在耳边大声呼唤; 对于婴儿, 拍打足底. 可以给予"睁开眼睛", "动动手指"这样的简单指令.</p>
<p><strong>如伤病员无反应</strong>: 1. 向周围人表明急救员身份 2. <strong>指定</strong>一个人拨打120 3. 寻求他人帮助 (比如寻找AED) 4. 向他人问明伤员情况, 如是否有内出血/骨折/脊柱损伤等. (万一周围人就知道点什么呢) 5. 记录时间 (现在这个时代了, 拿出手机随便照一张就把时间地点什么的都记录在照片的元数据里了👍)</p>
<p><strong>如伤病员有反应</strong>: 1. 表明急救员身份 2. 心理安慰 3. <strong>视情况</strong>拨打120 4. 帮助调整伤员为<a href="#复苏体位">复苏体位</a>, 排除气道异物, 打开气道 5. 记录时间</p>
<h5 id="判断有无呼吸">判断有无呼吸</h5>
<p>此处提供两种方法, 一种是培训班老师教的, 一种是我在网上看到的, 同样有效且我觉得操作难度更低的.</p>
<h6 id="老师教的方法">老师教的方法</h6>
<p>伏低身子, 以伤病员头至脚方向观察胸部起伏. 从<strong>1001数到1008</strong> (数四位数是以实际的发音代替了停顿, 这样数得更精确), 这期间应当观察到<strong>两次起伏</strong>. ❗到底数多快见下方<a href="#参考视频">参考视频</a>, 基本上一秒数一下.</p>
<p>💡 正常人3-4秒一次呼吸, 一分钟15-20次呼吸.</p>
<h6 id="我更推荐的方法">我更推荐的方法</h6>
<p>我自己想到了一个我感觉挺有效的方法, 将眼镜或者手机屏幕等玻璃凑到伤病员鼻子前, 如果观察到水汽则有呼吸.</p>
<p>之所以我更推荐这个方法是因为实际上微弱的胸部起伏很难观察到, 一般还需要解开伤病员衣服. 而观察是否有水汽是一件非常容易的事情, 而且很灵敏 👍</p>
<p><strong>如果伤病员有呼吸</strong>: 1. 调整伤病员为<a href="#复苏体位">复苏体位</a>, 清理气道异物, 打开气道 2. 密切关注其呼吸是否衰竭</p>
<h4 id="几种心肺复苏方式">几种心肺复苏方式</h4>
<p>根据急救员水平, 现场环境, 伤病员情况等有几种方式可选: 1. <a href="#标准心肺复苏"><strong>标准心肺复苏</strong></a> (<strong>C</strong>ardio<strong>P</strong>ulmonary <strong>R</strong>esuscitation) 2. <strong>单纯胸外按压</strong> (<strong>C</strong>ardio<strong>C</strong>erebral <strong>R</strong>esuscitation)<br>
不可以长时间进行单纯胸外按压, 最好两分钟内进行一次人工呼吸 3. <strong>标准心肺复苏 + AED</strong><br>
进行五组标准心肺复苏后进行一次电击, 然后立即再进行五组标准心肺复苏. 然后检查是否恢复了脉搏/呼吸.</p>
<p>其中， <strong>未经培训或仅受过最低等级培训的急救员推荐只进行单纯胸外按压心肺复苏</strong>, 而对于专业人士, 则推荐进行标准心肺复苏. 造成这种差异的原因是多方面的. 实际上&lt;2011年国际急救与复苏指南&gt;这本书里列举了大量实验, 都是试图探究标准心肺复苏与单纯胸外按压的效果差异, 但目前并没有实验能证明两者中哪个有明显优势. 但是对于非专业人士来说, 是有许多理由推荐只进行单纯胸外按压心肺复苏的: 1. 非专业人士更能接受不需要进行人工呼吸的单纯胸外按压心肺复苏, 不会因为对标准心肺复苏的犹豫而耽误抢救. 2. 心肺复苏讲究<strong>胸外按压的连贯性以及按压深度要够</strong>. 然而标准心肺复苏30:2的按压/通气比导致胸外按压会被频繁打断, 因此非专业人士很容易耗费大量时间在人工呼吸上, 导致胸外按压不够连贯, 按压深度逐渐达不到标准. 3. 据统计非专业人士的人工呼吸效果很差, 达不到标准. 4. 单纯胸外按压比标准心肺复苏更容易掌握, 一段时间后能保证更为完整的按压技能. 5. 单纯胸外按压比标准心肺复苏操作要简单些, 更方便120电话指导进行.</p>
<h5 id="几种常见心脏停搏情况及应对">几种常见心脏停搏情况及应对</h5>
<ul>
<li>原发性心脏停搏
<ul>
<li>心室纤维性颤动 (即室颤, VF): 可应用AED</li>
<li>无脉性室性心动过速 (即室速, VT): 可应用AED</li>
<li>无脉性电活动: AED会不建议电击</li>
<li>心脏停跳: AED会不建议电击</li>
</ul></li>
<li>继发于呼吸衰竭的心脏停搏: 先进行两次人工呼吸, 再进行心肺复苏</li>
</ul>
<p>💡 心脏停跳后10秒晕厥, 15秒抽搐, 30秒呼吸停止, 1-2分钟瞳孔放大, 3-5分钟致死, 7分钟大脑遭受不可逆性损伤.<br>
💡 室颤会迅速消耗心肌细胞的能量, 应在1-2分钟内进行除颤.</p>
<p>❗ 要注意心脏停搏和心脏停跳是不一样的, 心脏停搏指的是<strong>心脏射血功能停止</strong>, 可能是由于心脏停跳, 但也可能是因为心脏电气活动紊乱等.</p>
<h5 id="aed的使用">AED的使用</h5>
<p>首先我们需要意识到AED是在心肺复苏时<strong>很重要</strong>的工具, 不仅使用非常简单 (基本不需要培训, 跟着语音来就行), 而且功能丰富. 另外虽然从名字来说它只是用来除颤的机器, 但现在的AED也能对许多其他情况提供帮助. AED里面通常还包含用于人工呼吸的脸罩, 一些常用的急救工具等. 而且现在的AED不止可以除颤, 显示心电图, 还有些AED的电极贴片上有传感器, 支持监测胸外按压的频率和深度, 从而指导急救者进行有效的心肺复苏. 还有些支持记录音频, 心电图, 电击数据等... 👍nb</p>
<p>要注意<strong>A</strong>utomated <strong>E</strong>xternal <strong>D</strong>efibrillator, 即自动体外心脏<strong>除颤</strong>器, 其功能是判断特定的心率不正, 并且给予去颤电击, 强制终止心脏所有电活动. 电击后需要急救员立即进行胸外按压帮助心脏重新开始电活动. 相当于当电脑出问题了无脑重启一下. 更具体一点, 正如傻瓜相机虽然操作简单但也功能有限, AED功能也有限:</p>
<blockquote>
<p>(摘自维基百科) <strong>AED只能针对两种情况: 心室纤维性颤动和无脉性室性心动过速</strong>. 不同于一般专为医疗人员设计的专业心脏电击器，除了以上所提的两种情形外，它无法诊断其他各式各样的心率不整也无法提供治疗，而且它无法对心搏过慢提供体外心率调节的功能。</p>
</blockquote>
<p>就是说AED没法处理心脏停跳的情况. 那个针对心脏停跳的是心脏起搏器, 是用外部电信号带动心脏跳动. 不过作为非专业人士我们也没法判断到底是什么情况. 好在AED能够自动根据心电图判断是否应该给予电击. 如果是上述AED没法处理的情况AED会直接发出不建议进行电击的提示 (即便按电击键也没法强制电击).</p>
<p>目前常见的AED有两种: 全自动和半自动. 区别在于AED判读心电图决定是否电击后, 是否需要操作者按下电击键才开始电击.</p>
<p>💡 有的人贴电极的地方会因为电击出现类似烧伤的症状, 但这是小问题.</p>
<h5 id="标准心肺复苏">标准心肺复苏</h5>
<p>⭐ 要点: (具体动作见下<a href="#参考视频">参考视频</a>) 1. 在硬的地面上进行 2. 按压时注意观察患者是否有苏醒迹象 😆 3. 按压两乳连线中点, 或者剑突上方两指处 (如果位置不准容易导致肋骨断裂, 内脏破损) 4. 成人用双手按, 儿童 (1-12岁) 用单手按, 婴儿用两指按 (食指+中指或两拇指) 5. 成人需要按下5-6cm, 婴儿需要按下3-4cm 6. 按压不可过猛, 手不要离开按压位置 7. 按压时数两位数, 按压频率约为100次/分钟 8. 救护员身在伤病员右手侧 9. 胸外按压/人工呼吸比例为30:2 10. 对婴儿人工呼吸可以包住口鼻 11. 人工呼吸过程中要保持伤病员气道打开, 不可吹得太快, 过于用力. 应吹至胸腔微起并停止1s 12. 如果要换人, 五组换一次 (五组心肺复苏一般用时2min)</p>
<h4 id="参考视频">参考视频</h4>
<p>因为涉及到许多文字无法描述出的节奏, 最后还是放一个我看来看去觉得说明最详细, 正规的心肺复苏教学视频. ❗视频里老师并没有检查病人是否有呼吸, 而是检查的病人的大动脉搏动. 这其实是更加专业的做法, 但是基于"检查脉搏不应增加判断时间, 未经训练判断是否有脉搏难度较大"这样的因素, 对于初级急救员这样面向大众的急救标准只要求了检查呼吸. 毕竟专业急救人员也要遵循这样一条原则:</p>
<blockquote>
<p>专业救援人员应该检查脉搏，如果不能确定是否有搏动，应该认作无脉搏。</p>
</blockquote>
<iframe src="//player.bilibili.com/player.html?aid=17883263&amp;bvid=BV1oW411q7hG&amp;cid=29195038&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<h3 id="气道异物梗阻">气道异物梗阻</h3>
<p>❗直立/坐时不可拍背, 反而容易使异物卡得更深</p>
<ol type="1">
<li>背部叩击法: 使患者弯腰后用<strong>掌根</strong>向前下拍两肩胛骨中间5次</li>
<li>海姆立克冲击法: 斜向上冲击肚脐上两指处5次.</li>
</ol>
<p>也不要太用力了, 不然会造成伤害. 进行5次都不能排出异物的话🔥速打120</p>
<h3 id="创伤">创伤</h3>
<h4 id="外出血基础">外出血基础</h4>
<ol type="1">
<li>成人血液约占体重8%, 有约4L血液.</li>
<li>出血的定义: 血管破裂导致血液流至血管外. 分为内出血和外出血.
<ol type="1">
<li><strong>动脉出血</strong>: 鲜红血, 涌泉状</li>
<li><strong>静脉出血</strong>: 暗红血, 平稳流出</li>
<li><strong>毛细血管出血</strong>: 血色鲜红, 量不大</li>
</ol></li>
<li><strong>轻度失血</strong>: 失800mL (20%), 出冷汗, 口渴, 手足湿冷, 脉搏快<br>
<strong>中度失血</strong>: 失800-1600mL (20-40%), 中度休克 (以上症状+呼吸急促)<br>
<strong>重度失血</strong>: 失1600mL以上, 以上症状+表情淡漠+脉搏弱得摸不到</li>
<li>止血: 清理伤口异物后以敷料按压至不再出血 (或用止血带止血). 敷料应盖过伤口周边至少3cm. ❗当一块敷料被血浸透后<strong>不要取下</strong>, 直接再盖一块上去. 这是因为刚开始流的血中血小板最多, 凝血效果最好; 而且医生可以根据敷料被浸湿程度判断失血量.</li>
</ol>
<h4 id="按部位应对">按部位应对</h4>
<ol type="1">
<li>头
<ol type="1">
<li>按压耳前1-2cm处动脉可止血</li>
<li>头上部出血用帽式包扎</li>
<li>出鼻血<strong>不可仰头</strong>, 要低头, 按压鼻翼中点静脉血管丛来止血</li>
</ol></li>
<li>颈
<ol type="1">
<li>静脉出血直接按压</li>
<li>动脉出血理论上向颈椎方向按</li>
</ol></li>
<li>肩: 燕尾式包扎</li>
<li>胸, 背
<ol type="1">
<li>燕尾式包扎</li>
<li>开放式气胸: 在呼气末将塑料膜塞入伤口, 加压包扎</li>
</ol></li>
<li>肠管溢出: 采取仰卧屈膝位 (就是做卷腹运动的准备姿势), 以干净塑料膜或者浸湿的敷料覆盖, 然后用碗盖住, 捆在身上.</li>
<li>上肢
<ol type="1">
<li>大出血: (方法一) 上臂上1/3处用止血带, 绞棒. ❗<strong>记得标注时间</strong>, 以便每40min放一次血, 放2-3min, 让手臂不会因为长时间不过血受伤, 甚至坏死.<br>
(方法二)按压上臂中点 (肱动脉), 如果是手指创伤, 按压指根两侧.</li>
<li>骨折: 若是关节骨折, 以肢体为夹板. 夹板需要长过该骨. 💡悬臂带需要包住肘而露出手指.</li>
<li>包扎方法: 肢体八字. 螺旋, 螺旋反转 (适用于无弹性绷带), 关节八字. 包扎好后, 如果没有用到止血带, 需要检查一下血液循环: 按压指尖, 两秒内恢复; 在皮肤上划动测试知觉; 测试活动能力</li>
</ol></li>
<li>下肢
<ol type="1">
<li>腿部大出血, 在大腿中上部扎止血带</li>
<li>若大腿骨折, 夹板需要过脚, 腰. 或者用<strong>健肢固定法</strong>: 在骨折处上下, 小腿, 脚踝处固定, 两腿间加衬垫.</li>
</ol></li>
</ol>
<p>💡tips - 心率过快时考虑有内出血; 外观失血不多但是有休克症状考虑有内出血; 左右上腹受创时考虑肝, 脾包膜内出血, 不可轻易移动, 否则容易变为外出血; 臀部受创时考虑骨盆内出血. - 深伤口不宜包扎. - 呼吸困难时采取半卧位 (就是屈膝斜坐着). - 休克时将下肢抬高, 让脚高于心脏. - 不可以给大量出血者喝水, 否则伤员的水盐平衡会失衡, 容易导致内脏抽搐. 另外这样也不利于麻醉, 因为麻醉要求空腹. 如果一定要喝水, 用淡盐水涂唇. - 断肢的保存: 将断肢放入干净的塑料袋, 用毛巾包住, 外面套一个塑料袋, 然后放入一个放有冰块的塑料袋.</p>
<h3 id="其他">其他</h3>
<h4 id="复苏体位">复苏体位</h4>
<p>将伤病员置于复苏体位是为了防止因气道堵塞导致窒息. 有两种原因可能导致气道阻塞: 机械阻塞 (大部分情况是由于伤员失去意识而失去对舌头的控制, 舌头后坠至咽后部), 液体阻塞 (胃里出来的呕吐物之类)</p>
<p>💡打呼噜也是舌头后坠导致的</p>
<p>目前比较受认可的复苏体位有两种: 侧卧体位和HAINES体位. 要点是要将头微微后仰, 如此保证打开气道. HAINES体位和侧卧体位的操作方法类似, 区别在于可能有脊柱损失时HAINES体位比侧卧体位更安全. (但这个体位没有侧卧体位舒服)</p>
<p><embed src="初级急救员笔记/侧卧体位.png?50"></p>
<p><embed src="初级急救员笔记/HAINES体位.jpg?80"></p>
<h4 id="误食强酸强碱">误食强酸/强碱</h4>
<p>喝下大量强酸/强碱不宜利用中和反应中和 (会大量放热) 或者催吐 (伤害食道), 应<strong>服用大量蛋白质</strong>.</p>
<h4 id="烫伤">烫伤</h4>
<p>烫伤后应用流动凉水冲洗. 不要弄破烫伤导致的水泡, 普通烫伤的水泡第三天起为吸收期, 7-8天恢复.</p>
<h4 id="脑卒中">脑卒中</h4>
<p>脑卒中, 即中风, 是由于脑部血管突然破裂或因血管阻塞导致血液不能流入大脑而引起脑组织损伤的一组疾病, 根据是血管破裂还是血管阻塞导致的分为出血性脑卒中和缺血性脑卒中. 其中缺血性脑卒中发病率更高, 出血性脑卒中死亡率更高. 面对脑卒中牢记<strong>FAST原则</strong>:</p>
<p><embed src="初级急救员笔记/FAST原则.png?65"></p>
<p>❗ 禁食, 水</p>
<h4 id="淹溺">淹溺</h4>
<p>抢救上岸后以干毛巾由远心端向近心端摩擦, 促进血液循环.</p>
<p>❗ 溺水导致的心脏停搏在进行心肺复苏前并<strong>不需要排出伤员呛的水</strong>, 这样做甚至可能导致肺炎. 这些水都在胃里, 很少会进到肺里.</p>
<h4 id="动物咬伤">动物咬伤</h4>
<p>被动物咬伤后应立即用肥皂水/盐水/清水冲洗15min, 然后马上去就医.</p>
<h4 id="地震">地震</h4>
<ol type="1">
<li>能在12秒内跑出就尽量跑.</li>
<li>不管如何要保护好头部.</li>
<li>中国提倡三角空间而日本不提倡三角空间. 因为中国大多数房子中有预制板, 房子垮塌时要掉也是大块的, 而在日本只会掉小件.</li>
<li>不要站在围墙下.</li>
<li>不要站在天花板有东西的墙沿.</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>健康</category>
      </categories>
  </entry>
  <entry>
    <title>LaTeX杂记</title>
    <url>/zh-CN/2021/05/24/LaTeX%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<p>最近在用LaTeX写毕业论文 (学院支持甚至提供了LaTeX模板真是太幸运了), 在此记录下我写论文用到的一些语法方便以后抄.</p>
<a id="more"></a>
<p>为了专注一个主题, 我只想在这里记录一些我可能用到的语法 (要是你只是想写一份精美本科毕设论文的话也不用管太多). 想更系统更详细了解LaTeX的话, 我推荐下列三个详细程度递减的教程:</p>
<ul>
<li><a href="http://mirrors.ctan.org/info/lshort/chinese/lshort-zh-cn.pdf" target="_blank" rel="noopener">一份不太简短的LaTeX2ε介绍 (lshot中文版)</a>: 这是一份比较详细的入门教程的中文翻译版, 看完会解开许多初学时可能会有的疑惑, 比如它甚至列出了一些写LaTeX时可能用到或生成的文件类型都是什么用途. 网上各种中文LeTaX资料的名词翻译很不统一, 可以以这份教程的翻译为准. 这份lshort中文版其实不是单纯的翻译, 还增添了涉及中文使用的内容, 这无疑是十分有用的 (对于以后可能要写中文论文的我)</li>
<li><a href="https://github.com/wklchris/Note-by-LaTeX" target="_blank" rel="noopener">简单粗暴LaTeX</a>: 这份入门教材比上面这个短许多, 因为它更注重实用性内容, 讲解相对更少. 但对于在有模板的情况下写本科毕业论文的需求仍然是妥妥够用的. 而且因为这本书给出了源代码, 你甚至可以看看作者到底是怎么用LaTeX的 (如果你有那个闲心的话)</li>
<li><a href="https://www.overleaf.com/learn" target="_blank" rel="noopener">Overleaf的LaTeX文档</a>: Overleaf的文档更是讲解很少, 基本每个内容直接是使用示例.</li>
<li>要是你还想看更多内容, 可以先看看<a href="https://www.latexstudio.net/archives/51802.html" target="_blank" rel="noopener">LaTeX工作室推荐的资料</a>.</li>
</ul>
<p>另外推荐一个<a href="http://latexref.xyz/" target="_blank" rel="noopener">LaTeX命令参考手册</a>, 可以在这搜索想查的命令.</p>
<h2 id="给我用overleafvscode写">给我用Overleaf/VSCode写</h2>
<p>我是在Linux系统下用安装了<a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop" target="_blank" rel="noopener">LaTeX Workshop</a>插件的VSCode写的LaTeX, 这个插件通过调用你安装的LeTaX发行版来提供丰富的LeTaX支持. 我使用的发行版正是LaTeX Workshop最推荐的<a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">Tex Live</a>. 这东西的离线安装包有点大, 而且很有可能需要单独下一些包, 有点麻烦. 幸好我Manjaro系统一句<code>yay -S texlive-most texlive-lang biber</code>就把我下面需要用到的所有工具都安装好了. <strong>如果你目前没有安装Tex Live, 不妨先试试在<a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a>在线编辑LaTeX试试, 操作很简便, 下述操作中除了<a href="#术语表">术语表</a>处我的方案需要额外工具<code>bib2gls</code>Overleaf上没有外都支持, 非常省事.</strong> 比本地编辑器好的一点是Overleaf开箱即用地支持多人在线协作.</p>
<p>只要你不是要写上百页的论文, Overleaf绝对是够用的, 但反正Manjaro上Tex Live下着很容易, 而且我又喜欢折腾, 我就试着本地写LaTeX. 试了一圈后<strong>我只推荐用VSCode当本地编辑器</strong>. 那些LaTeX专用编辑器看网上说法体验起来功能并没有比Overleaf多什么, 而且很丑 (我已经搜的是这些软件最新版的截图了)... 而用VSCode就不一样了, 如果你熟悉VSCode你就应当知道VSCode能做到非常高度的自定义 (补全, 代码段, 语法检查, 拼写检查, 皮肤等), 而且因为VCSode是基于Chromium开发的因此天然支持内置浏览pdf. 相比<code>vim + Okular</code>这样的尴尬方案, VSCode的LaTeX Workshop插件使得在VSCode中的LaTeX与pdf的正反向搜索 (正向搜索就是在生成的pdf中搜索指定LaTeX源代码对应的内容, 反向搜索就是反过来) 精度非常高, 比起<code>vim + Okular</code>方案只能精准到对应行, VSCode能精准到单词! 此外LaTeX Workshop也提供了许多贴心的功能, 比如可以很容易地自己配置编译工具链, 自动格式化并排序bib引用文件等, 支持<a href="https://github.com/James-Yu/LaTeX-Workshop/wiki/View#invert-mode" target="_blank" rel="noopener">pdf反色</a>晚上长时间写LaTeX也不怕泪目...</p>
<p>💡 关于如何安装Tex Live可以看看<a href="https://oi-wiki.org/tools/latex/#_4" target="_blank" rel="noopener">这个说明</a>.</p>
<!-- TODO: 是哪个没法实现最好指出 基本就bib2gls? -->
<h2 id="项目结构">项目结构</h2>
<p>首先是关于这东西从哪开始写. 不了解的话会觉得LaTeX的文件又多语法又乱七八糟, 那么要写个LaTeX的"Hello World"该怎么做? 这个其实很简单:</p>
<ol type="1">
<li><p>创建一个tex文件, 比如<strong>first.tex</strong>: </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\documentclass{article}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line">Hello World</span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>如果你已经正确安装了Tex Live那么环境里应当已经有<code>xelatex</code>这个可以生成tex文件对应pdf的工具了. 在<strong>first.tex</strong>所在文件夹执行<code>xelatex first.tex</code>. 然后你会发现文件夹里多了三个文件: <strong>first.pdf</strong>, <strong>first.aux</strong>, <strong>fisrt.log</strong>. 后两个文件基本是无关紧要的东西, 我在我的VSCode里设置了每次构建后删除这些文件. 而这个<strong>first.pdf</strong>正是我们需要的pdf文件 🎉</p></li>
</ol>
<p>要用LaTeX写一个简单文档需要的语法都很简单没有争议, 需要的工具也只有<code>xelatex</code>. 想快速了解LaTeX最基本的语法可以看看<a href="https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes" target="_blank" rel="noopener">Overleaf的30min入门教程</a>. 不过其实用不了30分钟, 因为只讲了最基础的内容因此大致看一遍了解一下就好😂. 看了一些教程后我觉得Overleaf的文档是非常简短 (因此很不详细) 但足够全面的了, 最重要的是<strong>基本用的都是最新最简洁的语法</strong> (正如现在有些python问题还有人在给出python2的绕来绕去的方案, 随便看网上说法会觉得LaTeX怎么这么麻烦功能这么少 🤦‍♂️). 因此后文的文档参考我也基本是给出的是Overleaf的文档.</p>
<p>大致看了一遍上面链接后就知道怎么用LaTeX写一份用Markdown或者word写也很方便的文档啦. 但要用来写一份高逼格论文的话还需要深入一些, 不然LaTeX的优势也体现不出来了. 首先来看一些绕不开且容易的语法, 然后是各种插入富文本的语法, 最后是关于让引用不管是插入还是看起来体验都更好的内容 (因为需要更改构建工具链这个部分在overleaf无法实现).</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 📁Appendices        各个附录的tex文件文件夹</span><br><span class="line">├── 📁Figures           图片文件夹</span><br><span class="line">├── 📁Front             前置页的tex文件文件夹</span><br><span class="line">├── 📁Sections          各个章节的tex文件文件夹</span><br><span class="line">├── 📑main.tex          根文件</span><br><span class="line">└── 📑References.bib    所有引用的bibtex放这里</span><br></pre></td></tr></tbody></table></figure>
<p>在Overleaf的快速教程中能看到只用一个tex文件就可以写LaTeX了, 但一般见到的论文模板都是多个文件的 (比如我更新的<a href="https://github.com/LeoJhonSong/UESTC-Glasgow-Final-Year-Report-Template/blob/master/README.md" target="_blank" rel="noopener">学院毕设模板</a>), 类似上面☝这样的结构. 将不同内容分别放在不同文件, 不然太长了不方便组织以及查找出错地方. 通常在根目录的<strong>main.tex</strong>被作为根文件 (root file), <strong>只有根文件中有<code>\begin{document}</code></strong>. 通常习惯将各种全局设置, 包的引用, 标题, 作者, 自己定义的新命令, 宏定义等导言 (<a href="https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes#The_preamble_of_a_document" target="_blank" rel="noopener">preamble</a>), 都放在<strong>main.tex</strong>中. 而<code>\begin{document}</code>后的正文内容基本是以<code>\include{}</code>插入在<strong>Front</strong>, <strong>Sections</strong>, <strong>Appendices</strong>中的tex文件, 以及插入目录, 插入图表索引, 插入引用的语句等. 也就是说<strong>main.tex</strong>中没有具体内容, 基本是环境配置, 参数设置, 大纲这样子. 给一个毕设论文的main.tex的大致结构:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\documentclass{article}</span><br><span class="line">% 导言部分 (preamble)</span><br><span class="line">% 一些包的导入, 一些全局设置等</span><br><span class="line">% ...</span><br><span class="line">% 将图表目录, 术语表, 参考文献列表显示在目录中. nottoc参数是不将目录本身显示在目录中</span><br><span class="line">\usepackage[nottoc]{tocbibind}</span><br><span class="line">% 如果想让术语可点击, 需要在导入hyperref包后导入glossaries-extra, 而hyperref包是最好最后导入的.</span><br><span class="line">% 也就是说现在是hyperref倒数第二个导入, glossaries-extra最后导入</span><br><span class="line">\usepackage[symbols, nogroupskip, record]{glossaries-extra}</span><br><span class="line">\GlsXtrLoadResources[</span><br><span class="line"> src={Notations},  % 术语都放在根目录下Notations.bib文件里</span><br><span class="line"> type=symbols,  % put these entries in the 'symbols' glossary (这两句英语注释我抄来的, 懒得管到底什么意思了)</span><br><span class="line"> save-locations=false  % don't save locations</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">% 正文部分 (指大纲)</span><br><span class="line">\begin{document}</span><br><span class="line">\pagestyle{plain}</span><br><span class="line">\include{Front/Cover.tex}</span><br><span class="line"></span><br><span class="line">\pagenumbering{roman}  % 正文前页数页码用罗马数字计数 (如果显示在目录里, 也会是罗马数字页码)</span><br><span class="line">\include{Front/Abstract.tex}</span><br><span class="line">\include{Front/Acknowledgement.tex}</span><br><span class="line">% 一些目录</span><br><span class="line">\tableofcontents  % 目录</span><br><span class="line">% \pagebreak  % 如果图表目录另起一页目录页最后也不会显得空那就另起一页</span><br><span class="line">\listoffigures  % 图目录</span><br><span class="line">\listoftables  % 表目录</span><br><span class="line">\pagebreak  % 另起一页</span><br><span class="line">\printunsrtglossary[type=symbols,style=long,title={List of Notations}]  % 术语表</span><br><span class="line">\pagebreak</span><br><span class="line"></span><br><span class="line">% 这开始是文章内容了</span><br><span class="line">\pagestyle{headings} % 切回正文的页眉页脚格式</span><br><span class="line">\pagenumbering{arabic}  % 这里开始用阿拉伯数字页码</span><br><span class="line">\include{Sections/Section1.tex}</span><br><span class="line">\include{Sections/Section2.tex}</span><br><span class="line">\include{Sections/Section3.tex}</span><br><span class="line">\include{Sections/Section4.tex}</span><br><span class="line">\include{Sections/Section5.tex}</span><br><span class="line">% 参考文献列表</span><br><span class="line">\setcounter{biburllcpenalty}{7000}  % 这两句是为了参考文献列表中跨行的网页链接也能正常使用</span><br><span class="line">\setcounter{biburlucpenalty}{8000}</span><br><span class="line">\printbibliography[heading=bibintoc]</span><br><span class="line">\appendix  % 告诉LaTeX这后面的章节都是附录. 在目录里附录章节就不是12345排序的了, 是ABCD这样大写字母顺序的</span><br><span class="line">\include{Appendices/Appendix.tex}</span><br><span class="line">\end{document}</span><br><span class="line">% 这后面即便有内容也会被忽略</span><br></pre></td></tr></tbody></table></figure>
<div class="note info">
            <p>如果有看不懂到底怎么操作的地方, 可以看看我搓的<a href="https://github.com/LeoJhonSong/UESTC-Glasgow-Final-Year-Report-Template" target="_blank" rel="noopener">学院毕业论文的完整模板</a></p>
          </div>
<p>💡 也有的模板是单独将导言放在一个文件, 根文件中则只有正文. 到底怎么分割文件其实都可以, 最重要的是要<strong>能让自己分清哪部分是导言</strong>. 具体正文中引用哪些包, 配置什么全局参数会出问题我没有一一试过, 但文档推荐放在导言部分的语句就尽量听文档的, 免得出问题 👍</p>
<ul>
<li>插入tex文件内容可以用<code>\include{}</code>或者<code>\input{}</code>, 区别在于<code>\include{}</code>会另起一页再插入内容, 如果刚好一个文件放一章的话, 那每章开头都会另起一页 (看着会比较多).</li>
<li><code>\pagestyle{}</code>是用来设置页眉页脚样式的. 在<a href="https://www.overleaf.com/learn/latex/Headers_and_footers#Setting_page_style_for_current_page_only" target="_blank" rel="noopener">Overleaf的页眉页脚文档</a>中可以看到<code>plain</code>样式是没有页眉, 有显示页码的页脚. 因为我<strong>Cover.tex</strong>中的内容包含在<code>titlepage</code>环境中, 所以不显示页码. 之所以把<code>\pagenumbering{roman}</code>放在插入封面页后面是因为要是调换顺序, 封面页还是不会显示页码, 摘要页页码则是<strong>ii</strong>, <strong>i</strong>页就消失了. 我这种写法目录页, 图表目录和术语表也会有罗马数字页码, 不想要的话可以在这几页前设置<code>\pagestyle{empty}</code>, 就什么页眉页脚都没有了.</li>
</ul>
<h3 id="术语表">术语表</h3>
<div>
<img style="width:40%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/notation.jpg">
</div>
<p>论文中有很多专业名词/缩写/符号的话可以放一个术语表在前头, 类似上面☝这样, 在这个表上也可以反向列出这些词都在哪里出现过. 在术语表的实现上<a href="https://www.overleaf.com/learn/latex/Glossaries#Compiling_the_glossary" target="_blank" rel="noopener">overleaf给出的方案</a>只是最基础的方式, 这里有个<a href="http://mirror.ctan.org/macros/latex/contrib/glossaries/glossaries-user.html#tab:options" target="_blank" rel="noopener">术语表实现方案比较表</a>, 不过对比得比较细节. 大意就是用<code>bib2gls</code>的方案除了需要额外安装<code>bib2gls</code>和java的缺点全是优点. 而这两个东西一点都不难安: <code>bib2gls</code>似乎并不需要额外安装, 至少我这安装了<em>texlive-most</em>后就已经有了. 而Java, 至少在Linux系统上, 网上随便一搜就一堆教程, 基本也就是几句命令的事. 从上图我的示例可以看出这个方案生成的术语表可以很好的排序混杂有希腊字母以及下标的各种术语, 而且用一个单独的bib文件管理所有术语, 只有文章里实际用到的术语才会列在术语表里, 很省心.</p>
<p>安好了<code>bib2gls</code>和java, 如果你是用VSCode来编辑LaTeX的, 那事情很简单. 打开VSCode的用户级配置json, 然后把LaTeX Workshop的编译工具链方案配置改成这个 (反正默认配置json里还有默认配置, 别担心):</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"xelatex ➞ bib2gls ➞ biber ➞ xelatex"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="string">"bib2gls"</span>,</span><br><span class="line">            <span class="string">"biber"</span>,</span><br><span class="line">            <span class="string">"xelatex"</span></span><br><span class="line">        ]</span><br><span class="line">    },</span><br><span class="line">],</span><br></pre></td></tr></tbody></table></figure>
<p>等你重启VSCode后你会发现LaTeX Workshop插件的面板里<strong>Build LaTeX project</strong>一栏里就只有<em>xelatex ➞ bib2gls ➞ biber ➞ xelatex</em>这一个方案了 😏 这样一来就配置好了, 接下来只需要想上面的模板一样导入<strong><em>glossaries-extra</em></strong>包, 在自己的术语表bib文件中加点术语, 就可以在正文中用<code>\gls{}</code>来插入术语了! 具体例子看<a href="https://tex.stackexchange.com/a/366282" target="_blank" rel="noopener">这个回答</a>的<strong>Method 4</strong> (得往下翻翻).</p>
<p>💡 之所以要调用两次<strong>xelatex</strong>是因为文中对图表的引用, 术语表的引用等交叉引用第一次编译只会生成在辅助文件 (aux) 中, 第二次编译才会生成完整的文章. <strong>biber</strong>是干嘛用的<a href="#引用">后文</a>会说到.</p>
<h2 id="版式">版式</h2>
<p>在<code>main.tex</code>最开头:</p>
<p>💡 方括号中为可选参数, 我只是列出我觉得比较有用的参数, 按需添加.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\documentclass[</span><br><span class="line">    12pt,  % 设置字号为12pt. 默认字号为10pt, 但好像一般都要求12pt</span><br><span class="line">    twoside,  % 设置双开页. article和report默认为单页</span><br><span class="line">    twocolumn,  % 设置为全文双栏排版. 默认为单栏. 使用multicols环境更好用, 可以设置多栏</span><br><span class="line">    showframe,  % 用线框可视化显示当前布局各边距大小</span><br><span class="line">    draft  % 指定为草稿模式, 会进行简化使生成更快, 在断行不良/溢出出加黑色方块给出提示. 默认为final (终稿模式)</span><br><span class="line">]{article}  % 设置文档类型为article (常规文档), 可能的文档类型还有report (较长的报告, 如博士论文, 技术报告等), book等</span><br><span class="line"></span><br><span class="line">\usepackage[</span><br><span class="line">    a4paper,  % 纸张大小在\documentclass的参数中也可以设置, 但在这统一管理尺寸问题比较省事. 默认大小为美式信纸 (letterpaper)</span><br><span class="line">    inner=2.5cm,</span><br><span class="line">    outer=2cm,</span><br><span class="line">    top=2cm,  % 上边距</span><br><span class="line">    bottom=2cm  % 下边距</span><br><span class="line">]{geometry}  % 使用geometry这个包设置更具体的页面大小和页边距</span><br><span class="line"></span><br><span class="line">% 将行间距设置为1.5倍 (显得多一些)</span><br><span class="line">\usepackage{setspace}</span><br><span class="line">\onehalfspacing{}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="布局页边距设置">布局/页边距设置</h3>
<p><a href="https://www.overleaf.com/learn/latex/Page_size_and_margins" target="_blank" rel="noopener">Overleaf相关文档</a></p>
<p>因为我的本科毕业论文是要打印的 (但最后也没打印555), 我就设置了<strong>双开页</strong>, 作用在于页面会有左右之分了. 比如我们学院要求内侧页边距2.5cm, 外侧页边距2cm, 那么左边这页的左页边距为2cm, 右页边距为2.5cm, 而右边这页的左页边距为2.5cm, 右页边距为2cm. 之所以内侧页边距多一些是给装订留一些出血 (就是会被装订得看不到的余地). 使用<code>showframe</code>这个选项的话生成的pdf会以线框的形式可视化显示到底布局是怎样的, 就能很明心啊看出左右两页不一样了. 另外页眉页脚位置, 页码位置也会是左右对称的, 如果你设置了显示这些的话.</p>
<h3 id="字体及中文支持">字体及中文支持</h3>
<p>全文的字体大小在<code>\documentclass[]{}</code>的参数中指定, 基本就用12pt. 在此处指定字体大小后文中想改变字体大小实际是通过<code>\large</code>, <code>\small</code>这样的命令给出的, 并不使用具体字号. 关于字体大小更多的设定我暂时没有研究过.</p>
<p>实际上想用latex文件生成pdf有好几个编译器可以用, 最常被提到且速度最快的是<code>pdflatex</code>, 但pdflatex对UTF-8支持不够好, 对现代字体支持也不够好, 而且可能因为我的文档页数不够多, 我真没体验出速度有什么差别. <code>xelatex</code>对特殊字符及现代字体支持很好, 对中文兼容也很好, 因此目前我更偏向使用xelatex. 这个编译器生成的pdf文件会比pdflatex无参数生成的小不少, 因为它默认会进行无损压缩.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\usepackage{fontspec}</span><br><span class="line">\setromanfont{Times New Roman}  % 指定普通字体</span><br><span class="line">\setsansfont{Arial}  % 指定无衬线字体</span><br><span class="line">\setmonofont{Courier New}  % 指定等宽字体</span><br><span class="line">\usepackage{xeCJK}  % 中文支持</span><br></pre></td></tr></tbody></table></figure>
<p>当使用<code>xelatex</code>作为编译器时可以使用<strong><em>fontspec</em></strong>包来指定字体. 更详细的指定方式参见<a href="https://es.overleaf.com/learn/latex/XeLaTeX" target="_blank" rel="noopener">Overleaf的文档</a>. 不过虽然我们学院的论文格式要求也对字体提出了要求, 但所要求的<strong>Times New Roman</strong>, <strong>Arial</strong>这几个字体其实都是Windows系统专有的. 我的Manjaro系统虽然也有替代字体, 但是我感觉默认字体看着也挺好而且老师其实没管所以就没折腾. 实际写作我并没有主动使用过切换字体的命令, 暂时感觉用不到.</p>
<p>当设置好全文字体大小及字体后, 在文中想设置文字的样式, 比如加粗/斜体/下划线/小型大写字母, 或者大点/小点的, 用到的命令<a href="https://www.overleaf.com/learn/latex/Font_sizes%2C_families%2C_and_styles#Reference_guide" target="_blank" rel="noopener">这里</a>有一个列表可查. 注意变更样式的部分用大括号括起来, 不然后面所有字符的样式都会维持这样.</p>
<h3 id="两个常见问题">两个常见问题</h3>
<h4 id="如何创建能在目录中显示的四级标题">如何创建能在目录中显示的四级标题</h4>
<p>LaTeX原生提供了7级标题:</p>
<ul>
<li><strong>-1</strong> <code>\part{}</code> (只有report和book类型文档中可用)</li>
<li><strong>0</strong> <code>\chapter{}</code> (只有report和book类型文档中可用)</li>
<li><strong>1</strong> <code>\section{}</code></li>
<li><strong>2</strong> <code>\subsection{}</code></li>
<li><strong>3</strong> <code>\subsubsection{}</code></li>
<li><strong>4</strong> <code>\paragraph{}</code></li>
<li><strong>5</strong> <code>\subparagraph{}</code></li>
</ul>
<p>💡如果刻意不想让某一章节/子章节之类出现在标题中, 那就用<code>\section*{}</code>, <code>\subsection*{}</code>这样带星号的.</p>
<p><code>\paragraph{}</code>和<code>\subparagraph{}</code>无法被显示在目录中, 在文中看着也不太像是标题, 更像加粗的正文. 下图中<strong>test 1</strong>为<code>\paragraph{}</code>, <strong>test 2</strong>为<code>\subparagraph{}</code>, <strong>test 3</strong>为<code>\subsubsection{}</code>.</p>
<div>
<img style="width:80%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/sections.jpg">
</div>
<p>因此真要说的话在article这种文档类型中LaTeX原生提供的标题只有三级. 要是写短篇论文的话确实也不需要更小的标题了, 但是记个笔记之类还是有可能需要更多级的标题. <a href="https://tex.stackexchange.com/questions/60209/how-to-add-an-extra-level-of-sections-with-headings-below-subsubsection" target="_blank" rel="noopener">这个stackoverflow问题</a>有给出一些解决方案.</p>
<h4 id="underfull和overfull警告是什么">underfull和overfull警告是什么</h4>
<p>这两种警告是在编译后非常常见的警告, 意味着编译器在这一行找不到合适的换行的地方, 导致这一行在文字框限制内排版出来要不是太空了 (underfull) 要不就是太挤了 (overfull). 也就是说这基本是英文这样的字母语言才会遇到的问题. Overleaf<a href="https://www.overleaf.com/learn/how-to/Understanding_underfull_and_overfull_box_warnings" target="_blank" rel="noopener">这篇文章</a>很详细讲了原因, 但几乎没给处理办法. 💡 要注意其中提到的<strong><em>microtype</em></strong>包xelatex<a href="https://tex.stackexchange.com/questions/118713/is-microtype-fully-supported-now-by-xelatex-if-not-how-can-i-keep-myself-up-to" target="_blank" rel="noopener">目前几乎不支持</a>, 但我感觉我就用默认排版工具生成的pdf排版也还挺好的? 以下是一些关于断行的小技巧.</p>
<h5 id="断词与不要断词">断词与不要断词</h5>
<p>实际上遇到行末长单词干扰LaTeX排版的时候LaTeX会自动按音节将这个长单词断词, 在行末留个<code>-</code>. 不过有时会想要指定一些单词的断词位置, 有两种方式: 1. 在正文中通过加入<code>\-</code>允许在此处断词. 可以指定多处允许断词的地方, 然后LaTeX会选择其中一个位置来断词: </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">what a phen\-omen\-on.</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol start="2" type="1">
<li>在导言部分用<code>\hyphenation{}</code>指定一组词的断词位置. 同样, 需要断词时LaTeX会从指定的几个位置之一断词. 💡注意这些词是大小写不敏感的: <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\hyphenation{hy-phe-n-a-tion t-est}  % 指定hyphenation和test的断词位置</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>而有时甚至会不想这个词断掉, 还是有两种方式: 1. 在正文中用<code>\mbox{}</code>强制一串字符不被断开: </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">KFC phone number is \mbox{400 823 823}</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol start="2" type="1">
<li>其实<code>\hyphenation{}</code>也可以用来指定一组禁止被断词的单词. 只要不给出断词位置, 就会被认为不能断词: <figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\hyphenation{hyphenation python}  % 指定hyphenation和python不能被断开</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h5 id="空格">空格</h5>
<p>看教程前我其实是没注意到的, LaTeX排版出的空格竟然有这么些细小区别...</p>
<ul>
<li>在LaTeX中多个空格会被当成一个空格 (多个回车也只会产生到下一段的效果). 想用word那样的空格魔法或者回车魔法的话用<code>\hspace{len}</code>和<code>\vspace{len}</code> 😏.</li>
<li><strong>带子</strong> (tie) <code>~</code>. 在两个单词间加<code>~</code>而不是空格能产生一个不会被断行的空格. 一般用在人名之类的地方.</li>
<li>句末标点 (<strong>小写字母</strong>后的./?/!) 后的空格会比普通空格长一些. 之所以强调是小写字母后的, 是因为以大写字母结尾会被LaTeX认为最后这个词是人名因而不加长空格. 此时 (如果你真在意这个的话) 用<code>\@</code>手动指明. 你会发现下面这个图里<code>OK.</code>后的空格长度确实有区别, 但区别非常小: <img style="width:80%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/space.jpg"> 另一种情况则是非句末标点被识别为句末标点了, 比如"Prof. Smith". 此时可以用<code>~</code>或者<code>\</code> (👈 注意\后面有个空格)来缩短间距. 不过<code>~</code>不允许空格处断行而<code>\</code>允许.</li>
<li>还有时会看到<code>\Tex{} Live</code>或<code>\Tex\ Live</code>这样明明不支持参数的命令 (如<code>\Tex</code>) 后却有{}或者<code>\</code>, 这是为了让不支持参数的命令后的空格能被正常排版.</li>
</ul>
<h5 id="手动断行">手动断行</h5>
<p>用<code>\\</code>可以在段落内手动换行. 但不同于在word中到处用回车, <a href="https://www.overleaf.com/learn/how-to/Understanding_underfull_and_overfull_box_warnings?#Notes_on_using_.5C.5C" target="_blank" rel="noopener">无脑<code>\\</code>似乎是不被推荐的</a>. 在上文中推荐的<em>一份不太简短的LaTeX2ε介绍</em>中<strong>2.4.2 手动断行和断页</strong>这节有提到几种断行命令的具体区别 (但我感觉没必要管就没看).</p>
<h2 id="超链接">超链接</h2>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\usepackage[svgnames]{xcolor}  % colouring</span><br><span class="line">\definecolor{bleu_cite}{RGB}{34,111,212}</span><br><span class="line"></span><br><span class="line">\usepackage{hyperref}  % 这个包的导入最好放在导言区最后</span><br><span class="line">\hypersetup{</span><br><span class="line">    colorlinks=true,</span><br><span class="line">    linkcolor=LightSlateGray,  % 默认值red</span><br><span class="line">    citecolor=bleu_cite,  % 默认值green</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这年代写论文超链接肯定得有, 不然逼格不太够. 导入了<strong><em>hyperref</em></strong>这个包, 目录, 参考文献引用, 图表的交叉引用, 网页链接等才会具有超链接的特性. 上面是我的配置. 导入<strong><em>xcolor</em></strong>包可以用<code>\definecolor{}</code>命令自定义一些颜色, 带参数的话也可以使用<strong><em>xcolor</em></strong>提供的很多种颜色, 比如上面用的<code>svgnames</code>这个颜色集里有<code>LightSlateGray</code>. 我基本就用这个颜色集, 下图列出了<em>svgnames</em>提供的所有颜色. 这里的<em>linkcolor</em>指的不是网页链接的颜色, 是页内链接的, 比如目录, 术语到术语表的跳转链接等. 网页链接的颜色值对应的是<em>urlcolor</em>, 默认颜色是品红色, 还挺好看的, 我就没改. 正如在有的论文中见到的那样, 超链接也可以改成带颜色框的样式, 操作方式参考<a href="https://tex.stackexchange.com/questions/50747/options-for-appearance-of-links-in-hyperref" target="_blank" rel="noopener">这个回答</a>.</p>
<div>
<p><img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/color1.jpg"> <img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/color2.jpg"></p>
</div>
<h2 id="加速生成">加速生成</h2>
<h3 id="草稿模式">草稿模式</h3>
<p>随着工程大起来生成pdf会变慢, 有一些技巧可以加速生成不完整的pdf, 在写作过程中快速检查. 因为LaTeX每次生成并不能利用.</p>
<p>一种方式是开启草稿模式. 方式是在上面提到的<code>\documentclass[]{}</code>的参数里加个<code>draft</code>. 以草稿模式生成的pdf里图片不会实际插入, 是用一个同样大小的方框来表示. 超链接, 书签等功能也会被关闭. 另外比较好的一点是在underfull/overfull的行会被在行末添加一个黑色方块标记出来.</p>
<h3 id="xelatex的pdf压缩等级">xelatex的pdf压缩等级</h3>
<p>xelatex在生成pdf时默认会进行压缩, 这会让生成的pdf相对很小, 同时也会耗时更长. 写作过程中其实并没有必要压缩pdf, 那可以设置压缩等级为0加速pdf生成, 等生成最终版pdf时再把压缩等级拉满设为9.</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">% 放在导言部分</span><br><span class="line">\special{dvipdfmx:config z 0}  % 👈这个0换成9就是最大压缩等级了.</span><br></pre></td></tr></tbody></table></figure>
<h2 id="插入">插入</h2>
<h3 id="数学公式-样式">数学公式, 样式</h3>
<p>这个CSDN上的<a href="https://blog.csdn.net/ethmery/article/details/50670297" target="_blank" rel="noopener">LaTeX基本数学公式语法</a>列出了希腊字母, 上下标, 矢量, 特殊符号, 矩阵等数学公式常用命令, 还挺全的.</p>
<p>作为一个菜鸟我还没用LaTeX写过很复杂的公式, 因此还没有用过<strong><em>amsmath</em></strong>这个增强<a href="https://www.overleaf.com/learn/latex/Aligning%20equations%20with%20amsmath" target="_blank" rel="noopener">公式排版</a>的包, 但据overleaf这篇文章原生支持对排版支持不够好, 因此我先码住.</p>
<p>然后这还有一篇Overleaf的<a href="https://www.overleaf.com/learn/latex/Mathematics" target="_blank" rel="noopener">数学相关内容合集</a> 🐮</p>
<h3 id="浮动体">浮动体</h3>
<p>figure和table是LaTeX原生的两种浮动体环境, 用于灵活排版图片和表格, 并且为图表标题 (caption) 提供环境 (就是说即便不放在浮动体里也可以将图片表格插入LaTeX). 而且其实这两种环境中什么都能放, 没有限定只能放图片或表格. 这两种环境都可以给[<em>placement</em>]参数 (默认是<code>btp</code>), 通过指定<code>htb</code>限制只能放在这三种位置 (也就是不允许单独成页). 可用参数参见<a href="https://www.overleaf.com/learn/latex/Inserting_Images#Positioning" target="_blank" rel="noopener">这附近有的一个表格</a>. 值得一提的是LaTeX总是以h-t-b-p的优先级来决定浮动体位置, 和填的参数的顺序无关. 💡 除单独成页外, 默认每页不超过3个浮动体, 其中顶部不超过2个, 底部不超过1个以及浮动体空间占页面的百分比 (默认顶部不超过70%, 底部不超过30%)</p>
<p>关于双栏环境下浮动体的排版以及其他细节见<em>一份不太简短的LaTeX2ε介绍</em>的<strong>3.9 浮动体</strong>.</p>
<h4 id="图片">图片</h4>
<p>先上一个论文利用的懒人模板样例 (效果如图):</p>
<div>
<img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/figure.jpg">
</div>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">% 导言部分</span><br><span class="line">\usepackage{graphicx}  % 图片插入支持宏包</span><br><span class="line">\graphicspath{{./}}  % 将之后插入图片的检索路径设为根文件所在目录, 不然插入图片时的图片地址是相对于当前tex文件的, 会比较麻烦</span><br><span class="line">% \graphicspath{{./Figures}}  % 其实更常见的是直接将检索路径设为你的图片文件夹, 但我为了能触发我VSC的路径补全所以只设成了根文件所在目录</span><br><span class="line">\usepackage[</span><br><span class="line">   colorlinks=true,</span><br><span class="line">]{hyperref}  % 给交叉引用的引用编号添加超链接支持</span><br><span class="line"></span><br><span class="line">% 正文部分</span><br><span class="line">\begin{figure}[htb]</span><br><span class="line">      \centering  % 让图片居中. 默认是左对齐</span><br><span class="line">      \includegraphics[width=0.8\textwidth]{Figures/mesh.jpg}  % 限制图片宽度为0.8倍版面宽度</span><br><span class="line">      \caption[Test]{Test: blablabla}\label{f:mesh}</span><br><span class="line">\end{figure}</span><br><span class="line"></span><br><span class="line">As you can see in \autoref{f:mesh}, the function grows near 0.</span><br></pre></td></tr></tbody></table></figure>
<p>用<code>\caption</code>命令可以给图片等浮动体加标题, 在<code>{}</code>中的是长标题, 就是显示在图下那个. 而在<code>[]</code>中的短标题是会显示在图目录中的标题 (用<code>\listoffigures</code>来生成图目录). 我习惯在长标题里开头用短标题, 能实现很多论文里<strong>概要: 详细描述</strong>的图标题形式.</p>
<p><code>\lable</code>是交叉引用, 可以用来在文中提及章节/公式/图表等. 导入<strong><em>hyperref</em></strong>包能支持点击引用处跳转, 这样体验才够良好. 用<code>\autoref</code>而不是<code>\ref</code>能让整个引用编号 (比如上面的红色的<strong>Figure 1</strong>)而不是只有<strong>1</strong>是超链接. <code>\ref{}</code>或者<code>\autoref{}</code>的参数可以随便写, 之所以加个<code>f:</code>的前缀是为了将图片, 表格等类交叉引用区别开, 方便管理, 比如说VSC的LaTeX Workshop支持交叉引用的补全提示.</p>
<p>细节解释可以参考这几个链接: - <a href="https://www.overleaf.com/learn/latex/Inserting_Images#Generating_high-res_and_low-res_images" target="_blank" rel="noopener">Overleaf的插入图片全教程</a> - <a href="https://tex.stackexchange.com/questions/24496/use-caption-and-long-description-for-figure/422496" target="_blank" rel="noopener">如何添加图片短标题</a> - <a href="https://tex.stackexchange.com/a/53062" target="_blank" rel="noopener">如何在表格中插入图片</a> - <a href="https://tex.stackexchange.com/questions/101645/how-to-turn-latex-figure-by-90-degrees-along-with-the-caption" target="_blank" rel="noopener">如何旋转图片</a></p>
<p>还有一点是如何插入矢量图形. 目前所有LaTeX编译器都没有对svg提供原生支持, 倒是<a href="https://tex.stackexchange.com/questions/2099/how-to-include-svg-diagrams-in-latex" target="_blank" rel="noopener">有办法可以强行插入svg</a>, 但是也很麻烦. 其实解决办法很简单: <strong>不要插入svg</strong> 😁 svg可以很容易地被转为pdf, 而LaTeX对pdf插入支持很好 (其实现在这年代LaTeX中插入矢量图片就是插入pdf). 在Linux下可以用<strong>inkscape</strong>打开svg然后直接另存为pdf. ❗注意不要勾选<em>Omit text in PDF and create LaTeX file</em>. 这狗屎东西会把你svg里的文字无脑转为LaTeX然后你会发现你好不容易排版的文字在LaTeX里绘制出来后大小, 字体都是正文字体, 经常直接没法看. 直接转为pdf的话会生成一个和svg同样尺寸的pdf, 透明部分会被填充为白色, 不过写论文的话这样刚好.</p>
<p>关于制作论文用矢量图, 因为我目前并不需要绘制复杂的矢量图, 基本是给位图或者程序生成的矢量图加点箭头文字然后排版一下之类. 因此我目前就是PPT做图, 全选当前页上所有东西 (如果你也是一页PPT画一张图的话), 然后另存为svg, 免得想在其他电脑/WPS编辑时发现不太兼容 (更保险一点你可以<a href="https://support.microsoft.com/zh-cn/office/%E5%B5%8C%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%9A%84%E5%A5%BD%E5%A4%84-cb3982aa-ea76-4323-b008-86670f222dbc" target="_blank" rel="noopener">将字体嵌入PPT</a>, 防止出字体问题). 如果你做的这张图用到了PPT的背景, 存svg是没法把背景一块存下来的. 此样的话选打印, 然后选仅打印当前页, 这样就能获得一个单页的pdf矢量图了!</p>
<h4 id="表格">表格</h4>
<p>同样先上个懒人模板: </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">% 导言部分</span><br><span class="line">\usepackage{tabularx}  % 表格插入支持宏包</span><br><span class="line">\usepackage{booktabs}  % 好像只是拿来画分隔线的</span><br><span class="line"></span><br><span class="line">% 正文部分</span><br><span class="line">\begin{table}[htb]</span><br><span class="line">    \renewcommand*{\arraystretch}{1.3}  % 增大一点行间距让表格不那么紧凑</span><br><span class="line">    \centering</span><br><span class="line">    \caption[Short Title]{Short Title: long description}\label{t:table_test}</span><br><span class="line">    \begin{tabularx}{0.6\textwidth}{Xcc}</span><br><span class="line">        \toprule</span><br><span class="line">        title1 &amp; title2 &amp; title3 \\</span><br><span class="line">        \midrule</span><br><span class="line">        experiment 1 &amp; item 11 &amp; item 12 \\</span><br><span class="line">        experiment 2  &amp; item 21  &amp; item 22 \\</span><br><span class="line">        \bottomrule</span><br><span class="line">    \end{tabularx}</span><br><span class="line">\end{table}</span><br></pre></td></tr></tbody></table></figure><p></p>
<div>
<img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/table.jpg">
</div>
<p>图中前一个表格是上面的模板的效果, 后一个表格是没有增大行间距的表格的效果. 插入表格有几种环境可用, <code>tabularx</code>这个环境是允许指定整个表的宽度和每列的对齐方式后自动计算每列宽度, 我觉得比<code>tabular</code>环境更智能省心. <code>tabularx</code>环境接受两个参数, 前一个是整个表格的宽度, 后一个是每列的对齐方式. <code>X</code>和<code>l</code>都是左对齐, 但<code>X</code>会让这列的列宽更宽, 让内容能占满整个表格. 比如上图前面的表格第一列就是<code>X</code>而后一个表格第一列是<code>l</code>, 就只有刚好适应单元格内容的列宽. 从单元格的侧边框可以看出最后一列确实是居中对齐, 但因为LaTeX是从左到右排版表格的, 因此多了些空余... <code>c</code>和<code>r</code>则是适应单元格宽度的居中对齐和右对齐. 想要智能宽度的居中对齐和右对齐的话用<code>&gt;{\centering\arraybackslash}X</code>和<code>&gt;{\raggedleft\arraybackslash}X</code> (没错这一长串和<code>l</code>一样往里填)</p>
<p><code>&amp;</code>用来分隔一行中的单元格, <code>\\</code>表示一行的末尾. <strong><em>booktabs</em></strong>这个包里好像只有一些分隔线, <code>\toprule</code>, <code>\midrule</code>这些的. 更多画边框线的方式参加<a href="https://www.overleaf.com/learn/latex/tables" target="_blank" rel="noopener">overleaf-表格</a>.</p>
<h3 id="列表">列表</h3>
<p>有序列表用<code>enumerate</code>环境, 无序列表用<code>itemize</code>环境. 这个没啥难的, 有问题参见<a href="https://www.overleaf.com/learn/latex/lists" target="_blank" rel="noopener">overleaf-列表</a>.</p>
<p>💡 另外这里有个通过给<code>itemize</code>和<code>enumerate</code>环境的选项的方式<a href="https://tex.stackexchange.com/questions/10684/vertical-space-in-lists" target="_blank" rel="noopener">调整列表行间距的方法</a>.</p>
<h3 id="代码">代码</h3>
<p><code>lstlisting</code>环境 (需要导入<strong><em>listings</em></strong>宏包) 是传统的插入代码用环境, 只是插入个代码的话倒是语法也很简单, 但是要想让插入的代码有语法高亮的话就必须<a href="https://www.overleaf.com/learn/latex/Code_listing#Code_styles_and_colours" target="_blank" rel="noopener">这样</a>自己在导言区放一个语法高亮配色方案, 很不简洁. 强推一下<code>minted</code>环境 (需要导入<strong><em>minted</em></strong>宏包), 这是一个自带多种语法高亮配色方案且支持绝大多数语言语法高亮的很现代的代码插入环境! 使用方式见<a href="https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted#Introduction" target="_blank" rel="noopener">overleaf-用minted语法高亮</a>. 如果你追求比较高, 觉得minted自带的语法高亮不够细致, 比如minted对yaml的语法高亮不会像VSC那样将布尔值, 数字, 字符串等类型值用颜色标示出来, 那可以看看stackoverflow上这个<a href="https://tex.stackexchange.com/questions/152829/how-can-i-highlight-yaml-code-in-a-pretty-way-with-listings" target="_blank" rel="noopener">自定义语法高亮问题</a>.</p>
<p>💡 <strong><em>minted</em></strong>包依赖于一个叫<em>Pygments</em>的python包. 如果你环境里本来就有python那事情就很简单了, 一句<code>pip install pygments</code>搞定.</p>
<p>补充: <a href="https://tex.stackexchange.com/questions/12428/code-spanning-over-two-pages-with-minted-inside-listing-with-caption" target="_blank" rel="noopener">跨页代码无法caption问题</a>.</p>
<h3 id="特殊符号">特殊符号</h3>
<div>
<img style="width:70%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/symbol.jpg">
</div>
<p>LaTeX里更特殊的符号其实是靠<strong><em>tkiz</em></strong>包绘制出来的, 比如上面这段话里的圆圈1, 是通过在导言区定义了一个新的命令<code>\ballnumber{}</code>然后在文中调用的方式来实现的:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage{tikz}  % 绘图宏包</span><br><span class="line">\newcommand{\ballnumber}[1]{</span><br><span class="line">    \tikz[baseline=(myanchor.base)]</span><br><span class="line">    \node[circle,fill=.,inner sep=1pt](myanchor){\color{-.}\bfseries\footnotesize #1};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样的东西要用只能是现场上网搜了. 在这个<a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener">手绘查询符号网站</a>可以通过手绘的方式查到绝大多数符号 (但上面说的这个圆圈1查不到). 这里再吹一下VSC的LaTeX Workshop插件, 提供了一个快速插入常见符号LaTeX命令的面板, 还能快速插入常用tkiz绘制 🐮</p>
<div>
<img style="width:35%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/snippet.jpg">
</div>
<h2 id="中文支持">中文支持</h2>
<p>我目前还没用LaTeX写过中文内容, 不过看起来<strong><em>xeCJK</em></strong>宏包提供的中文支持效果还不错 (前提是用xelatex作为编译器), 不知道大量使用中文时会不会出问题. 这篇<a href="https://www.overleaf.com/learn/latex/Chinese#xeCJK_with_XeLaTeX" target="_blank" rel="noopener">overleaf-中文支持</a>我先码住.</p>
<h2 id="引用">引用</h2>
<p><code>biblatex</code>是毋庸置疑比<code>bibtex</code>更现代使用更简洁灵活的参考文献管理工具. 先上个我偏好的配置:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage[</span><br><span class="line">    backend=biber,</span><br><span class="line">    style=ieee,  % 参考文献列表显示格式</span><br><span class="line">    citestyle=authoryear,  % 引用显示格式</span><br><span class="line">    backref=true,  % 在参考文献列表中反向列出当前引用条目被引用的页码</span><br><span class="line">    maxcitenames=1,  % 在引用处最多显示作者数量</span><br><span class="line">    maxbibnames=999,  % 在参考文献列表中最多显示作者数量. 直接拉到一个很大的数强制显示全部作者</span><br><span class="line">    sorting=ynt,  % 参考文献列表中条目排序主键: year-name-title</span><br><span class="line">]{biblatex}</span><br><span class="line">% 添加参考文献bib文件 (可以有多个)</span><br><span class="line">\addbibresource{References.bib}  % 然后放一个References.bib在根目录</span><br><span class="line">% 让链接包含整个\cite{}对应的内容</span><br><span class="line">\makeatletter</span><br><span class="line">    \let\abx@macro@citeOrig\abx@macro@cite{}</span><br><span class="line">    \renewbibmacro{cite}{\bibhyperref{\let\bibhyperref\relax\relax\abx@macro@citeOrig{}}}</span><br><span class="line">\makeatother{}</span><br><span class="line">% 使\citetitle{}对应内容支持超链接</span><br><span class="line">\DeclareCiteCommand{\citetitle}{\usebibmacro{prenote}}{</span><br><span class="line">    \ifciteindex{\indexfield{indextitle}}{}\printtext[bibhyperref]{\printfield[citetitle]{labeltitle}}</span><br><span class="line">}{\multicitedelim}{\usebibmacro{postnote}}</span><br><span class="line"></span><br><span class="line">\usepackage[colorlinks=true]{hyperref}  % 开启超链接支持</span><br><span class="line"></span><br><span class="line">% 正文</span><br><span class="line">\cite{test}  %在要引用的地方用个这个就行, 参数填bib文件中这个参考文献条目的标识 (大括号后第一个东西)</span><br><span class="line"></span><br><span class="line">\printbibliography  % 输出参考文献列表</span><br></pre></td></tr></tbody></table></figure>
<div>
<img style="width:70%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/cite.jpg"> <img style="width:70%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/bib.jpg">
</div>
<ul>
<li><code>backend=biber</code>是因为<code>biblatex</code>需要额外工具<strong>biber</strong>作为后端来生成参考文献列表. 因此我<a href="#术语表">这附近</a>给出的VSCode的LaTeX编译工具链配置里有一环是<strong>biber</strong>.</li>
<li><code>style=ieee</code>指的参考文献列表显示参考文献信息的格式, <a href="https://www.overleaf.com/learn/latex/Biblatex_bibliography_styles" target="_blank" rel="noopener">这里</a>有一个各种格式的列表. 基本我看到的短篇论文用的是<em>authoryear</em>格式, 长篇论文用的是<em>ieee</em>格式. 我个人相对更喜欢<em>ieee</em>格式一些, 因为有序号.</li>
<li><code>citestyle=authoryear</code>则是指在文中引用处用<code>\cite{}</code>显示出的内容的格式. <em>Zhangsan et al. 2020</em>这样的格式是我最常见到的引用格式 (Overleaf有列出<a href="https://www.overleaf.com/learn/latex/Biblatex_citation_styles#Citation_styles" target="_blank" rel="noopener">biblatex可用的引用格式</a>). 要实现上面这样整个引用内容被包含在超链接中, 而不是只有年份带超链接还需要自己加一段宏. biblatex的维护者在<a href="https://github.com/plk/biblatex/issues/1024" target="_blank" rel="noopener">github仓库的issue</a>回答了之所以不将超链接包含整个引用内容做成一个自带功能, 是因为这会使有其他自定义需求的用户实现起来更麻烦 (咱也不知道是不是, 反正自己想实现的话一小段网上找的宏就实现了). 这块要想玩得花很有可能需要自定义一段宏, 那自己不会写能咋办, 只能上网偷几段呗.</li>
<li><code>maxcitenames=1, maxbibnames=999</code>是为了像上图展示的那样在引用处只显示一个作者, 而在参考文献列表里显示全部作者. 如果不强制拉满的话有时候在参考文献列表中作者也列不全, 带"et al.". 这不是什么大问题, 但看着尴尬了点.</li>
<li>想让引用内容可点击且颜色不一样还需要导入<strong><em>hyperref</em></strong>这个包, 这个稍后介绍.</li>
</ul>
<p>之所以说biblatex是比bibtex更现代的参考文献管理工具, 一大原因是因为biblatex原生支持一些现代人写论文会用到的"参考文献"类型, 比如网页对应<em>online</em>类型 (对我目前就多用到这一个). 给出<a href="https://www.overleaf.com/learn/latex/Bibliography_management_with_biblatex#Reference_guide" target="_blank" rel="noopener">overleaf上biblatex支持的参考文献类型列表</a>. 顺带一提我还看到了能让<a href="https://tex.stackexchange.com/questions/149506/biblatex-urldate-set-to-today" target="_blank" rel="noopener">biblatex中@online的urldata字段自动更新到今日</a>的神奇代码, 但想了想写论文出于严谨态度就该哪天确认的网页有效就写哪天, 单纯自动更新日期没有意义.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
        <category>语言</category>
        <category>LaTeX</category>
      </categories>
  </entry>
  <entry>
    <title>2022年5月15日 版本控制与敏捷项目管理分享</title>
    <url>/zh-CN/2022/05/23/2022%E5%B9%B45%E6%9C%8815%E6%97%A5%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p><span></span></p>
<a id="more"></a>
<p>最近又在<a href="https://uestc-msc.github.io/" target="_blank" rel="noopener">电子科大微软学生俱乐部</a>做了一次分享, 这次的主题是版本控制与敏捷项目管理, 不过因为时间远超我的预期 (我以为一小时就能讲完了结果楞是讲了三个小时), 因此项目管理这部分一笔带过了.</p>
<p><a href="https://github.com/uestc-msc/VCPM-salon" target="_blank" rel="noopener">📑 文字稿</a> (包含视频中用到的所有链接)</p>
<iframe src="//player.bilibili.com/player.html?aid=726745413&amp;bvid=BV1DS4y1B7XP&amp;cid=723097569&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>💡 视频的评论区有带可跳转的时间节点的大纲.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>CI/CD</category>
        <category>杂记</category>
        <category>版本控制</category>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>微积分课程笔记</title>
    <url>/zh-CN/2022/06/02/%E5%BE%AE%E7%A7%AF%E5%88%86%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>前前后后数理基础课也学了好几遍了, 但这些内容不常用就容易忘记. 虽然每次学都会记手写的电子笔记, 但这次我打算记一份能长期维护的印刷体电子笔记, 因为大概不会再需要一板一眼地把这几门最基础的课学一遍了. 我的想法是记重要概念, 术语, 重要思路和技巧, 以及一些易错点, 这样当我忘记内容时能很快知道我需要的是什么, 然后具体推导和习题再看教材就好 💪</p>
<a id="more"></a>
<div class="note success">
            <h2 id="教材">教材</h2><ol type="1"><li><a href="https://zh.b-ok.cc/book/5589738/691ece" target="_blank" rel="noopener">高等数学 同济第七版 上</a></li><li><a href="https://zh.b-ok.cc/book/5589739/7ed05b" target="_blank" rel="noopener">高等数学 同济第七版 下</a></li><li><a href="https://zh.b-ok.cc/book/11736398/a2e1f4" target="_blank" rel="noopener">高等数学习题全解指南 同济第七版 上</a></li><li><a href="https://zh.b-ok.cc/book/5589740/4a8648" target="_blank" rel="noopener">高等数学习题全解指南 同济第七版 下</a></li></ol>
          </div>
<h2 id="内容">内容</h2>
<h3 id="函数与极限">函数与极限</h3>
<blockquote>
<p>高等数学的研究对象是变动的量. 所谓函数关系就是变量之间的依赖关系, 极限方法是研究变量的一种基本方法.</p>
</blockquote>
<h4 id="极限">极限</h4>
<blockquote>
<p>极限概念是在探求某些实际问题的精确解答过程中产生的. 极限方法已称为高等数学中的一种基本方法.</p>
</blockquote>
<h5 id="数列的极限">数列的极限</h5>
<p><em>数列</em>: 如果按照某一法则, 对每个<span class="math inline">\(n \in N\)</span>, 对应着一个确定的实数<span class="math inline">\(x_n\)</span>, 这些实数<span class="math inline">\(x_n\)</span>按照下标<span class="math inline">\(n\)</span>从小到大排列得到的一个序列<span class="math inline">\(x_{1}, x_{2}, x_{3}, \dots, x_{n}, \dots\)</span>就叫数列.</p>
<p><em>数列极限定义</em>:</p>
<p><span class="math display">\[
\lim_{ n \to \infty } x_{n}=a \leftrightarrow \forall \epsilon&gt;0, \exists 正整数N, 当n&gt;N时, 有\mid x_{n}-a\mid&lt;\epsilon
\]</span></p>
<p>💡这个定义里的核心是<strong>可以任意给定</strong>的<span class="math inline">\(\epsilon\)</span>:</p>
<ul>
<li>只有这样, 不等式<span class="math inline">\(\mid x_{n}-a\mid&lt;\epsilon\)</span>才能表达出<span class="math inline">\(x_n\)</span>与<span class="math inline">\(a\)</span>无限接近的意思</li>
<li><strong><span class="math inline">\(N\)</span>是随着<span class="math inline">\(\epsilon\)</span>的给定而选定的</strong></li>
<li>更好理解的说法是, 选定一个以<span class="math inline">\(a\)</span>为中心的开区间<span class="math inline">\((a-\epsilon, a+\epsilon)\)</span>后, 对于数列<span class="math inline">\(\{x_{n}\}\)</span>只有有限个 (不多于<span class="math inline">\(N\)</span>个) <span class="math inline">\(\{x_{n}\}\)</span>的项在这个区间外. 如果这个区间可以任意小, 那当然可以说<span class="math inline">\(x_{n}\)</span>是无限接近<span class="math inline">\(a\)</span>的.</li>
</ul>
<h6 id="数列极限的性质">数列极限的性质</h6>
<ol type="1">
<li><strong>唯一性</strong></li>
<li><strong>有界性</strong></li>
<li><strong>保号性</strong></li>
<li>收敛数列与其子数列间的关系: 如果数列<span class="math inline">\(\{x_{n}\}\)</span>收敛于<span class="math inline">\(a\)</span>, 那么它的任一子数列也收敛且极限为<span class="math inline">\(a\)</span>. 由此可以得出两个有用推论:
<ol type="1">
<li><strong>子数列发散<span class="math inline">\(\to\)</span>原数列发散</strong></li>
<li><strong>有两个收敛于不同极限的子数列<span class="math inline">\(\to\)</span>原数列发散</strong></li>
</ol></li>
</ol>
<h5 id="函数的极限">函数的极限</h5>
<blockquote>
<p>从数列极限可以引申出函数极限的一般概念: 在自变量的某个变化过程中, 如果对应的函数值无限接近于某个确定的数, 那么这个确定的数就叫在这一变化过程中函数的极限.</p>
</blockquote>
<p>极限这个概念的重点就在于这个趋近的过程, 可以认为<strong>极限是一个动态的过程</strong>. 这个极限是与自变量的变化过程密切相关的, 由于自变量变化过程不同, 函数极限就表现为不同形式 (其中最主要的是下面两种).</p>
<p><em>函数极限定义1 (自变量趋于<strong>无穷大</strong>)</em>: 正负无穷大极限分别存在且相等.</p>
<p><span class="math display">\[
\lim_{ x \to \infty } f(x)=A \leftrightarrow \lim_{ x \to -\infty } f(x)=\lim_{ x \to +\infty } f(x)=A
\]</span></p>
<ul>
<li>函数当自变量趋于<strong>正无穷大</strong>时的极限: (趋于负无穷大时的极限就是把范围换成<span class="math inline">\(\color{yellow}{x&lt;-X}\)</span>) <span class="math display">\[
\lim_{ x \to +\infty } f(x)=A \leftrightarrow \forall \epsilon&gt;0, \exists X&gt;0, 当\color{yellow}{x&gt;X}时, 有\mid f(x)-A\mid&lt;\epsilon
\]</span></li>
<li>无穷大不是具体的数, 本身就是一种极限<br>
</li>
<li>无穷大指的是<strong>绝对值</strong>大于任何具体的数, 因此同时包括正无穷大和负无穷大.</li>
</ul>
<p><em>函数极限定义2 (自变量<strong>从两侧</strong>趋于<strong>有限值</strong>)</em>: 左右极限分别存在且相等.</p>
<p><span class="math display">\[
\lim_{ x \to x_{0} } f(x)=A \leftrightarrow \lim_{ x \to -x_{0} } f(x)=\lim_{ x \to +x_{0} } f(x)=A
\]</span></p>
<ul>
<li>函数左极限定义 (自变量<strong>仅从左侧</strong>趋于<strong>有限值</strong>): 右极限就是把范围换成<span class="math inline">\(\color{yellow}{x_{0}&lt;x&lt;x_{0}+\epsilon}\)</span> <span class="math display">\[
\lim_{ x \to x_{0}^- } f(x)=A \leftrightarrow \forall\epsilon&gt;0, \exists\delta&gt;0, 当\color{yellow}{x_{0}-\delta&lt;x&lt;x_{0}}时, 有\mid f(x)-A\mid&lt;\epsilon
\]</span></li>
<li><span class="math inline">\(\lim_{ x \to x_0 }f(x)\)</span>是否存在和<span class="math inline">\(f(x_{0})\)</span>是否存在<strong>没有关系</strong></li>
</ul>
<h6 id="函数极限的性质">函数极限的性质</h6>
<p>参照数列极限的性质可以得到相应的函数极限性质, 同样由于函数极限的定义按自变量的变化过程不同有不同形式.</p>
<ol type="1">
<li><strong>唯一性</strong>: 如果<span class="math inline">\(\lim_{ x \to x_0 } f(x)\)</span>或<span class="math inline">\(\lim_{ x \to \infty } f(x)\)</span>存在, 则此极限唯一. 因此: <span class="math display">\[\begin{align*}&amp;\lim_{ x \to +\infty } e^x=+\infty, \lim_{ x \to -\infty } e^x=0 \to \color{pink}{\lim_{ x \to \infty } e^x不存在\ (\lim_{ x \to \infty } e^{\frac{1}{x}}同理)}
 \\&amp;\lim_{ x \to +0 } \frac{\sin x}{\mid x\mid}=1, \lim_{ x \to -0 } \frac{\sin x}{\mid x\mid}=-1 \to \color{pink}{\lim_{ x \to 0 } \frac{\sin x}{\mid x\mid}不存在}
\\&amp;在x=0附近\frac{1}{x}\sin \frac{1}{x}是无界量, 在(-\infty, +\infty)范围振荡\ (因此不是无穷大量) \to \color{pink}{\lim_{ x \to 0 } \frac{1}{x}\sin \frac{1}{x}不存在}
\\&amp;\tiny{(可以通过找几个收敛于不同极限的子数列来反证函数不收敛)}
\end{align*}\]</span></li>
<li><strong>局部有界性</strong></li>
<li><strong>局部保号性</strong></li>
<li>函数极限与数列极限的关系 (<strong>海涅定理</strong>): 设<span class="math inline">\(\{x_n\}\)</span>为任一<span class="math inline">\(f(x)\)</span>定义域内以<span class="math inline">\(x_0\)</span>为极限的数列 (<span class="math inline">\(x_{n}\neq x_{0}\)</span>), 有 <span class="math display">\[\lim_{ x \to x_{0} } f(x)=A \leftrightarrow \lim_{\color{pink}{n \to \infty}} f(x_{n})=A
\]</span> 💡<span class="math inline">\(x\)</span>是变量而<span class="math inline">\(x_n\)</span>只是具体的数</li>
</ol>
<h6 id="两个重要极限">两个重要极限</h6>
<p><span class="math display">\[\begin{align}
&amp;\lim_{ x \to 0 } \frac{\sin x}{x}=1 \\
&amp;\lim_{ x \to \infty } \left( 1+\frac{1}{x} \right)^x=e
\end{align}
\]</span></p>
<h5 id="求数列函数极限的方法">求数列/函数极限的方法</h5>
<ol type="1">
<li>定义法==TODO==</li>
</ol>
<h4 id="函数">函数</h4>
<h5 id="函数的几种特性">函数的几种特性</h5>
<ol type="1">
<li><strong>有界性</strong></li>
<li><strong>单调性</strong></li>
<li><strong>奇偶性</strong></li>
<li><strong>周期性</strong> 设函数<span class="math inline">\(f(x)\)</span>的定义域为<span class="math inline">\(D\)</span>. 如果存在一个<strong>正数</strong><span class="math inline">\(T\)</span>, 使得对于任意<span class="math inline">\(x \in D\)</span>有<span class="math inline">\((x \pm T) \in D\)</span>, 且 <span class="math display">\[f(x+T)=f(x)\]</span> 恒成立, 则<span class="math inline">\(f(x)\)</span>为周期函数, <span class="math inline">\(T\)</span>称为<span class="math inline">\(f(x)\)</span>的周期. 通常我们说周期函数的周期指的是<strong>最小正周期</strong>.</li>
</ol>
<h5 id="一些函数">一些函数</h5>
<p><em>狄利克雷 (Dirichlet)函数</em>:</p>
<p><span class="math display">\[
D(x)=\begin{cases}
1, x \in Q, \\
0, x \in Q^c. \\
\end{cases}
\]</span></p>
<p><span class="math inline">\(Q\)</span>是有理数集, <span class="math inline">\(Q^c\)</span>是无理数集. 易证任何正有理数<span class="math inline">\(r\)</span>都是它的周期. 因为不存在最小的正有理数, 所以狄利克雷函数<strong>没有最小正周期</strong>.</p>
<p><em>初等函数</em>: 以下五类函数统称为<strong>基本初等函数</strong>, 由常数和基本初等函数经过有限次四则运算和有限次函数复合所构成并可以用一个式子表示的函数, 称为初等函数.</p>
<ul>
<li>幂函数<span class="math inline">\(y=x^ \alpha\)</span></li>
<li>指数函数<span class="math inline">\(y=a^x\)</span></li>
<li>对数函数<span class="math inline">\(y=\log_{a}x\)</span></li>
<li>三角函数</li>
<li>反三角函数</li>
</ul>
<h5 id="函数的连续性">函数的连续性</h5>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程学习笔记</category>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>探海利器-声呐课程笔记</title>
    <url>/zh-CN/2022/05/23/%E6%8E%A2%E6%B5%B7%E5%88%A9%E5%99%A8-%E5%A3%B0%E5%91%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>看了<a href="https://www.bilibili.com/video/BV1qu411679n" target="_blank" rel="noopener">哈工程公开课-探海利器-声呐</a>这门概论性质的课对声呐有了一个最基础的了解, 看的过程中记了一些笔记. 搜索的时候还发现另外两门更深入的课程: <a href="https://www.icourse163.org/course/HRBEU-1002013001" target="_blank" rel="noopener">哈工程-水声学</a>, <a href="https://www.xuetangx.com/course/nau07021002103/10327221" target="_blank" rel="noopener">海军航空大学-声纳技术</a>, 有机会也来看一看.</p>
<a id="more"></a>
<h2 id="定义和发展方向">定义和发展方向</h2>
<p>现代声呐: 在水下利用声波进行探测, 导航, 定位, 识别, 通信等所有电子设备的总称.</p>
<p>发展特点: 低频, 大功率, 宽频带, 高搜索率, 高定位精度</p>
<p>发展方向:</p>
<ul>
<li>先进的信号处理技术</li>
<li>水声通信和声呐组网技术</li>
<li>被动声呐技术</li>
<li>低频大功率主动声呐技术</li>
</ul>
<h2 id="海洋">海洋</h2>
<ul>
<li><p>是双界面波导, 上面是波浪起伏的海面, 下面是凹凸不平的海底</p></li>
<li><p>海水中声速受该点温度, 盐度, 压力影响</p>
<ul>
<li><p>温度+1, 声速+4.2m/s</p></li>
<li><p>盐度+1‰, 声速+1.3m/s (淡水中盐度变化对声速影响可以忽略不计)</p></li>
<li><p>压力+1atm, 声速+0.17m/s</p></li>
<li><p>声速随海水深度先降后升, 声速最小处称<strong>声道轴</strong>. 在海面附近由于阳光照射温度较高, 越往下温度越低.水深到一定程度后温度几乎不变, 由于盐度和压力也在增加所以速度又增大. 💡淡水中目前没有发现声道轴, 主要受温度影响, 会有声线弯曲.</p>
<div>
<img style="width:30%; display:block; margin-left:auto; margin-right:auto;" data-src="./探海利器-声呐课程笔记/声速深度曲线图.jpg">
</div></li>
</ul></li>
<li><p>海水是时变空变的水声信道 (滤波器). 水声信道特性:</p>
<ul>
<li>多途效应
<ul>
<li>引起信号的时间展宽(浅海几百毫秒, 深海几秒), 码间干扰, 改变码元波形并产生误码, 降低系统可靠性和通信速率</li>
<li>抗多途干扰措施:
<ol type="1">
<li>增加码元保护间隔 (会降低通信速率)</li>
<li>使用指向性换能器</li>
<li>利用衰落的各种选择性, 使用合适的分集技术</li>
<li>使用合理的调制技术, 扩频技术</li>
<li>使用合适的自适应技术</li>
<li>...</li>
</ol></li>
</ul></li>
<li>频散效应: 不同频率声波在海中传播的群速度不同, 因此会有信号的变形</li>
<li>多普勒频移: 由发射接收相对运动或水流引起, 与相对运动速度和工作频率成正比.</li>
<li>声传播方向偏转</li>
<li>在浅海传播时的低频截止现象</li>
<li>在深海传播时的会聚现象</li>
</ul></li>
</ul>
<h2 id="水声技术与电磁波技术对比">水声技术与电磁波技术对比</h2>
<ul>
<li>有多少种运用电磁波的观通设备, 水下就大致有多少种功能类似的声呐</li>
<li>电磁波速度<span class="math inline">\(3\times10^8m/s\)</span>, 声波在水中速度<span class="math inline">\(1500m/s\)</span>, 决定
<ul>
<li>雷达工作频率约<span class="math inline">\(10^9Hz\)</span>, 声呐频率约<span class="math inline">\(10^3Hz\)</span></li>
<li>声呐分辨率差, 声图像模糊</li>
</ul></li>
<li>信息载体不同 (声波/ 电磁波), 信道不同 (海洋/空气)</li>
</ul>
<div>
<img style="width:80%; display:block; margin-left:auto; margin-right:auto;" data-src="./探海利器-声呐课程笔记/水声信道无线信道对比.jpg">
</div>
<h2 id="类型">类型</h2>
<h3 id="按工作方式">按工作方式</h3>
<ul>
<li><p>主动声呐</p>
<ul>
<li>最重要三个影响因素: 环境噪声, 平台噪声, 混响 (来源于气泡, 冷热水团, 不均匀性, 界面的不平整性)</li>
</ul></li>
<li><p>被动声呐</p>
<ul>
<li>需要获得的信息: 目标自身发出的声信号或者辐射噪声 (机械噪声, 螺旋桨噪声, 水动力噪声)</li>
<li>干扰: 环境噪声, 平台自噪声 (近场噪声)</li>
</ul></li>
</ul>
<h3 id="按用途分-测绘声呐">按用途分 (测绘声呐)</h3>
<p>💡 不知道有没有类似平行光源 (比如激光) 概念的平行声源, 理论上是否可实现. 等我有机会问问老师.</p>
<div>
<div style="display:inline-block;width:33%;">
<pre><code>&lt;img src="./探海利器-声呐课程笔记/测扫声呐.jpg"&gt;</code></pre>
</div>
<div style="display:inline-block;width:33%;">
<pre><code>&lt;img src="./探海利器-声呐课程笔记/多波束测深声呐.jpg"&gt;</code></pre>
</div>
<div style="display:inline-block;width:32%;">
<img data-src="./探海利器-声呐课程笔记/浅地层剖面声呐.jpg">
</div>
</div>
<ul>
<li>测扫声呐: 探测海底底质. 收发合置的测扫声呐只能发射完成再接收, 收发分置的测扫声呐可以边发边收.
<div>
<img style="width:50%; display:block; margin-left:auto; margin-right:auto;" data-src="./探海利器-声呐课程笔记/测扫声呐原理.jpg">
</div>
<blockquote>
<p>测扫声呐工作原理 ⚠ 注意6的回波比5先回到换能器.</p>
</blockquote></li>
<li>多波束测深声呐: 探测海底地形地貌</li>
<li>浅地层剖面声呐: 探测海底表面以下分层结构及分层介质的构成</li>
<li>多功能集成: 基于参量阵, 实现地形, 底质, 地层构造等信息的一体化探测
<ul>
<li>高频/原频: 地形/底质</li>
<li>低频/差频: 地层构造</li>
</ul></li>
</ul>
<h2 id="声呐信号处理">声呐信号处理</h2>
<div>
<div style="display:inline-block;width:47%;">
<pre><code>&lt;img src="./探海利器-声呐课程笔记/声呐系统.jpg"&gt;</code></pre>
</div>
<div style="display:inline-block;width:49%;">
<pre><code>&lt;img src="./探海利器-声呐课程笔记/声呐系统典型构成.jpg"&gt;</code></pre>
</div>
</div>
<blockquote>
<p>上右图为声呐系统典型构成</p>
</blockquote>
<p>声呐信号处理的基础是<strong>海洋环境</strong>和<strong>声场声传播条件</strong>.</p>
<p>经典声呐信号处理任务: 目标检测, 定位, 识别</p>
<p>声呐信号处理面临的难题:</p>
<ul>
<li>水声信号带宽窄, 数据传输速度低, 声呐搜索速度慢</li>
<li>波束展宽引起分辨率降低</li>
<li>性能受环境影响大</li>
<li>目标及其信号的种类多, 特征复杂</li>
</ul>
<h2 id="海底测绘常用海底特性">海底测绘常用海底特性:</h2>
<ul>
<li>海底表面的起伏</li>
<li>海底表面沉积物类别</li>
<li>海底表面以下的地层构造 (分层结构及沉积物类别)</li>
</ul>
<h2 id="水声通信">水声通信</h2>
<div>
<img style="width:80%; display:block; margin-left:auto; margin-right:auto;" data-src="./探海利器-声呐课程笔记/海陆空天一体化通信体系.jpg">
</div>
<p>蛟龙号水声通信种类:</p>
<ul>
<li>相干水声通信: 高速, 可传输图像</li>
<li>非相干水声通信: 中速, 用于传输文字, 指令, 数据</li>
<li>扩频通信: 远程, 低速, 用于传输指令</li>
</ul>
<div>
<img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./探海利器-声呐课程笔记/水声信道典型带宽.jpg">
</div>
<blockquote>
<p>水声信道典型带宽</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程学习笔记</category>
        <category>水声学</category>
        <category>声呐</category>
      </categories>
  </entry>
  <entry>
    <title>关于我的NexT主题博客的个性化配置以及遇到的一些问题</title>
    <url>/zh-CN/2019/01/07/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84NexT%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<div data-align="right">
<p>Language: <a href="/2018/12/24/About-My-Custom-Settings-of-My-Next-Theme-Blog-and-Problem-Killing"><kbd>English</kbd></a> <a href="/zh-CN/2019/01/07/关于我的NexT主题博客的个性化配置以及遇到的一些问题"><kbd>中文</kbd></a></p>
</div>
<a id="more"></a>
<p><span style="color:red"><strong>更多配置请见英文页面</strong></span></p>
<h2 id="遇到的问题">遇到的问题</h2>
<h3 id="更改配置后页面未出现变化">更改配置后页面未出现变化</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity" target="_blank" rel="noopener">priority</a></p>
<h3 id="markdown中文换行导致的空格问题">markdown中文换行导致的空格问题</h3>
<p>请看<a href="https://codehut.me/posts/Y3Vyc29yOjg=" target="_blank" rel="noopener">这里</a>，它完美解决了问题。我在<strong>themes/next/scripts/</strong>下放了一个<code>fuck_chinese_space.js</code>,里面正是上面这位老兄博文里写的：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">hexo.extend.filter.register(<span class="string">'after_render:html'</span>, fix);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fix</span>(<span class="params">str</span>) </span>{ <span class="keyword">return</span> str.replace(<span class="regexp">/([¡«·»¿;·՚-՟։׀׃׆׳-״؉-؊،-؍؛؞-؟٪-٭۔܀-܍߷-߹।-॥॰෴๏๚-๛༄-༒྅࿐-࿔၊-၏჻፡-፨᙭-᙮᛫-᛭᜵-᜶។-៖៘-៚᠀-᠅᠇-᠊᥄-᥅᧞-᧟᨞-᨟᭚-᭠᰻-᰿᱾-᱿\u2000-\u206e⳹-⳼⳾-⳿⸀-\u2e7e⺀-\u2efe\u3000-〾・㇀-\u31ee㈀-㋾㌀-㏾㐀-\u4dbe一-\u9ffe꘍-꘏꙳꙾꡴-꡷꣎-꣏꤮-꤯꥟꩜-꩟豈-\ufafe︐-︖︙︰-﹎﹐-﹒﹔-﹗﹟-﹡﹨﹪-﹫！-＃％-＇＊，．-／：-；？-＠＼｡､-･]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud800[\udd00-\udd01\udf9f\udfd0]|\ud802[\udd1f\udd3f\ude50-\ude58]|\ud809[\udc00-\udc7e]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e])\n\s*/g</span>, <span class="string">'$1'</span>); }</span><br></pre></td></tr></tbody></table></figure>
<h3 id="google站点地图报错">Google站点地图报错</h3>
<p><a href="https://alanlee.fun/2017/12/30/google-sitemap/" target="_blank" rel="noopener">这里</a></p>
<h3 id="如何建立多级分类">如何建立多级分类</h3>
<p>参见<a href="http://aiellochan.com/2018/02/13/hexo/Hexo-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA-categories/" target="_blank" rel="noopener">这里</a></p>
<h2 id="个性化配置">个性化配置</h2>
<h3 id="多语言">多语言</h3>
<p><a href="https://www.ieclipse.cn/2016/06/02/other/tech-hexo-i18n/index.html" target="_blank" rel="noopener">参考1</a> <a href="https://bambooom.github.io/2018/03/08/hexo-multi-lang/" target="_blank" rel="noopener">参考2</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>当VSCode成为一种生活方式</title>
    <url>/zh-CN/2019/01/07/%E5%BD%93VSCode%E6%88%90%E4%B8%BA%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<div data-align="right">
<p>Language: <a href="/2018/12/25/When-VSCode-Becomes-A-Lifestyle"><kbd>English</kbd></a> <a href="/zh-CN/2019/01/07/当VSCode成为一种生活方式"><kbd>中文</kbd></a></p>
</div>
<!-- TODO -->
<p>VSCode是一款很强大的编辑器, 因为我现在的电脑性能不太好, 开规模很大的那些2IDE特别慢, 我很喜欢用VSCode. 而且用VSCode在某些方面确实能获得很不错的体验<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span> 本文算是VSCode 安利和我个人的使用技巧.</p>
<a id="more"></a>
<h1 id="why-vscode">Why VSCode</h1>
<h2 id="写markdown">写Markdown</h2>
<h2 id="写前端">写前端</h2>
<h2 id="写小段代码">写小段代码</h2>
<h3 id="写python">写Python</h3>
<h3 id="写cc">写C/C++</h3>
<h2 id="写latex">写LaTeX</h2>
<h1 id="插件安利">插件安利</h1>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 要注意的是最好不要在一个项目中使用过多插件, 这会让VSCode最开始的加载非常慢, 这是得不偿失的. 我们仍要记得VSCode只是一个编辑器. 而我们通常面临的尴尬情况是:有很多日常会用到的插件, 但并不是在每个项目中都需要用到全部的插件, 很多本工作区用不到的插件放在那里只会浪费资源. 而通过将一些插件设为<strong>禁用(工作区)</strong>可以仅在这个项目中禁用这个插件! 这样能大大缩短VSCode启动时间<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<h1 id="vscode-个性化设置">VSCode 个性化设置</h1>
<h2 id="改编辑器选项卡关闭按钮位置至左边">改编辑器选项卡关闭按钮位置至左边</h2>
<p>在这之前有一件让我很恼火的事: 我经常由于文件标题过长而选项卡关闭按钮在右侧而不能轻松地关闭一个选项卡, 因为关闭按钮没能显示出来! 而我将关闭按钮改至左侧后, <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span>爽到!</p>
<p>:heavy_check_mark: 更改方法: 在设置中搜索 <code>workbench.editor.tabCloseButton</code>, 设置为<strong>left</strong></p>
<h2 id="在一定数量的等宽字符后显示垂直标尺">在一定数量的等宽字符后显示垂直标尺</h2>
<p>VSCode有许多很好用的功能!<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span> 这是其中之一. 你可以设置任意多个标尺来作为字数的参考线!</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>editor.rulers</code>, 选择后在数组中填入要画线处的字数.</p>
<h2 id="代码格式化">代码格式化</h2>
<p>统一用 <code>Alt+shift+F</code> 作为代码格式化快捷键</p>
<h2 id="查看键盘快捷方式">查看键盘快捷方式</h2>
<p>如果你新安装了一个插件, 其中几个快捷键不知道为什么不好用或者效果不对, 你应当到 <strong>键盘快捷方式</strong>查看一下这个快捷键在该情况下是不是对应了不止一个命令.</p>
<h2 id="关闭enter键接受建议">关闭Enter键接受建议</h2>
<p>很多时候原本想换行的, 但是按Enter却接受了VSCode的沙雕建议, 令人郁闷, 通过关掉Enter接受建议能让心情好很多<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span> 虽然习惯Enter接受建议突然改成只能用Tab接受建议会有点不适应, 但再适应一下就会觉得非常舒服了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8">👏</span></p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>editor.acceptSuggestionOnEnter</code>, 改为 <strong>off</strong></p>
<h2 id="设置git-commit成功即上传">设置git commit成功即上传</h2>
<p>在使用个人repository时我认为commit和push是没必要分开进行的, 因为只有自己用, 在本地存着和在云端存着没什么区别. 甚至有可能发生代码忘记上传云端就把电脑格式化了因而损失大段代码的惨案<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span> 因此git有一项选项特别适合我: commit成功即push</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>git.postCommitCommand</code>, 设置为<strong>push</strong></p>
<h2 id="打开用户设置的同时打开默认设置">打开用户设置的同时打开默认设置</h2>
<p>虽然打开<strong>settings.json</strong>时同时打开默认设置的json文件应当是默认设置, 但我有一次安装 VSCode之后发现这个选项没被勾上.</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>workbench.settings.openDefaultSettings</code>, 设置为<strong>true</strong>.</p>
<h2 id="允许编辑器中水平滚动">允许编辑器中水平滚动</h2>
<p>触摸板和一些鼠标 (比如我的Microsooft Arch) 是支持水平滚动界面的, 但VSCode默认禁止水平滚动, 只能滑动底下的滑条来左右滑, 但这个选项可以打开.</p>
<p>:heavy_check_mark: 设置方法: 在设置中搜索<code>workbench.tree.horizontalScrolling</code>, 设置为<strong>true</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具</category>
        <category>软件配置</category>
        <category>VSC</category>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>几个提高效率的小技巧</title>
    <url>/zh-CN/2019/01/18/%E5%87%A0%E4%B8%AA%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>记录和分享一些我觉得提高了自己效率的技巧。</p>
<a id="more"></a>
<h1 id="虚拟桌面分割任务">虚拟桌面分割任务</h1>
<p>Windows有一个我觉得蛮有意思的功能, <strong>虚拟桌面</strong>. 按 <code>Windows+Tab</code> 或者点击任务栏上有个长得有点奇怪的图标可以打开<strong>任务视图</strong>, 然后可以新建桌面, 管理桌面. 通过把应用界面分别放到不同桌面可以让任务栏不会堆积很多页面. 有时候同时写多个项目的时候会用浏览器搜好几个主题 (是的我就是浏览器选手) 如果都放到一起太乱太多了, 因此放到不同桌面是个非常不错的选择. 我经常将娱乐的玩意, 什么网易云, 百度云之类放一个桌面, 然后一个项目放一个桌面, 心情愉悦让效率大大提高<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<h1 id="更改输入法符号">更改输入法符号</h1>
<p>有时, 比如写中文文档时, 我们需要频繁切换中英文输入法, 而代码中打符号的时候我总是忘记切换成英文输入法, 打出万恶的中文字符, 比如；什么的. 而我发现快捷键 <code>Ctrl+.</code>可以只切换符号的中英文! 也就是说你可以在中文输入法下打出英文标点 (比如我的句号是英文句号). 这样就解决了中英文标点易混淆的烦恼<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p>
<!-- TODO -->
<!-- chrom -->
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技巧</category>
      </categories>
  </entry>
</search>
