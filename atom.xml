<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeoJhon.Song&#39;s Blog</title>
  
  <subtitle>欢迎来到我的博客!</subtitle>
  <link href="/zh-CN/atom.xml" rel="self"/>
  
  <link href="https://leojhonsong.github.io/zh-CN/"/>
  <updated>2022-05-25T04:01:00.000Z</updated>
  <id>https://leojhonsong.github.io/zh-CN/</id>
  
  <author>
    <name>LeoJhon.Song</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微积分课程笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2022/11/06/%E5%BE%AE%E7%A7%AF%E5%88%86%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2022/11/06/%E5%BE%AE%E7%A7%AF%E5%88%86%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-06T08:20:29.537Z</published>
    <updated>2022-05-25T04:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前前后后数理基础课也学了好几遍了, 但这些内容不常用就容易忘记. 虽然每次学都会记手写的电子笔记, 但这次我打算记一份能长期维护的印刷体电子笔记, 因为大概不会再需要一板一眼地把这几门最基础的课学一遍了. 我的想法是记重要概念, 术语, 重要思路和技巧, 以及一些易错点, 这样当我忘记内容时能很快知道我需要的是什么, 然后具体推导和习题再看教材就好 💪</p><a id="more"></a><div class="note success">            <h2 id="教材">教材</h2><ol type="1"><li><a href="https://zh.b-ok.cc/book/5589738/691ece" target="_blank" rel="noopener">高等数学 同济第七版 上</a></li><li><a href="https://zh.b-ok.cc/book/5589739/7ed05b" target="_blank" rel="noopener">高等数学 同济第七版 下</a></li><li><a href="https://zh.b-ok.cc/book/11736398/a2e1f4" target="_blank" rel="noopener">高等数学习题全解指南 同济第七版 上</a></li><li><a href="https://zh.b-ok.cc/book/5589740/4a8648" target="_blank" rel="noopener">高等数学习题全解指南 同济第七版 下</a></li></ol>          </div><h2 id="内容">内容</h2><h3 id="函数与极限">函数与极限</h3><blockquote><p>高等数学的研究对象是变动的量. 所谓函数关系就是变量之间的依赖关系, 极限方法是研究变量的一种基本方法.</p></blockquote><h4 id="极限">极限</h4><blockquote><p>极限概念是在探求某些实际问题的精确解答过程中产生的. 极限方法已称为高等数学中的一种基本方法.</p></blockquote><h5 id="数列的极限">数列的极限</h5><p><em>数列</em>: 如果按照某一法则, 对每个<span class="math inline">\(n \in N\)</span>, 对应着一个确定的实数<span class="math inline">\(x_n\)</span>, 这些实数<span class="math inline">\(x_n\)</span>按照下标<span class="math inline">\(n\)</span>从小到大排列得到的一个序列<span class="math inline">\(x_{1}, x_{2}, x_{3}, \dots, x_{n}, \dots\)</span>就叫数列.</p><p><em>数列极限定义</em>:</p><p><span class="math display">\[\lim_{ n \to \infty } x_{n}=a \leftrightarrow \forall \epsilon&gt;0, \exists 正整数N, 当n&gt;N时, 有\mid x_{n}-a\mid&lt;\epsilon\]</span></p><p>💡这个定义里的核心是<strong>可以任意给定</strong>的<span class="math inline">\(\epsilon\)</span>:</p><ul><li>只有这样, 不等式<span class="math inline">\(\mid x_{n}-a\mid&lt;\epsilon\)</span>才能表达出<span class="math inline">\(x_n\)</span>与<span class="math inline">\(a\)</span>无限接近的意思</li><li><strong><span class="math inline">\(N\)</span>是随着<span class="math inline">\(\epsilon\)</span>的给定而选定的</strong></li><li>更好理解的说法是, 选定一个以<span class="math inline">\(a\)</span>为中心的开区间<span class="math inline">\((a-\epsilon, a+\epsilon)\)</span>后, 对于数列<span class="math inline">\(\{x_{n}\}\)</span>只有有限个 (不多于<span class="math inline">\(N\)</span>个) <span class="math inline">\(\{x_{n}\}\)</span>的项在这个区间外. 如果这个区间可以任意小, 那当然可以说<span class="math inline">\(x_{n}\)</span>是无限接近<span class="math inline">\(a\)</span>的.</li></ul><h6 id="数列极限的性质">数列极限的性质</h6><ol type="1"><li><strong>唯一性</strong></li><li><strong>有界性</strong>: 收敛<span class="math inline">\(\textcolor{red}{\to}\)</span>有界. 比如<span class="math inline">\((-1)^n\)</span>有界但不收敛.</li><li><strong>保号性</strong></li><li>收敛数列与其子数列间的关系: 如果数列<span class="math inline">\(\{x_{n}\}\)</span>收敛于<span class="math inline">\(a\)</span>, 那么它的任一子数列也收敛且极限为<span class="math inline">\(a\)</span>. 由此可以得出两个有用推论:<ol type="1"><li><strong>子数列发散<span class="math inline">\(\to\)</span>原数列发散</strong></li><li><strong>有两个收敛于不同极限的子数列<span class="math inline">\(\to\)</span>原数列发散</strong></li></ol></li></ol><h6 id="求数列极限的方法">求数列极限的方法</h6><ol type="1"><li>根据<strong>海涅定理</strong>有: <span class="math display">\[\begin{cases}\lim\limits_{ x \to x_{0} } f(x)=A \\\lim\limits_{ n \to \infty } \{x_{n}\}=x_{0}\end{cases} \to \lim_{ n \to \infty } f(x_{n})=A\]</span> <span class="math display">\[\begin{align*}\tiny比如\lim_{ x \to 0 } f(x)=A \to \lim_{ n \to \infty } f\left( \frac{1}{n} \right)=A\end{align*}\]</span></li><li><strong>单调有界</strong>数列必有极限:<ol type="1"><li>先假设法求出极限值<span class="math inline">\(a\)</span>, 然后想办法证明<span class="math inline">\(a\)</span>是<span class="math inline">\(\{x_{n}\}\)</span>的上/下界</li><li>计算<span class="math inline">\(x_{n+1}-x_{n}\)</span>或<span class="math inline">\(\frac{x_{n+1}}{x_{n}} (\textcolor{red}{\{x_{n}\}同号})\)</span>证出数列单调 (可能会用到<span class="math inline">\(a\)</span>是上/下界的条件)</li></ol></li><li><strong>夹逼法</strong>: 用<em>不等式缩放</em>出一大一小两个好求极限且收敛于同一值的数列</li><li><strong>定义法1</strong>:<ol type="1"><li>假设极限存在, 求出<span class="math inline">\(a\)</span></li><li>构造出 <span class="math display">\[\mid x_{n}-a\mid=k\mid x_{n-1}-a\mid=\dots=k^n\mid x_{0}-a\mid, 0&lt;k&lt;1\]</span></li><li><span class="math inline">\(\lim\limits_{ n \to \infty } \mid x_{n}-a\mid=0 \to \lim\limits_{ n \to \infty } x_{n}=a\)</span></li></ol></li><li><strong>定义法2</strong>: 由<span class="math inline">\(\mid x_{n}-a\mid&lt;\epsilon\)</span>得<span class="math inline">\(n\)</span>关于<span class="math inline">\(\epsilon\)</span>的取值范围, 然后用<span class="math inline">\(N\)</span>替换<span class="math inline">\(n\)</span>并向上取整得到<span class="math inline">\(N=\lceil f(\epsilon)\rceil\)</span></li></ol><h5 id="函数的极限">函数的极限</h5><blockquote><p>从数列极限可以引申出函数极限的一般概念: 在自变量的某个变化过程中, 如果对应的函数值无限接近于某个确定的数, 那么这个确定的数就叫在这一变化过程中函数的极限.</p></blockquote><p>极限这个概念的重点就在于这个趋近的过程, 可以认为<strong>极限是一个动态的过程</strong>. 这个极限是与自变量的变化过程密切相关的, 由于自变量变化过程不同, 函数极限就表现为不同形式 (其中最主要的是下面两种).</p><p><em>函数极限定义1 (自变量趋于<strong>无穷大</strong>)</em>: 正负无穷大极限分别存在且相等.</p><p><span class="math display">\[\lim_{ x \to \infty } f(x)=A \leftrightarrow \lim_{ x \to -\infty } f(x)=\lim_{ x \to +\infty } f(x)=A\]</span></p><ul><li>函数当自变量趋于<strong>正无穷大</strong>时的极限: (趋于负无穷大时的极限就是把范围换成<span class="math inline">\(\textcolor{yellow}{x&lt;-X}\)</span>) <span class="math display">\[\lim_{ x \to +\infty } f(x)=A \leftrightarrow \forall \epsilon&gt;0, \exists X&gt;0, 当\textcolor{yellow}{x&gt;X}时, 有\mid f(x)-A\mid&lt;\epsilon\]</span></li><li>无穷大不是具体的数, 本身就是一种极限</li><li>无穷大指的是<strong>绝对值</strong>大于任何具体的数, 因此同时包括正无穷大和负无穷大.</li></ul><p><em>函数极限定义2 (自变量<strong>从两侧</strong>趋于<strong>有限值</strong>)</em>: 左右极限分别存在且相等.</p><p><span class="math display">\[\lim_{ x \to x_{0} } f(x)=A \leftrightarrow \lim_{ x \to -x_{0} } f(x)=\lim_{ x \to +x_{0} } f(x)=A\]</span></p><ul><li>函数左极限定义 (自变量<strong>仅从左侧</strong>趋于<strong>有限值</strong>): 右极限就是把范围换成<span class="math inline">\(\textcolor{yellow}{x_{0}&lt;x&lt;x_{0}+\epsilon}\)</span> <span class="math display">\[\lim_{ x \to x_{0}^- } f(x)=A \leftrightarrow \forall\epsilon&gt;0, \exists\delta&gt;0, 当\textcolor{yellow}{x_{0}-\delta&lt;x&lt;x_{0}}时, 有\mid f(x)-A\mid&lt;\epsilon\]</span></li><li><span class="math inline">\(\lim\limits_{ x \to x_0 }f(x)\)</span>是否存在和<span class="math inline">\(f(x_{0})\)</span>是否存在<strong>没有关系</strong></li></ul><h6 id="函数极限的性质">函数极限的性质</h6><p>参照数列极限的性质可以得到相应的函数极限性质, 同样由于函数极限的定义按自变量的变化过程不同有不同形式.</p><ol type="1"><li><strong>唯一性</strong>: 如果<span class="math inline">\(\lim_{ x \to x_0 } f(x)\)</span>或<span class="math inline">\(\lim_{ x \to \infty } f(x)\)</span>存在, 则此极限唯一. 因此: <span class="math display">\[\begin{align*}&amp;\lim_{ x \to +\infty } e^x=+\infty, \lim_{ x \to -\infty } e^x=0 \to \textcolor{pink}{\lim_{ x \to \infty } e^x不存在\ (\lim_{ x \to \infty } e^{\frac{1}{x}}同理)} \\&amp;\lim_{ x \to +0 } \frac{\sin x}{\mid x\mid}=1, \lim_{ x \to -0 } \frac{\sin x}{\mid x\mid}=-1 \to \textcolor{pink}{\lim_{ x \to 0 } \frac{\sin x}{\mid x\mid}不存在} \\&amp;在x=0附近\frac{1}{x}\sin \frac{1}{x}是无界量, 在(-\infty, +\infty)范围振荡\ (因此不是无穷大量) \to \textcolor{pink}{\lim_{ x \to 0 } \frac{1}{x}\sin \frac{1}{x}不存在} \\&amp;\tiny{(可以通过找几个收敛于不同极限的子数列来反证函数不收敛)}\end{align*}\]</span></li><li><strong>局部有界性</strong></li><li><strong>局部保号性</strong></li><li>函数极限与数列极限的关系 (<strong>海涅定理</strong>): <span class="math display">\[\lim_{ x \to x_{0} } f(x)=A \leftrightarrow \begin{cases}\textcolor{red}{\forall \{x_{n}\}}, \lim\limits_{ n \to \infty } \{x_{n}\}=x_{0}, f(x)定义域内 \\\lim\limits_\textcolor{pink}{n \to \infty} f(x_{n})=A\end{cases}\]</span> 💡<span class="math inline">\(x\)</span>是变量而<span class="math inline">\(x_n\)</span>只是具体的数</li></ol><h6 id="两个重要极限">两个重要极限</h6><p><span class="math inline">\(\lim\limits_{ x \to 0 } \frac{\sin x}{x}=1\)</span></p><p><span class="math inline">\(\lim\limits_{ x \to \infty } \left( 1+\frac{1}{x} \right)^x=e\)</span></p><h6 id="求函数极限的方法">求函数极限的方法</h6><ol type="1"><li>化简<ol type="1"><li>提出极限存在<strong>但不为0</strong>的因式</li><li>考虑<span class="math inline">\(t=\frac{1}{x}\)</span>倒代换</li><li>无穷小量替换 (<strong>只能以给整个式子乘以值为1的<span class="math inline">\(\frac{f(x)}{g(x)}\)</span>的方式</strong>):<ul><li><span class="math inline">\(x\to 0\)</span><ul><li><span class="math inline">\(a^x-1\sim x\ln a\)</span></li><li><span class="math inline">\(1-\cos x\sim \frac{1}{2}x^2\)</span></li><li><span class="math inline">\(\ln(x+\sqrt{ 1+x^2 })\sim x\)</span></li></ul></li><li><span class="math inline">\(x\to 1\)</span><ul><li><span class="math inline">\(\ln x\sim x-1\)</span></li></ul></li></ul></li></ol></li><li>判断类型<ol type="1"><li>直接背公式:<ul><li><span class="math inline">\(\lim\limits_{ x \to 0 } x^x=0\)</span></li><li><span class="math inline">\(\lim\limits_{ n \to \infty } \sum\limits^n_{i=1}f\left( \frac{i}{n} \right) \frac{1}{n}=\int^1_{0} f(x) \, dx\)</span></li><li><span class="math inline">\(\lim\limits_{ x \to a } \frac{f(x)}{g(x)}存在\to \lim\limits_{ x \to a } \frac{f(x)}{g(x)}(x-a)=0\)</span></li><li><span class="math inline">\(\lim\limits_{ x \to a } \frac{f(x)}{g(x)}=0\to \lim\limits_{ x \to a } f(x)=0\)</span></li></ul></li><li>有反三角函数直接泰勒展开</li><li>有取整必然用夹逼法</li><li>有根式相减先有理化</li><li>七种未定式<ol type="1"><li><span class="math inline">\(\frac{0}{0}/\frac{\infty}{\infty}/0 \cdot \infty\)</span><ol type="1"><li>洛必达 (<strong>结果存在或为<span class="math inline">\(\infty\)</span>时才有效</strong>)</li><li>泰勒展开</li><li>夹逼法</li></ol></li><li><span class="math inline">\(\infty-\infty\)</span>: 有理化/倒代换/通分</li><li><span class="math inline">\(\infty^0/0^0\)</span>: <span class="math inline">\(\lim u^v=e^{\lim v\ln u}\to e^{0\cdot \infty}\)</span>变成第一种</li><li><span class="math inline">\(1^\infty\)</span>: <strong>(慎用)</strong> <span class="math inline">\(\lim u^v=e^{\lim (u-1)v}\to e^{0\cdot \infty}\)</span>变成第一种</li></ol></li></ol></li></ol><h4 id="函数">函数</h4><h5 id="函数的几种特性">函数的几种特性</h5><ol type="1"><li><strong>有界性</strong></li><li><strong>单调性</strong></li><li><strong>奇偶性</strong></li><li><strong>周期性</strong> 设函数<span class="math inline">\(f(x)\)</span>的定义域为<span class="math inline">\(D\)</span>. 如果存在一个<strong>正数</strong><span class="math inline">\(T\)</span>, 使得对于任意<span class="math inline">\(x \in D\)</span>有<span class="math inline">\((x \pm T) \in D\)</span>, 且 <span class="math display">\[f(x+T)=f(x)\]</span> 恒成立, 则<span class="math inline">\(f(x)\)</span>为周期函数, <span class="math inline">\(T\)</span>称为<span class="math inline">\(f(x)\)</span>的周期. 通常我们说周期函数的周期指的是<strong>最小正周期</strong>.</li></ol><h5 id="一些函数">一些函数</h5><p><em>狄利克雷 (Dirichlet)函数</em>:</p><p><span class="math display">\[D(x)=\begin{cases}1, x \in Q, \\0, x \in Q^c. \\\end{cases}\]</span></p><p><span class="math inline">\(Q\)</span>是有理数集, <span class="math inline">\(Q^c\)</span>是无理数集. 易证任何正有理数<span class="math inline">\(r\)</span>都是它的周期. 因为不存在最小的正有理数, 所以狄利克雷函数<strong>没有最小正周期</strong>.</p><p><em>初等函数</em>: 以下五类函数统称为<strong>基本初等函数</strong>, 由常数和基本初等函数经过有限次四则运算和有限次函数复合所构成并可以用一个式子表示的函数, 称为初等函数.</p><ul><li>幂函数<span class="math inline">\(y=x^ \alpha\)</span></li><li>指数函数<span class="math inline">\(y=a^x\)</span></li><li>对数函数<span class="math inline">\(y=\log_{a}x\)</span></li><li>三角函数</li><li>反三角函数</li></ul><h5 id="函数的连续性">函数的连续性</h5><p>==TODO==</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前前后后数理基础课也学了好几遍了, 但这些内容不常用就容易忘记. 虽然每次学都会记手写的电子笔记, 但这次我打算记一份能长期维护的印刷体电子笔记, 因为大概不会再需要一板一眼地把这几门最基础的课学一遍了. 我的想法是记重要概念, 术语, 重要思路和技巧, 以及一些易错点, 这样当我忘记内容时能很快知道我需要的是什么, 然后具体推导和习题再看教材就好 💪&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程学习笔记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数学" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>探海利器-声呐课程笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2022/05/23/%E6%8E%A2%E6%B5%B7%E5%88%A9%E5%99%A8-%E5%A3%B0%E5%91%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2022/05/23/%E6%8E%A2%E6%B5%B7%E5%88%A9%E5%99%A8-%E5%A3%B0%E5%91%90%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-22T20:35:00.000Z</published>
    <updated>2022-05-22T20:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了<a href="https://www.bilibili.com/video/BV1qu411679n" target="_blank" rel="noopener">哈工程公开课-探海利器-声呐</a>这门概论性质的课对声呐有了一个最基础的了解, 看的过程中记了一些笔记. 搜索的时候还发现另外两门更深入的课程: <a href="https://www.icourse163.org/course/HRBEU-1002013001" target="_blank" rel="noopener">哈工程-水声学</a>, <a href="https://www.xuetangx.com/course/nau07021002103/10327221" target="_blank" rel="noopener">海军航空大学-声纳技术</a>, 有机会也来看一看.</p><a id="more"></a><h2 id="定义和发展方向">定义和发展方向</h2><p>现代声呐: 在水下利用声波进行探测, 导航, 定位, 识别, 通信等所有电子设备的总称.</p><p>发展特点: 低频, 大功率, 宽频带, 高搜索率, 高定位精度</p><p>发展方向:</p><ul><li>先进的信号处理技术</li><li>水声通信和声呐组网技术</li><li>被动声呐技术</li><li>低频大功率主动声呐技术</li></ul><h2 id="海洋">海洋</h2><ul><li><p>是双界面波导, 上面是波浪起伏的海面, 下面是凹凸不平的海底</p></li><li><p>海水中声速受该点温度, 盐度, 压力影响</p><ul><li><p>温度+1, 声速+4.2m/s</p></li><li><p>盐度+1‰, 声速+1.3m/s (淡水中盐度变化对声速影响可以忽略不计)</p></li><li><p>压力+1atm, 声速+0.17m/s</p></li><li><p>声速随海水深度先降后升, 声速最小处称<strong>声道轴</strong>. 在海面附近由于阳光照射温度较高, 越往下温度越低.水深到一定程度后温度几乎不变, 由于盐度和压力也在增加所以速度又增大. 💡淡水中目前没有发现声道轴, 主要受温度影响, 会有声线弯曲.</p><p><img style="width:30%" data-src="./探海利器-声呐课程笔记/声速深度曲线图.jpg"></p></li></ul></li><li><p>海水是时变空变的水声信道 (滤波器). 水声信道特性:</p><ul><li>多途效应<ul><li>引起信号的时间展宽(浅海几百毫秒, 深海几秒), 码间干扰, 改变码元波形并产生误码, 降低系统可靠性和通信速率</li><li>抗多途干扰措施:<ol type="1"><li>增加码元保护间隔 (会降低通信速率)</li><li>使用指向性换能器</li><li>利用衰落的各种选择性, 使用合适的分集技术</li><li>使用合理的调制技术, 扩频技术</li><li>使用合适的自适应技术</li><li>...</li></ol></li></ul></li><li>频散效应: 不同频率声波在海中传播的群速度不同, 因此会有信号的变形</li><li>多普勒频移: 由发射接收相对运动或水流引起, 与相对运动速度和工作频率成正比.</li><li>声传播方向偏转</li><li>在浅海传播时的低频截止现象</li><li>在深海传播时的会聚现象</li></ul></li></ul><h2 id="水声技术与电磁波技术对比">水声技术与电磁波技术对比</h2><ul><li>有多少种运用电磁波的观通设备, 水下就大致有多少种功能类似的声呐</li><li>电磁波速度<span class="math inline">\(3\times10^8m/s\)</span>, 声波在水中速度<span class="math inline">\(1500m/s\)</span>, 决定<ul><li>雷达工作频率约<span class="math inline">\(10^9Hz\)</span>, 声呐频率约<span class="math inline">\(10^3Hz\)</span></li><li>声呐分辨率差, 声图像模糊</li></ul></li><li>信息载体不同 (声波/ 电磁波), 信道不同 (海洋/空气)</li></ul><p><img style="width:80%" data-src="./探海利器-声呐课程笔记/水声信道无线信道对比.jpg"></p><h2 id="类型">类型</h2><h3 id="按工作方式">按工作方式</h3><ul><li><p>主动声呐</p><ul><li>最重要三个影响因素: 环境噪声, 平台噪声, 混响 (来源于气泡, 冷热水团, 不均匀性, 界面的不平整性)</li></ul></li><li><p>被动声呐</p><ul><li>需要获得的信息: 目标自身发出的声信号或者辐射噪声 (机械噪声, 螺旋桨噪声, 水动力噪声)</li><li>干扰: 环境噪声, 平台自噪声 (近场噪声)</li></ul></li></ul><h3 id="按用途分-测绘声呐">按用途分 (测绘声呐)</h3><p>💡 不知道有没有类似平行光源 (比如激光) 概念的平行声源, 理论上是否可实现. 等我有机会问问老师.</p><div style="width:33%; display: inline-block"><p><img data-src="./探海利器-声呐课程笔记/测扫声呐.jpg"></p></div><div style="width:33%; display: inline-block"><p><img data-src="./探海利器-声呐课程笔记/多波束测深声呐.jpg"></p></div><div style="width:32%; display: inline-block"><p><img data-src="./探海利器-声呐课程笔记/浅地层剖面声呐.jpg"></p></div><ul><li><p>测扫声呐: 探测海底底质. 收发合置的测扫声呐只能发射完成再接收, 收发分置的测扫声呐可以边发边收. <img style="width:50%" data-src="./探海利器-声呐课程笔记/测扫声呐原理.jpg"></p><blockquote><p>测扫声呐工作原理 ⚠ 注意6的回波比5先回到换能器.</p></blockquote></li><li>多波束测深声呐: 探测海底地形地貌</li><li>浅地层剖面声呐: 探测海底表面以下分层结构及分层介质的构成</li><li>多功能集成: 基于参量阵, 实现地形, 底质, 地层构造等信息的一体化探测<ul><li>高频/原频: 地形/底质</li><li>低频/差频: 地层构造</li></ul></li></ul><h2 id="声呐信号处理">声呐信号处理</h2><div style="width:47%; display: inline-block"><p><img data-src="./探海利器-声呐课程笔记/声呐系统.jpg"></p></div><div style="width:49%; display: inline-block"><p><img data-src="./探海利器-声呐课程笔记/声呐系统典型构成.jpg"></p></div><blockquote><p>上右图为声呐系统典型构成</p></blockquote><p>声呐信号处理的基础是<strong>海洋环境</strong>和<strong>声场声传播条件</strong>.</p><p>经典声呐信号处理任务: 目标检测, 定位, 识别</p><p>声呐信号处理面临的难题:</p><ul><li>水声信号带宽窄, 数据传输速度低, 声呐搜索速度慢</li><li>波束展宽引起分辨率降低</li><li>性能受环境影响大</li><li>目标及其信号的种类多, 特征复杂</li></ul><h2 id="海底测绘常用海底特性">海底测绘常用海底特性:</h2><ul><li>海底表面的起伏</li><li>海底表面沉积物类别</li><li>海底表面以下的地层构造 (分层结构及沉积物类别)</li></ul><h2 id="水声通信">水声通信</h2><p><img style="width:80%" data-src="./探海利器-声呐课程笔记/海陆空天一体化通信体系.jpg"></p><p>蛟龙号水声通信种类:</p><ul><li>相干水声通信: 高速, 可传输图像</li><li>非相干水声通信: 中速, 用于传输文字, 指令, 数据</li><li>扩频通信: 远程, 低速, 用于传输指令</li></ul><p><img style="width:60%" data-src="./探海利器-声呐课程笔记/水声信道典型带宽.jpg"></p><blockquote><p>水声信道典型带宽</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了&lt;a href=&quot;https://www.bilibili.com/video/BV1qu411679n&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;哈工程公开课-探海利器-声呐&lt;/a&gt;这门概论性质的课对声呐有了一个最基础的了解, 看的过程中记了一些笔记. 搜索的时候还发现另外两门更深入的课程: &lt;a href=&quot;https://www.icourse163.org/course/HRBEU-1002013001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;哈工程-水声学&lt;/a&gt;, &lt;a href=&quot;https://www.xuetangx.com/course/nau07021002103/10327221&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;海军航空大学-声纳技术&lt;/a&gt;, 有机会也来看一看.&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程学习笔记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="水声学" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B0%B4%E5%A3%B0%E5%AD%A6/"/>
    
      <category term="声呐" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%A3%B0%E5%91%90/"/>
    
    
  </entry>
  
  <entry>
    <title>2022年5月15日 版本控制与敏捷项目管理分享</title>
    <link href="https://leojhonsong.github.io/zh-CN/2022/05/23/2022%E5%B9%B45%E6%9C%8815%E6%97%A5%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%86%E4%BA%AB/"/>
    <id>https://leojhonsong.github.io/zh-CN/2022/05/23/2022%E5%B9%B45%E6%9C%8815%E6%97%A5%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%88%86%E4%BA%AB/</id>
    <published>2022-05-22T20:10:00.000Z</published>
    <updated>2022-05-22T20:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近又在<a href="https://uestc-msc.github.io/" target="_blank" rel="noopener">电子科大微软学生俱乐部</a>做了一次分享, 这次的主题是版本控制与敏捷项目管理, 不过因为时间远超我的预期 (我以为一小时就能讲完了结果楞是讲了三个小时), 因此项目管理这部分一笔带过了.</p><a id="more"></a><p><a href="https://github.com/uestc-msc/VCPM-salon" target="_blank" rel="noopener">📑 文字稿</a> (包含视频中用到的所有链接)</p><iframe src="//player.bilibili.com/player.html?aid=726745413&amp;bvid=BV1DS4y1B7XP&amp;cid=723097569&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><p>💡 视频的评论区有带可跳转的时间节点的大纲.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又在&lt;a href=&quot;https://uestc-msc.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电子科大微软学生俱乐部&lt;/a&gt;做了一次分享, 这次的主题是版本控制与敏捷项目管理, 不过因为时间远超我的预期 (我以为一小时就能讲完了结果楞是讲了三个小时), 因此项目管理这部分一笔带过了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="CI/CD" scheme="https://leojhonsong.github.io/zh-CN/categories/CI-CD/"/>
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="版本控制" scheme="https://leojhonsong.github.io/zh-CN/categories/CI-CD/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="git" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
    
  </entry>
  
  <entry>
    <title>LaTeX杂记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2021/04/24/LaTeX%E6%9D%82%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2021/04/24/LaTeX%E6%9D%82%E8%AE%B0/</id>
    <published>2021-04-23T16:00:00.000Z</published>
    <updated>2022-02-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在用LaTeX写毕业论文 (学院支持甚至提供了LaTeX模板真是太幸运了), 在此记录下我写论文用到的一些语法方便以后抄.</p><a id="more"></a><p>为了专注一个主题, 我只想在这里记录一些我可能用到的语法 (要是你只是想写一份精美本科毕设论文的话也不用管太多). 想更系统更详细了解LaTeX的话, 我推荐下列三个详细程度递减的教程:</p><ul><li><a href="http://mirrors.ctan.org/info/lshort/chinese/lshort-zh-cn.pdf" target="_blank" rel="noopener">一份不太简短的LaTeX2ε介绍 (lshot中文版)</a>: 这是一份比较详细的入门教程的中文翻译版, 看完会解开许多初学时可能会有的疑惑, 比如它甚至列出了一些写LaTeX时可能用到或生成的文件类型都是什么用途. 网上各种中文LeTaX资料的名词翻译很不统一, 可以以这份教程的翻译为准. 这份lshort中文版其实不是单纯的翻译, 还增添了涉及中文使用的内容, 这无疑是十分有用的 (对于以后可能要写中文论文的我)</li><li><a href="https://github.com/wklchris/Note-by-LaTeX" target="_blank" rel="noopener">简单粗暴LaTeX</a>: 这份入门教材比上面这个短许多, 因为它更注重实用性内容, 讲解相对更少. 但对于在有模板的情况下写本科毕业论文的需求仍然是妥妥够用的. 而且因为这本书给出了源代码, 你甚至可以看看作者到底是怎么用LaTeX的 (如果你有那个闲心的话)</li><li><a href="https://www.overleaf.com/learn" target="_blank" rel="noopener">Overleaf的LaTeX文档</a>: Overleaf的文档更是讲解很少, 基本每个内容直接是使用示例.</li><li>要是你还想看更多内容, 可以先看看<a href="https://www.latexstudio.net/archives/51802.html" target="_blank" rel="noopener">LaTeX工作室推荐的资料</a>.</li></ul><p>另外推荐一个<a href="http://latexref.xyz/" target="_blank" rel="noopener">LaTeX命令参考手册</a>, 可以在这搜索想查的命令.</p><h2 id="给我用overleafvscode写">给我用Overleaf/VSCode写</h2><p>我是在Linux系统下用安装了<a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop" target="_blank" rel="noopener">LaTeX Workshop</a>插件的VSCode写的LaTeX, 这个插件通过调用你安装的LeTaX发行版来提供丰富的LeTaX支持. 我使用的发行版正是LaTeX Workshop最推荐的<a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">Tex Live</a>. 这东西的离线安装包有点大, 而且很有可能需要单独下一些包, 有点麻烦. 幸好我Manjaro系统一句<code>yay -S texlive-most texlive-lang biber</code>就把我下面需要用到的所有工具都安装好了. <strong>如果你目前没有安装Tex Live, 不妨先试试在<a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a>在线编辑LaTeX试试, 操作很简便, 下述操作中除了<a href="#术语表">术语表</a>处我的方案需要额外工具<code>bib2gls</code>Overleaf上没有外都支持, 非常省事.</strong> 比本地编辑器好的一点是Overleaf开箱即用地支持多人在线协作.</p><p>只要你不是要写上百页的论文, Overleaf绝对是够用的, 但反正Manjaro上Tex Live下着很容易, 而且我又喜欢折腾, 我就试着本地写LaTeX. 试了一圈后<strong>我只推荐用VSCode当本地编辑器</strong>. 那些LaTeX专用编辑器看网上说法体验起来功能并没有比Overleaf多什么, 而且很丑 (我已经搜的是这些软件最新版的截图了)... 而用VSCode就不一样了, 如果你熟悉VSCode你就应当知道VSCode能做到非常高度的自定义 (补全, 代码段, 语法检查, 拼写检查, 皮肤等), 而且因为VCSode是基于Chromium开发的因此天然支持内置浏览pdf. 相比<code>vim + Okular</code>这样的尴尬方案, VSCode的LaTeX Workshop插件使得在VSCode中的LaTeX与pdf的正反向搜索 (正向搜索就是在生成的pdf中搜索指定LaTeX源代码对应的内容, 反向搜索就是反过来) 精度非常高, 比起<code>vim + Okular</code>方案只能精准到对应行, VSCode能精准到单词! 此外LaTeX Workshop也提供了许多贴心的功能, 比如可以很容易地自己配置编译工具链, 自动格式化并排序bib引用文件等, 支持<a href="https://github.com/James-Yu/LaTeX-Workshop/wiki/View#invert-mode" target="_blank" rel="noopener">pdf反色</a>晚上长时间写LaTeX也不怕泪目...</p><p>💡 关于如何安装Tex Live可以看看<a href="https://oi-wiki.org/tools/latex/#_4" target="_blank" rel="noopener">这个说明</a>.</p><!-- TODO: 是哪个没法实现最好指出 基本就bib2gls? --><h2 id="项目结构">项目结构</h2><p>首先是关于这东西从哪开始写. 不了解的话会觉得LaTeX的文件又多语法又乱七八糟, 那么要写个LaTeX的"Hello World"该怎么做? 这个其实很简单:</p><ol type="1"><li><p>创建一个tex文件, 比如<strong>first.tex</strong>: </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{article}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line">Hello World</span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p>如果你已经正确安装了Tex Live那么环境里应当已经有<code>xelatex</code>这个可以生成tex文件对应pdf的工具了. 在<strong>first.tex</strong>所在文件夹执行<code>xelatex first.tex</code>. 然后你会发现文件夹里多了三个文件: <strong>first.pdf</strong>, <strong>first.aux</strong>, <strong>fisrt.log</strong>. 后两个文件基本是无关紧要的东西, 我在我的VSCode里设置了每次构建后删除这些文件. 而这个<strong>first.pdf</strong>正是我们需要的pdf文件 🎉</p></li></ol><p>要用LaTeX写一个简单文档需要的语法都很简单没有争议, 需要的工具也只有<code>xelatex</code>. 想快速了解LaTeX最基本的语法可以看看<a href="https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes" target="_blank" rel="noopener">Overleaf的30min入门教程</a>. 不过其实用不了30分钟, 因为只讲了最基础的内容因此大致看一遍了解一下就好😂. 看了一些教程后我觉得Overleaf的文档是非常简短 (因此很不详细) 但足够全面的了, 最重要的是<strong>基本用的都是最新最简洁的语法</strong> (正如现在有些python问题还有人在给出python2的绕来绕去的方案, 随便看网上说法会觉得LaTeX怎么这么麻烦功能这么少 🤦‍♂️). 因此后文的文档参考我也基本是给出的是Overleaf的文档.</p><p>大致看了一遍上面链接后就知道怎么用LaTeX写一份用Markdown或者word写也很方便的文档啦. 但要用来写一份高逼格论文的话还需要深入一些, 不然LaTeX的优势也体现不出来了. 首先来看一些绕不开且容易的语法, 然后是各种插入富文本的语法, 最后是关于让引用不管是插入还是看起来体验都更好的内容 (因为需要更改构建工具链这个部分在overleaf无法实现).</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── 📁Appendices        各个附录的tex文件文件夹</span><br><span class="line">├── 📁Figures           图片文件夹</span><br><span class="line">├── 📁Front             前置页的tex文件文件夹</span><br><span class="line">├── 📁Sections          各个章节的tex文件文件夹</span><br><span class="line">├── 📑main.tex          根文件</span><br><span class="line">└── 📑References.bib    所有引用的bibtex放这里</span><br></pre></td></tr></tbody></table></figure><p>在Overleaf的快速教程中能看到只用一个tex文件就可以写LaTeX了, 但一般见到的论文模板都是多个文件的 (比如我更新的<a href="https://github.com/LeoJhonSong/UESTC-Glasgow-Final-Year-Report-Template/blob/master/README.md" target="_blank" rel="noopener">学院毕设模板</a>), 类似上面☝这样的结构. 将不同内容分别放在不同文件, 不然太长了不方便组织以及查找出错地方. 通常在根目录的<strong>main.tex</strong>被作为根文件 (root file), <strong>只有根文件中有<code>\begin{document}</code></strong>. 通常习惯将各种全局设置, 包的引用, 标题, 作者, 自己定义的新命令, 宏定义等导言 (<a href="https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes#The_preamble_of_a_document" target="_blank" rel="noopener">preamble</a>), 都放在<strong>main.tex</strong>中. 而<code>\begin{document}</code>后的正文内容基本是以<code>\include{}</code>插入在<strong>Front</strong>, <strong>Sections</strong>, <strong>Appendices</strong>中的tex文件, 以及插入目录, 插入图表索引, 插入引用的语句等. 也就是说<strong>main.tex</strong>中没有具体内容, 基本是环境配置, 参数设置, 大纲这样子. 给一个毕设论文的main.tex的大致结构:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{article}</span><br><span class="line">% 导言部分 (preamble)</span><br><span class="line">% 一些包的导入, 一些全局设置等</span><br><span class="line">% ...</span><br><span class="line">% 将图表目录, 术语表, 参考文献列表显示在目录中. nottoc参数是不将目录本身显示在目录中</span><br><span class="line">\usepackage[nottoc]{tocbibind}</span><br><span class="line">% 如果想让术语可点击, 需要在导入hyperref包后导入glossaries-extra, 而hyperref包是最好最后导入的.</span><br><span class="line">% 也就是说现在是hyperref倒数第二个导入, glossaries-extra最后导入</span><br><span class="line">\usepackage[symbols, nogroupskip, record]{glossaries-extra}</span><br><span class="line">\GlsXtrLoadResources[</span><br><span class="line"> src={Notations},  % 术语都放在根目录下Notations.bib文件里</span><br><span class="line"> type=symbols,  % put these entries in the 'symbols' glossary (这两句英语注释我抄来的, 懒得管到底什么意思了)</span><br><span class="line"> save-locations=false  % don't save locations</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">% 正文部分 (指大纲)</span><br><span class="line">\begin{document}</span><br><span class="line">\pagestyle{plain}</span><br><span class="line">\include{Front/Cover.tex}</span><br><span class="line"></span><br><span class="line">\pagenumbering{roman}  % 正文前页数页码用罗马数字计数 (如果显示在目录里, 也会是罗马数字页码)</span><br><span class="line">\include{Front/Abstract.tex}</span><br><span class="line">\include{Front/Acknowledgement.tex}</span><br><span class="line">% 一些目录</span><br><span class="line">\tableofcontents  % 目录</span><br><span class="line">% \pagebreak  % 如果图表目录另起一页目录页最后也不会显得空那就另起一页</span><br><span class="line">\listoffigures  % 图目录</span><br><span class="line">\listoftables  % 表目录</span><br><span class="line">\pagebreak  % 另起一页</span><br><span class="line">\printunsrtglossary[type=symbols,style=long,title={List of Notations}]  % 术语表</span><br><span class="line">\pagebreak</span><br><span class="line"></span><br><span class="line">% 这开始是文章内容了</span><br><span class="line">\pagestyle{headings} % 切回正文的页眉页脚格式</span><br><span class="line">\pagenumbering{arabic}  % 这里开始用阿拉伯数字页码</span><br><span class="line">\include{Sections/Section1.tex}</span><br><span class="line">\include{Sections/Section2.tex}</span><br><span class="line">\include{Sections/Section3.tex}</span><br><span class="line">\include{Sections/Section4.tex}</span><br><span class="line">\include{Sections/Section5.tex}</span><br><span class="line">% 参考文献列表</span><br><span class="line">\setcounter{biburllcpenalty}{7000}  % 这两句是为了参考文献列表中跨行的网页链接也能正常使用</span><br><span class="line">\setcounter{biburlucpenalty}{8000}</span><br><span class="line">\printbibliography[heading=bibintoc]</span><br><span class="line">\appendix  % 告诉LaTeX这后面的章节都是附录. 在目录里附录章节就不是12345排序的了, 是ABCD这样大写字母顺序的</span><br><span class="line">\include{Appendices/Appendix.tex}</span><br><span class="line">\end{document}</span><br><span class="line">% 这后面即便有内容也会被忽略</span><br></pre></td></tr></tbody></table></figure><div class="note info">            <p>如果有看不懂到底怎么操作的地方, 可以看看我搓的<a href="https://github.com/LeoJhonSong/UESTC-Glasgow-Final-Year-Report-Template" target="_blank" rel="noopener">学院毕业论文的完整模板</a></p>          </div><p>💡 也有的模板是单独将导言放在一个文件, 根文件中则只有正文. 到底怎么分割文件其实都可以, 最重要的是要<strong>能让自己分清哪部分是导言</strong>. 具体正文中引用哪些包, 配置什么全局参数会出问题我没有一一试过, 但文档推荐放在导言部分的语句就尽量听文档的, 免得出问题 👍</p><ul><li>插入tex文件内容可以用<code>\include{}</code>或者<code>\input{}</code>, 区别在于<code>\include{}</code>会另起一页再插入内容, 如果刚好一个文件放一章的话, 那每章开头都会另起一页 (看着会比较多).</li><li><code>\pagestyle{}</code>是用来设置页眉页脚样式的. 在<a href="https://www.overleaf.com/learn/latex/Headers_and_footers#Setting_page_style_for_current_page_only" target="_blank" rel="noopener">Overleaf的页眉页脚文档</a>中可以看到<code>plain</code>样式是没有页眉, 有显示页码的页脚. 因为我<strong>Cover.tex</strong>中的内容包含在<code>titlepage</code>环境中, 所以不显示页码. 之所以把<code>\pagenumbering{roman}</code>放在插入封面页后面是因为要是调换顺序, 封面页还是不会显示页码, 摘要页页码则是<strong>ii</strong>, <strong>i</strong>页就消失了. 我这种写法目录页, 图表目录和术语表也会有罗马数字页码, 不想要的话可以在这几页前设置<code>\pagestyle{empty}</code>, 就什么页眉页脚都没有了.</li></ul><h3 id="术语表">术语表</h3><div><img style="width:40%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/notation.jpg"></div><p>论文中有很多专业名词/缩写/符号的话可以放一个术语表在前头, 类似上面☝这样, 在这个表上也可以反向列出这些词都在哪里出现过. 在术语表的实现上<a href="https://www.overleaf.com/learn/latex/Glossaries#Compiling_the_glossary" target="_blank" rel="noopener">overleaf给出的方案</a>只是最基础的方式, 这里有个<a href="http://mirror.ctan.org/macros/latex/contrib/glossaries/glossaries-user.html#tab:options" target="_blank" rel="noopener">术语表实现方案比较表</a>, 不过对比得比较细节. 大意就是用<code>bib2gls</code>的方案除了需要额外安装<code>bib2gls</code>和java的缺点全是优点. 而这两个东西一点都不难安: <code>bib2gls</code>似乎并不需要额外安装, 至少我这安装了<em>texlive-most</em>后就已经有了. 而Java, 至少在Linux系统上, 网上随便一搜就一堆教程, 基本也就是几句命令的事. 从上图我的示例可以看出这个方案生成的术语表可以很好的排序混杂有希腊字母以及下标的各种术语, 而且用一个单独的bib文件管理所有术语, 只有文章里实际用到的术语才会列在术语表里, 很省心.</p><p>安好了<code>bib2gls</code>和java, 如果你是用VSCode来编辑LaTeX的, 那事情很简单. 打开VSCode的用户级配置json, 然后把LaTeX Workshop的编译工具链方案配置改成这个 (反正默认配置json里还有默认配置, 别担心):</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"xelatex ➞ bib2gls ➞ biber ➞ xelatex"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="string">"bib2gls"</span>,</span><br><span class="line">            <span class="string">"biber"</span>,</span><br><span class="line">            <span class="string">"xelatex"</span></span><br><span class="line">        ]</span><br><span class="line">    },</span><br><span class="line">],</span><br></pre></td></tr></tbody></table></figure><p>等你重启VSCode后你会发现LaTeX Workshop插件的面板里<strong>Build LaTeX project</strong>一栏里就只有<em>xelatex ➞ bib2gls ➞ biber ➞ xelatex</em>这一个方案了 😏 这样一来就配置好了, 接下来只需要想上面的模板一样导入<strong><em>glossaries-extra</em></strong>包, 在自己的术语表bib文件中加点术语, 就可以在正文中用<code>\gls{}</code>来插入术语了! 具体例子看<a href="https://tex.stackexchange.com/a/366282" target="_blank" rel="noopener">这个回答</a>的<strong>Method 4</strong> (得往下翻翻).</p><p>💡 之所以要调用两次<strong>xelatex</strong>是因为文中对图表的引用, 术语表的引用等交叉引用第一次编译只会生成在辅助文件 (aux) 中, 第二次编译才会生成完整的文章. <strong>biber</strong>是干嘛用的<a href="#引用">后文</a>会说到.</p><h2 id="版式">版式</h2><p>在<code>main.tex</code>最开头:</p><p>💡 方括号中为可选参数, 我只是列出我觉得比较有用的参数, 按需添加.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[</span><br><span class="line">    12pt,  % 设置字号为12pt. 默认字号为10pt, 但好像一般都要求12pt</span><br><span class="line">    twoside,  % 设置双开页. article和report默认为单页</span><br><span class="line">    twocolumn,  % 设置为全文双栏排版. 默认为单栏. 使用multicols环境更好用, 可以设置多栏</span><br><span class="line">    showframe,  % 用线框可视化显示当前布局各边距大小</span><br><span class="line">    draft  % 指定为草稿模式, 会进行简化使生成更快, 在断行不良/溢出出加黑色方块给出提示. 默认为final (终稿模式)</span><br><span class="line">]{article}  % 设置文档类型为article (常规文档), 可能的文档类型还有report (较长的报告, 如博士论文, 技术报告等), book等</span><br><span class="line"></span><br><span class="line">\usepackage[</span><br><span class="line">    a4paper,  % 纸张大小在\documentclass的参数中也可以设置, 但在这统一管理尺寸问题比较省事. 默认大小为美式信纸 (letterpaper)</span><br><span class="line">    inner=2.5cm,</span><br><span class="line">    outer=2cm,</span><br><span class="line">    top=2cm,  % 上边距</span><br><span class="line">    bottom=2cm  % 下边距</span><br><span class="line">]{geometry}  % 使用geometry这个包设置更具体的页面大小和页边距</span><br><span class="line"></span><br><span class="line">% 将行间距设置为1.5倍 (显得多一些)</span><br><span class="line">\usepackage{setspace}</span><br><span class="line">\onehalfspacing{}</span><br></pre></td></tr></tbody></table></figure><h3 id="布局页边距设置">布局/页边距设置</h3><p><a href="https://www.overleaf.com/learn/latex/Page_size_and_margins" target="_blank" rel="noopener">Overleaf相关文档</a></p><p>因为我的本科毕业论文是要打印的 (但最后也没打印555), 我就设置了<strong>双开页</strong>, 作用在于页面会有左右之分了. 比如我们学院要求内侧页边距2.5cm, 外侧页边距2cm, 那么左边这页的左页边距为2cm, 右页边距为2.5cm, 而右边这页的左页边距为2.5cm, 右页边距为2cm. 之所以内侧页边距多一些是给装订留一些出血 (就是会被装订得看不到的余地). 使用<code>showframe</code>这个选项的话生成的pdf会以线框的形式可视化显示到底布局是怎样的, 就能很明心啊看出左右两页不一样了. 另外页眉页脚位置, 页码位置也会是左右对称的, 如果你设置了显示这些的话.</p><h3 id="字体及中文支持">字体及中文支持</h3><p>全文的字体大小在<code>\documentclass[]{}</code>的参数中指定, 基本就用12pt. 在此处指定字体大小后文中想改变字体大小实际是通过<code>\large</code>, <code>\small</code>这样的命令给出的, 并不使用具体字号. 关于字体大小更多的设定我暂时没有研究过.</p><p>实际上想用latex文件生成pdf有好几个编译器可以用, 最常被提到且速度最快的是<code>pdflatex</code>, 但pdflatex对UTF-8支持不够好, 对现代字体支持也不够好, 而且可能因为我的文档页数不够多, 我真没体验出速度有什么差别. <code>xelatex</code>对特殊字符及现代字体支持很好, 对中文兼容也很好, 因此目前我更偏向使用xelatex. 这个编译器生成的pdf文件会比pdflatex无参数生成的小不少, 因为它默认会进行无损压缩.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\usepackage{fontspec}</span><br><span class="line">\setromanfont{Times New Roman}  % 指定普通字体</span><br><span class="line">\setsansfont{Arial}  % 指定无衬线字体</span><br><span class="line">\setmonofont{Courier New}  % 指定等宽字体</span><br><span class="line">\usepackage{xeCJK}  % 中文支持</span><br></pre></td></tr></tbody></table></figure><p>当使用<code>xelatex</code>作为编译器时可以使用<strong><em>fontspec</em></strong>包来指定字体. 更详细的指定方式参见<a href="https://es.overleaf.com/learn/latex/XeLaTeX" target="_blank" rel="noopener">Overleaf的文档</a>. 不过虽然我们学院的论文格式要求也对字体提出了要求, 但所要求的<strong>Times New Roman</strong>, <strong>Arial</strong>这几个字体其实都是Windows系统专有的. 我的Manjaro系统虽然也有替代字体, 但是我感觉默认字体看着也挺好而且老师其实没管所以就没折腾. 实际写作我并没有主动使用过切换字体的命令, 暂时感觉用不到.</p><p>当设置好全文字体大小及字体后, 在文中想设置文字的样式, 比如加粗/斜体/下划线/小型大写字母, 或者大点/小点的, 用到的命令<a href="https://www.overleaf.com/learn/latex/Font_sizes%2C_families%2C_and_styles#Reference_guide" target="_blank" rel="noopener">这里</a>有一个列表可查. 注意变更样式的部分用大括号括起来, 不然后面所有字符的样式都会维持这样.</p><h3 id="两个常见问题">两个常见问题</h3><h4 id="如何创建能在目录中显示的四级标题">如何创建能在目录中显示的四级标题</h4><p>LaTeX原生提供了7级标题:</p><ul><li><strong>-1</strong> <code>\part{}</code> (只有report和book类型文档中可用)</li><li><strong>0</strong> <code>\chapter{}</code> (只有report和book类型文档中可用)</li><li><strong>1</strong> <code>\section{}</code></li><li><strong>2</strong> <code>\subsection{}</code></li><li><strong>3</strong> <code>\subsubsection{}</code></li><li><strong>4</strong> <code>\paragraph{}</code></li><li><strong>5</strong> <code>\subparagraph{}</code></li></ul><p>💡如果刻意不想让某一章节/子章节之类出现在标题中, 那就用<code>\section*{}</code>, <code>\subsection*{}</code>这样带星号的.</p><p><code>\paragraph{}</code>和<code>\subparagraph{}</code>无法被显示在目录中, 在文中看着也不太像是标题, 更像加粗的正文. 下图中<strong>test 1</strong>为<code>\paragraph{}</code>, <strong>test 2</strong>为<code>\subparagraph{}</code>, <strong>test 3</strong>为<code>\subsubsection{}</code>.</p><div><img style="width:80%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/sections.jpg"></div><p>因此真要说的话在article这种文档类型中LaTeX原生提供的标题只有三级. 要是写短篇论文的话确实也不需要更小的标题了, 但是记个笔记之类还是有可能需要更多级的标题. <a href="https://tex.stackexchange.com/questions/60209/how-to-add-an-extra-level-of-sections-with-headings-below-subsubsection" target="_blank" rel="noopener">这个stackoverflow问题</a>有给出一些解决方案.</p><h4 id="underfull和overfull警告是什么">underfull和overfull警告是什么</h4><p>这两种警告是在编译后非常常见的警告, 意味着编译器在这一行找不到合适的换行的地方, 导致这一行在文字框限制内排版出来要不是太空了 (underfull) 要不就是太挤了 (overfull). 也就是说这基本是英文这样的字母语言才会遇到的问题. Overleaf<a href="https://www.overleaf.com/learn/how-to/Understanding_underfull_and_overfull_box_warnings" target="_blank" rel="noopener">这篇文章</a>很详细讲了原因, 但几乎没给处理办法. 💡 要注意其中提到的<strong><em>microtype</em></strong>包xelatex<a href="https://tex.stackexchange.com/questions/118713/is-microtype-fully-supported-now-by-xelatex-if-not-how-can-i-keep-myself-up-to" target="_blank" rel="noopener">目前几乎不支持</a>, 但我感觉我就用默认排版工具生成的pdf排版也还挺好的? 以下是一些关于断行的小技巧.</p><h5 id="断词与不要断词">断词与不要断词</h5><p>实际上遇到行末长单词干扰LaTeX排版的时候LaTeX会自动按音节将这个长单词断词, 在行末留个<code>-</code>. 不过有时会想要指定一些单词的断词位置, 有两种方式: 1. 在正文中通过加入<code>\-</code>允许在此处断词. 可以指定多处允许断词的地方, 然后LaTeX会选择其中一个位置来断词: </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what a phen\-omen\-on.</span><br></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>在导言部分用<code>\hyphenation{}</code>指定一组词的断词位置. 同样, 需要断词时LaTeX会从指定的几个位置之一断词. 💡注意这些词是大小写不敏感的: <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hyphenation{hy-phe-n-a-tion t-est}  % 指定hyphenation和test的断词位置</span><br></pre></td></tr></tbody></table></figure></li></ol><p>而有时甚至会不想这个词断掉, 还是有两种方式: 1. 在正文中用<code>\mbox{}</code>强制一串字符不被断开: </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KFC phone number is \mbox{400 823 823}</span><br></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>其实<code>\hyphenation{}</code>也可以用来指定一组禁止被断词的单词. 只要不给出断词位置, 就会被认为不能断词: <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\hyphenation{hyphenation python}  % 指定hyphenation和python不能被断开</span><br></pre></td></tr></tbody></table></figure></li></ol><h5 id="空格">空格</h5><p>看教程前我其实是没注意到的, LaTeX排版出的空格竟然有这么些细小区别...</p><ul><li>在LaTeX中多个空格会被当成一个空格 (多个回车也只会产生到下一段的效果). 想用word那样的空格魔法或者回车魔法的话用<code>\hspace{len}</code>和<code>\vspace{len}</code> 😏.</li><li><strong>带子</strong> (tie) <code>~</code>. 在两个单词间加<code>~</code>而不是空格能产生一个不会被断行的空格. 一般用在人名之类的地方.</li><li>句末标点 (<strong>小写字母</strong>后的./?/!) 后的空格会比普通空格长一些. 之所以强调是小写字母后的, 是因为以大写字母结尾会被LaTeX认为最后这个词是人名因而不加长空格. 此时 (如果你真在意这个的话) 用<code>\@</code>手动指明. 你会发现下面这个图里<code>OK.</code>后的空格长度确实有区别, 但区别非常小: <img style="width:80%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/space.jpg"> 另一种情况则是非句末标点被识别为句末标点了, 比如"Prof. Smith". 此时可以用<code>~</code>或者<code>\</code> (👈 注意\后面有个空格)来缩短间距. 不过<code>~</code>不允许空格处断行而<code>\</code>允许.</li><li>还有时会看到<code>\Tex{} Live</code>或<code>\Tex\ Live</code>这样明明不支持参数的命令 (如<code>\Tex</code>) 后却有{}或者<code>\</code>, 这是为了让不支持参数的命令后的空格能被正常排版.</li></ul><h5 id="手动断行">手动断行</h5><p>用<code>\\</code>可以在段落内手动换行. 但不同于在word中到处用回车, <a href="https://www.overleaf.com/learn/how-to/Understanding_underfull_and_overfull_box_warnings?#Notes_on_using_.5C.5C" target="_blank" rel="noopener">无脑<code>\\</code>似乎是不被推荐的</a>. 在上文中推荐的<em>一份不太简短的LaTeX2ε介绍</em>中<strong>2.4.2 手动断行和断页</strong>这节有提到几种断行命令的具体区别 (但我感觉没必要管就没看).</p><h2 id="超链接">超链接</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\usepackage[svgnames]{xcolor}  % colouring</span><br><span class="line">\definecolor{bleu_cite}{RGB}{34,111,212}</span><br><span class="line"></span><br><span class="line">\usepackage{hyperref}  % 这个包的导入最好放在导言区最后</span><br><span class="line">\hypersetup{</span><br><span class="line">    colorlinks=true,</span><br><span class="line">    linkcolor=LightSlateGray,  % 默认值red</span><br><span class="line">    citecolor=bleu_cite,  % 默认值green</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这年代写论文超链接肯定得有, 不然逼格不太够. 导入了<strong><em>hyperref</em></strong>这个包, 目录, 参考文献引用, 图表的交叉引用, 网页链接等才会具有超链接的特性. 上面是我的配置. 导入<strong><em>xcolor</em></strong>包可以用<code>\definecolor{}</code>命令自定义一些颜色, 带参数的话也可以使用<strong><em>xcolor</em></strong>提供的很多种颜色, 比如上面用的<code>svgnames</code>这个颜色集里有<code>LightSlateGray</code>. 我基本就用这个颜色集, 下图列出了<em>svgnames</em>提供的所有颜色. 这里的<em>linkcolor</em>指的不是网页链接的颜色, 是页内链接的, 比如目录, 术语到术语表的跳转链接等. 网页链接的颜色值对应的是<em>urlcolor</em>, 默认颜色是品红色, 还挺好看的, 我就没改. 正如在有的论文中见到的那样, 超链接也可以改成带颜色框的样式, 操作方式参考<a href="https://tex.stackexchange.com/questions/50747/options-for-appearance-of-links-in-hyperref" target="_blank" rel="noopener">这个回答</a>.</p><div><p><img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/color1.jpg"> <img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/color2.jpg"></p></div><h2 id="加速生成">加速生成</h2><h3 id="草稿模式">草稿模式</h3><p>随着工程大起来生成pdf会变慢, 有一些技巧可以加速生成不完整的pdf, 在写作过程中快速检查. 因为LaTeX每次生成并不能利用.</p><p>一种方式是开启草稿模式. 方式是在上面提到的<code>\documentclass[]{}</code>的参数里加个<code>draft</code>. 以草稿模式生成的pdf里图片不会实际插入, 是用一个同样大小的方框来表示. 超链接, 书签等功能也会被关闭. 另外比较好的一点是在underfull/overfull的行会被在行末添加一个黑色方块标记出来.</p><h3 id="xelatex的pdf压缩等级">xelatex的pdf压缩等级</h3><p>xelatex在生成pdf时默认会进行压缩, 这会让生成的pdf相对很小, 同时也会耗时更长. 写作过程中其实并没有必要压缩pdf, 那可以设置压缩等级为0加速pdf生成, 等生成最终版pdf时再把压缩等级拉满设为9.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 放在导言部分</span><br><span class="line">\special{dvipdfmx:config z 0}  % 👈这个0换成9就是最大压缩等级了.</span><br></pre></td></tr></tbody></table></figure><h2 id="插入">插入</h2><h3 id="数学公式-样式">数学公式, 样式</h3><p>这个CSDN上的<a href="https://blog.csdn.net/ethmery/article/details/50670297" target="_blank" rel="noopener">LaTeX基本数学公式语法</a>列出了希腊字母, 上下标, 矢量, 特殊符号, 矩阵等数学公式常用命令, 还挺全的.</p><p>作为一个菜鸟我还没用LaTeX写过很复杂的公式, 因此还没有用过<strong><em>amsmath</em></strong>这个增强<a href="https://www.overleaf.com/learn/latex/Aligning%20equations%20with%20amsmath" target="_blank" rel="noopener">公式排版</a>的包, 但据overleaf这篇文章原生支持对排版支持不够好, 因此我先码住.</p><p>然后这还有一篇Overleaf的<a href="https://www.overleaf.com/learn/latex/Mathematics" target="_blank" rel="noopener">数学相关内容合集</a> 🐮</p><h3 id="浮动体">浮动体</h3><p>figure和table是LaTeX原生的两种浮动体环境, 用于灵活排版图片和表格, 并且为图表标题 (caption) 提供环境 (就是说即便不放在浮动体里也可以将图片表格插入LaTeX). 而且其实这两种环境中什么都能放, 没有限定只能放图片或表格. 这两种环境都可以给[<em>placement</em>]参数 (默认是<code>btp</code>), 通过指定<code>htb</code>限制只能放在这三种位置 (也就是不允许单独成页). 可用参数参见<a href="https://www.overleaf.com/learn/latex/Inserting_Images#Positioning" target="_blank" rel="noopener">这附近有的一个表格</a>. 值得一提的是LaTeX总是以h-t-b-p的优先级来决定浮动体位置, 和填的参数的顺序无关. 💡 除单独成页外, 默认每页不超过3个浮动体, 其中顶部不超过2个, 底部不超过1个以及浮动体空间占页面的百分比 (默认顶部不超过70%, 底部不超过30%)</p><p>关于双栏环境下浮动体的排版以及其他细节见<em>一份不太简短的LaTeX2ε介绍</em>的<strong>3.9 浮动体</strong>.</p><h4 id="图片">图片</h4><p>先上一个论文利用的懒人模板样例 (效果如图):</p><div><img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/figure.jpg"></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% 导言部分</span><br><span class="line">\usepackage{graphicx}  % 图片插入支持宏包</span><br><span class="line">\graphicspath{{./}}  % 将之后插入图片的检索路径设为根文件所在目录, 不然插入图片时的图片地址是相对于当前tex文件的, 会比较麻烦</span><br><span class="line">% \graphicspath{{./Figures}}  % 其实更常见的是直接将检索路径设为你的图片文件夹, 但我为了能触发我VSC的路径补全所以只设成了根文件所在目录</span><br><span class="line">\usepackage[</span><br><span class="line">   colorlinks=true,</span><br><span class="line">]{hyperref}  % 给交叉引用的引用编号添加超链接支持</span><br><span class="line"></span><br><span class="line">% 正文部分</span><br><span class="line">\begin{figure}[htb]</span><br><span class="line">      \centering  % 让图片居中. 默认是左对齐</span><br><span class="line">      \includegraphics[width=0.8\textwidth]{Figures/mesh.jpg}  % 限制图片宽度为0.8倍版面宽度</span><br><span class="line">      \caption[Test]{Test: blablabla}\label{f:mesh}</span><br><span class="line">\end{figure}</span><br><span class="line"></span><br><span class="line">As you can see in \autoref{f:mesh}, the function grows near 0.</span><br></pre></td></tr></tbody></table></figure><p>用<code>\caption</code>命令可以给图片等浮动体加标题, 在<code>{}</code>中的是长标题, 就是显示在图下那个. 而在<code>[]</code>中的短标题是会显示在图目录中的标题 (用<code>\listoffigures</code>来生成图目录). 我习惯在长标题里开头用短标题, 能实现很多论文里<strong>概要: 详细描述</strong>的图标题形式.</p><p><code>\lable</code>是交叉引用, 可以用来在文中提及章节/公式/图表等. 导入<strong><em>hyperref</em></strong>包能支持点击引用处跳转, 这样体验才够良好. 用<code>\autoref</code>而不是<code>\ref</code>能让整个引用编号 (比如上面的红色的<strong>Figure 1</strong>)而不是只有<strong>1</strong>是超链接. <code>\ref{}</code>或者<code>\autoref{}</code>的参数可以随便写, 之所以加个<code>f:</code>的前缀是为了将图片, 表格等类交叉引用区别开, 方便管理, 比如说VSC的LaTeX Workshop支持交叉引用的补全提示.</p><p>细节解释可以参考这几个链接: - <a href="https://www.overleaf.com/learn/latex/Inserting_Images#Generating_high-res_and_low-res_images" target="_blank" rel="noopener">Overleaf的插入图片全教程</a> - <a href="https://tex.stackexchange.com/questions/24496/use-caption-and-long-description-for-figure/422496" target="_blank" rel="noopener">如何添加图片短标题</a> - <a href="https://tex.stackexchange.com/a/53062" target="_blank" rel="noopener">如何在表格中插入图片</a> - <a href="https://tex.stackexchange.com/questions/101645/how-to-turn-latex-figure-by-90-degrees-along-with-the-caption" target="_blank" rel="noopener">如何旋转图片</a></p><p>还有一点是如何插入矢量图形. 目前所有LaTeX编译器都没有对svg提供原生支持, 倒是<a href="https://tex.stackexchange.com/questions/2099/how-to-include-svg-diagrams-in-latex" target="_blank" rel="noopener">有办法可以强行插入svg</a>, 但是也很麻烦. 其实解决办法很简单: <strong>不要插入svg</strong> 😁 svg可以很容易地被转为pdf, 而LaTeX对pdf插入支持很好 (其实现在这年代LaTeX中插入矢量图片就是插入pdf). 在Linux下可以用<strong>inkscape</strong>打开svg然后直接另存为pdf. ❗注意不要勾选<em>Omit text in PDF and create LaTeX file</em>. 这狗屎东西会把你svg里的文字无脑转为LaTeX然后你会发现你好不容易排版的文字在LaTeX里绘制出来后大小, 字体都是正文字体, 经常直接没法看. 直接转为pdf的话会生成一个和svg同样尺寸的pdf, 透明部分会被填充为白色, 不过写论文的话这样刚好.</p><p>关于制作论文用矢量图, 因为我目前并不需要绘制复杂的矢量图, 基本是给位图或者程序生成的矢量图加点箭头文字然后排版一下之类. 因此我目前就是PPT做图, 全选当前页上所有东西 (如果你也是一页PPT画一张图的话), 然后另存为svg, 免得想在其他电脑/WPS编辑时发现不太兼容 (更保险一点你可以<a href="https://support.microsoft.com/zh-cn/office/%E5%B5%8C%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%9A%84%E5%A5%BD%E5%A4%84-cb3982aa-ea76-4323-b008-86670f222dbc" target="_blank" rel="noopener">将字体嵌入PPT</a>, 防止出字体问题). 如果你做的这张图用到了PPT的背景, 存svg是没法把背景一块存下来的. 此样的话选打印, 然后选仅打印当前页, 这样就能获得一个单页的pdf矢量图了!</p><h4 id="表格">表格</h4><p>同样先上个懒人模板: </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% 导言部分</span><br><span class="line">\usepackage{tabularx}  % 表格插入支持宏包</span><br><span class="line">\usepackage{booktabs}  % 好像只是拿来画分隔线的</span><br><span class="line"></span><br><span class="line">% 正文部分</span><br><span class="line">\begin{table}[htb]</span><br><span class="line">    \renewcommand*{\arraystretch}{1.3}  % 增大一点行间距让表格不那么紧凑</span><br><span class="line">    \centering</span><br><span class="line">    \caption[Short Title]{Short Title: long description}\label{t:table_test}</span><br><span class="line">    \begin{tabularx}{0.6\textwidth}{Xcc}</span><br><span class="line">        \toprule</span><br><span class="line">        title1 &amp; title2 &amp; title3 \\</span><br><span class="line">        \midrule</span><br><span class="line">        experiment 1 &amp; item 11 &amp; item 12 \\</span><br><span class="line">        experiment 2  &amp; item 21  &amp; item 22 \\</span><br><span class="line">        \bottomrule</span><br><span class="line">    \end{tabularx}</span><br><span class="line">\end{table}</span><br></pre></td></tr></tbody></table></figure><p></p><div><img style="width:60%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/table.jpg"></div><p>图中前一个表格是上面的模板的效果, 后一个表格是没有增大行间距的表格的效果. 插入表格有几种环境可用, <code>tabularx</code>这个环境是允许指定整个表的宽度和每列的对齐方式后自动计算每列宽度, 我觉得比<code>tabular</code>环境更智能省心. <code>tabularx</code>环境接受两个参数, 前一个是整个表格的宽度, 后一个是每列的对齐方式. <code>X</code>和<code>l</code>都是左对齐, 但<code>X</code>会让这列的列宽更宽, 让内容能占满整个表格. 比如上图前面的表格第一列就是<code>X</code>而后一个表格第一列是<code>l</code>, 就只有刚好适应单元格内容的列宽. 从单元格的侧边框可以看出最后一列确实是居中对齐, 但因为LaTeX是从左到右排版表格的, 因此多了些空余... <code>c</code>和<code>r</code>则是适应单元格宽度的居中对齐和右对齐. 想要智能宽度的居中对齐和右对齐的话用<code>&gt;{\centering\arraybackslash}X</code>和<code>&gt;{\raggedleft\arraybackslash}X</code> (没错这一长串和<code>l</code>一样往里填)</p><p><code>&amp;</code>用来分隔一行中的单元格, <code>\\</code>表示一行的末尾. <strong><em>booktabs</em></strong>这个包里好像只有一些分隔线, <code>\toprule</code>, <code>\midrule</code>这些的. 更多画边框线的方式参加<a href="https://www.overleaf.com/learn/latex/tables" target="_blank" rel="noopener">overleaf-表格</a>.</p><h3 id="列表">列表</h3><p>有序列表用<code>enumerate</code>环境, 无序列表用<code>itemize</code>环境. 这个没啥难的, 有问题参见<a href="https://www.overleaf.com/learn/latex/lists" target="_blank" rel="noopener">overleaf-列表</a>.</p><p>💡 另外这里有个通过给<code>itemize</code>和<code>enumerate</code>环境的选项的方式<a href="https://tex.stackexchange.com/questions/10684/vertical-space-in-lists" target="_blank" rel="noopener">调整列表行间距的方法</a>.</p><h3 id="代码">代码</h3><p><code>lstlisting</code>环境 (需要导入<strong><em>listings</em></strong>宏包) 是传统的插入代码用环境, 只是插入个代码的话倒是语法也很简单, 但是要想让插入的代码有语法高亮的话就必须<a href="https://www.overleaf.com/learn/latex/Code_listing#Code_styles_and_colours" target="_blank" rel="noopener">这样</a>自己在导言区放一个语法高亮配色方案, 很不简洁. 强推一下<code>minted</code>环境 (需要导入<strong><em>minted</em></strong>宏包), 这是一个自带多种语法高亮配色方案且支持绝大多数语言语法高亮的很现代的代码插入环境! 使用方式见<a href="https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted#Introduction" target="_blank" rel="noopener">overleaf-用minted语法高亮</a>. 如果你追求比较高, 觉得minted自带的语法高亮不够细致, 比如minted对yaml的语法高亮不会像VSC那样将布尔值, 数字, 字符串等类型值用颜色标示出来, 那可以看看stackoverflow上这个<a href="https://tex.stackexchange.com/questions/152829/how-can-i-highlight-yaml-code-in-a-pretty-way-with-listings" target="_blank" rel="noopener">自定义语法高亮问题</a>.</p><p>💡 <strong><em>minted</em></strong>包依赖于一个叫<em>Pygments</em>的python包. 如果你环境里本来就有python那事情就很简单了, 一句<code>pip install pygments</code>搞定.</p><p>补充: <a href="https://tex.stackexchange.com/questions/12428/code-spanning-over-two-pages-with-minted-inside-listing-with-caption" target="_blank" rel="noopener">跨页代码无法caption问题</a>.</p><h3 id="特殊符号">特殊符号</h3><div><img style="width:70%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/symbol.jpg"></div><p>LaTeX里更特殊的符号其实是靠<strong><em>tkiz</em></strong>包绘制出来的, 比如上面这段话里的圆圈1, 是通过在导言区定义了一个新的命令<code>\ballnumber{}</code>然后在文中调用的方式来实现的:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage{tikz}  % 绘图宏包</span><br><span class="line">\newcommand{\ballnumber}[1]{</span><br><span class="line">    \tikz[baseline=(myanchor.base)]</span><br><span class="line">    \node[circle,fill=.,inner sep=1pt](myanchor){\color{-.}\bfseries\footnotesize #1};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样的东西要用只能是现场上网搜了. 在这个<a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener">手绘查询符号网站</a>可以通过手绘的方式查到绝大多数符号 (但上面说的这个圆圈1查不到). 这里再吹一下VSC的LaTeX Workshop插件, 提供了一个快速插入常见符号LaTeX命令的面板, 还能快速插入常用tkiz绘制 🐮</p><div><img style="width:35%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/snippet.jpg"></div><h2 id="中文支持">中文支持</h2><p>我目前还没用LaTeX写过中文内容, 不过看起来<strong><em>xeCJK</em></strong>宏包提供的中文支持效果还不错 (前提是用xelatex作为编译器), 不知道大量使用中文时会不会出问题. 这篇<a href="https://www.overleaf.com/learn/latex/Chinese#xeCJK_with_XeLaTeX" target="_blank" rel="noopener">overleaf-中文支持</a>我先码住.</p><h2 id="引用">引用</h2><p><code>biblatex</code>是毋庸置疑比<code>bibtex</code>更现代使用更简洁灵活的参考文献管理工具. 先上个我偏好的配置:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage[</span><br><span class="line">    backend=biber,</span><br><span class="line">    style=ieee,  % 参考文献列表显示格式</span><br><span class="line">    citestyle=authoryear,  % 引用显示格式</span><br><span class="line">    backref=true,  % 在参考文献列表中反向列出当前引用条目被引用的页码</span><br><span class="line">    maxcitenames=1,  % 在引用处最多显示作者数量</span><br><span class="line">    maxbibnames=999,  % 在参考文献列表中最多显示作者数量. 直接拉到一个很大的数强制显示全部作者</span><br><span class="line">    sorting=ynt,  % 参考文献列表中条目排序主键: year-name-title</span><br><span class="line">]{biblatex}</span><br><span class="line">% 添加参考文献bib文件 (可以有多个)</span><br><span class="line">\addbibresource{References.bib}  % 然后放一个References.bib在根目录</span><br><span class="line">% 让链接包含整个\cite{}对应的内容</span><br><span class="line">\makeatletter</span><br><span class="line">    \let\abx@macro@citeOrig\abx@macro@cite{}</span><br><span class="line">    \renewbibmacro{cite}{\bibhyperref{\let\bibhyperref\relax\relax\abx@macro@citeOrig{}}}</span><br><span class="line">\makeatother{}</span><br><span class="line">% 使\citetitle{}对应内容支持超链接</span><br><span class="line">\DeclareCiteCommand{\citetitle}{\usebibmacro{prenote}}{</span><br><span class="line">    \ifciteindex{\indexfield{indextitle}}{}\printtext[bibhyperref]{\printfield[citetitle]{labeltitle}}</span><br><span class="line">}{\multicitedelim}{\usebibmacro{postnote}}</span><br><span class="line"></span><br><span class="line">\usepackage[colorlinks=true]{hyperref}  % 开启超链接支持</span><br><span class="line"></span><br><span class="line">% 正文</span><br><span class="line">\cite{test}  %在要引用的地方用个这个就行, 参数填bib文件中这个参考文献条目的标识 (大括号后第一个东西)</span><br><span class="line"></span><br><span class="line">\printbibliography  % 输出参考文献列表</span><br></pre></td></tr></tbody></table></figure><div><img style="width:70%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/cite.jpg"> <img style="width:70%; display:block; margin-left:auto; margin-right:auto;" data-src="./LaTeX杂记/bib.jpg"></div><ul><li><code>backend=biber</code>是因为<code>biblatex</code>需要额外工具<strong>biber</strong>作为后端来生成参考文献列表. 因此我<a href="#术语表">这附近</a>给出的VSCode的LaTeX编译工具链配置里有一环是<strong>biber</strong>.</li><li><code>style=ieee</code>指的参考文献列表显示参考文献信息的格式, <a href="https://www.overleaf.com/learn/latex/Biblatex_bibliography_styles" target="_blank" rel="noopener">这里</a>有一个各种格式的列表. 基本我看到的短篇论文用的是<em>authoryear</em>格式, 长篇论文用的是<em>ieee</em>格式. 我个人相对更喜欢<em>ieee</em>格式一些, 因为有序号.</li><li><code>citestyle=authoryear</code>则是指在文中引用处用<code>\cite{}</code>显示出的内容的格式. <em>Zhangsan et al. 2020</em>这样的格式是我最常见到的引用格式 (Overleaf有列出<a href="https://www.overleaf.com/learn/latex/Biblatex_citation_styles#Citation_styles" target="_blank" rel="noopener">biblatex可用的引用格式</a>). 要实现上面这样整个引用内容被包含在超链接中, 而不是只有年份带超链接还需要自己加一段宏. biblatex的维护者在<a href="https://github.com/plk/biblatex/issues/1024" target="_blank" rel="noopener">github仓库的issue</a>回答了之所以不将超链接包含整个引用内容做成一个自带功能, 是因为这会使有其他自定义需求的用户实现起来更麻烦 (咱也不知道是不是, 反正自己想实现的话一小段网上找的宏就实现了). 这块要想玩得花很有可能需要自定义一段宏, 那自己不会写能咋办, 只能上网偷几段呗.</li><li><code>maxcitenames=1, maxbibnames=999</code>是为了像上图展示的那样在引用处只显示一个作者, 而在参考文献列表里显示全部作者. 如果不强制拉满的话有时候在参考文献列表中作者也列不全, 带"et al.". 这不是什么大问题, 但看着尴尬了点.</li><li>想让引用内容可点击且颜色不一样还需要导入<strong><em>hyperref</em></strong>这个包, 这个稍后介绍.</li></ul><p>之所以说biblatex是比bibtex更现代的参考文献管理工具, 一大原因是因为biblatex原生支持一些现代人写论文会用到的"参考文献"类型, 比如网页对应<em>online</em>类型 (对我目前就多用到这一个). 给出<a href="https://www.overleaf.com/learn/latex/Bibliography_management_with_biblatex#Reference_guide" target="_blank" rel="noopener">overleaf上biblatex支持的参考文献类型列表</a>. 顺带一提我还看到了能让<a href="https://tex.stackexchange.com/questions/149506/biblatex-urldate-set-to-today" target="_blank" rel="noopener">biblatex中@online的urldata字段自动更新到今日</a>的神奇代码, 但想了想写论文出于严谨态度就该哪天确认的网页有效就写哪天, 单纯自动更新日期没有意义.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在用LaTeX写毕业论文 (学院支持甚至提供了LaTeX模板真是太幸运了), 在此记录下我写论文用到的一些语法方便以后抄.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="LaTeX" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/LaTeX/"/>
    
    
  </entry>
  
  <entry>
    <title>初级急救员笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2021/01/21/%E5%88%9D%E7%BA%A7%E6%80%A5%E6%95%91%E5%91%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2021/01/21/%E5%88%9D%E7%BA%A7%E6%80%A5%E6%95%91%E5%91%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-20T17:43:00.000Z</published>
    <updated>2022-05-28T17:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近假期了, 把十八岁暑假去参加的初级急救员培训笔记拿出来写在这里好了. 望指正.</p><a id="more"></a><h2 id="关于红十字会的初级急救员培训">关于红十字会的初级急救员培训</h2><h3 id="为什么要学急救">为什么要学急救</h3><p>学急救对普通人来说并不是一件小题大做的事情, 所谓初级急救员培训, 一共只有16小时 (两天), 我当时报名所想要达到的目的也仅是在遇到突发情况时不至于茫然无措. 摘抄一段成都红会的课程介绍页面的话:</p><blockquote><p>通过现场初级急救知识的学习和实践, 使受训人员掌握基本救护理论和实践操作技能, 在遇到突发事件或意外伤害时能自救互救, 以减轻痛苦、减少伤残, 为挽救生命争取宝贵时间</p></blockquote><p>实际上这样的"突发事件或意外伤害"发生在身边, 甚至亲友身上的几率<strong>并不小</strong>. 实际上我已经有过<strong>两次</strong>我在场时亲人发生突发事件的经历了. 正是第一次遇到这种情况时的无助让我在高中结束时思考假期做什么第一个想到了学急救培训. 但即便我认真地做了笔记, 也不时地关注一些急救信息, 我第二次面临这样的情况时仍然完全没法沉着冷静. 虽然做了些调整体位, 等救护车等力所能及的事情, 但是我内心仍然是茫然无助的. 毕竟只是普通人, 又只学了些急救的皮毛, 非常容易遇到没有头绪的情况 (甚至可能因为经验太少而产生误判). 因此遇到突发事件我的经验是:</p><p><strong>第一要务是给120打电话, 说明情况并寻求帮助</strong></p><p>这是否意味着自己就没有学急救的意义了呢? 学习急救知识对于普通人来说仍然是十分必要的, 因为急救讲究争分夺秒, 在救护车赶来前, 如果我们能做一些应急措施, 那将是非常有意义的. 但是如果我们毫无相关常识 (甚至可能有错误的认知), 比如不知道<a href="#复苏体位">复苏体位</a>到底是怎样的, 不知道<a href="#标准心肺复苏">心肺复苏的要点</a>, 不清楚<a href="#误食强酸-强碱">喝了大量强酸</a>该马上找什么... 那么即便有120在旁电话指导我们仍然很难做出有效的应对措施. 身边人的健康是非常重要的事情, 学一学成本不大, 但价值极高 👍</p><h3 id="报名渠道">报名渠道</h3><p>在各地的红十字会官网上应当就能搜到报名方式.</p><p>🔗 <a href="http://www.scredcross.org.cn/htm/detail_6355.html" target="_blank" rel="noopener">四川红会的课程介绍</a> 🔗 <a href="http://www.chengduredcross.cn/list_wjpx.asp?ClassID=020501" target="_blank" rel="noopener">成都红会初级急救员培训报名渠道</a></p><p>这个培训要收个两百多的报名费, 但也不算贵, 毕竟会发一个培训用创伤训练包 👍 (说起来培训的氛围非常好, 老师特别亲和)</p><h2 id="笔记">笔记</h2><p>💡 这里有一份<a href="./初级急救员笔记/2011年国际急救与复苏指南.pdf">2011年国际急救与复苏指南</a>和<a href="./初级急救员笔记/日常急救手册.pdf">日常急救手册</a>可供下载. 以下<a href="#心肺复苏">心肺复苏</a>, <a href="#气道异物梗阻">气道异物梗阻</a>, <a href="#创伤">创伤</a>, <a href="#其他">其他</a>几个板块是急救培训老师着重讲的部分, 其实在前面这本急救与复苏指南里还有好一些内容.</p><div class="note warning">            <p>这里会涉及到许多没有实际操作过就无法把握要点的技术, 这只是一份<strong>笔记</strong>.</p>          </div><h3 id="心肺复苏">心肺复苏</h3><h4 id="判断是否进行心肺复苏">判断是否进行心肺复苏</h4><p>虽然人人都知道有个叫心肺复苏的技术能救命, 但实际上实施心肺复苏有一定的条件, 盲目进行心肺复苏反而容易出问题. 下面便是判断是否进行心肺复苏的流程.</p><p><img style="zoom:50%;" data-src="./初级急救员笔记/判断是否进行心肺复苏流程图.svg"></p><p>❗是的<strong>对于非专业人士来说判断是否进行心肺复苏并不需要判断伤病员是否有脉搏</strong>. 另外要注意即便专业人士也只会判断是否有脉搏, 是<strong>不会判断是否心脏停跳</strong>的. (详见下文<a href="#AED的使用">AED的使用</a>)</p><h5 id="确认现场环境安全">确认现场环境安全</h5><p>举例: - 关闭受损汽车的发动机, 拉下手刹 - 在抢救触电者前切断电源 - 远离危险地带 (比如易塌墙) - 远离有毒有害气体 (比如开窗通风)</p><p>❗尽量不要移动伤员</p><h5 id="做好自我防护措施">做好自我防护措施</h5><p>随意接触伤员有一定可能染上病, 以下是一些可能的, 对彼此都有防护作用的措施: - 处理伤口前洗手, 尽量戴手套. 如果没有手套的话塑料袋也可以. - 戴口罩 - 处理大量出血的外伤时戴防护镜 - 做人工呼吸时隔一层布或纸</p><h5 id="判断有无意识">判断有无意识</h5><p>要判断有无意识, 对于成人, 拍打双肩, 在耳边大声呼唤; 对于婴儿, 拍打足底. 可以给予"睁开眼睛", "动动手指"这样的简单指令.</p><p><strong>如伤病员无反应</strong>: 1. 向周围人表明急救员身份 2. <strong>指定</strong>一个人拨打120 3. 寻求他人帮助 (比如寻找AED) 4. 向他人问明伤员情况, 如是否有内出血/骨折/脊柱损伤等. (万一周围人就知道点什么呢) 5. 记录时间 (现在这个时代了, 拿出手机随便照一张就把时间地点什么的都记录在照片的元数据里了👍)</p><p><strong>如伤病员有反应</strong>: 1. 表明急救员身份 2. 心理安慰 3. <strong>视情况</strong>拨打120 4. 帮助调整伤员为<a href="#复苏体位">复苏体位</a>, 排除气道异物, 打开气道 5. 记录时间</p><h5 id="判断有无呼吸">判断有无呼吸</h5><p>此处提供两种方法, 一种是培训班老师教的, 一种是我在网上看到的, 同样有效且我觉得操作难度更低的.</p><h6 id="老师教的方法">老师教的方法</h6><p>伏低身子, 以伤病员头至脚方向观察胸部起伏. 从<strong>1001数到1008</strong> (数四位数是以实际的发音代替了停顿, 这样数得更精确), 这期间应当观察到<strong>两次起伏</strong>. ❗到底数多快见下方<a href="#参考视频">参考视频</a>, 基本上一秒数一下.</p><p>💡 正常人3-4秒一次呼吸, 一分钟15-20次呼吸.</p><h6 id="我更推荐的方法">我更推荐的方法</h6><p>我自己想到了一个我感觉挺有效的方法, 将眼镜或者手机屏幕等玻璃凑到伤病员鼻子前, 如果观察到水汽则有呼吸.</p><p>之所以我更推荐这个方法是因为实际上微弱的胸部起伏很难观察到, 一般还需要解开伤病员衣服. 而观察是否有水汽是一件非常容易的事情, 而且很灵敏 👍</p><p><strong>如果伤病员有呼吸</strong>: 1. 调整伤病员为<a href="#复苏体位">复苏体位</a>, 清理气道异物, 打开气道 2. 密切关注其呼吸是否衰竭</p><h4 id="几种心肺复苏方式">几种心肺复苏方式</h4><p>根据急救员水平, 现场环境, 伤病员情况等有几种方式可选: 1. <a href="#标准心肺复苏"><strong>标准心肺复苏</strong></a> (<strong>C</strong>ardio<strong>P</strong>ulmonary <strong>R</strong>esuscitation) 2. <strong>单纯胸外按压</strong> (<strong>C</strong>ardio<strong>C</strong>erebral <strong>R</strong>esuscitation)<br>不可以长时间进行单纯胸外按压, 最好两分钟内进行一次人工呼吸 3. <strong>标准心肺复苏 + AED</strong><br>进行五组标准心肺复苏后进行一次电击, 然后立即再进行五组标准心肺复苏. 然后检查是否恢复了脉搏/呼吸.</p><p>其中， <strong>未经培训或仅受过最低等级培训的急救员推荐只进行单纯胸外按压心肺复苏</strong>, 而对于专业人士, 则推荐进行标准心肺复苏. 造成这种差异的原因是多方面的. 实际上&lt;2011年国际急救与复苏指南&gt;这本书里列举了大量实验, 都是试图探究标准心肺复苏与单纯胸外按压的效果差异, 但目前并没有实验能证明两者中哪个有明显优势. 但是对于非专业人士来说, 是有许多理由推荐只进行单纯胸外按压心肺复苏的: 1. 非专业人士更能接受不需要进行人工呼吸的单纯胸外按压心肺复苏, 不会因为对标准心肺复苏的犹豫而耽误抢救. 2. 心肺复苏讲究<strong>胸外按压的连贯性以及按压深度要够</strong>. 然而标准心肺复苏30:2的按压/通气比导致胸外按压会被频繁打断, 因此非专业人士很容易耗费大量时间在人工呼吸上, 导致胸外按压不够连贯, 按压深度逐渐达不到标准. 3. 据统计非专业人士的人工呼吸效果很差, 达不到标准. 4. 单纯胸外按压比标准心肺复苏更容易掌握, 一段时间后能保证更为完整的按压技能. 5. 单纯胸外按压比标准心肺复苏操作要简单些, 更方便120电话指导进行.</p><h5 id="几种常见心脏停搏情况及应对">几种常见心脏停搏情况及应对</h5><ul><li>原发性心脏停搏<ul><li>心室纤维性颤动 (即室颤, VF): 可应用AED</li><li>无脉性室性心动过速 (即室速, VT): 可应用AED</li><li>无脉性电活动: AED会不建议电击</li><li>心脏停跳: AED会不建议电击</li></ul></li><li>继发于呼吸衰竭的心脏停搏: 先进行两次人工呼吸, 再进行心肺复苏</li></ul><p>💡 心脏停跳后10秒晕厥, 15秒抽搐, 30秒呼吸停止, 1-2分钟瞳孔放大, 3-5分钟致死, 7分钟大脑遭受不可逆性损伤.<br>💡 室颤会迅速消耗心肌细胞的能量, 应在1-2分钟内进行除颤.</p><p>❗ 要注意心脏停搏和心脏停跳是不一样的, 心脏停搏指的是<strong>心脏射血功能停止</strong>, 可能是由于心脏停跳, 但也可能是因为心脏电气活动紊乱等.</p><h5 id="aed的使用">AED的使用</h5><p>首先我们需要意识到AED是在心肺复苏时<strong>很重要</strong>的工具, 不仅使用非常简单 (基本不需要培训, 跟着语音来就行), 而且功能丰富. 另外虽然从名字来说它只是用来除颤的机器, 但现在的AED也能对许多其他情况提供帮助. AED里面通常还包含用于人工呼吸的脸罩, 一些常用的急救工具等. 而且现在的AED不止可以除颤, 显示心电图, 还有些AED的电极贴片上有传感器, 支持监测胸外按压的频率和深度, 从而指导急救者进行有效的心肺复苏. 还有些支持记录音频, 心电图, 电击数据等... 👍nb</p><p>要注意<strong>A</strong>utomated <strong>E</strong>xternal <strong>D</strong>efibrillator, 即自动体外心脏<strong>除颤</strong>器, 其功能是判断特定的心率不正, 并且给予去颤电击, 强制终止心脏所有电活动. 电击后需要急救员立即进行胸外按压帮助心脏重新开始电活动. 相当于当电脑出问题了无脑重启一下. 更具体一点, 正如傻瓜相机虽然操作简单但也功能有限, AED功能也有限:</p><blockquote><p>(摘自维基百科) <strong>AED只能针对两种情况: 心室纤维性颤动和无脉性室性心动过速</strong>. 不同于一般专为医疗人员设计的专业心脏电击器，除了以上所提的两种情形外，它无法诊断其他各式各样的心率不整也无法提供治疗，而且它无法对心搏过慢提供体外心率调节的功能。</p></blockquote><p>就是说AED没法处理心脏停跳的情况. 那个针对心脏停跳的是心脏起搏器, 是用外部电信号带动心脏跳动. 不过作为非专业人士我们也没法判断到底是什么情况. 好在AED能够自动根据心电图判断是否应该给予电击. 如果是上述AED没法处理的情况AED会直接发出不建议进行电击的提示 (即便按电击键也没法强制电击).</p><p>目前常见的AED有两种: 全自动和半自动. 区别在于AED判读心电图决定是否电击后, 是否需要操作者按下电击键才开始电击.</p><p>💡 有的人贴电极的地方会因为电击出现类似烧伤的症状, 但这是小问题.</p><h5 id="标准心肺复苏">标准心肺复苏</h5><p>⭐ 要点: (具体动作见下<a href="#参考视频">参考视频</a>) 1. 在硬的地面上进行 2. 按压时注意观察患者是否有苏醒迹象 😆 3. 按压两乳连线中点, 或者剑突上方两指处 (如果位置不准容易导致肋骨断裂, 内脏破损) 4. 成人用双手按, 儿童 (1-12岁) 用单手按, 婴儿用两指按 (食指+中指或两拇指) 5. 成人需要按下5-6cm, 婴儿需要按下3-4cm 6. 按压不可过猛, 手不要离开按压位置 7. 按压时数两位数, 按压频率约为100次/分钟 8. 救护员身在伤病员右手侧 9. 胸外按压/人工呼吸比例为30:2 10. 对婴儿人工呼吸可以包住口鼻 11. 人工呼吸过程中要保持伤病员气道打开, 不可吹得太快, 过于用力. 应吹至胸腔微起并停止1s 12. 如果要换人, 五组换一次 (五组心肺复苏一般用时2min)</p><h4 id="参考视频">参考视频</h4><p>因为涉及到许多文字无法描述出的节奏, 最后还是放一个我看来看去觉得说明最详细, 正规的心肺复苏教学视频. ❗视频里老师并没有检查病人是否有呼吸, 而是检查的病人的大动脉搏动. 这其实是更加专业的做法, 但是基于"检查脉搏不应增加判断时间, 未经训练判断是否有脉搏难度较大"这样的因素, 对于初级急救员这样面向大众的急救标准只要求了检查呼吸. 毕竟专业急救人员也要遵循这样一条原则:</p><blockquote><p>专业救援人员应该检查脉搏，如果不能确定是否有搏动，应该认作无脉搏。</p></blockquote><iframe src="//player.bilibili.com/player.html?aid=17883263&amp;bvid=BV1oW411q7hG&amp;cid=29195038&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h3 id="气道异物梗阻">气道异物梗阻</h3><p>❗直立/坐时不可拍背, 反而容易使异物卡得更深</p><ol type="1"><li>背部叩击法: 使患者弯腰后用<strong>掌根</strong>向前下拍两肩胛骨中间5次</li><li>海姆立克冲击法: 斜向上冲击肚脐上两指处5次.</li></ol><p>也不要太用力了, 不然会造成伤害. 进行5次都不能排出异物的话🔥速打120</p><h3 id="创伤">创伤</h3><h4 id="外出血基础">外出血基础</h4><ol type="1"><li>成人血液约占体重8%, 有约4L血液.</li><li>出血的定义: 血管破裂导致血液流至血管外. 分为内出血和外出血.<ol type="1"><li><strong>动脉出血</strong>: 鲜红血, 涌泉状</li><li><strong>静脉出血</strong>: 暗红血, 平稳流出</li><li><strong>毛细血管出血</strong>: 血色鲜红, 量不大</li></ol></li><li><strong>轻度失血</strong>: 失800mL (20%), 出冷汗, 口渴, 手足湿冷, 脉搏快<br><strong>中度失血</strong>: 失800-1600mL (20-40%), 中度休克 (以上症状+呼吸急促)<br><strong>重度失血</strong>: 失1600mL以上, 以上症状+表情淡漠+脉搏弱得摸不到</li><li>止血: 清理伤口异物后以敷料按压至不再出血 (或用止血带止血). 敷料应盖过伤口周边至少3cm. ❗当一块敷料被血浸透后<strong>不要取下</strong>, 直接再盖一块上去. 这是因为刚开始流的血中血小板最多, 凝血效果最好; 而且医生可以根据敷料被浸湿程度判断失血量.</li></ol><h4 id="按部位应对">按部位应对</h4><ol type="1"><li>头<ol type="1"><li>按压耳前1-2cm处动脉可止血</li><li>头上部出血用帽式包扎</li><li>出鼻血<strong>不可仰头</strong>, 要低头, 按压鼻翼中点静脉血管丛来止血</li></ol></li><li>颈<ol type="1"><li>静脉出血直接按压</li><li>动脉出血理论上向颈椎方向按</li></ol></li><li>肩: 燕尾式包扎</li><li>胸, 背<ol type="1"><li>燕尾式包扎</li><li>开放式气胸: 在呼气末将塑料膜塞入伤口, 加压包扎</li></ol></li><li>肠管溢出: 采取仰卧屈膝位 (就是做卷腹运动的准备姿势), 以干净塑料膜或者浸湿的敷料覆盖, 然后用碗盖住, 捆在身上.</li><li>上肢<ol type="1"><li>大出血: (方法一) 上臂上1/3处用止血带, 绞棒. ❗<strong>记得标注时间</strong>, 以便每40min放一次血, 放2-3min, 让手臂不会因为长时间不过血受伤, 甚至坏死.<br>(方法二)按压上臂中点 (肱动脉), 如果是手指创伤, 按压指根两侧.</li><li>骨折: 若是关节骨折, 以肢体为夹板. 夹板需要长过该骨. 💡悬臂带需要包住肘而露出手指.</li><li>包扎方法: 肢体八字. 螺旋, 螺旋反转 (适用于无弹性绷带), 关节八字. 包扎好后, 如果没有用到止血带, 需要检查一下血液循环: 按压指尖, 两秒内恢复; 在皮肤上划动测试知觉; 测试活动能力</li></ol></li><li>下肢<ol type="1"><li>腿部大出血, 在大腿中上部扎止血带</li><li>若大腿骨折, 夹板需要过脚, 腰. 或者用<strong>健肢固定法</strong>: 在骨折处上下, 小腿, 脚踝处固定, 两腿间加衬垫.</li></ol></li></ol><p>💡tips - 心率过快时考虑有内出血; 外观失血不多但是有休克症状考虑有内出血; 左右上腹受创时考虑肝, 脾包膜内出血, 不可轻易移动, 否则容易变为外出血; 臀部受创时考虑骨盆内出血. - 深伤口不宜包扎. - 呼吸困难时采取半卧位 (就是屈膝斜坐着). - 休克时将下肢抬高, 让脚高于心脏. - 不可以给大量出血者喝水, 否则伤员的水盐平衡会失衡, 容易导致内脏抽搐. 另外这样也不利于麻醉, 因为麻醉要求空腹. 如果一定要喝水, 用淡盐水涂唇. - 断肢的保存: 将断肢放入干净的塑料袋, 用毛巾包住, 外面套一个塑料袋, 然后放入一个放有冰块的塑料袋.</p><h3 id="其他">其他</h3><h4 id="复苏体位">复苏体位</h4><p>将伤病员置于复苏体位是为了防止因气道堵塞导致窒息. 有两种原因可能导致气道阻塞: 机械阻塞 (大部分情况是由于伤员失去意识而失去对舌头的控制, 舌头后坠至咽后部), 液体阻塞 (胃里出来的呕吐物之类)</p><p>💡打呼噜也是舌头后坠导致的</p><p>目前比较受认可的复苏体位有两种: 侧卧体位和HAINES体位. 要点是要将头微微后仰, 如此保证打开气道. HAINES体位和侧卧体位的操作方法类似, 区别在于可能有脊柱损失时HAINES体位比侧卧体位更安全. (但这个体位没有侧卧体位舒服)</p><p><img style="zoom:50%;" data-src="初级急救员笔记/侧卧体位.png"></p><p><img style="zoom:80%;" data-src="初级急救员笔记/HAINES体位.jpg"></p><h4 id="误食强酸强碱">误食强酸/强碱</h4><p>喝下大量强酸/强碱不宜利用中和反应中和 (会大量放热) 或者催吐 (伤害食道), 应<strong>服用大量蛋白质</strong>.</p><h4 id="烫伤">烫伤</h4><p>烫伤后应用流动凉水冲洗. 不要弄破烫伤导致的水泡, 普通烫伤的水泡第三天起为吸收期, 7-8天恢复.</p><h4 id="脑卒中">脑卒中</h4><p>脑卒中, 即中风, 是由于脑部血管突然破裂或因血管阻塞导致血液不能流入大脑而引起脑组织损伤的一组疾病, 根据是血管破裂还是血管阻塞导致的分为出血性脑卒中和缺血性脑卒中. 其中缺血性脑卒中发病率更高, 出血性脑卒中死亡率更高. 面对脑卒中牢记<strong>FAST原则</strong>:</p><p><img style="zoom:65%;" data-src="初级急救员笔记/FAST原则.png"></p><p>❗ 禁食, 水</p><h4 id="淹溺">淹溺</h4><p>抢救上岸后以干毛巾由远心端向近心端摩擦, 促进血液循环.</p><p>❗ 溺水导致的心脏停搏在进行心肺复苏前并<strong>不需要排出伤员呛的水</strong>, 这样做甚至可能导致肺炎. 这些水都在胃里, 很少会进到肺里.</p><h4 id="动物咬伤">动物咬伤</h4><p>被动物咬伤后应立即用肥皂水/盐水/清水冲洗15min, 然后马上去就医.</p><h4 id="地震">地震</h4><ol type="1"><li>能在12秒内跑出就尽量跑.</li><li>不管如何要保护好头部.</li><li>中国提倡三角空间而日本不提倡三角空间. 因为中国大多数房子中有预制板, 房子垮塌时要掉也是大块的, 而在日本只会掉小件.</li><li>不要站在围墙下.</li><li>不要站在天花板有东西的墙沿.</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近假期了, 把十八岁暑假去参加的初级急救员培训笔记拿出来写在这里好了. 望指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="健康" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%81%A5%E5%BA%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>HPV与宫颈癌小知识</title>
    <link href="https://leojhonsong.github.io/zh-CN/2021/01/11/HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://leojhonsong.github.io/zh-CN/2021/01/11/HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-01-10T17:30:00.000Z</published>
    <updated>2021-01-10T17:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>帮人查HPV疫苗的信息整理了一份资料出来, 就分享一下好了. ❗ 注意以下信息为截止2020年12月的信息.</p><a id="more"></a><h2 id="hpv">HPV</h2><p>HPV (human papilloma virus), 即<strong>人类乳头状瘤病毒</strong>. 和乳头没有关系, 是大部分类型得了会长出乳头状的瘤 (即疣, 皮肤上的粗糙, 坚硬颗粒), 有近200种类型. <strong>不论是一般身体部位或生殖器的皮肤, 只要有鳞状上皮, 就可以被人类乳突病毒感染的, 但每种HPV通常只能感染特定区域皮肤.</strong></p><h3 id="较常见hpv与疣的种类">较常见HPV与疣的种类</h3><p>❗ 大多数时候感染后没有任何临床症状, 也就是说连下面这些疣都不会有. 而出现了疣的话大致可以分以下几种情况.</p><table><colgroup><col style="width: 15%"><col style="width: 39%"><col style="width: 39%"><col style="width: 5%"></colgroup><thead><tr class="header"><th>疣类型</th><th>说明</th><th>HPV类型</th><th>危害程度</th></tr></thead><tbody><tr class="odd"><td>普通疣 (瘊子)</td><td>有着粗糙的表面, 通常发生在手及脚部, 但亦有可能在身体其他区域发生</td><td>2, 4 (最常见), 1, 3, 26, 29, 57</td><td>良性</td></tr><tr class="even"><td>扁平疣</td><td>扁平而光滑的疣, 呈现肉色, 可能一长就是许多个；最常发生在头、脸、颈部、手、手肘及膝盖</td><td>3, 10, 28</td><td>良性</td></tr><tr class="odd"><td>丝状疣</td><td>呈螺丝或者指头状, 在颈部, 脸部, 尤其是嘴唇以及眼皮周围上发生, 常见于中老年, 孕妇等 (因为抵抗力下降). <strong>注意与皮赘区别</strong></td><td>1, 2, 4, 7, 26, 27, 28, 29</td><td>良性</td></tr><tr class="even"><td>跖疣</td><td>发生在足底部. <strong>注意与鸡眼, 老茧区别</strong></td><td>1 (最常见), 2, 3, 4, 27, 28, 58</td><td>良性</td></tr><tr class="odd"><td>肛门生殖器疣 (尖锐湿疣)</td><td>长在肛门/生殖器附近. <strong>注意与珍珠疹, 假性湿疣区别</strong></td><td><strong>6, 11</strong> (90%), 13, 40, 42, 43, 44, 54, 61, 72, 81, 89</td><td>低危</td></tr><tr class="even"><td>(癌和子宫颈细胞化生不良)</td><td>与癌症有关, 特别是子宫颈癌, 并且还可能会导致一些外阴, 阴道, 阴茎, 肛门和口咽的癌. 男性也可能感染</td><td><strong>16, 18</strong> (70%宫颈癌, 90%肛门癌, 很大比例阴道癌), <strong>31, 33, 45, 52, 58</strong>(20%宫颈癌), 35, 39, 59</td><td>高危</td></tr></tbody></table><p>💡 高危/低危根据致癌性划分. 无论是高危类型的HPV还是低危类型的HPV, <strong>目前都没有明确有效的抗病毒治疗手段</strong>, 只能治疗HPV导致的病变</p><p>💡 <strong>由此可见只有四十余种HPV通过性行为传播且有危害性, 大部分HPV性质和脚气类似, 并非性传播</strong> (但是能通过疫苗预防的几种HPV确实只有与性相关的几种)</p><p>💡 从整体上看, 我国的感染型别与国际以及亚洲地区其他国家略有差异, 在细胞学正常人群中, 全球范围内最常见的HPV型别依次是 HPV 16/52/31/53, 而在我国排名前四的型别依次是HPV 16/18/58/52. <strong>除了广泛流行的 HPV 16/18 型, HPV 58/52 型在中国宫颈癌中占比为 14.7%, 明显高于全球占比 7.4%</strong>.</p><p>80%感染的HPV会在6-24个月内会被身体的免疫系统自动清除, 医学上称为<strong>一过性感染</strong>.</p><h3 id="感染hpv的常见途径">感染HPV的常见途径</h3><ol start="2" type="1"><li>间接接触传播 (共用拖鞋, 共用毛巾, 共用剃须刀, 公用马桶, 私人衣物等)</li><li>性传播</li><li>母婴传播</li><li>医源性感染</li></ol><h2 id="宫颈癌">宫颈癌</h2><p>到目前为止, 宫颈癌是人类唯一一个找到病因且可预防的癌症种类. 中国女性 HPV 感染率按年龄呈[双峰] 分布：第一个高峰在[17-24 岁], 第二个高峰在[40-44 岁].</p><p>宫颈癌与hpv关联: 只有少数高危型的 HPV 持续感染才会有一定几率引发宫颈癌, 通常情况下持续感染经过 10-20 年的自然演化发展, 才可能会发展成为宫颈癌.</p><h3 id="中国子宫颈癌综合防控指南提出的三级预防策略">中国《子宫颈癌综合防控指南》提出的三级预防策略</h3><ol type="1"><li><strong>一级预防 (治未病)</strong>: 开展健康教育和接种 HPV 预防性疫苗</li><li><strong>二级预防 (治初病)</strong>: 对所有适龄妇女定期开展宫颈癌筛查</li><li><strong>三级预防 (治已病)</strong>: 根据宫颈癌的临床分期, 开展适宜的手术、放疗、化疗及姑息疗法</li></ol><p>🌟 筛查比hpv疫苗重要得多</p><p><img data-src="HPV与宫颈癌小知识/screening.jpg"></p><h2 id="hpv疫苗">HPV疫苗</h2><h3 id="工作原理">工作原理</h3><p>以L1蛋白外壳模拟HPV病毒, 本身不是病毒, 不会造成感染</p><h3 id="意义">意义</h3><ul><li><p>预防大部分有致癌风险的HPV</p></li><li><p><strong>感染过HPV也仍有接种价值</strong>: HPV感染或由此引发的宫颈病变治愈后, 进行HPV疫苗接种可以减少疾病的复发率. 理论上认为, 人体自然感染HPV后, 抵抗病毒的体系是细胞免疫, 主要在宫颈局部起作用, 产生的抗体水平很低, 不足以对抗病毒的再次进攻. 而疫苗是肌肉注射, 会引发人体产生强烈有效的免疫反应, 产生的抗体的滴度是自然感染的40倍以上, 这样就可以防止病毒的感染.</p></li></ul><h3 id="接种条件及方式">接种条件及方式</h3><ul><li>对疫苗活性成分 (L1蛋白) 或任何辅料成分有超敏反应者禁用</li><li>目前大陆没有开放男性接种HPV疫苗 (国外可以)</li><li>肌肉注射 (首选上臂三角肌), 每次0.5ml</li></ul><h3 id="类型">类型</h3><p><img data-src="HPV与宫颈癌小知识/types.png"></p><p>共二, 四, 九价三种HPV疫苗, "价"指疫苗能预防的HPV亚种数. 目前全世界只有葛兰素史克 (英国), 默沙东 (美国), 万泰沧海 (中国) 三家能生产HPV疫苗, 其中四价, 九价疫苗目前只有默沙东能生产.</p><h3 id="性价比">性价比</h3><p><strong>万泰沧海二价 &gt; GSK二价 &gt; 默沙东九价 &gt; 默沙东四价</strong></p><ul><li><p>万泰沧海疫苗价格低的原因在于研发原理带来的低成本. 默沙东疫苗基于酒酿酵母表达体系, GSK 疫苗基于<strong>昆虫细胞</strong>表达系统, 万泰沧海疫苗基于<strong>大肠杆菌</strong>表达体系.</p></li><li>万泰对16/18型保护效力高于进口疫苗, 且不良反应小</li><li><p>四价只比二价多了对尖锐湿疣的预防, 但是尖锐湿疣看网上信息意思基本是良性的, 因此不如九价性价比高</p></li><li>国内目前都是自费接种, 因此其实大部分人还是选择等九价. 不过可能出现打完一针后缺货的情况.</li><li><p>打过了二价或四价, 也可以再接种九价, 不过要等完成接种的一年后才可以, 而且有点亏</p></li></ul><h3 id="周期">周期</h3><p>打疫苗要按周期, 一共打三次. 可以比建议时间晚几天, 但最好不要提前打. 这是为了产生最多的抗体. 提前打浪费. <strong>一年内完成三针产生的抗体量都是够的</strong>.</p><h3 id="保护能力持续时间">保护能力持续时间</h3><p>尚不清楚, 目前可以确保是10年以上. (因为这个疫苗一共出现才十多年)</p><h3 id="年龄限制">年龄限制</h3><p>九价建议注射年龄是16~26岁, 指第一针需要在26岁半前接种, 27岁前完成三针. 之所以国内对默沙东九价疫苗限制年龄段比国外窄是因为国内的默沙东九价疫苗临床数据目前只做了16-26岁女性的 (同时也有疫苗资源紧张的原因).也因为同样原因大陆没有开放男性接种HPV疫苗.</p><h3 id="供应量">供应量</h3><p>九价供应短缺原因:</p><ul><li>国内缺口大: 国家统计局最新数据显示, 九价HPV疫苗的适龄人群 (16-26岁) 约<strong>1.2亿</strong>. 而按照智飞生物2019年九价HPV疫苗批签发量332.4万计算, 能够接种到该疫苗的人数还<strong>不足总数的1%</strong>. (按照10%的核心人群渗透率算)</li><li>九价国内审批只用了八天, 默沙东产量预估不足, 并且增加产能决心不强烈</li><li>目前国外很多市场已经淘汰二价, 四价疫苗, 以售卖九价疫苗为主.</li></ul><p>现状:</p><ul><li><p>目前只有默沙东一家生产九价疫苗. 2023年默沙东新生产线将投产.</p></li><li><p>截至2020年7月国内HPV疫苗研发概况👇 (可以看到甚至十一, 十四价HPV疫苗也已经开始研发了), 但是我看网上消息的意思, 直到2026年估计不会有国产九价疫苗上市 🤦‍♂ ️</p></li></ul><p><img data-src="HPV与宫颈癌小知识/outline.jpeg"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;帮人查HPV疫苗的信息整理了一份资料出来, 就分享一下好了. ❗ 注意以下信息为截止2020年12月的信息.&lt;/p&gt;
    
    </summary>
    
    
      <category term="健康" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%81%A5%E5%BA%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>我从Ubuntu换到了Manjaro</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/07/26/%E6%88%91%E4%BB%8EUbuntu%E6%8D%A2%E5%88%B0%E4%BA%86Manjaro/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/07/26/%E6%88%91%E4%BB%8EUbuntu%E6%8D%A2%E5%88%B0%E4%BA%86Manjaro/</id>
    <published>2020-07-26T02:26:37.000Z</published>
    <updated>2022-01-19T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天闲来无事下了一个听说了很久的Manjaro (KDE版), 在Live CD体验了一会果断装了实体机. 体验比Ubuntu好太多了!</p><a id="more"></a><!-- TODO --><h2 id="manjaro-kde比起ubuntu的优势">Manjaro-KDE比起Ubuntu的优势</h2><p>在实体机上使用快要有一个月了, 体验下来相比于Ubuntu, 以不是专业软件开发者, 而是机器人开发者的角度, Manjaro KDE最吸引我的三个关键词是: KDE, 不太激进的Arch系, MHWD. 当然两者还有些其他区别, 但我目前感触最深的就是这三个关键词.</p><h3 id="kde的好处">KDE的好处</h3><p>Manjaro有好几个版本, Architect, Gnome, KDE Plasma, XFCE四个官方版本, i3等九个社区版本, 这几个版本都是给x64/x86平台用的, 主要区别是窗口管理器不同. 确切的说: - Architect没有图形界面 - Gnome, KDE Plasma, XFCE是桌面环境, 有各自的窗口管理器 (比如Plasma的窗口管理器是KWin), 但他们提供的不只有窗口管理器, 这几个大社区各自开发了一套配套基础应用, 总的来说都很有用 - 9个社区版相当与Manjaro Architect+一个预装的窗口管理器, 据我观察没有提供什么配套的东西</p><p>而另外还有针对arm平台几款常见单板机的Manjaro, 每款都提供KDE Plasma和XFCE两个版本. Linux平台桌面环境有很多, 其中我认为最有价值的就是XFCE和KDE. XFCE以<strong>轻量级, 稳定的同时足够友好</strong>著称, 是在电脑性能不太好时的首选桌面. 而KDE Plasma以<strong>现代, 高度可定制, 友好</strong>著称. 至于Gnome... 自从体验过KDE后, 除了很多软件或多或少依赖Gnome这一点, 我找不出它比起XFCE或者KDE有什么优势...</p><p>值得一提的是, KDE的初衷只是开发一个桌面环境, <strong>K</strong>ool <strong>D</strong>esktop <strong>E</strong>nvironment, 但随着社区的发展, <strong>KDE现在代表的是一个软件社区</strong>, 而桌面环境被分离出来, 只作为其中的一个产品, KDE Plasma. 另外还有KDE Applications, KDE Framework. 这样以来许多KDE软件在Windows, OS X也能运行.</p><h4 id="能轻松高度个性化且稳定的plasma桌面环境">能轻松高度个性化且稳定的Plasma桌面环境</h4><p>在体验KDE前我用了许久Gnome, 还折腾了许多个性化, 把Grub界面, Plymouth界面, 登录界面, 窗口主题, gnome shell主题, 图标主题都以较为硬核, 需要输入一些网上看来的命令的方式换掉了. 但体验了KDE后觉得自己实在是愚蠢: 有那功夫折腾Gnome的个性化, 直接换到KDE在系统设置点几下鼠标进行个性化多好? 上面提到的几个除了GRUB界面系统设置没有提供设定入口, <strong>统统在系统设置就可以下载, 更换主题</strong>! KDE还提供了更多可以个性化的东西, 比如一堆桌面特效, 应用窗口切换动画, 一堆任务栏的挂件等等. 实在是现代, 友好, 高度可定制!</p><p>💡 值得一提的是在Manjaro KDE的系统设置的<code>Time and Date</code>一栏即可勾选<strong>Hardware clock in local time zone</strong>, 也就是说勾选上这个Manjaro就会将硬件时间作为当前时区时间!</p><p>当然, 功能如此丰富的Plasma桌面环境运行起来消耗的资源比XFCE多, 但仍比Gnome消耗的资源少, 是较新的电脑的首选桌面环境😆</p><h4 id="齐全而贴心的系统自带软件">齐全而贴心的系统自带软件</h4><p>KDE自带的软件的贴心程度震撼到我: - 虽然Ubuntu也有类似<strong>FileLight</strong>的磁盘空间分析工具, 但是我总觉得有些bug, 体验不是很好, 而FileLight没有这些毛病, 甚至在扫描时是有动画的, 很贴心. - KDE自带的图片查看器, pdf阅读器比Gnome自带的功能更加丰富, 但也不会杂乱. - KDE的硬件信息查看软件, 类似任务管理器的软件比Gnome的更加直观, 信息更加丰富. - Manjaro KDE这个软件商店 (叫Add/Remove Software, 我也不知道算不算是KDE的) 吊打Ubuntu应用商店. 我基本没有成功从UBuntu应用商店下下来过东西, 但Manjaro KDE这个软件商店体验很好, 可以图形化设置是否开启AUR, Snap, Flatpak的支持, 设置如何处理包的缓存文件等.</p><h3 id="kde的缺点">KDE的缺点</h3><p>KDE也不是没有缺点. KDE, Gnome均遵循GPL协议, Gnome采用的图形库GTK遵循GPL协议, 但<strong>KDE采用的图形库Qt不遵循GPL协议</strong>. 这导致Gnome获得的商业支持远多于KDE, 所以现在很多主流发行版的默认桌面环境是Gnome, 进一步导致很多软件或多或少依赖Gnome, 很多教程也是针对Gnome的.</p><p><del>比如deepin全系软件都对Gnome有一定依赖, 在Manjaro KDE直接安装AUR里打包好的tim是无法启动的, 需要<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/90#issuecomment-653921540" target="_blank" rel="noopener">再安装一个依赖, 编辑一段代码</a>.</del> <strong>2022年更新:</strong> <em>应该是从去年开始就基本没这问题了, 在Manjaro很久没遇到安装不是一行命令搞定的软件了. aur源里总会有一个热心网友解决好依赖问题的版本 😁 目前TIM我用的<a href="https://aur.archlinux.org/packages/com.qq.tim.spark/" target="_blank" rel="noopener">com.qq.tim.spark</a>, 微信用的<a href="https://aur.archlinux.org/packages/com.qq.weixin.deepin/" target="_blank" rel="noopener">com.qq.weixin.deepin</a>, 都是最新版, 体验也很流畅</em></p><p>这些其实不算大问题, 都能在网上较为容易地找到解决方案, 但确实不能算新手难度.</p><h3 id="manjaro与arch-linux">Manjaro与Arch Linux</h3><h4 id="manjaro不是arch-linux">Manjaro不是Arch Linux</h4><p>要注意Manjaro虽然是Arch系, 但又与Arch Linux不完全兼容. AUR (Arch User Repository) 更多是面向Arch Linux用户的, 社区主导的第三方仓库, 里面都是社区用户<strong>自行维护</strong>的软件包 (足够热门足够好的话也会被Arch Linux官方收入官方维护的community仓库). 而Manjaro官方则只会对Arch Linux官方仓库的更新进行测试, 兼容性适配等后以一两周的延迟同步到Manjaro自己的官方仓库 (不过我感觉Manjaro是一批一批同步的, 因此不像Arch用户每天都可以更新一点什么, Manjaro是几天更新一批). 这意味着如果AUR上的软件维护者只在Arch Linux上进行测试的话, Manjaro用户可能发现自己从AUR上下下来的软件有问题. 不过Manjaro与Arch Linux绝大部分是兼容的, 就我这一年多的使用经验来看 (这段内容是2022年更新的), 主流的软件都没有兼容性问题, 冷门一些的软件小概率会碰到兼容性问题. 我仅有几次遇到的AUR软件问题基本都是因为Manjaro仓库与Arch Linux仓库之间的更新延迟, 导致软件的依赖或者依赖的依赖只更新了一部分, 因此依赖关系断了, 出现的问题. 这种问题我还没碰到过影响很重要软件的时候, 不急的话稍等几天就自然修复了, 急用的话回滚一下版本就好.</p><p>总的来说要记住<strong>Manjaro不是Arch Linux</strong> 😏 去Arch社区提问的话记得先说自己是Manjaro用户, 不然一群Arch老哥怎么也不能复现你遇到的问题才发现你其实是Manjaro用户的话会骂人的.</p><p>那为什么不直接用Arch Linux? 因为设计理念不一样. Arch Linux的用户是一群凡事更情愿自己啃文档自己动手丰衣足食的极客, 对于只是把Linux系统当一个工具的人来说Arch Linux使用起来太麻烦了. 正相反, Manjaro, 尤其是Manjaro-KDE提供了很多非常人性化的功能, 界面也非常现代等... 是非常阳间的操作系统 ❤️</p><h4 id="坐靠aur的好处">坐靠AUR的好处</h4><p>虽然如前面提到, 在Manjaro系统使用AUR上的软件可能遇到兼容性的问题, 但AUR社区的软件之丰富, 版本之新, 使用之简便, 社区之活跃足够让我忽视那小概率弊端.</p><p>举个例子. 我有一台有N卡的电脑, 我现在需要运行一个开启了CUDA加速的基于OpenCV的图像识别C++程序. 如果支持用最新版本的CUDA和OpenCV运行, 那么运行<code>yay -S opencv-cuda</code>, 然后最新的CUDA, cuDNN, 开启了CUDA加速的OpenCV的C++, Python库就都装好了🎉 N卡驱动是装Manjaro系统时选安装闭源驱动然后Manjaro就会很省心配置好的, 当然装好后在系统设置也能一键装好闭源驱动. 非常省心. 即便是有版本要求, 比如需要CUDA10.1和OpenCV3.4, 那先<code>yay -S cuda-10.1 cudnn7-cuda10.1</code>, 然后OpenCV确实是需要手动下载源码编译的了, 不过至少可以参考<code>opencv-cuda</code>包的<strong>PKGBUILD</strong>的写法.</p><h3 id="manjaro-hardware-detection-mhwd">Manjaro Hardware Detection (MHWD)</h3><p>MHWD绝对是让Manjaro从众多Linux系统中脱颖而出的一个重要原因. 这个工具能自动检测你的硬件并安装驱动, 当然你也可以自己选. 他主要是解决了我N卡驱动装着麻烦的问题, 在系统安装的时候引导就会问你是否安装闭源驱动, 然后这个工具就会帮你安好闭源的N卡驱动.</p><h2 id="manjaro是否对linux新手友好">Manjaro是否对Linux新手友好</h2><p>从Manjaro提供的众多贴心功能来说他对任何用户都是友好的, 比如如果安装Manjaro之前已有Windows系统的话安装好Manjaro后 Windows盘就自动被挂载了, 在资源管理器能看到侧边栏有个Windows图标, 可以说非常贴心了.</p><p>但另一方面, 滚动更新让Manjaro相比Ubuntu更容易出现问题, 虽然也更容易解决, 但是需要对Linux有一点了解. 但是我体验下来基本就这一个毛病, 学一学就不是大问题了 👍</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天闲来无事下了一个听说了很久的Manjaro (KDE版), 在Live CD体验了一会果断装了实体机. 体验比Ubuntu好太多了!&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="软件配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下各用途我最认可的工具推荐</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/07/26/Linux%E4%B8%8B%E5%90%84%E7%94%A8%E9%80%94%E6%88%91%E6%9C%80%E8%AE%A4%E5%8F%AF%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/07/26/Linux%E4%B8%8B%E5%90%84%E7%94%A8%E9%80%94%E6%88%91%E6%9C%80%E8%AE%A4%E5%8F%AF%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2020-07-26T02:26:37.000Z</published>
    <updated>2022-05-28T17:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning">            <p>因为各种好用软件层出不穷, 提到的软件也可能在快速更新, 因此这篇文章时效性会很短, 请注意☝更新时间.</p>          </div><p>用Linux的时间已经比用Windows的时间还长了, 随着使用逐渐找到了各用途我最认可的工具, 或从软件源安装, 或在线使用. 在此整理一份我的Linux下各用途好用工具推荐. (出于私心将从一个<strong>Manjaro-KDE</strong>用户角度介绍)</p><p>💡各位如果有什么推荐的软件也可以底下评论, 我觉得好用会加进去的.</p><a id="more"></a><blockquote><p>首先, 不得不吹一下Manjaro是一个多么贴心的系统. Manjaro自带了一个叫<strong>Manjaro Hello</strong>的入门程序, 点进这个程序的<code>Applications</code>入口能看到Manjaro社区为各常见用途已经提供了一些推荐, 勾选就可以安装. 可以说没有更贴心的系统了!</p><p><img style="zoom:70%;" data-src="Linux下各用途我最认可的工具推荐/Manjaro_Hello.jpg"></p></blockquote><h2 id="日常使用">日常使用</h2><h3 id="中文输入法">中文输入法</h3><p>随着fcitx5日渐成熟, 现在有了两种我推荐的中文输入法方案:</p><h4 id="fcitx5框架配套中文输入法">fcitx5框架+配套中文输入法</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S fcitx5-im</span><br><span class="line">yay -S fcitx5-chinese-addons</span><br><span class="line">yay -S fcitx5-material-color</span><br></pre></td></tr></tbody></table></figure><p>这个<strong>fcitx5-material-color</strong>是一个模仿win10的中文输入法的皮肤, 在fcitx5的设置中可以更换皮肤, 可以做到下面这样的效果 👇 <img style="zoom:80%;" data-src="Linux下各用途我最认可的工具推荐/inputMethod.gif"></p><h4 id="fcitx4框架搜狗输入法">fcitx4框架+搜狗输入法</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S fcitx-im fcitx-configtool</span><br><span class="line">yay -S fcitx-sogoupinyin</span><br></pre></td></tr></tbody></table></figure><hr><p>安装完输入法框架和中文输入法后还需要在配置文件中设置几个环境变量. 因为有很多配置文件会在用户登录过程中被加载, 所以这里的设置方式其实不唯一. 我是在<code>~/.pam_environment</code>中写了这几行:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE DEFAULT=fcitx</span><br><span class="line">XMODIFIERS DEFAULT=@im=fcitx</span><br></pre></td></tr></tbody></table></figure><p>我目前使用的是fcitx5的方案. 我一个同学体验后觉得搜狗的词库做得更好, 能提供更精确的联想. 这点我倒是没什么感觉, fcitx5这个方案完全满足我的使用. 但另一方面fcitx5配套的中文输入法的优势非常明显:</p><ul><li>有一个Quick Phrase功能, 支持类似snippets一样根据关键词插入设定好的内容的功能. 默认提供了一些颜文字, emoji, LeTaX片段, 也可以自己加</li><li>整个方案成体系, 使用体验非常好! fcitx4+搜狗输入法这个方案始终是缝合怪, 很容易有点小问题. 比如我之前用的时候每次从英文输入法切换回搜狗输入法, 我对搜狗输入法的一些设置 (比如使用半角标点符号) 都会恢复默认值</li><li>支持云拼音联想</li><li>配置起来很简单直观</li><li>支持导入搜狗细胞词库 (我没试过), 可以导入许多专业词汇的词库</li></ul><p><strong>总的来说我是推荐试试fcitx5框架+配套中文输入法这个方案的</strong></p><h3 id="截图">截图</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S flameshot</span><br></pre></td></tr></tbody></table></figure><p>很遗憾我没有找到一个像Windows平台的snipaste那样功能非常齐全的截图/贴图软件. 我试了Manjaro-KDE自带的spectacle, flameshot, deepin的deepin-screen-recorder, flameshot的体验最好, 最贴近snipaste, <strong>甚至也支持贴屏</strong>.</p><table><colgroup><col style="width: 14%"><col style="width: 42%"><col style="width: 42%"></colgroup><thead><tr class="header"><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>Flameshot</td><td>支持像snipaste一样将截图贴在屏幕最上层</td><td>1. 在KDE上无法设置截图质量, 只能是原画质; 2. 无法自动贴靠屏幕上的窗口</td></tr><tr class="even"><td>Spectacle</td><td>作为KDE官方开发的截图软件, 全屏截图, 选定窗口截图, 选定矩形截图, 截图后做一些编辑这些功能都是全的. 是这三款软件里<strong>唯一可以设置存储图片的压缩质量</strong>的.</td><td>使用逻辑有点别扭, 是先截图然后在软件里进一步选择是进行编辑或者存到什么地方之类. 我更喜欢flameshot那样在截图的时候就能编辑, 选择存到剪贴板还是本地的方式.</td></tr><tr class="odd"><td>Deepin Screen Recoder</td><td>Deepin这个其实不单单是截图软件了, 同时可以录屏, 看起来功能很全面, 也能贴屏.</td><td>很遗憾目前为止在Manjaro-KDE上根本没法用, 有好几个bug.</td></tr></tbody></table><h3 id="录屏">录屏</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S simplescreenrecorder</span><br><span class="line">yay -S peek</span><br></pre></td></tr></tbody></table></figure><p>SimpleScreenRecorder名字里虽然有simple, 但是实际上关于录屏的功能非常全, 有好几屏的设置项, 可以设置帧率, 视频源可以来自屏幕, 摄像头, 也可以设置音频源, 支持录制成<code>mkv</code>, <code>mp4</code>, <code>mp3</code>等多种格式, 视频编码参数, etc... 可以说功能非常全面了 (但不支持录制成<code>gif</code>).</p><p>而如果只是想随手录一个gif, 那使用<strong>peek</strong>还是很好的.</p><h3 id="显示按键">显示按键</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S screenkey</span><br></pre></td></tr></tbody></table></figure><p>这个可以在屏幕上显示按下了的键盘按键, 鼠标按键. 在演示, 示教时很好用 👍</p><h2 id="驱动">驱动</h2><h3 id="显卡驱动">显卡驱动</h3><p>这里又不得不点名表扬一下Manjaro, 在装机时勾选了安装<strong>Proprietary Driver</strong> (非自由驱动)的话会自动装好闭源N卡驱动! 比如我的笔记本有一个intel UHD Graphics (集显) 和一个Nvidia RTX2070 (独显), 安装好系统后已经自动安装了采用最新的intel集显与Nvidia独显共存的<a href="https://wiki.archlinux.org/index.php/PRIME" target="_blank" rel="noopener">Prime方案</a>的混合驱动<strong>video-hybrid-intel-nvidia-prime</strong> 🎉</p><p>我也没有细看Prime方案和Bumblebee方案的具体差异, 看起来大概意思就是Bumblebee是软件实现, 有一定性能损失, 而Prime方案是更为推荐的新一代方案.</p><p>Prime技术让我们能够同时使用两个显卡: 以intel核显渲染画面, 以独显运行高负荷任务. <del>但是目前无论Prime方案还是Bumblebee方案都有个缺陷: 同时使用两个显卡时N卡无法输出画面, 即从直连N卡的HDMI接口无法输出画面, 但仅使用N卡的话可以从N卡输出画面. 仅使用N卡从性能方面没什么问题, 但是耗电, 发热会很夸张, 这对日常使用来说很不划算. 因此我们还是需要一个方法让我们能在需要N卡输出画面时能切换到仅N卡模式.</del></p><blockquote><p><del>至于外接屏幕, 我的解决办法是买一个有雷电接口 (雷电接口是直连CPU的, 其视频输出由intel核显承担) 的电脑, 这样一来在混合模式也能从雷电接口输出视频信号 😅</del></p></blockquote><p>卧槽我前几天试了一下现在在混合显卡模式也能从直连N卡的HDMI接口输出视频信号了! 😲</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S optimus-manager-qt</span><br></pre></td></tr></tbody></table></figure><p>💡 Manjaro KDE用户<a href="https://github.com/Askannz/optimus-manager#important--manjaro-kde-users" target="_blank" rel="noopener">需要编辑一下/etc/sddm.conf</a></p><p><a href="https://github.com/Askannz/optimus-manager" target="_blank" rel="noopener">optimus-manager</a>允许我们在<strong>仅intel显卡模式</strong>, <strong>仅N卡模式</strong>, <strong>混合模式</strong>三种模式间切换. 而optimus-manager-qt则为我们提供了一个GUI界面来进行设置, 一个系统托盘小图标来进行快速切换 (和装饰)</p><p>因为各种显卡模式切换方案基本带有对独显的电源管理方案, 因此在optimus-manager-qt也可以根据自己的情况选择适合的独显电源管理方案. 我的笔记本满足 "N卡为Turing架构及以上, intel CPU为CoffeeLake架构及以上" 的条件, 因此<a href="https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options#configuration-1--dynamic-power-management-inside-the-nvidia-driver-runtime-d3-power-management" target="_blank" rel="noopener">可以用N卡自带的动态电源管理</a>, Runtime D3 Power Management, 省心又省电 👍 不用时我的N卡功耗可以低到<strong>4W</strong> (是的用这个方案即便完全没有在使用N卡, 仍然会稍微消耗一点能量), 整个电脑的功耗最低到过9W (虽然长时间使用还是被长续航轻薄本吊打, 追求游戏本的续航是不现实的)</p><h3 id="oled屏幕亮度调节">OLED屏幕亮度调节</h3><p><a href="https://github.com/LeoJhonSong/oled-brightness/blob/master/oled-brightness" target="_blank" rel="noopener">我自己写的脚本</a> 😏</p><p>目前Linux对OLED屏幕支持很差, 似乎还没有发行版默认支持OLED屏幕亮度调节. 普通LCD屏幕的亮度调节是通过调整屏幕背光板的电压, 即背光板亮度来实现的. 当你在滑动你的Linux系统提供的亮度调节滑条时, <code>/sys/class/backlight/intel_backlight/brightness</code>的值会被改动, 然后系统会根据这个值和<code>/sys/class/backlight/intel_backlight/max_brightness</code>所记录的亮度最大值来调节背光板电压. 然而OLED屏幕根本没有背光板, 每个LED的亮度是可以单独调节的. 因此目前调节OLED屏幕亮度的方案是调整画面的Gamma值. 于是我写了这个基于<code>xrandr</code>的脚本, 这个脚本会监控<code>/sys/class/backlight/intel_backlight/brightness</code>值的变化并据此改变指定屏幕 (默认为主屏幕) 画面的gamma值.</p><p>顺带一提<code>xrandr</code>是一个功能很强大的设置屏幕画面的分辨率, 方向, 位置等参数的强大工具.</p><h3 id="镜像烧录">镜像烧录</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S ventoy-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用的时候用:</span></span><br><span class="line">sudo ventoyweb</span><br></pre></td></tr></tbody></table></figure><p>有了<a href="https://www.ventoy.net/cn/index.html" target="_blank" rel="noopener">Ventoy</a>这个项目, balenaEtcher, rufus这些传统意义上的镜像烧录软件就可以丢弃了! Ventoy支持一个U盘里放多个镜像, 在以这个U盘启动时会进入一个GRUB界面, 在这个页面再选择到底进入哪个镜像 🐮 我在我U盘里放了Windows镜像, Manjaro-KDE, Ubuntu20.04, 还有一个可以用来修复分区的<a href="https://gparted.org/download.php" target="_blank" rel="noopener">GParted</a>镜像, 还换了个GRUB主题, 爽到.</p><h2 id="系统工具">系统工具</h2><h3 id="资源管理器">资源管理器</h3><p><strong>Dolphin</strong>绝对是最好用的资源管理器! 多标签页, 显示预览等功能不在话下. Dolphin的右键菜单很贴心, Gnome自带资源管理器所没有的右键新建文件功能 (就离谱) 当然是有的, 也有创建快捷方式, 解压 (不论是rar还是zip还是tar都是同一个按键), 也可以很方便地自己创建脚本添加右键菜单的功能.</p><p>而Dolphin最突出的功能是按<kbd>F4</kbd>可以直接打开一个<strong>Dolphin内嵌终端</strong>. 这个终端的路径会随着在资源管理器里点击自动切换 (除非已经打开类似vim这样的程序), 使用起来超方便, 结合了终端的便捷和GUI的可视化等优势.</p><p><img style="zoom:70%;" data-src="Linux下各用途我最认可的工具推荐/Dolphin.png"></p><h3 id="任务管理器">任务管理器</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S htop</span><br></pre></td></tr></tbody></table></figure><p><strong>htop</strong>是升级版的top. 一是交互人性化很多, 支持鼠标交互, 设置页面分了页, 直观很多. 二是能以列表或者树的样式显示丰富得多的值, 比如该进程的线程数等, 还支持以关键词过滤显示的进程等功能.</p><h3 id="磁盘管理器">磁盘管理器</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S filelight</span><br><span class="line">yay -S partitionmanager</span><br></pre></td></tr></tbody></table></figure><p><strong>Filelight</strong>是KDE的图形化磁盘空间使用情况分析工具, 能以很多环同心扇形的形式直观地显示出哪里有大文件. <strong>partitionmanager</strong>是KDE的磁盘管理工具, 就类似Windows的磁盘管理器. 这两个应用Gnome社区也有类似的, 但感觉还是KDE的做得更人性化一些.</p><p>💡 用<code>du -sh /path/to/check/* | sort -hr</code>可以在命令行列出指定文件夹下按大小降序列出各文件夹/文件</p><h3 id="电脑管家">"电脑管家"</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S stacer</span><br></pre></td></tr></tbody></table></figure><p>虽然很多Linux老哥们认为Linux用户不需要这种东西, 但如果是习惯了在各种电脑管家打卡的Windows用户, 我推荐<strong>Stacer</strong>. 这是一个系统优化与监控软件 (和CCleaner等电脑管家画风很像), 可以看系统资源使用该要, 有任务管理器一栏, 可以清理垃圾, 可以管理开机自启项, 卸载已安装软件等... (是个很Windows画风的东西😅)</p><h3 id="tcp调试助手">TCP调试助手</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S nmap</span><br></pre></td></tr></tbody></table></figure><p>netcat被称为网络编程的瑞士军刀, 功能属实很多👍 要注意netcat有好几个版本, 给的参数略有区别. <strong>ncat</strong>是为Nmap项目写的netcat, 包含在nmap包中. 在其man中自称是诸多netcat版本中的巅峰之作 (水平有限俺也不知道是不是). <strong>nmap</strong>本身同样是一个用法很多的网络编程工具, 我主要用来扫端口.</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ncat监听本地8080端口</span></span><br><span class="line">ncat -l 8080</span><br><span class="line"><span class="comment"># ncat连接本地8080端口</span></span><br><span class="line">ncat 127.0.0.1 8080</span><br><span class="line"><span class="comment"># ncat监听本地8080端口, 发送一串16进制数据 (socket一个字节的内容为两位16进制数)过去并以双字节16进制显示输出</span></span><br><span class="line"><span class="comment"># 如果不满意显示格式的话可以换用hexdump -C然后加参数设置显示格式. hexdump支持的显示格式比xxd要丰富些. 注意不加-C参数的话hexdump默认按双字节小端转换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'0006303030304e43'</span> | xxd -r -p | ncat -l 8080 | xxd</span><br><span class="line"><span class="comment"># nmap扫描当前路由器192.168.1.1下所有设备的端口 (找树莓派之类设备IP时很方便)</span></span><br><span class="line">nmap 192.168.1.1/24</span><br></pre></td></tr></tbody></table></figure><h2 id="通讯">通讯</h2><h3 id="qq微信">QQ/微信</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin-wine-tim  # 比起QQ我更喜欢简洁的TIM (夹带私货)</span><br><span class="line">yay -S deepin-wine-wechat</span><br></pre></td></tr></tbody></table></figure><p>这两个软件在国内基本是必备了吧 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f937-2642.png?v8">🤷♂</span>. 在Linux上我体验下来最推荐的版本是以deepin-wine版. <a href="https://github.com/vufa/deepin-wine-wechat-arch#%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93%E6%98%BE%E7%A4%BA%E4%B8%BA%E6%96%B9%E6%A1%86%E6%98%BE%E7%A4%BA%E6%A8%A1%E7%B3%8A" target="_blank" rel="noopener">这里</a>是微信中中文字体显示为方框的解决方案. 如果使用的是4k高清屏, deepin-wine系软件显示得很小, 可以在<strong>deepin-wine5中</strong>设置分辨率. 比如设置TIM的分辨率:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env WINEPREFIX=$HOME/.deepinwine/Deepin-TIM deepin-wine5 winecfg</span><br></pre></td></tr></tbody></table></figure><p>然后会打开一个设置界面. 调节其中的<code>Graphics &gt; Screen resolution</code>一项. 我是4k屏幕, 感觉设成<strong>192dpi</strong>比较OK.</p><h3 id="会议">会议</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S wemeet-bin</span><br><span class="line">yay -S zoom</span><br><span class="line">yay -S teams</span><br></pre></td></tr></tbody></table></figure><p>我在Linux目前体验能用的视频会议软件有三个:</p><ul><li><strong>腾讯会议</strong>: deepin是真的nb. 这个腾讯会议我用起来似乎没有任何问题, 屏幕共享, 摄像头, 语音这些都没有问题 🐮🍺</li><li><strong>zoom</strong>: zoom看起来是会根据<code>QT_SCREEN_SCALE_FACTORS</code>环境变量设置界面缩放.我在系统设置中设置了1.75倍的全局缩放, 因此从终端, desktop entries打开应用的环境中都有这个环境变量. 在这种情况下打开zoom会看到一个巨大无比的zoom界面😂 解决方案有二:<ol type="1"><li>修改zoom的desktop entry的Exec这行, 在<code>/usr/bin/zoom</code>前面加<code>env QT_SCREEN_SCALE_FACTORS=1</code>来改变QT的缩放大小.</li><li>修改zoom的配置文件<em>~/.config/zoomus.conf</em>, 把<code>autoscale</code>设置为<strong>false</strong></li></ol></li><li><strong>Microsoft Teams</strong>: teams不是专门的视频会议软件, 是微软Office中的办公聊天软件, 不过它的视频会议版块功能丝毫不比zoom少, 甚至得益于Office套件间的联动使用体验非常流畅, 有很多类似到时间提醒参会成员, 自动生成会议云录制的字幕等很贴心的功能. 其界面非常现代, 功能也很多 (有很多插件). 其实这个也支持在网页参加会议, 体验很好的.</li></ul><h2 id="下载云盘">下载/云盘</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yay -S baidunetdisk-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> yay -S xunlei-bin</span></span><br><span class="line">yay -S aria2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台运行启用了RPC, aria2</span></span><br><span class="line">nohup aria2c --enable-rpc --allow-piece-length-change &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> yay -S motrix-bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo motrix --no-sandbox  <span class="comment"># 然后右键系统托盘里的图标退出</span></span></span><br></pre></td></tr></tbody></table></figure><p>下载大文件虽然还是经常避不开百度云, 但已经有越来越多人在用各种新出的网速还能拉满的网盘了, 比如阿里云盘, 夸克云盘. 前几天在淘宝买了个电影资源, 老板发给我个百度云链接, 我试了下3.1G被限速实在要下太久了, 搜了搜好像也没有很方便的解除限速的方式. 但其实解决方法很简单: 我问老板有没有其他云盘的下载方式, 然后老板给我了个夸克云盘的链接, 我就网速拉满地下完了. 这个baidunetdisk-bin就是有热心网友将百度云盘的官方的Linux版deb系安装包适配后发布到arch源里了, Linux版的和Windows版用起来并没有区别, <strong>仍然是有限速的</strong> 😁</p><p>磁力链和torrent我是用chrome插件<a href="https://chrome.google.com/webstore/detail/aria2-for-chrome/mpkodccbngfoacfalldjimigbofkhgjn" target="_blank" rel="noopener">Aria2 for Chrome</a>下的. 这个插件以aria2为后端, 能够自动拦截chrome中http, 磁力链, FTP等协议下载任务, 也支持torrent. 在插件的设置页面中设置触发自动拦截下载任务的文件大小为0MB的话torrent文件也会通过aria2下载, 而aria2默认开启了下载的是torrent文件时自动开始BT下载任务的选项, 体验会很好. 有点遗憾的是这个插件所使用的前端虽然可以对aria2进行设置, 但是这些设置在aria2重启后会丢失. 如果想要每次启动aria2后都能自动加载这些配置的话还是需要写一个aria2的配置文件<code>~/.config/aria2/aria2.conf</code>:</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认下载路径</span></span><br><span class="line">dir=/home/leo/Downloads</span><br><span class="line"><span class="comment"># 代理服务器</span></span><br><span class="line">all-proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line"><span class="built_in">continue</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 最大同时下载任务数</span></span><br><span class="line">max-concurrent-downloads=10</span><br><span class="line"><span class="comment"># 单服务器最大连接数</span></span><br><span class="line">max-connection-per-server=15</span><br><span class="line"><span class="comment"># 最小文件分片大小</span></span><br><span class="line">min-split-size=10M</span><br><span class="line"><span class="comment"># 允许所有来源</span></span><br><span class="line">rpc-allow-origin-all=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 允许非外部访问</span></span><br><span class="line">rpc-listen-all=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 最小做种时间. 当设置为0时在BT下载任务完成后不再做种</span></span><br><span class="line">seed-time=0</span><br></pre></td></tr></tbody></table></figure><p>然后可以运行来自<a href="https://github.com/P3TERX/aria2.conf/blob/master/tracker.md" target="_blank" rel="noopener">P3TERX/aria2.conf</a>的脚本<code>bash &lt;(curl -fsSL git.io/tracker.sh) "/home/leo/.config/aria2/aria2.conf"</code>添加一个Tracker列表给aria2配置文件, 提升torrent下载速度.</p><p>如果想用本地客户端下载磁力链和torrent的话强推<strong>motrix</strong>: 集成了每日自动更新的Tracker服务器列表的支持, 支持迅雷链接下载协议, 而且因为是electron做的所以界面非常美观! 不过除了Ubuntu镜像我能以30MB/s的速度下载我暂时还没下到过速度超过100Kb/s的... 这个软件在Arch系下似乎有bug, 安装好后需要用上面那条命令sudo启动然后关闭一次, 之后就能正常使用了.</p><p>💡据我同学说迅雷对一些资源有更快的速度, 我试了下还真是... 比用tracker的qbittorrent还要快很多 (是正经资源)</p><h2 id="图片视频处理">图片/视频处理</h2><h3 id="视频压缩">视频压缩</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S handbrake</span><br></pre></td></tr></tbody></table></figure><p>handbrake是一个支持非常丰富的视频格式转换/压缩工具. 视频编辑方面接触不多的人会意识不到一个录屏只需放进压缩软件简单<strong>无损压缩</strong>一下通常可以减小为原本体积的<strong>一半以下</strong>.而handbrake提供了许多直观的预设参数组. 我通常就用的<code>Offical&gt;General&gt;Very Fast 1080p30</code>这个预设. handbrake支持批量处理, 操作起来也很简单.</p><h3 id="图片压缩">图片压缩</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S jpegoptim</span><br><span class="line">yay -S optipng</span><br><span class="line">yay -S imagemagick</span><br></pre></td></tr></tbody></table></figure><p><strong>jpegoptim</strong>, <strong>optipng</strong>这两个终端程序可以分别对jpg/jpeg, png进行无损/有损压缩, 调用也很简单, 普通无损压缩的话跟的参数就图片名就可以.</p><p><strong>imagemagick</strong>是一套用于创建, 编辑, 显示图片的强大终端工具, 其中有一个<strong>magick</strong>终端程序可以实现jpg转png, 也可以压缩jpg, png等. 但是参数比上面两个复杂一些, 我反正记不住.</p><p>💡没有用到透明图层的png图片可以转为jpg, 能大幅压缩体积</p><h3 id="视频播放器">视频播放器</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S vlc</span><br></pre></td></tr></tbody></table></figure><p><strong>vlc是一个很神奇的播放器</strong>.</p><p>它不光支持非常多种视频文件格式, 还可以播放网络视频流, 比如RTSP视频流, IPTV网络电视, 还可以播放摄像头视频流... 加上它有截取视频一帧画面, 录制视频流, 高倍速播放, 在截取的画面上显示当前视频时间等功能, 他可以:</p><ul><li>当Linux上的相机软件</li><li>用来调试usb摄像头/IP摄像头</li><li>当网络电视 (顺便放一个非常全的<a href="https://github.com/iptv-org/iptv" target="_blank" rel="noopener">IPTV频道合集</a>)</li><li>看网课视频利器</li></ul><p>🐮🍺</p><h3 id="视频编辑器">视频编辑器</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S kdenlive</span><br></pre></td></tr></tbody></table></figure><p><strong>Kdenlive</strong>是一个界面很像Adobe Premiere的软件, 现在是KDE旗下项目. Kdenlive的语言看起来是继承的系统语言, 支持中文 (汉化得还是比较全面的). Kdenlive操作起来还是很简单的, 零基础随便看一看教程也就会用个大概了. Kdenlive的效果我感觉还是涵盖了Pr中最主要的那些了, 定位应该是和Pr一样也是视频剪辑软件 (Linux平台也有对标Ae的软件, Natron). Kdenlive也有Windows版, 而且安装包只有80MB, 很值得尝试的 👍</p><h3 id="制图">制图</h3><h4 id="图片">图片</h4><p>因为我处理图片的需求不大, 因此普通一些的需求我就在WPS的PPT软件里处理的, 有稍微复杂一点的PS需求时都是使用的这个<a href="https://www.uupoop.com/#/old" target="_blank" rel="noopener">在线PS</a>, 支持PhotoShop的<strong>PSD</strong>, sketch的<strong>sketch</strong>格式, GIMP的<strong>XCF</strong>格式等, 覆盖了常见格式, 十分方便 😆</p><h4 id="uml图">UML图</h4><ul><li>Graphviz: 这是一个根据代码自动生成图形的程序, 有<a href="https://dreampuf.github.io/GraphvizOnline/" target="_blank" rel="noopener">在线版</a>, 也有<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz" target="_blank" rel="noopener">VSCode插件版本</a>什么的. (顺便<a href="/zh-CN/2020/03/12/Graphviz简要语法/">这里</a>是我写的介绍Graphviz语法的博客)</li><li><a href="https://www.diagrams.net/" target="_blank" rel="noopener"><strong>diagrams.net</strong></a>: 这个是全平台的, 有在线版, 也有各系统的安装包. 它有非常丰富的元素, 能画出很好看很复杂的UML图, 但是无法自动整理布局. 不过它<strong>可以打开Visio的.vsdx文件</strong> 👍</li><li><a href="">PlantUML</a>: 这个则是以代码生成UML图的强大工具, 后端其实也是Graphviz (Graphviz本身用起来真的有点阴间), 提供有很多种类的模板, 可以几行代码画出一个非常好看的UML图! <a href="https://www.planttext.com/" target="_blank" rel="noopener">在线编辑器</a>在此</li><li><a href="http://asciiflow.com/" target="_blank" rel="noopener">ASCIIFlow Infinity</a>: 这个在线绘图工具是用来绘制<strong>纯文本</strong>框图. 不过因为它开源了, 因此也可以在本地使用 <code>yay -S asciiflow2-git</code></li></ul><h4 id="其他">其他</h4><ul><li><a href="http://patorjk.com/software/taag/" target="_blank" rel="noopener">Text to ASCII Art Generator (TAAG)</a>: 是一个生成文本的ASCII Art的在线工具 (就是oh-my-zsh更新时会显示的那种文本拼出来的大logo)</li></ul><h2 id="办公">办公</h2><h3 id="文档">文档</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S typora</span><br><span class="line">yay -S okular</span><br><span class="line">yay -S google-chrome</span><br></pre></td></tr></tbody></table></figure><p>做文档我首推Markdown, Markdown编辑器我首推<strong>Typora</strong>. (我还写过<a href="/zh-CN/2019/09/23/Markdown安利-Typora简要使用教程/">Markdown安利&amp;Typora简要使用教程</a>)</p><p>普通看pdf的话KDE的<strong>okular</strong>和GNOME的<strong>evince</strong>我觉得界面还比较简洁而不简陋, 现代. 相比起来okular功能更多一些, 对触控笔/手写等操作支持好许多 (虽然我不怎么用). 看文章时我更喜欢在<strong>Chrome</strong>的<a href="https://saladict.crimx.com/" target="_blank" rel="noopener">沙拉查词</a>插件提供的pdf.js的pdf阅读器里看, 查单词, 搜索很方便. 如果要做笔记的话我是在我的Windows系统平板上看的.</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S ghostscript</span><br></pre></td></tr></tbody></table></figure><p>补充一个可以用来压缩pdf的小工具<code>ps2pdf</code>, 在ghostscript软件包中, 还是挺实用的. 用<code>ps2pdf -dPDFSETTINGS=/ebook input.pdf output.pdf</code>就可以将pdf压缩为150dpi的质量. <code>-dPDFSETTINGS=/prepress</code>参数的话能得到质量为300dpi的pdf, 完全满足打印的需求了.</p><h3 id="latex">latex</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S visual-studio-code-bin</span><br><span class="line">yay -S texlive-most texlive-lang biber</span><br></pre></td></tr></tbody></table></figure><p>TeX Live是很大一套软件, 嫌麻烦的话最好就直接把包含了绝大多数部件的<strong>texlive-most</strong>以及语言包<strong>texlive-lang</strong>下下来. 其中CTeX包含在<strong>texlive-langchinese</strong>这个包中. <strong>biber</strong>则是比biblatex更先进的引用处理工具. 顺带一提<a href="/zh-CN/2021/05/24/LaTeX杂记">这里</a>是我写的LaTeX语法笔记.</p><p>在Linux上使用LaTeX我只推荐两种方案:</p><ol type="1"><li><p>在<a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a>中在线编辑</p><p>Overleaf以TeX Live作为后端, 开箱支持选择编译器, 支持基础的vim键映射, 提供看得过去的补全, 提供拼写和语法 (指LaTeX)检查... 点开Overleaf就有了一个还不错的LaTeX环境, 不需要担心缺少依赖, 不需要设置编译工具链, 编辑界面还算好看, 编译速度也很快, 是真的很省心了 👍 除此以外Overleaf支持git同步, 也支持多人协作编辑, 对于不想费心配置环境的人来说是真的很棒了</p></li><li><p>借助<a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop" target="_blank" rel="noopener">LaTeX Workshop</a>插件在VSCode中本地编辑</p><p>曾经看了<a href="https://zhuanlan.zhihu.com/p/60049290?utm_source=qq&amp;utm_medium=social&amp;utm_oi=911363543885045760" target="_blank" rel="noopener">这篇文章</a>我也一度想试试在vim中编辑TeX文件, 以Okular显示的方案, 但体验后发现用vim编辑富文本文档真是傻逼. 我原本是馋这样快捷的补全, 但事实证明装几个补全插件, 都还不需要自己添加snippet补全体验就已经很不错了 (毕竟我不是数学专业, 并不会频繁用到奇怪公式). 另一方面, 我试了好几个pdf软件, 反向搜索都只能具体到行, 不能让光标精确定位到我在pdf中点到的词/图上, 而LaTeX Worshop提供的VSC内置pdf阅读器支持精确的反向搜索. 另外我在VSC中装了<a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener">拼写检查</a>和<a href="https://marketplace.visualstudio.com/items?itemName=CodeInChinese.EnglishChineseDictionary" target="_blank" rel="noopener">查单词</a>的插件, (有拼写检查很重要!) 而我很久以前搜的时候并没有搜到好用的vim拼写检查插件. 其他方面vim倒是和VSC差不多.</p></li></ol><h3 id="office套件">Office套件</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S wps-office-cn  # wps套件国内版</span><br><span class="line">yay -S wps-office-mui-zh-cn  # wps中文语言包</span><br><span class="line">yay -S ttf-wps-fonts  # wps需要的字体和符号</span><br></pre></td></tr></tbody></table></figure><p>💡安装WPS遇到的问题都可以在<a href="https://wiki.archlinux.org/title/WPS_Office_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">ArchWiki-WPS Office</a>找到答案.</p><p>我体验了Office365 Online, LibreOffice, Google Docs, WPS后发现在Linux用Office套件只能是用WPS, 而且很好用. 其他软件简直是一坨💩</p><p>Office365 Online当然是格式兼容最好的, 但是必须在线使用, 而且打开一个本地文件时会先把这个文件上传到onedrive中然后从云端打开, 文件稍微大点那体验很差. 在线版Office表面看岁月静好, 其实功能阉割非常严重. Google Docs虽然可以安装为chrome插件离线使用, 但是功能更加简陋了! 而LibreOffice就很离谱了, 明明是一个本地使用的Office套件, 但支持的功能并不比前两者多多少, 同时界面还有点古老.</p><p>这三者的功能缺失到底有多严重呢? 我来举几个例子:</p><ol type="1"><li>都没有内置插入富文本公式的功能</li><li>都不可以设置插入的矩形的透明度 (有时候我会用一个带透明度的矩形来作为图片蒙版)</li><li>Office365 Online和LibreOffice的PPT软件都不支持插入本地视频, Google Docs我就没试了. Office365 Onlineq其实是可以插入视频, 但是只支持来自于youtube等几个有限选择的联机视频... 而LibreOffice的PPT软件在编辑时可以插入本地视频, 但是保存为<code>.ppt</code>后这个视频不知道为什么没了... (我没试保存为它自己的格式的话能不能行, 因为那也没什么用)</li><li>...如果上面几个功能都不支持我不如写Markdown文档了所以不用试了</li></ol><p>而另一边, <strong>WPS出乎我意料的好!</strong> 以上功能WPS统统支持, 用起来和MS Office真的是区别不大了👍 目前注意到的也就是PPT里不支持3D模型 (但是也能显示成图片), 甚至平滑切换效果这个MS Office的特色功能都支持了! 另外选中一些对象右键另存为图片时好像不能另存为svg或其他矢量图格式, 无伤大雅. 格式不完全兼容这个问题当然还是存在, 但是在接受范围内. 而且, WPS现在还挺好看的🐮</p><p><img data-src="Linux下各用途我最认可的工具推荐/wps.png"></p><p>至于MS Office套件提供的其他我使用的软件:</p><ul><li><p>Outlook, 微软待办事项, 日历我使用的是网页版 (在Windows我也用的网页版, 因为可以和微软待办事项, 日历联动我觉得体验反而比Outlook本地客户端体验更加良好)</p></li><li><p>teams则是有官方Linux版本, 可以执行<code>yay -S teams</code>安装. 不过网页版也能获得完整的体验, 我感觉没什么差别</p></li><li><p>OneDrive的话虽然有人开发了<a href="https://abraunegg.github.io/" target="_blank" rel="noopener">OneDrive Linux客户端</a>, 但我并没有使用. 虽然我平时使用Linux系统, 但是我把我的Windows盘挂载在了我的Linux系统里, 可以访问并编辑OneDrive文件夹里的文件, 然后我对同步频率的要求没多高, 因此暂时没感觉不方便 (主要是很久以前试过这个客户端, 当时体验很一般). 比较有意思的是目前在企业版Office365 (学校给的) 的应用列表中直接有列出OneDrive Linux版的图标, 但链接到的是一个<a href="https://github.com/skilion/onedrive" target="_blank" rel="noopener">有很多bug功能很不全的版本</a>, 而且我的个人版Office365的应用列表并没有列出这个 😅<img data-src="Linux下各用途我最认可的工具推荐/onedrive.png"></p><p>在<a href="https://github.com/skilion/onedrive/issues/518" target="_blank" rel="noopener">这个issue</a>中可以看出skilion完全不想为社区开发, 但同时拒绝向abraunegg的版本引流或注明自己的版本的问题... 👎</p></li></ul><h2 id="工程">工程</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S minicom  # 终端串口调试助手, 也有GUI版, cutecom</span><br><span class="line"><span class="meta">#</span><span class="bash"> 未完待续...</span></span><br></pre></td></tr></tbody></table></figure><h3 id="命令行工具">命令行工具</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yay -S zsh</span><br><span class="line">chsh -s /usr/bin/zsh  # 切换默认shell为zsh, 要注意你的zsh也许不在/usr/bin/zsh</span><br><span class="line"></span><br><span class="line">yay -S tmux</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用gpakosz的tmux主题</span></span><br><span class="line">cd ~ &amp;&amp; git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s -f .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local .</span><br><span class="line"></span><br><span class="line">yay -S lsd</span><br><span class="line">git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf</span><br><span class="line">~/.fzf/install</span><br><span class="line">yay -S bat</span><br></pre></td></tr></tbody></table></figure><p>在这里我想先辨析一下<code>终端</code>, <code>shell</code>, <code>命令行</code>这三个词:</p><ul><li><p><strong>终端</strong> (terminal), 最开始指的是一种用来与计算机主机交互的输入输出设备, 是硬件, 而我们如今绝大多数情况下说的终端实际上是终端模拟器 (terminal emulator) 的简称, 是一类模拟终端这种提供与计算机交互界面的功能的软件. 有的终端模拟器不仅可以显示字符还可以显示图像. 我用的终端是KDE提供的<strong>Konsole</strong>. 去掉标题栏及边框后能达到👇这样的效果, 我感觉还挺好看😁 <img data-src="Linux下各用途我最认可的工具推荐/terminal.png"></p></li><li><p><strong>shell</strong>, 指的是一种让用户能够与操作系统内核进行交互的软件 (我们通常说的是命令行界面shell, 但实际上shell这个概念还包含了GUI的shell, 比如KDE). Ubuntu及Manjaro等系统自带的shell程序是bash, MacOS自带的shell则是zsh. 实际上zsh是比bash体验好很多的shell程序, 自身的补全更加智能, 有很丰富的插件选择, 有<a href="https://ohmyz.sh/" target="_blank" rel="noopener">Oh My Zsh</a>这样的便利shell配置管理框架... 反正谁用谁知道 👍 我也不清楚为什么大多数Linux系统仍将bash作为系统默认shell, 这点表扬MacOS. 用下面的命令来安装并切换默认shell为zsh.</p></li><li><p><strong>命令行</strong>, 看了前两者的描述能发现命令行指的只是相对于图形化界面操作的一种操作方式, 一般是纯文本界面, 少数命令行程序支持鼠标操作, 比如vim (需要设置), htop (命令行任务管理器), ranger (命令行资源管理器), w3m (命令行浏览器), tmux.</p></li></ul><p>然后我来介绍几个好用的命令行工具:</p><ul><li><p>tmux是一个终端复用器 (解释起来比较复杂, 建议自行搜索一下), 我主要用来在一个终端里开多个窗口 / 连服务器. tmux的设计使得与服务器交互时在服务器侧开一个tmux后即便丢失与服务器的连接, 服务器端tmux中的任务仍会正常执行下去, 并且下次连上服务器后进入tmux就可以回到这个工作现场. 推荐一下<a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">这个tmux主题</a>, 开箱就能有很不错的体验, 颜值很高, 配置也很容易个性化.</p></li><li><p>lsd是<code>ls</code>命令的替代品, 最主要的价值是让ls命令的输出变成彩色而且每种文件有对应图标显示的了 😁 要注意需要安装<a href="https://github.com/ryanoasis/nerd-fonts/blob/master/readme.md" target="_blank" rel="noopener">特定类型的字体</a> (Manjaro已经自带这种字体)</p></li><li><p><a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">fzf</a>是一个模糊查找器, 不止可以在zsh里用, vim, tmux中也有支持. 我主要喜欢用来在zsh中能模糊输入我设定了的几个命令, 结合<strong>bat</strong>, 这个升级版cat, 能获得很流畅的 (装逼) 体验. 之所以不从aur装fzf是因为从aur装的fzf不知为什么会缺少<code>.fzf.zsh</code>这个文件. 贴上我在<code>.zshrc</code>中对fzf的配置:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> fzf config and initial</span></span><br><span class="line">if [ -f ~/.fzf.zsh ]; then</span><br><span class="line">    export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow"</span><br><span class="line">    # export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow --exclude $FD_EXCLUDES"</span><br><span class="line">    export FZF_COMPLETION_TRIGGER=']'</span><br><span class="line">    export FZF_DEFAULT_OPTS='--layout=reverse --info=hidden --marker="✔ " --prompt=" "'</span><br><span class="line">    # Use fd (https://github.com/sharkdp/fd) instead of the default find</span><br><span class="line">    # command for listing path candidates.</span><br><span class="line">    # - The first argument to the function ($1) is the base path to start traversal</span><br><span class="line">    # - See the source code (completion.{bash,zsh}) for the details.</span><br><span class="line">    _fzf_compgen_path() {</span><br><span class="line">        fd --type f --hidden --follow . "$1"</span><br><span class="line">    }</span><br><span class="line">    # Use fd to generate the list for directory completion</span><br><span class="line">    _fzf_compgen_dir() {</span><br><span class="line">        fd --type d --hidden --follow . "$1"</span><br><span class="line">    }</span><br><span class="line">    # (EXPERIMENTAL) Advanced customization of fzf options via _fzf_comprun function</span><br><span class="line">    # - The first argument to the function is the name of the command.</span><br><span class="line">    # - You should make sure to pass the rest of the arguments to fzf.</span><br><span class="line">    _fzf_comprun() {</span><br><span class="line">        local command=$1</span><br><span class="line">        shift</span><br><span class="line">        case "$command" in</span><br><span class="line">            cd)             fzf "$@" --preview 'lsd --tree {} | head -200' ;;</span><br><span class="line">            export|unset)   fzf "$@" --preview "eval 'echo \$'{}" ;;</span><br><span class="line">            ssh)            fzf "$@" --preview 'dig {}' ;;</span><br><span class="line">            vim)            fzf "$@" --preview 'bat --style=numbers --color=always --line-range :500 {}' ;;</span><br><span class="line">            *)              fzf "$@" ;;</span><br><span class="line">        esac</span><br><span class="line">    }</span><br><span class="line">    source ~/.fzf.zsh</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="远程服务器相关">远程/服务器相关</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yay -S sshfs</span><br><span class="line">yay -S frp</span><br><span class="line">yay -S filezilla # 访问ftp/sftp等协议文件系统</span><br><span class="line">yay -S remmina # 支持多种协议的远程桌面</span><br><span class="line">yay -S freerdp # 为了让remmina支持rdp协议需要安装这个</span><br></pre></td></tr></tbody></table></figure><p>sshfs允许以SFTP将SSH服务器的指定路径挂载到本机, 在懒得配服务器的IDE/编辑器时可以用这种方式在本地编辑, 对不需要IDE/编辑器的高阶调试时还是挺方便的.</p><p>frp则是一种以反向代理的方式让我们能非常方便地ssh到一台内网服务器的方式! 使用非常简单, 在要访问的内网机器和作为跳板的公网服务器上分别放一个程序和配置文件就能用了👍 参见<a href="https://gofrp.org/docs/setup/" target="_blank" rel="noopener">frp文档</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note warning&quot;&gt;
            &lt;p&gt;因为各种好用软件层出不穷, 提到的软件也可能在快速更新, 因此这篇文章时效性会很短, 请注意☝更新时间.&lt;/p&gt;
          &lt;/div&gt;
&lt;p&gt;用Linux的时间已经比用Windows的时间还长了, 随着使用逐渐找到了各用途我最认可的工具, 或从软件源安装, 或在线使用. 在此整理一份我的Linux下各用途好用工具推荐. (出于私心将从一个&lt;strong&gt;Manjaro-KDE&lt;/strong&gt;用户角度介绍)&lt;/p&gt;
&lt;p&gt;💡各位如果有什么推荐的软件也可以底下评论, 我觉得好用会加进去的.&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>笔记本电脑性能提升/选购指南</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/05/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/05/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</id>
    <published>2020-05-08T07:26:17.000Z</published>
    <updated>2020-05-08T07:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>自去年三月多开始有意识了解电脑配件至今已有一年多, 对这些乱七八糟的了解多了许多, 整理一下我对<strong>笔记本</strong>性能提升的经验以及选购指南. 因为我很了解在不了解这些时听到这些陌生概念的望而畏怯以及半信半疑, 我尽量解释得小白些.</p><p>❗️ 因为我自己没有台式机所以这里只谈笔记本相关.</p><a id="more"></a><!-- TODO --><h2 id="性能提升">性能提升</h2><p>不同于台式机里什么配件都可以换, 比如很多笔记本的CPU, 显卡是焊死在主板上的. 即便你的笔记本支持更换这两样, 这也不是容易事. 因为笔记本的散热是精打细算设计好的, 更换了更好的CPU或者显卡通常以为着更大的发热量, 很容易导致过热然后出奇奇怪怪的问题.</p><p>因此为了提升笔记本性能常见的操作是<strong>更换硬盘和内存</strong>.</p><h3 id="更换硬盘">更换硬盘</h3><h3 id="更换内存">更换内存</h3><h2 id="选购指南">选购指南</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自去年三月多开始有意识了解电脑配件至今已有一年多, 对这些乱七八糟的了解多了许多, 整理一下我对&lt;strong&gt;笔记本&lt;/strong&gt;性能提升的经验以及选购指南. 因为我很了解在不了解这些时听到这些陌生概念的望而畏怯以及半信半疑, 我尽量解释得小白些.&lt;/p&gt;
&lt;p&gt;❗️ 因为我自己没有台式机所以这里只谈笔记本相关.&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="https://leojhonsong.github.io/zh-CN/categories/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年4月12日 Vim经验分享</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/04/20/2020%E5%B9%B44%E6%9C%8812%E6%97%A5vim%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/04/20/2020%E5%B9%B44%E6%9C%8812%E6%97%A5vim%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2020-04-20T09:01:34.000Z</published>
    <updated>2020-04-20T09:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>最近在<a href="https://uestc-msc.github.io/" target="_blank" rel="noopener">电子科大微软学生俱乐部</a>做了一次vim经验分享, 下面是当时的录像. 这个录像是用zoom的会议录制功能得到的. 顺带一提zoom是有Linux平台的目前为止体验最好的视频会议软件, zoom录制的会议视频似乎本身就会进行压缩, 不像用其他软件得到的会议录制我还要自己压缩一下. zoom要是再有网页端就更好了😆</p><iframe src="//player.bilibili.com/player.html?aid=710237273&amp;bvid=BV18Q4y1K744&amp;cid=177852832&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><p>然后因为当时准备得有些仓促导致有几个地方演示得不充分有的地方说串了, 所以我补全了幻灯片. 👇下面这个就是我的幻灯片, 使用<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">Markdown Preview Enhanced</a>制作的markdown幻灯片. 屏幕gif录制工具为<a href="https://github.com/phw/peek" target="_blank" rel="noopener">peek</a>, 键盘按键可视化工具为<a href="https://gitlab.com/screenkey/screenkey" target="_blank" rel="noopener">screenkey</a></p><div style="width:100%; padding-bottom:56.25%; position:relative;"><p><iframe src="https://leojhonsong.github.io/vim-share/vim.html" style="width:94%; height:94%; position:absolute; transform: translate(3%,3%); box-shadow: 0 0 6px 7px black;"></iframe></p></div><p>🔗 你也可以点击<a href="https://leojhonsong.github.io/vim-share/vim.html">这个链接</a>全屏观看. 这个幻灯片的源代码在<a href="https://github.com/LeoJhonSong/vim-share/blob/master/vim.md" target="_blank" rel="noopener">这里</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="vim" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>单硬盘三系统安装记录</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/04/04/%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/04/04/%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-04T07:04:15.000Z</published>
    <updated>2020-05-25T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一下我在同一个SSD里同时安装Ubuntu, Windows, macOS三个系统并以GRUB作为开机引导的经验. 说实话过程并不复杂.</p><a id="more"></a><p>也不知道最近自己时间都浪费哪里去了😑 3月7号弄好的东西现在才得以闲下来记录一番. 先秀一张GRUB界面😏</p><p><img data-src="单硬盘三系统安装记录/grub.jpg"></p><h2 id="动机">动机</h2><p>说说我的心路历程😏</p><p>直到上大学我都对电脑了解甚少, <strong>只知道有Windows系统</strong>, 并不知道还可以有其他系统, 更别说在这之上的骚操作了😂 上大学后<strong>我逐渐熟悉了Windows系统</strong>并且喜欢上了这个很有现代感的系统. 但随着我对编程的学习逐渐深入, 以及我为了尽早熟悉机器人相关知识而想要了解Linux系统, 在听人介绍后我费了些力气<strong>在虚拟机里装上了Ubuntu16.04</strong>, 不过那时候了解的还是太少, 只是跟着网上的教程将这个东西装好了, 没什么收获. 装好后因为那时也没什么夸张到要开虚拟机在Ubuntu里编程的项目, 所以就体验了几下就束之高阁了. 毕竟那时对于编程, 甚至查找资料的经验都太少了, 只看到一些令人头大的辣鸡资料, 因此并没能学到什么.</p><p>大一下的时候我选了一门叫智能嵌入式的课, 其中有个课题是要编写一个能手势识别的程序并移植到树莓派上. 因此我就买了一个树莓派3b+. 不过那时懵懂的我对于怎么给一个SD卡安装系统手足无措, 就在网上搜资料给树莓派依次装了Ubuntu Mate, ArchLinux, 最后才是Raspbian😂 (我记得Mate是因为我当时没有找到arm架构的国内源就抛弃了, 而ArchLinux我就根本没装上...) 费劲心力我最后总算是把那个课题做完了, 但一方面我写得很差, 再加上树莓派3b+对图像处理的性能很一般, 所以我的手势识别程序移植到树莓派后十分卡顿😅 那是我<strong>第一次将程序移植到Linux平台, 也是第一次接触Linux嵌入式</strong></p><p>后来在一个实验室学习时接触到了ROS, 而那时Ubuntu18.04已经较为成熟了, 我就安装了个Ubuntu18.04的虚拟机在里面跟着刷了一遍ROS基础教程, 这回算是<strong>对Ubuntu的基本使用比较了解了</strong>. 不过那时其实并完全不了解ROS的最大作用是什么, 只是知道很牛逼, 跟着教程做了一遍, 没多久就忘了, 只是了解到有那么些概念😁 那时我以为Linux系统也就那样, 我在虚拟机体验到的就是它的全部了. 因此那时有同学和我讨论装Linux虚拟机好还是Windows, Linux双系统好时, 我的想法就是这系统又没那么便利, 误操作带来的危险性又那么大, 当然是装在虚拟机好.</p><p>而我装Windows, Ubuntu双系统的契机应该是<a href="/zh-CN/2019/03/30/我打算换电脑了/">我电脑的机械硬盘开始老化</a>, 速度变得极慢. 那应该是我大二下刚开学的时候, 我实在忍受不了在机械硬盘运行本身就很耗资源的Windows系统了, 而那时我的编程活动也开始多起来, 再加上我偶然得知Ubuntu能识别到已经存在的Windows系统并傻瓜式安装, 我就给自己<strong>装了个Windows, Ubuntu双系统</strong>. 不久后我的机械硬盘彻底不行了就买个一个1T的SSD. 不过换了硬盘后我也还是装的双系统, 因为我<strong>逐渐尝到了Linux系统的甜头</strong>.</p><blockquote><p>我在<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/">另一篇文章</a>写了自己对Linux和Windows的对比</p></blockquote><p>而随着我逐渐熟悉Ubuntu, 我开始像大多数Linux用户那样折腾自己的配置, 美化环境😏 期间也尝试了挺多东西, 到现在也形成了自己的使用习惯. 不过很尴尬的是在美化方面, 我经常看到这个好康的在Linux没有但macOS有的字眼. 所以<strong>我开始眼馋macOS</strong>. 不过那时我也就是眼馋, 因为我对比了一番, 发现macOS从接口, 生态等角度都不太适合做嵌入式开发就没有想过安一个试试. (我也在VMware里折腾过macOS虚拟机, 但和Ubuntu虚拟机一样装了没多久就删了)</p><p>而直到最近, 我看到了很详细的黑苹果安装教程, 加上我一个同学根据那份教程成功安上了黑苹果, 我也蠢蠢欲动了. 毕竟疫情期间闲着也是闲着+都用双系统了再多一个也不多. 于是我折腾一番<strong>给单硬盘安装了三个系统</strong>😁</p><p>P.S. 第一次体验macOS的本土包一开始连怎么删除文件都没搞懂, 还是现查的😅 使用逻辑与Windows/Linux差得真的太多了! 甚至因为别扭一度弃用了几天. 不过光是macOS下终端的美观程度就把俺勾回来了🤤</p><p>之前也看到网上有人装三系统的文章, 但基本都用了些杂牌子工具一通瞎操作... 所以我分享一下自己较为<strong>清爽</strong>的安装方法.</p><p>❗️ 我的电脑是真的一点不矫情, 安装很顺利, 不保证你的电脑上同样的不会出幺蛾子.</p><h2 id="关于镜像烧录">关于镜像烧录</h2><h3 id="镜像烧录工具">镜像烧录工具</h3><p>镜像烧录工具是唯一需要的第三方工具了. 强烈推荐使用<a href="https://www.ventoy.net/cn/doc_start.html" target="_blank" rel="noopener">Ventoy</a>! 这个软件可以将你的U盘创建为一个启动盘, 之后只需要将各种系统镜像放进这个U盘, 到时候以这个U盘启动时会进入一个GRUB界面, 在这个页面再来选择到底进入哪个镜像 👍 有了Ventoy, 装三系统的操作简单了很多!</p><h3 id="下载镜像">下载镜像</h3><p>因此将U盘创建为启动盘后就把要用到的三个镜像都放进U盘的<strong>Ventoy</strong>这个分区就完事.</p><ul><li>MacOS镜像: <a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html" target="_blank" rel="noopener">这个文章最后的百度云链接</a></li><li>Windows10镜像: 微软现在提供了<a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO" target="_blank" rel="noopener">官方的镜像下载网站</a> 👍 当然要激活的话还是需要激活码的. 而激活码在淘宝就可以买到, 只是需要巧妙措辞 😏</li><li><a href="https://cn.ubuntu.com/download" target="_blank" rel="noopener">Ubuntu镜像</a></li></ul><p>安装每个系统平均下来十五分钟, 因此全过程<strong>一个小时内</strong>就能搞定.</p><h2 id="系统安装">系统安装</h2><p>我安装系统的顺序是:</p><ol type="1"><li>macOS10.15.4</li><li>Windows10</li><li>Ubuntu18.04</li></ol><p>之所以是先安装macOS是因为看网上都说<strong>macOS要求EFI分区不小于200MB</strong>, 否则在安装时会提示无法安装. 然后我搜了搜EFI分区扩容, 似乎并没什么清爽的办法. 因此时刻准备着重装系统的我判定<strong>还是直接格式化硬盘来得清爽</strong>. 然后在安装的时候先安装macOS那它自己就会处理好这个事情, 不需要我担心😁</p><p>(不过我把三个系统都装完这个EFI分区也才用了120MB, 也不知道它要那么大干嘛)</p><p>而最后才安装Ubuntu是基于两方面考虑:</p><ol type="1"><li>如果先装Ubuntu就意味着得给Windows系统留下一定空间. 那么就需要在安装Ubuntu过程中"Installation Type"这一页选择<code>Something else</code>来<strong>自己给Linux系统分区</strong> (如果不选这种方式, 另外两种方式都会使用硬盘剩余的所有空间). 然而麻烦的是你不光需要给Ubuntu系统分一个主分区, 你还需要讲这个主分区分成几个逻辑分区, 而且每个逻辑分区的大小有一定的讲究. 我目前没有研究过这里的门道并且我对Ubuntu安装程序帮我规划的各个分区的大小没有不满. 因此我决定不去管这种事, <strong>我选择最后来安装Ubuntu, 让安装程序用我给它剩下的空间自己看着办</strong>😏</li><li>Ubuntu安装程序能识别电脑里已经安装的Windows系统 (识别不到我的黑苹果系统), 并<strong>自动处理好与Windows系统共存的配置</strong>, 将Windows添加到GRUB引导项中. 因为我的主力系统是Ubuntu而且我也很喜欢使用GRUB作为开机引导程序, 因此这帮我省了一些事.</li></ol><h3 id="macos安装">macOS安装</h3><p>我使用的黑苹果镜像是<a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html" target="_blank" rel="noopener">在这个文章最后的百度云链接</a></p><p>❗️ 我安装完之后才从使用苹果系统的同学们那得知macOS10.15, 也就是Catalina目前bug还比较多, 外观上和10.14也没什么区别, 因此建议安装macOS<strong>10.14</strong>, 而不是10.15.</p><p>这个镜像很棒的一点是它不止包含一个macOS系统安装程序, <strong>还有一个Windows PE</strong>, 也就是一个可以从U盘启动的专门魔改过, 用于修复系统的Windows系统. 这个Windows PE中包含了大多数你在网上教你修复系统发中文教程中提到的各种看起来有点不靠谱的工具 😂</p><p>我安装macOS使用的是<a href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" target="_blank" rel="noopener">这个教程</a>. 跟着一步步操作就可以了. 安装好后发现有驱动问题等先放着不管, 把三个系统都装好再来看上面那个镜像的链接里提供的问题解决方案好了, 不然容易心情变得焦躁的 🤗</p><h4 id="更改efi分区文件">更改EFI分区文件</h4><p>看到网上说装黑苹果最重要的就是要有对应自己电脑型号的EFI文件, 过了这一关就八九不离十了.</p><p><a href="https://github.com/daliansky/Hackintosh#%E9%BB%91%E8%8B%B9%E6%9E%9C%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4%E6%9C%BA%E5%9E%8B%E6%95%B4%E7%90%86-by-%E6%88%91%E6%84%8F" target="_blank" rel="noopener">这里</a>是一份黑苹果爱好者们提供了EFI分区文件的笔记本和台式机的型号列表, 也有他们自己的安装过程分享. 我使用的是其中的<a href="https://github.com/YGQ8988/dell-3568" target="_blank" rel="noopener">Dell Inspiron 3568</a></p><p>💡 在安装前我也曾担心后续两个系统的安装会不会破坏已经安装好的macOS的EFI文件, 实验表明他们是互不干扰的, 不会看对方不顺眼就删掉对方 😏</p><h4 id="网卡问题">网卡问题</h4><p>这似乎是在实体机安装黑苹果一定会有的问题, 有人是直接买了一个苹果能识别的网卡换上, 而我懒一点, 我买了一个有macOS驱动的外置网卡, Comfast的<strong>CF-811 AC</strong>, 很小一个, 不贵, 速度也很不错. macOS在使用这个外置网卡时不会认为在使用WiFi, 而是认为是接入了一个以太网. 唯一缺点是我还没有搞清如何让使用这样外置网卡的macOS连接上星巴克WiFi这样需要等它弹出登录页面才能用的公共WiFi--并不会有什么页面弹出 😓</p><h3 id="windows安装">Windows安装</h3><p>在安装系统的第一步就会要你选择安装在哪里, 在此时创建一个想要的大小的分区选中就可以进行安装了. 因为我的硬盘是1TSSD, 所以我分了一个274G的分区给Windows, 绰绰有余. 如果我真用满了也意味着我该重装了.</p><h4 id="system-reserved分区">System Reserved分区</h4><p>当你安好Windows系统后会发现在给Windows划分的分区前后多了两个分区, 一个叫<strong>System Reserved</strong>, 一个叫<strong>Microsoft Windows Recovery Environment</strong>如果你断定自己不会用到安装在硬盘的Windows系统的恢复模式 (实际上Windows安装盘的恢复模式或者Windows PE盘可能会是你遇到麻烦时的更好选择), 那么<strong>Microsoft Windows Recovery Environment</strong>这个分区可以随便删. 而<strong>System Reserved</strong>这个分区<strong>绝对不能随便删, 最好是别动</strong>. 血泪教训啊! 一次我看这分区不爽一气之下删掉了, 然后就因为缺少文件而无法启动Windows了...</p><p>🔗 <a href="https://www.zhihu.com/question/60154583" target="_blank" rel="noopener">Windows的System Reserved分区是什么以及能否删除</a></p><p>我找到了这个<a href="http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf" target="_blank" rel="noopener">Windows Boot Environment - Murali Ravirala (Microsoft)</a>, 里面讲述了Windows系统的启动过程, 提到了这个分区的作用.</p><p>总结下来意思就是<strong>System Reserved</strong>这个分区不能随便删, 要删还要不会出错操作很麻烦, 因此就别动它了 🤦‍♂</p><p>💡 值得一提的是Windows现在有了<strong>开发人员模式</strong>, 开启这个模式后在Windows开发的体验会好很多, 不会经常弄出些乱七八糟的错误.</p><h3 id="ubuntu安装">Ubuntu安装</h3><p>Ubuntu系统的安装就跟着<a href="https://ubuntu.com/tutorials/tutorial-install-ubuntu-desktop#1-overview" target="_blank" rel="noopener">官网安装教程</a>来是最简洁正确的. 唯一需要注意的是在官网教程第六步时, 因为之前安装了Windows系统, Ubuntu安装程序会检测到已安装的Windows系统, 并给出一个<strong>Install Ubuntu alongside Windows 10</strong>的选项. 选择这个是这种情况下最简单的安装方式. 另外选择这个的话Ubuntu安装程序会自动把Windows系统加入到GRUB中, 属实舒服.</p><p><strong>系统安装就全部完成了!</strong> 🎉</p><h2 id="grub配置及开机美化">GRUB配置及开机美化</h2><p>然后是我在这次重装前一直不确定的事: 是否能把macOS引导项也加入GRUB? 经过我的尝试答案是可以!</p><p>在网上搜索后我知道了怎么样来配置GRUB的引导项, 其实真心不难.</p><h3 id="引导项设置">引导项设置</h3><p>第一步是进入<code>/etc/grub.d/</code>, 添加/编辑引导项. ❗️ 建议在先备份这个路径下的文件, 等确认改动成功了再删除备份也不迟.</p><p>在我的这个路径下有这样一些文件. 是的这里甚至有一个README 😂</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00_header</span><br><span class="line">05_debian_theme</span><br><span class="line">10_linux</span><br><span class="line">20_linux_xen</span><br><span class="line">20_memtest86+</span><br><span class="line">30_os-prober</span><br><span class="line">30_uefi-firmware</span><br><span class="line">40_custom</span><br><span class="line">41_custom</span><br><span class="line">README</span><br></pre></td></tr></tbody></table></figure><p>这个README的内容是这样的:</p><blockquote><p>All executable files in this directory are processed in shell expansion order.</p><p>00_<em>: Reserved for 00_header.<br>10_</em>: Native boot entries.<br>20_*: Third party apps (e.g. memtest86+).</p><p>The number namespace in-between is configurable by system installer and/or administrator. For example, you can add an entry to boot another OS as 01_otheros, 11_otheros, etc, depending on the position you want it to occupy in the menu; and then adjust the default setting via /etc/default/grub.</p></blockquote><p>也就是说: - <strong>00_</strong>开头的是为<code>00_header</code>这个文件保留的, <strong>10_</strong>开头的是系统自带的引导项, 这个稍后解释. <strong>20_</strong>开头的是一些第三方软件的东西, 比如<code>20_memtest86+</code>是一个叫memtest86+的内存测试软件 (虽然不知道是干啥的). - 除了上面这三个前缀的文件名是可以自由改动的, 要把数字改成多少取决于你想让这个文件代表的引导项出现代GRUB引导菜单的第几个. (这个文件的顺序看起来就是最后生成出的<code>/boot/grub/grub.cfg</code>这个文件里引导项的顺序) - 这些文件写好之后在<code>/etc/default/grub</code>这个文件可以调一调设置.</p><p>一个引导项文件的写法示例 (也就是我的macOS的引导项文件):</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">exec tail -n +3 $0</span><br><span class="line"># This file provides an easy way to add custom menu entries.  Simply type the</span><br><span class="line"># menu entries you want to add after this comment.  Be careful not to change</span><br><span class="line"># the 'exec tail' line above.</span><br><span class="line"></span><br><span class="line">menuentry 'macOS Catalina 10.15.3' --class macosx {</span><br><span class="line">    insmod part_gpt</span><br><span class="line">    insmod fat</span><br><span class="line">    search --no-floppy --fs-uuid --set=root 67E3-17ED</span><br><span class="line">    chainloader /EFI/CLOVER/CLOVERX64.efi</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中前5行是<code>40_custom</code>中给出的注释, 我就抄过来了. 然后由<code>menuentry</code>起头声明一个引导项. 然后<code>--class</code>用来设置这个引导项的类型, 直观来说就是在GRUB界面里图标的名字. 此处的类型为<strong>macosx</strong>, 也就是说在我使用的GRUB主题的<code>icons</code>文件夹中有同名 (除了后缀名) 图标的话到时候这个引导项在GRUB界面里的文字前面的图标就是这个叫<code>macosx.png</code>的图标.</p><p>在这个引导项大括号里的内容是和在GRUB命令行进入一个系统需要输入的命令是一样的, 我感觉算是一种脚本? 我也不太懂, 只能说说大概理解: - 第一行指定硬盘分区表的格式 - 第二行指定文件系统 - 第三行指定在uuid为<strong>67E3-17ED</strong>的分区搜索引导项的启动文件 - 第四行指定这个引导项使用的启动文件 (因为黑苹果实际是有Clover启动的, 因此macOS引导项的指定启动文件为Clover的启动文件)</p><p>💡 其中<code>insmod</code>是<strong>ins</strong>ert <strong>mod</strong>e的缩写.</p><h3 id="grub-tone">Grub tone</h3><p>在<code>/etc/default/grub</code>这个文件里可以进行的设置有<code>GRUB_CMDLINE_LINUX_DEFAULT</code>, 这个在显卡不兼容时常用到的设置, 也有<code>GRUB_THEME</code>这个设置GRUB图形界面的主题的, 甚至可以通过<code>GRUB_INIT_TUNE</code>可以设置开机彩铃 😂</p><p>GRUB tone的值是什么意思以及可以看<a href="https://breadmaker.github.io/grub-tune-tester/" target="_blank" rel="noopener">GRUB_INIT_TUNE tester</a>, 这里也提供了一些好听的铃声. 我用过这个超级马里奥音效:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_INIT_TUNE="1750 523 1 392 1 523 1 659 1 784 1 1047 1 784 1 415 1 523 1 622 1 831 1 622 1 831 1 1046 1 1244 1 1661 1 1244 1 466 1 587 1 698 1 932 1 1175 1 1397 1 1865 1 1397 1"</span><br></pre></td></tr></tbody></table></figure><p>但是这个音效声音大小无法调节, 只能是最大声, 真的很大声那种😏 所以虽然很好玩, 我后来还是取消了这个设置.</p><h3 id="grub图形界面分辨率">GRUB图形界面分辨率</h3><p>如果你像我这样是4k屏幕, 那么当<code>/etc/default/grub</code>中分辨率参数为<strong>GRUB_GFXMODE=auto</strong>, 那么GRUB会是4k分辨率, 字会比较小, 然后画面刷新率很低, 导致有点卡, 于是我换成了<code>GRUB_GFXMODE=1920x1440x32</code> (32表示32位色深). 要注意这个分辨率必须是在GRUB图形化界面中按<kbd>c</kbd>进入命令行模式, 输入<code>videoinfo</code>后所列出的分辨率, 不然对分辨率的指定无效.</p><h3 id="最后微调">最后微调</h3><p>调整完上面三个后运行<code>update-grub</code>来更新<code>/boot/grub/grub.cfg</code>. 最后可以到<code>/boot/grub/grub.cfg</code>进行最后微调 (如果需要的话).</p><h3 id="开机美化">开机美化</h3><blockquote><p>因为最开始写这篇文章时我还没体验过Manjaro, 因此这部分就保留好了, 但我要说Manjaro真的比Ubuntu容易个性化太多了!!! (<a href="/zh-CN/2020/07/26/我从Ubuntu换到了Manjaro/">安利文</a>)</p></blockquote><p>Ubuntu开机过程中一共有三处可以美化:</p><ul><li>GRUB theme</li><li><a href="https://wiki.archlinux.org/index.php/plymouth" target="_blank" rel="noopener">Plymouth</a> theme</li><li><a href="https://wiki.archlinux.org/index.php/GDM" target="_blank" rel="noopener">GDM</a> theme</li></ul><p>我的GRUB主题是<a href="https://www.gnome-look.org/p/1009533/" target="_blank" rel="noopener">Aurora Penguinis GRUB2 Theme</a>, Plymouth主题是<a href="https://www.gnome-look.org/p/1009239/" target="_blank" rel="noopener">Aurora Penguinis Plymouth 2 Theme</a>. 而Gnome能使用的GDM主题我没看到什么我中意的, 就自行改动了一下<code>/usr/share/gnome-shell/theme/ubuntu.css</code>里的样式, 给登录界面加了个背景图片.</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#lockDialogGroup</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#2c001e</span> <span class="built_in">url</span>(file:///home/leo/Pictures/login-screen/custom.jpg);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center; }</span><br></pre></td></tr></tbody></table></figure><h2 id="关于启动">关于启动</h2><p>最后放上几个在搜索资料过程中看到的好资料:</p><ul><li><a href="https://help.ubuntu.com/community/Installation?_ga=2.230386906.774703488.1586350910-773002345.1585209571" target="_blank" rel="noopener">Ubuntu系统安装教程考古</a> 在<strong>Either Shrink the Windows C: Drive to Make Room for Linux OR Turn off Windows Updating</strong>这部分可以找到有人遇到的Windows系统更新却破坏了Ubuntu系统是怎么回事. (也很明显我这不会出现这问题)</li><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">阮一峰-计算机是如何启动的？</a> 在这里可以看到启动为什么叫<strong>boot</strong>, 也可以对启动过程中发生了什么有个大概了解.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一下我在同一个SSD里同时安装Ubuntu, Windows, macOS三个系统并以GRUB作为开机引导的经验. 说实话过程并不复杂.&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="软件配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
      <category term="macOS" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/macOS/"/>
    
      <category term="Windows" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"/>
    
      <category term="启动" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%90%AF%E5%8A%A8/"/>
    
      <category term="GRUB" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%90%AF%E5%8A%A8/GRUB/"/>
    
    
  </entry>
  
  <entry>
    <title>Graphviz简要语法</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/03/12/Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/03/12/Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/</id>
    <published>2020-03-11T19:46:33.000Z</published>
    <updated>2020-04-04T06:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://emden.github.io/" target="_blank" rel="noopener">Graphviz</a>是一个很强大的<strong>图形可视化工具</strong>. 它使用<strong>DOT</strong>语言来描述图形, 但它并不单纯是个绘图软件, 而是能接入程序, 进行函数调用流程, 决策树, 数据结构, 日志系统等图形关系生成, 而且可以是<strong>交互式</strong>的 (不过我暂时没研究过所以不太了解). 暂且不提这些扩展功能, graphviz的语法允许我们仅通过文字描述能绘制出样式极其丰富的图形, 这大大方便了对图形的改动的跟踪.</p><a id="more"></a><h2 id="有关官方文档">有关官方文档</h2><p>graphviz.org这个网站也不知道是不是停止维护了, 所有除了指向其他人的项目的链接都是无效链接了... 我在上面放的graphviz的官网链接是<a href="https://gitlab.com/graphviz/graphviz" target="_blank" rel="noopener">graphviz的GitLab repo</a>提供的地址. (实际上我觉得这个项目对文档的维护<strong>很烂</strong>, 描述得很不清楚, 有些地方甚至有错误. 这也是为什么我要自己总结一篇常用语法).</p><p>官方给出的有助于编写DOT文件的文档我觉得就这几个:</p><ul><li><a href="https://emden.github.io/_pages/doc/info/lang.html" target="_blank" rel="noopener">DOT语言概述</a></li><li><a href="https://emden.github.io/_pages/doc/info/attrs.html" target="_blank" rel="noopener">节点, 边线, 图形的属性列表</a></li><li><a href="https://emden.github.io/_pages/doc/info/shapes.html" target="_blank" rel="noopener">节点的三种形状设定方式及节点的样式详解</a> (此处又不得不吐槽graphviz开发组的文档组织真的差)</li><li><a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">箭头的头部形状参数详解</a></li><li><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">graphviz中可用颜色及颜色主题列表</a></li></ul><p>但其实给我帮助最大的是<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener"><strong>被graphviz开发组嫌弃的旧版文档 (dot布局版)</strong></a></p><p>❗️ 因为我最常使用的是<strong>dot</strong>布局所以此处涉及的内容大部分为dot布局下的情况.</p><h2 id="基础语法">基础语法</h2><h3 id="hello-world">Hello World</h3><p>还是先来个Hello World 😏</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph G{</span><br><span class="line">    Hello -&gt; World;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img style="zoom:25%;" data-src="Graphviz简要语法/helloworld.svg"></p><h3 id="常见用法">常见用法</h3><p>因为graphviz许多概念解释起来会套娃, 要理解概念A要先理解概念B, 要理解概念B则需要先知道什么是概念A 🤤 因此这里先放上一些常用属性来快速入门.</p><p>🌟 不明白到底如何使用属性的话点<a href="#属性">这里</a>快速跳转后文的实例.</p><table><colgroup><col style="width: 9%"><col style="width: 12%"><col style="width: 33%"><col style="width: 10%"><col style="width: 33%"></colgroup><thead><tr class="header"><th>用途</th><th>属性名</th><th>可选值</th><th>作用对象</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>轮廓颜色</td><td><code>color</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>节点, 边线, 簇</td><td></td></tr><tr class="even"><td>填充颜色</td><td><code>bgcolor</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>簇, 图</td><td><code>fillcolor</code>会覆盖<code>bgcolor</code></td></tr><tr class="odd"><td>填充颜色</td><td><code>fillcolor</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>节点, 边线, 簇</td><td>需要与<code>style=filled</code>一起使用. 如果设置了<code>style=filled</code>但没有设置<code>fillcolor</code>那么<code>color</code>的值将被同时用于轮廓和填充</td></tr><tr class="even"><td>字体颜色</td><td><code>fontcolor</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>节点, 边线, 簇, 图</td><td></td></tr><tr class="odd"><td>箭头方向</td><td><code>dir</code></td><td>"forward", "back", "both", "none"</td><td>边线</td><td>正向/反向/双向/无箭头</td></tr><tr class="even"><td>箭头形状</td><td><code>arrowhead</code> <code>arrortail</code></td><td>见备注</td><td>边线</td><td>graphviz提供了极其丰富的箭头形状值, 常用值参见<a href="https://emden.github.io/_pages/doc/info/attrs.html#k:arrowType" target="_blank" rel="noopener">这里</a>, 箭头形状值的完整说明见<a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">这里</a></td></tr><tr class="odd"><td>样式</td><td><code>style</code></td><td><a href="https://emden.github.io/_pages/doc/info/attrs.html#k:style" target="_blank" rel="noopener">各对象样式说明</a></td><td>节点, 边线, 簇, 图</td><td>emmm这个style很难准确地翻译为中文, 因为这个属性被很笼统地赋予了四种对象...总的来说是在描述这个对象长什么样, 是虚线的还是加粗的又或是点点的</td></tr><tr class="even"><td>边线风格</td><td><code>splines</code></td><td>none, line, polyline, curved, ortho, spline</td><td>图</td><td>不显示边线/线段 (false)/线段 (true)/弧线/直角折线/常规. 到底什么样详见<a href="https://emden.github.io/_pages/doc/info/attrs.html#d:splines" target="_blank" rel="noopener">splines说明</a> emmmm我感觉<strong>polyline</strong>和<strong>spline</strong>并没有区别...再次吐槽graphviz开发组的混乱逻辑 😩</td></tr><tr class="odd"><td>label水平对齐方式</td><td><code>labeljust</code></td><td>"l", "r"</td><td>图, 簇</td><td>"l"就是和图/簇的左边界对齐, "r"就是和图/簇的右边界对齐. 如果父级显性设置了这一属性, 子图会继承这一属性. <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 实际上还有一个可选值, 就是不设置这个属性, 那么label就会居中对齐.</td></tr><tr class="even"><td>label垂直对齐方式</td><td><code>labelloc</code></td><td>"t", "b", "c"</td><td>节点, 图, 簇</td><td>对于图和簇只有"t"和"b"是可用的, 即标签只能设置在图/簇的顶部或者底部. 如果父级显性设置了这一属性, 子图会继承这一属性. 而对于一个节点, 只有当它的高度大于label这个属性才是可用的.</td></tr><tr class="odd"><td>节点排布方向</td><td>rankdir</td><td>TB, BT, LR, RL</td><td>图</td><td>从上到下/从下到上/从左到右/从右到左</td></tr></tbody></table><h3 id="layout-布局">Layout (布局)</h3><p>💡 graphviz有一点不好的是节点在画布上的位置是<strong>由算法决定</strong>的, 不能<strong>完全</strong>自己设定, 因此有时候无法让图变得那么美观.</p><p>graphviz提供了多种<strong>用于排布节点, 边线箭头头部, 边线标签位置</strong>的布局算法.</p><p>因为了解graphviz的布局算法有助于我们更好的布局, 此处简单翻译一下<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener">被现在graphviz开发组嫌弃的旧版文档 (dot布局版)</a>描述的<strong>dot布局</strong>的图形绘制主要的四步:</p><ol type="1"><li>通过反转一些边线的指向来打破输入图形 (我猜这个输入图形说的是.dot文件) 中出现的所有循环 (因为dot布局算法是基于非循环图形的)</li><li><p>给各节点赋予不同的等级 (<code>rank</code>). (比如在一个top-to-bottom方向的图中等级决定了节点的纵坐标) 连接跨度超过一个等级的节点的边线会被分割成一串"虚拟"节点以及单位长度的边线</p><p>💡 后文会提及对节点的rank是可以进行一些设置的.</p></li><li>给同等级的节点排序, 避免绘图时出现边线的交叉 (估计只是减少交叉?)</li><li><p>在让边线尽可能短的情况下设定节点的横坐标, 然后绘制边线 (同样是假设是top-to-bottom方向的图)</p></li></ol><p>下面给出一些主要布局算法的简单说明和图例.</p><p>💡 以下布局的图例除了最后一个都来自<a href="https://emden.github.io/gallery/" target="_blank" rel="noopener">graphviz-gallary</a></p><h4 id="dot">dot</h4><p>用于绘制<strong>有向图</strong>, 他的布局算法原理上面已经说了, 特点是绘制出的图<strong>很有层次</strong>.</p><p>❗️ 注意dot布局和DOT语言不是一个东西.</p><p><img alt="img" style="zoom:25%;" data-src="Graphviz简要语法/cluster.png"></p><h4 id="neato">neato</h4><p>用于绘制<strong>无向图</strong>. neato布局算法的原理是构建一个虚拟物理模型并不断对其迭代最终得到一个<strong>最低总能量排布</strong> (low-energy configuration). 这个虚拟物理模型具体指的是在每个节点间放置一个<strong>理想弹簧</strong>, 这样得到的布局通常很合理. (在统计学中这种算法也被称作<strong>多维缩放</strong>). neato布局很适合用于<strong>通信网络</strong>及<strong>计算机程序</strong>的绘制.</p><p>💡 当图较大 (超过100个节点)时就该考虑换成fdp或者sfdp布局了</p><p><img style="zoom:33%;" data-src="Graphviz简要语法/ER.png"></p><h4 id="fdp">fdp</h4><p>同样是基于弹簧模型. 区别在于fdp算法的迭代是在试图减小节点间弹簧的力的大小而不是弹簧能量大小.</p><p><img style="zoom:40%;" data-src="Graphviz简要语法/fdpclust.png"></p><h4 id="sfdp">sfdp</h4><p>为大规模图而生的多尺度版fdp</p><p><img style="zoom:40%;" data-src="Graphviz简要语法/JGD_BIBD@bibd_17_3.gif"></p><p>上面这个图得自🔗 <a href="http://yifanhu.net/GALLERY/GRAPHS/index.html" target="_blank" rel="noopener">A Gallery of Large Graphs</a>. 这个网站还有<strong>很多</strong>很壮观的图😳</p><h4 id="twopi">twopi</h4><p>径向布局.</p><p><img style="zoom:50%;" data-src="Graphviz简要语法/twopi2.png"></p><h4 id="circo">circo</h4><p>圆形布局. 很适合有许多环路结构的图, 比如电信网络.</p><p><img style="zoom:33%;" data-src="Graphviz简要语法/circo.png"></p><h3 id="有关三种主要描述对象">有关三种主要描述对象</h3><p>DOT语言主要描述三种对象: <strong>graph</strong>, <strong>node</strong>, <strong>edge</strong>. 这里分别翻译为<strong>图</strong>, <strong>节点</strong>, <strong>边线</strong>. 每一种对象有各自可以设置的一组属性.</p><h4 id="graph-图">Graph (图)</h4><p>最外层的graph (main graph)可以被设定为<strong>有向图</strong><code>digraph</code>(directed graph)或是<strong>无向图</strong><code>graph</code>(undirected graph). main graph内可以用<code>subgraph</code>来定义一个节点和边线的集合. 也可以通过设定最外层图为<code>strict digraph</code>或者<code>strict graph</code>来禁用<strong>multi-edges</strong>. 也就是说<code>strict digraph</code>会让有向图中一个指向节点和一个被指向节点间只能有一条边线 (不过反过来还可以有一条, 也就是两节点间最多两条边线), <code>strict graph</code>则会让无向图中两节点间只能有一条边线.</p><p>最外层的图又称top-level graph, root graph (反正开发组文档都没能统一这东西的叫法). 图可以有子图 (subgraph), 子图会继承父级的显式设置的大部分属性. 有一种特殊的子图被称为<a href="#Cluster-簇"><strong>簇</strong></a>.</p><h4 id="node-节点">Node (节点)</h4><p>一个节点会<strong>在第一次在DOT文件中出现时被创建</strong>.</p><h4 id="edge-边线">Edge (边线)</h4><p>一条边线会在几个节点被用<code>-&gt;</code>边线操作符连接时被创建.</p><p>💡 <strong>在graphviz中可以直接用中文作为节点名.</strong></p><h3 id="label-标签">Label (标签)</h3><p>如果你想要显示的标签中有空格, 那通过把节点名用<code>""</code>括起来可以实现, 当然显式声明标签内容是更好的选择. 而<strong>如果你想让一些节点显示相同的标签那就必须显式声明节点的标签了</strong>, 因为节点名不能重复.</p><p>💡 label中可以使用转义字符比如<code>\n</code>来实现多行标签.</p><h4 id="html-like-label">HTML-like Label</h4><p>为了能提供更丰富的样式, dot布局支持使用HTML语法的HTML-like标签 (看了下似乎其他布局不支持这种东西).</p><p>具体可用语法格式参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 总结下来就是目前支持以下几种类HTML元素:</p><ul><li>斜体 &lt;i&gt;</li><li>粗体 &lt;b&gt;</li><li>下划线 &lt;u&gt;</li><li>上划线 &lt;o&gt;</li><li>删除线 &lt;s&gt;</li><li>下角标 &lt;sub&gt;</li><li>上角标 &lt;sup&gt;</li><li>指定字体 &lt;font&gt;</li><li>换行符 &lt;br /&gt;</li><li>表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;</li><li>图片 &lt;img&gt;</li><li>水平/竖直分割线 &lt;hr&gt; &lt;vr&gt;</li></ul><p>❗️ 要注意这种类HTML标签只是<strong>借鉴自HTML</strong>, 和HTML元素并不完全一样, 因此<strong>并不支持html中其他写法和属性</strong>. 再比如HTML中是没有上面这个<code>&lt;vr&gt;</code>tag的😅</p><p>不得不说类HTML标签确实极大地提升了灵活性, 让我们能写出奇形怪状的节点形状, 能在标签中嵌入图片等, 详情参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 不过这东西写起来确实麻烦一些...</p><blockquote><p>一个展示类HTML标签能带来的丰富样式的例子</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">  rankdir=LR</span><br><span class="line">  node [shape=plaintext]</span><br><span class="line">  a [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD ROWSPAN="3" BGCOLOR="yellow"&gt;class&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD PORT="here" BGCOLOR="lightblue"&gt;qualifier&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  b [shape=ellipse style=filled</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BGCOLOR="bisque"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="3"&gt;elephant&lt;/TD&gt;</span><br><span class="line">          &lt;TD ROWSPAN="2" BGCOLOR="chartreuse" VALIGN="bottom" ALIGN="right"&gt;two&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" ROWSPAN="2"&gt;</span><br><span class="line">            &lt;TABLE BGCOLOR="grey"&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;corn&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD BGCOLOR="yellow"&gt;c&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;f&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">            &lt;/TABLE&gt;</span><br><span class="line">          &lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="white"&gt;penguin&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" BORDER="4" ALIGN="right" PORT="there"&gt;4&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  c [</span><br><span class="line">    label=&lt;long line 1&lt;BR/&gt;line 2&lt;BR ALIGN="LEFT"/&gt;line 3&lt;BR ALIGN="RIGHT"/&gt;&gt;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  subgraph { rank=same b c }</span><br><span class="line">  a:here -&gt; b:there [dir=both arrowtail=diamond]</span><br><span class="line">  c -&gt; b</span><br><span class="line">  d [shape=triangle]</span><br><span class="line">  d -&gt; c [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD BGCOLOR="red" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">          &lt;TD&gt;Edge labels&lt;BR/&gt;also&lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="blue" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img style="zoom:60%;" data-src="Graphviz简要语法/html-like_label.svg"></p><h3 id="属性">属性</h3><p>属性是通过<code>name=value</code>形式来设置的. 节点与边线的属性需要放在<code>[]</code>方括号中.</p><blockquote><p>一个展示属性写法以及属性能做些什么的例子</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    size ="4,4"; //设置图形尺寸为4英寸长宽</span><br><span class="line">    方形节点 [shape=box];  /*这是一种注释写法*/</span><br><span class="line">    方形节点 -&gt; 上面是加粗线 [style=bold];</span><br><span class="line">    上面是加粗线 -&gt; 和下面的对比;</span><br><span class="line">    方形节点 -&gt; 上面是虚线 [style=dotted];</span><br><span class="line">    方形节点 -&gt; 重量更大导致垂直指下的节点[weight=4];</span><br><span class="line">    "和下面的对比" -&gt; { make_string; 上面是有标签的红线}  //可以一次连接多个节点</span><br><span class="line">    上面是虚线 -&gt; make_string;</span><br><span class="line">    edge [color=red];  // 这是另一种注释写法</span><br><span class="line">    方形节点 -&gt; 上面是有标签的红线 [label="100 times"];</span><br><span class="line">    make_string [label="多行\n标签"];</span><br><span class="line">    node [shape=box,style=filled,color=".7 .3 1.0"];</span><br><span class="line">    和下面的对比 -&gt; 在节点默认属性改变后才创建的节点;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="Graphviz简要语法/attr.svg"></p><h4 id="常用属性的默认值">常用属性的默认值</h4><p><strong>图</strong>的默认属性:</p><ul><li>labeljust="c"</li><li>labelloc="b" (簇的默认值为"t")</li><li>clusterrank="local"</li><li>compound=false</li><li>rankdir=TB</li></ul><p><strong>节点</strong>的默认属性是:</p><ul><li>shape=ellipse</li><li>width=0.75</li><li>height=0.5</li><li>标签为节点名</li><li>labelloc="c"</li></ul><h3 id="cluster-簇">Cluster (簇)</h3><p>簇是一种会将属于这个子图的元素都<strong>框在一个长方形里</strong>的特殊子图. 如果一个子图的名字以<strong>cluster</strong>开头那么这个子图就会被认为是一个簇 (这个判定方式好暴力😅). 但是如果在根图中设置了<code>clusterrank=none</code>那么簇这种特殊的子图会被禁用.</p><p>这里我又要来吐槽graphviz开发组了! 看看他们是怎么<a href="https://emden.github.io/_pages/doc/info/attrs.html#a:clusterrank" target="_blank" rel="noopener">说明clusterrank这个属性</a>的:</p><blockquote><p>the modes "global" and "none" <strong>appear</strong> to be identical, both turning off the special cluster processing.</p></blockquote><p>为什么官方开发组都在用这种表推测的语气啊... 🙃这也太迷惑了</p><p>如果根图中设置了<code>compound=true</code>, 那么dot布局允许用边线连接节点和簇的边框. 这是通过设置边线的<code>lhead</code>和<code>ltail</code>属性来实现的. 这样以来, 虽然边线仍然是从一个节点指向另一个节点的, 但是设置了<code>lhead</code>或者<code>ltail</code>的一侧<strong>会看起来像是被簇的边框盖住了</strong>.</p><blockquote><p>一个使用簇, 并且有连接节点与簇的边线的例子</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    compound=true;</span><br><span class="line">    subgraph cluster0 {</span><br><span class="line">        a -&gt; b;</span><br><span class="line">        a -&gt; c;</span><br><span class="line">        b -&gt; d;</span><br><span class="line">        c -&gt; d;</span><br><span class="line">    }</span><br><span class="line">    subgraph cluster1 {</span><br><span class="line">        e -&gt; g;</span><br><span class="line">        e -&gt; f;</span><br><span class="line">    }</span><br><span class="line">    b -&gt; f [lhead=cluster1];</span><br><span class="line">    d -&gt; e;</span><br><span class="line">    c -&gt; g [ltail=cluster0,lhead=cluster1];</span><br><span class="line">    c -&gt; e [ltail=cluster0];</span><br><span class="line">    d -&gt; h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img style="zoom:20%;" data-src="Graphviz简要语法/cluster.svg"></p><h2 id="高级语法">高级语法</h2><p>以下是几条我认为<strong>用来提示图的美观程度</strong>的语法.</p><h3 id="优化布局">优化布局</h3><p>知道了上面提到的<a href="#Layout-布局">布局的原理</a>我们就可以进行一些更个性化的布局, 比如设置<code>rankdir</code>可以设置节点的排布方向, 默认为<strong>TB</strong>, top to bottom, 也就是从上到下. 可选值有<strong>TB</strong>, <strong>BT</strong>, <strong>LR</strong>, <strong>RL</strong>.</p><p>再比如设置节点的<code>rank</code>属性我们可以改变节点的布局. <code>rank</code>的可选值有: <strong>same</strong>, <strong>min</strong>, <strong>source</strong>, <strong>max</strong>, <strong>sink</strong>.</p><blockquote><p>一个展示设置rank属性能达到什么效果的例子 (代码和图形都截自旧版文档, 因为代码没给全我也懒得写, 就这么放着吧👍)</p></blockquote><p><img style="zoom:60%;" data-src="Graphviz简要语法/image-20200313010630547.png"></p><p><img style="zoom:80%;" data-src="Graphviz简要语法/image-20200313010749024.png"></p><h3 id="node-port-节点端口">Node Port (节点端口)</h3><p>Graphviz提供了节点端口来指定边线应连接到节点的什么位置. 这提供了更高的个性化. 当没有被指定节点端口时边线是指向节点中心并在节点边界处被截断的.</p><p>一共有两种节点端口:</p><ul><li>基于方位的8个端口: n,ne, e, se, s, sw, w, nw</li><li>基<code>record</code>结构的端口: <code>shape=record</code>的节点可以以记录结构来定义端口. 而因为有&lt;TABLE&gt;元素的<a href="#html-like-label">HTML-like标签</a>与可以作为<code>shape=record</code>的扩展甚至替代品, 每个&lt;TD&gt;元素的<strong>PORT</strong>属性也都提供了一个到该单元格的端口名.</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    node [shape = box]</span><br><span class="line">    node0:n -&gt; node1:n [label = "n"]</span><br><span class="line">    node2:ne -&gt; node3:ne [label = "ne"]</span><br><span class="line">    node4:e -&gt; node5:e [label = "e"]</span><br><span class="line">    node6:se -&gt; node7:se [label = "se"]</span><br><span class="line">    node8:s -&gt; node9:s [label = "s"]</span><br><span class="line">    node10:sw -&gt; node11:sw [label = "sw"]</span><br><span class="line">    node12:w -&gt; node13:w [label = "w"]</span><br><span class="line">    node14:nw -&gt; node15:nw [label = "nw"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="Graphviz简要语法/node_port.svg"></p><h3 id="concentrators-边线合并">Concentrators (边线合并)</h3><p>在根图中设置<code>concentrate=true</code>将允许边线融合来避免图变得一团乱麻.</p><p>边线合并的条件是:</p><ul><li>他们的方向相同</li><li>他们有相同的起点或终点</li><li>他们的长度大于1</li></ul><h2 id="相关工具">相关工具</h2><h3 id="vsc的dot语言支持插件">VSC的dot语言支持插件</h3><p>我最喜欢的画graphviz图的工具是VSC里的<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz" target="_blank" rel="noopener">Graphviz(dot)语言支持插件</a>, 是的它<strong>只支持dot布局</strong>. 虽然也可以用graph来声明顶层图, 但绘制出来的仍然是有向图🤦‍♂ 不过无伤大雅, 我基本只画dot布局的图.</p><p>VSC里也有提供直接在markdown文档中渲染graphviz的dot布局图的插件, 不过我觉得这样的兼容性太低, 没有这个插件的人只会看到一串代码, 因此我选择的是一个能提供<strong>DOT语法高亮</strong>, 能提供<strong>自动刷新</strong>的预览图, <strong>能生成svg图</strong>的插件. 只要把这个svg插入markdown就能在文档看到graphviz图了, 而每次更改图片后只需要覆盖原本的svg即可更新md文档中的图, 也很方便的👍</p><h3 id="在线编辑器">在线编辑器</h3><p>也有很多在线网站提供在线绘制graphviz图的服务, 上网一搜就有, 不过我感觉做得都半斤八两, 体验不算好, 我认为只能拿来救急用, 因此也不给出推荐了.</p><p>💡 实际上有些工具绘制出的图都有细微风格差异, 你可以挨个体验出一个最喜欢的风格的工具.</p><p>不过比较有意思的是这个<a href="https://sketchviz.com/new" target="_blank" rel="noopener">sketchviz</a>, 绘制出的是<strong>手绘风</strong>的图.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://emden.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Graphviz&lt;/a&gt;是一个很强大的&lt;strong&gt;图形可视化工具&lt;/strong&gt;. 它使用&lt;strong&gt;DOT&lt;/strong&gt;语言来描述图形, 但它并不单纯是个绘图软件, 而是能接入程序, 进行函数调用流程, 决策树, 数据结构, 日志系统等图形关系生成, 而且可以是&lt;strong&gt;交互式&lt;/strong&gt;的 (不过我暂时没研究过所以不太了解). 暂且不提这些扩展功能, graphviz的语法允许我们仅通过文字描述能绘制出样式极其丰富的图形, 这大大方便了对图形的改动的跟踪.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Graphviz" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/Graphviz/"/>
    
    
  </entry>
  
  <entry>
    <title>广受好评的机器人相关 (数学/物理/控制/计算机类) 网课列表</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/02/22/%E5%B9%BF%E5%8F%97%E5%A5%BD%E8%AF%84%E7%9A%84%E6%95%B0%E5%AD%A6-IT%E7%B1%BB%E7%BD%91%E8%AF%BE%E5%88%97%E8%A1%A8/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/02/22/%E5%B9%BF%E5%8F%97%E5%A5%BD%E8%AF%84%E7%9A%84%E6%95%B0%E5%AD%A6-IT%E7%B1%BB%E7%BD%91%E8%AF%BE%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-22T08:18:42.000Z</published>
    <updated>2021-03-20T10:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近很多国内学校因为疫情开始在网上上课, 不过我们学校的网课体验很差... 网络问题暂且不说, 既然都是网课何不去学习那些广受好评的版本? 列出一些广受好评的课程链接, 希望能帮到一些同样在被迫害的同学们 (也方便我以后极速复习) 💩</p><a id="more"></a><p>❗️ 好的学习资料有很多, 种类也很多 (网课, 书, 网站, 习题集, 项目...) 为了避免内容太过杂乱此处只讨论网课.</p><p>P.S. 我觉得网课的好处是有老师的讲解十分易懂, 同时通过倍速播放可以极速学习 😏</p><p>💡 为达到最好效果, 我的做法是把网课视频都下载下来, 在vlc中<strong>设置播放时显示当前文件名及时间</strong>并倍速播放. 到关键点, 或者想要记笔记的地方就暂停并截屏保存到一个文件夹 (截屏软件Windows下推荐snipaste, Linux下推荐Flameshot)</p><h2 id="数学">数学</h2><h3 id="mit-线性代数">MIT-线性代数</h3><p>特点: 教授的粉笔巨大无比 😂</p><p>相较于国内老师从行列式入手, 这门课<strong>从几何空间的角度更加直观揭示线代的内核</strong>.</p><p>🔗<a href="https://www.bilibili.com/video/BV1zx411g7gq" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">网易公开课链接</a></p><h3 id="mit-概率论">MIT-概率论</h3><p>🔗<a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">b站链接</a></p><h3 id="张宇考研-数学-微积分-线性代数-概率论">张宇考研-数学 (微积分, 线性代数, 概率论)</h3><p>🔗<a href="https://www.youtube.com/watch?v=ghNtuabD6Ss&amp;list=PLRMOX8QaZK8z4yLzXRkiPO38R911V7TQE" target="_blank" rel="noopener">YouTube链接</a></p><h2 id="物理">物理</h2><h3 id="北航-理论力学">北航-理论力学</h3><p>王琪老师讲得特别贴合实际, 有许多很生动的例子 👍</p><p>🔗<a href="https://www.bilibili.com/video/BV1k7411T7QU" target="_blank" rel="noopener">b站链接</a></p><h2 id="信号处理">信号处理</h2><h3 id="mit-信号与系统">MIT-信号与系统</h3><p><strong>奥本海姆亲授版!</strong> 相信国内大部分学信号与系统这门课的同学的课本都是奥本海姆编写的. 虽然这个是二十多年前录制的课程了, 演示时使用的是很古老的覆盖片和只有绿色荧光的电脑屏幕, 但是奥本海姆教授讲解得十分清晰, 处理信号的核心思想贯穿始终, 让人学得十分系统性.</p><p>🔗<a href="https://www.bilibili.com/video/BV1xy4y167DD" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/free?pid=M8AROL7GG&amp;mid=M8AROOU9F" target="_blank" rel="noopener">网易公开课链接</a></p><h3 id="mit-数字信号处理">MIT-数字信号处理</h3><p>认准奥本海姆教授 👍</p><p>🔗<a href="https://www.bilibili.com/video/BV1uk4y1R771" target="_blank" rel="noopener">b站链接</a></p><h2 id="计算机">计算机</h2><h3 id="mit-计算机科学及编程导论">MIT-计算机科学及编程导论</h3><p>这门课主要针对<strong>从未接触过计算机科学或编程的人</strong>. 基于<strong>python</strong>讲解了基础的程序编写, 调试, 算法, 数据结构, 面向对象等内容, 比起知识的深度更注重知识的广度 (内容较为简单).</p><p>🔗<a href="https://www.bilibili.com/video/BV1m4411U7gs" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fbianchengdaolun.html" target="_blank" rel="noopener">网易公开课链接</a></p><h3 id="翁恺-c语言程序设计">翁恺-C语言程序设计</h3><p>C语言入门课.</p><p>🔗<a href="https://www.bilibili.com/video/BV1sJ411E7St" target="_blank" rel="noopener">b站链接</a> 🔗<a href="https://www.icourse163.org/course/ZJU-9001" target="_blank" rel="noopener">中国大学MOOC链接</a></p><h3 id="清华-数据结构与算法">清华-数据结构与算法</h3><p>🔗<a href="https://www.bilibili.com/video/BV1jt4y117KR" target="_blank" rel="noopener">b站链接</a></p><h3 id="mit-计算机教育中缺失的一课">MIT-计算机教育中缺失的一课</h3><p>这门课主要对一些非常常用但是大多数人不怎么了解的强大开发工具, 或者说常见操作进行了讲解. 比如说怎么洗数据, 怎么用shell脚本偷懒, 版本控制该怎么做, etc. 每一个部分视频时长基本只有1h, 但是已经覆盖了这些工具最有价值的部分, 可以说是性价比很高了 👍</p><p>🔗<a href="https://missing.csail.mit.edu/" target="_blank" rel="noopener">英文版</a> 🔗<a href="https://missing-semester-cn.github.io/" target="_blank" rel="noopener">中文版</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近很多国内学校因为疫情开始在网上上课, 不过我们学校的网课体验很差... 网络问题暂且不说, 既然都是网课何不去学习那些广受好评的版本? 列出一些广受好评的课程链接, 希望能帮到一些同样在被迫害的同学们 (也方便我以后极速复习) 💩&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>文件命名规则总结</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/02/06/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/02/06/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-06T07:34:23.000Z</published>
    <updated>2020-02-06T07:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果待处理文件的文件名中含有一些特殊字符, 有许多程序会因为考虑不完善 (或者说程序员偷懒) 而出现识别不到文件, 文件处理出错, 结果不符合意图, 甚至程序崩溃的问题. 而为了方便自己偷懒, 我总结了一些命名文件的规则.</p><a id="more"></a><p>💡 我并不是说文件名命名必须遵循这些准则, 只是在程序设计/输入不够严谨 (也就是想偷懒的情况下) 这样的命名准则是最不容易导致错误的👍</p><h2 id="文件名中只应该包含数字-字母-汉字-下划线-连字符-句点">文件名中只应该包含数字, 字母, 汉字, 下划线, 连字符, 句点</h2><p>许多特殊字符会让程序出错, 下面举几个例子:</p><ul><li><code>文件名里 有空格.jpg</code> 这样的文件名很可能让程序以为要处理的文件的名字是<code>文件名里</code>, 因而找不到文件或者处理了错误的文件. 而<code>有空格.jpg</code>会被当成无效参数, 多余字符.</li><li><code>文件名里/有左斜杠.avi</code> 这样的文件名在很多程序里会被认为是一个名为<code>文件名里</code>的文件夹下的<code>有左斜杠.avi</code>文件, 因此可能得到<strong>没有<code>文件名里</code>这个文件夹</strong>的报错</li><li><code>文件名里(有)括号.gif</code> 比如在markdown文档中用<code>![](文件名里(有)括号.gif)</code>来引用这个gif, 在有的markdown渲染器会被渲染为<strong>)括号.gif</strong>. 因为前一个)被认为是markdown引用图片的<code>![]()</code>语法的结束符了.</li><li>在一些较老的程序中汉字也算是一种特殊字符. 比如在python2中如果不特意注意编码格式转换问题的话中文很容易被读取为乱码. 当然现在的程序大多是兼容汉字的. (Python2在已经终止维护了🕯)</li></ul><blockquote><p>空格用下划线代替, 其他字符用连字符代替</p></blockquote><p>如果你原本想要包含这些特殊字符在文件名中来表达一些逻辑关系, 我的做法是用_来代替空格, 用-来代替其他字符.</p><h2 id="当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字-并且位数不足的用0在左侧占位">当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</h2><p>曾经我很困惑下面这两种情况的文件夹排序为什么不是从小到大的, 后来我发现前者是因为文件系统<strong>不把汉字数字作为排序用的数字</strong> (有意思的是我Ubuntu系统和Windows系统里图一情况排序不一样), 后一个是因为文件系统是<strong>逐字比较</strong>而不是把一串数字作为一个数 (windows系统和Ubuntu系统排序图2情况时都能正常排序)</p><blockquote><p>图一 Ubuntu系统下含汉字数字文件名排序</p></blockquote><p><img data-src="文件命名规则总结/image-20200207181027438.png"></p><blockquote><p>图二 百度云里含数字文件名排序</p></blockquote><p><img data-src="文件命名规则总结/Screenshot_20200207_181843.jpg"></p><p>因此如果想在文件名中包含有排序功能的数字, 或者表达顺序之意时应当<strong>用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</strong>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果待处理文件的文件名中含有一些特殊字符, 有许多程序会因为考虑不完善 (或者说程序员偷懒) 而出现识别不到文件, 文件处理出错, 结果不符合意图, 甚至程序崩溃的问题. 而为了方便自己偷懒, 我总结了一些命名文件的规则.&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>我开始用集成开发工具部署我的博客</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/10/06/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/10/06/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-10-05T21:34:39.000Z</published>
    <updated>2019-10-29T21:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天分别尝试了用<strong>Travis CI</strong>和<strong>GitHub Action</strong>部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢<strong>GitHub Action</strong>, 因为它就是Github的, 集成度更高. 而且<strong>Github Action</strong>支持的触发条件更多样一些.</p><a id="more"></a><p>先分别放上我使用Travis和GitHub Action时的配置文件</p><p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/blob/02ce864f1cbe09d82c0dfe6f617b36737344d41e/.travis.yml" target="_blank" rel="noopener">Travis配置文件</a></p><p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/tree/Root/.github/workflows" target="_blank" rel="noopener">GitHub Action配置文件</a></p><h2 id="github-action的缺点">GitHub Action的缺点</h2><p>可以看出Travis要更<strong>成熟</strong>一些, 提供了一些很方便的功能, 比如要添加ssh known hosts, travis只需要</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">addons:</span></span><br><span class="line">  <span class="attr">ssh_known_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">github.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ssh.github.com</span></span><br></pre></td></tr></tbody></table></figure><p>而在GitHub Action中需要</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">login</span> <span class="string">ssh</span> <span class="string">and</span> <span class="string">git</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">~/.ssh</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">-e</span> <span class="string">"Host github.com\nStrictHostKeyChecking no\nIdentityFile ~/.ssh/id_rsa_github_action"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/config</span></span><br></pre></td></tr></tbody></table></figure><p>看起来GitHub Action的配置更短, 但这句是强行不验证github.com的服务器, 并没有Travis中的配置直观, 合理.</p><p>另外GitHub Action暂时还不支持<strong>缓存</strong>, 照<a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts" target="_blank" rel="noopener">这个样子</a>即便实现了也是很别扭的东西... 我觉得缓存还是一个很重要的功能. 一个最简单的例子: 没有缓存的public文件夹导致刚换到GitHub Action时我的每篇博客<strong>更新时间与我的最后一次上传时间相同</strong> (hexo通过对比source文件夹和public文件夹的时间戳来判断更新时间). 目前我是通过将master分支下载到public文件夹来蛮力解决的.</p><h2 id="github-action的优点">GitHub Action的优点</h2><p>当然GitHub Action的优点也是明显的, 比如我的代码的<strong>托管平台和持续集成平台合二为一</strong>, 不说管理起来方便了多少至少内心通达了😆</p><p>另外GitHub Action的支持的触发条件更加丰富, 比如用下面代码可以指定只有<code>Root</code>分支有推送且有<strong>source/en</strong>文件夹以外的文件变动时才运行. 换句话说只有配置文件或者中文博客内容发生变动时才运行.</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Root</span></span><br><span class="line">    <span class="attr">paths-ignore:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'source/en/**'</span></span><br></pre></td></tr></tbody></table></figure><p>在<a href="https://docs.travis-ci.com/user/conditional-builds-stages-jobs/" target="_blank" rel="noopener">Travis的文档</a>中我并没有看到可以这么操作.</p><p>再有就是GitHub Action支持一个项目有<strong>多个</strong>workflow, 比如我的博客就同时在运行两个工作流: 一个生成并部署中文博客, 一个生成并部署英文博客. 这是一个十分吸引人的功能! 并且GitHub正试图将workflow打造成能<strong>轻松分享, 引用</strong>的东西, 这能极大减少人们写这些繁琐低级的配置文件的时间. 实际上GitHub已经<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">初步成功了</a>. 在我的配置中就引用了两个GitHub官方发布的action.</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">8.10</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="number">8.10</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>目前来说GitHub Action体验着很不错!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天分别尝试了用&lt;strong&gt;Travis CI&lt;/strong&gt;和&lt;strong&gt;GitHub Action&lt;/strong&gt;部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢&lt;strong&gt;GitHub Action&lt;/strong&gt;, 因为它就是Github的, 集成度更高. 而且&lt;strong&gt;Github Action&lt;/strong&gt;支持的触发条件更多样一些.&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="软件配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="CI/CD" scheme="https://leojhonsong.github.io/zh-CN/categories/CI-CD/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown安利&amp;Typora简要使用教程</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2019-09-23T06:45:31.000Z</published>
    <updated>2020-03-16T16:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在此我来安利一下<strong>Markdown</strong>和<strong>Typora</strong>.</p><a id="more"></a><h2 id="markdown安利">Markdown安利</h2><h3 id="什么是markdown">什么是Markdown</h3><p>Markdown是一门语言, 一门轻量级的<strong>标记语言</strong> (Markup Language). 有没有觉得这个词很眼熟? 是的, HTML全称<strong>HyperText Markup Language</strong>. Markdown和HTML同属于Markup Language(Markdown是一门Markup Language是Markdown作者的恶趣味), 它们与C, Python等编程语言并不是一类东西. <strong>Markup</strong>这个词源自<strong>印刷业</strong>, 指的是在电子排版技术出现之前人们对印刷物内容的排版进行标记的方式. 比如一段文字应当是<strong>粗体</strong>, <em>斜体</em>, <u>有下划线</u>还是<del>有删除线</del>, 使用什么字体, 字体大小, 左页边距应当是多少, 一张图片该放在哪里, 多大等等...</p><p>💡 也就是说以前的人们在将原稿最终印刷出来前想知道会印成什么样基本靠脑补, 而现在我们称这个由标记语言文件得到最终效果的过程为<strong>渲染</strong> (render).</p><p>而之所以我们说Markdown是一门<strong>轻量级</strong>的标记语言是因为在Markdown的语法比HTML等标记语言要简洁太多😆</p><ul><li>一</li><li>二</li></ul><p>比如👆 上面这个列表的Markdown实现代码为</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>一</span><br><span class="line"><span class="bullet">- </span>二</span><br></pre></td></tr></tbody></table></figure><p>而HTML实现代码为</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但Markdown有时候也会让人觉得太过轻量级以至于缺少一些语法, 比如这个<u>下划线</u> 其实是用HTML标签实现的. 好在你也可以在Markdown文件中写HTML, 如今的Markdown渲染工具基本都支持这个功能.</p><p>也是由于上面这个原因, 在Markdown作者们推出的 <a href="https://commonmark.org/" target="_blank" rel="noopener"><strong>CommonMark</strong></a>的基础上有了添加了更多语法的各种 Markdown超集, 比如GitHub发布的<a href="https://github.github.com/gfm/" target="_blank" rel="noopener"><strong>GitHub Flavored Markdown</strong></a>.</p><h3 id="markdown应用广泛吗">Markdown应用广泛吗</h3><p>实际上如今Markdown的使用相当广泛, 只要是支持所谓<strong>富文本</strong>的社区/论坛等, 比如说 <strong>GitHub</strong>, <strong>知乎</strong>, <strong>Stack OverFlow</strong>, <strong>CSDN博客</strong>, <strong>Wikipedia</strong>都是使用的 Markdown. 另外因为Markdown和HTML的转换十分容易, 目前大多个人博客都是编辑Markdown 格式的文章再生成HTML页面, 比如我正在码的也是Markdown文件.</p><p>再有就是目前大多数项目根目录的<strong>README</strong>文档都是Markdown格式, 而在线查看项目代码时 GitHub等代码托管网站都会自动将项目中所有Markdown文件渲染出来.</p><h3 id="为什么我们使用markdown">为什么我们使用Markdown</h3><p>以下是网上的一些总结和我个人的体会.</p><ol type="1"><li>Markdown的设计理念是易读易写, 因此<strong>即便不渲染Markdown文件的可读性也很高</strong>, 这让没有Markdown渲染工具的人也能很好地阅读, 而如果要脑力渲染HTML, 一会就眼晕了.</li><li>这种格式能让文档很方便的排列为很简洁好看的排版, <strong>能让人专注于书写内容</strong>, 不必费神排版</li><li>支持代码按语言的语法高亮</li><li><strong>能很方便的进行版本管理</strong>. 在要进行版本管理的项目中的Word文件简直是毒瘤, 不操作一番的话版本管理工具比如git并不能识别word文件具体变化, 而使用纯文本的 Markdown能让每次的更改被体现出来!</li><li><strong>占用空间小</strong> (可以想一想一个word文档的大小)</li><li><strong>能很容易地转为多种格式</strong>. Markdown和HTML是兄弟关系,因此Markdown文件能轻松转换成 <strong>HTML</strong>文件格式以及HTML文件能轻易转换为的格式(<strong>PDF</strong>, <strong>jpg</strong>, <strong>Epub</strong>等) 是显而易见的. 通过一些额外工具(比如<a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>)的帮助, Markdown文件还能一键转化为更多文件格式,比如<strong>LaTeX</strong>, <strong>Word</strong>, <strong>OpenOffice</strong>, <strong>Media Wiki</strong>等.</li><li>能方便的插入图片, 表格, 超链接等</li><li>兼容HTML语法, 因此我们想让页面显示成什么样就可以显示成什么样</li><li>可以兼容LaTeX语法, 可以很方便的显示复杂公式</li><li>还可以兼容<strong>Graphviz</strong>, <strong>Mermaid</strong>等流程图工具等等...</li></ol><h3 id="markdown简明语法">Markdown简明语法</h3><ul><li><p>一个标题以几个<code>#</code>开头, 空格后是文字. 以#的个数来表示第几级标题</p></li><li><p>以 - 开头接一个空格开始一个子弹列表, 以 1. 接空格开始一个有序列表</p></li><li><p>在要加粗的词两侧加 ** 来加粗. 如果要打出 ** 等特殊字符要在星号前加 &nbsp;来转义</p></li><li><p>在<strong>行内代码</strong>两侧加 ` . 注意这不是单引号, 在我键盘上在<kbd>Esc</kbd> 键下面. 当然这个不只是用来放行内代码的, 也可以放别的.</p></li><li><p>在代码块上下行加 ``` , 第一个```后写代码的语言.</p></li><li><p>在Typora这个软件里插入图片很容易, 直接<code>Ctrl V</code>粘贴就好了, 或者右键, 里面有插入图片的按键. 插入图片的markdown语法是</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">当图片失效时此处显示的文字</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>插入超链接的语法和插入图片的语法很像, 此处举例说明. 这是点击进入百度的链接👉 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></tbody></table></figure></li><li><p>表格用<code>|</code>分隔每个元素, 第一行是各列的名字, 第二行的 <code>|</code>间是<code>-</code>, 分隔列名和值. 以下是一个例子</p></li></ul><table><thead><tr class="header"><th>第一列</th><th>第二列</th><th>第三列</th></tr></thead><tbody><tr class="odd"><td>a</td><td>b</td><td>c</td></tr></tbody></table><ul><li>更详细的语法说明在Typora内可以查看Typora自带的Markdown语法参考手册</li></ul><figure><img alt="1569274096465" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569274096465.png"><figcaption>1569274096465</figcaption></figure><h2 id="typora安利">Typora安利</h2><p>那么用什么软件来写Markdown呢? 认准<a href="https://typora.io/#download" target="_blank" rel="noopener"><strong>Typora</strong></a>!</p><p>Typora的优点多到我不想写 (不其实是单纯不想写了), 最突出的优点我觉得是它的<strong>颜值</strong>, 以及<strong>能直接将图片粘贴到文件中</strong>.</p><h3 id="typora快速入门">Typora快速入门</h3><h4 id="主题">主题</h4><p>在<strong>Themes</strong>一栏可以切换软件的主题</p><figure><img alt="1569271897771" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569271897771.png"><figcaption>1569271897771</figcaption></figure><h4 id="大纲视图">大纲视图</h4><p>可以按这个<strong>OutLine</strong>或者按左下角的小圆圈触发大纲视图, 点击大纲视图里的标题可以快速跳转.</p><figure><img alt="1569272130639" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272130639.png"><figcaption>1569272130639</figcaption></figure><h4 id="源代码视图">源代码视图</h4><p>按左下角这个<kbd>&lt;/&gt;</kbd>可以切换到源代码视图</p><figure><img alt="1569272534032" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272534032.png"><figcaption>1569272534032</figcaption></figure><h4 id="拼写检查">拼写检查</h4><p>右下角这里可以选择进行拼写检查的语言或者关闭这个功能.</p><figure><img alt="1569272445049" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272445049.png"><figcaption>1569272445049</figcaption></figure><h4 id="更多设置">更多设置</h4><p>按这个<strong>Preference</strong>可以进行更多偏好设置.</p><figure><img alt="1569272312746" data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272312746.png"><figcaption>1569272312746</figcaption></figure><p>以下是我的推荐设置</p><p><img data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051240.png"></p><figure><img alt="image-20200227124912356" data-src="Markdown安利-Typora简要使用教程/image-20200227124912356.png"><figcaption>image-20200227124912356</figcaption></figure><p>勾选<strong>对网络图片应用上述规则</strong>那直接粘贴从浏览器复制的图片时Typora会自动将该图片下载到这个指定文件夹.</p><p>忽略单个换行让Typora遵循GFM: 单个换行不渲染为换行, 两个换行才渲染为换行</p><p><img data-src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051204.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在此我来安利一下&lt;strong&gt;Markdown&lt;/strong&gt;和&lt;strong&gt;Typora&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Markdown" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/Markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>意识到了我的中文有多差</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/</id>
    <published>2019-09-13T13:46:47.000Z</published>
    <updated>2019-09-13T13:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子别人给我分享了<a href="https://www.byvoid.com/" target="_blank" rel="noopener">这个博客</a>, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!</p><a id="more"></a><p>先不提这个博主喜爱音韵学, 单说同样是理工科出身的博主, 我的表达能力和思想深度比他差了太多.</p><p>通常在解释一段程序时我会想好一会来组织语言, <strong>将我使用这段代码的意图尽可能体现出来, 描述尽可能准确, 有条理</strong>. 我对此体会良多: 当我刚开始接触一个领域, 在网上看资料时常常无法确定我理解得对不对, 需要结合多篇文章才能确定. 这是因为<strong>作者们自身接触这些许久, 无意识的省略了一些话</strong>. 但我认为文章既然要写出来就应该能让所有人无障碍的看懂, 不然只给自己看的话何不就放到自己github仓库?</p><p><a href="https://akaedu.github.io/book/index.html" target="_blank" rel="noopener">Linux C编程一站式学习</a>和 <a href="https://www.pyimagesearch.com" target="_blank" rel="noopener">pyimagesearch</a>的文章就让人觉得文章读起来很流畅很易懂, 不会浪费时间在理解文章上. 比如<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" target="_blank" rel="noopener">这篇文章</a> 曾带我轻松完成了困扰了我好几天的如何在树莓派上安装OpenCV的问题. 这个问题现在当然不会像前年那样困扰我, 但能有这样一篇好懂的文章指导我迅速完成我当然是十分乐意的.</p><p>因此我总是试图让我的文章能达到同样水准. 但我发现这很难. 说来可笑, 很多时候我甚至不知道怎么样去描述我的操作🤦‍ 而让文章有条理同样不是一件容易的事. 我感觉这和写一篇议论文围绕一个中心套用总分总的文章结构就可以写不一样, 我总是喜欢把一个主题的东西一股脑放到一篇文章里, 但我发现一方面<strong>文章太长会让人失去读下去的兴趣</strong>, 另一方面<strong>什么东西都往一篇文章里放会让文章失其重点</strong>. 我又不是在写书, 不如将一个主题的内容再按照几个重点分成几篇文章. 可<strong>将一篇文章分割为主题更明确的多篇文章</strong>对我来说并不是易事...</p><p>至于说<strong>byvoid</strong>的文章有思想深度, 从<a href="https://www.byvoid.com/zht/blog/why-the-usa-is-so-boring-1" target="_blank" rel="noopener">这篇文章</a>可见一斑. 我也喜欢旅游, 并且因为我小时候见了许多很美的自然景观, 我更倾向于体验一处的文化. 到一处游览后能有像<strong>byvoid</strong>这种深度的心得正是我所想努力做到的. 但一是我的文笔不够好, 二是我并没有做功课去研究旅游地的文化.</p><p>从<strong>byvoid</strong>的文章能体会到中文的魅力: 用得好了读起来十分流畅, 四字成语言简意赅地表达出了意思, 很多用以佐证的诗句更是回味无穷... 这只是我个人的体会, 我也知道很粗浅. 当然我并不后悔初高中没有投入大量精力背诵各种诗句, 品鉴各大文豪的文章: 体会不到这些的魅力时我背下来又有什么用呢?</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子别人给我分享了&lt;a href=&quot;https://www.byvoid.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个博客&lt;/a&gt;, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://leojhonsong.github.io/zh-CN/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>更好的Shebang使用方式</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2019-09-12T16:57:25.000Z</published>
    <updated>2019-09-13T09:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统的脚本第一行我们通常用 <a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang</a>语句来指明解释器路径, 一方面有的脚本没有文件后缀名, 需要通过shebang语句指明系统才知道要用什么解释器运行. 另一方面有时候为了兼容性我们会指明使用标准位置的系统安装版本解释器.</p><p>但我发现有时候我们并不能确定使用者把我们需要类型的解释器装到了地方, 如果我们只想指出<strong>使用的解释器类型</strong>而不是具体路径, 可以使用<code>/usr/bin/env</code>命令. 比如如果我们想用Python3解释器执行一个脚本, 可以在第一行加:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br></pre></td></tr></tbody></table></figure><p><code>env</code>会调用用户<strong>$PATH</strong>中首先出现的解释器版本.</p><p>当然对于更复杂的情况更建议专门写一段程序来决定用哪个解释器.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux系统的脚本第一行我们通常用 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Shebang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shebang&lt;/a&gt;语句来指明解释器路径, 一方面有的脚本没有文件后缀名,
      
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础语法</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/12/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/12/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2019-09-11T19:50:22.000Z</published>
    <updated>2021-03-16T05:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇</p><a id="more"></a><h2 id="python解释器">Python解释器</h2><h2 id="实现">实现</h2><table><thead><tr class="header"><th>版本</th><th>实现方式</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>CPython</td><td>C语言写的Python</td><td>速度快</td></tr><tr class="even"><td>JPython</td><td>由Java编写的Python</td><td>可以直接调用Java的各种函数库</td></tr><tr class="odd"><td>PyPy</td><td>由rPython编写的Python</td><td>更灵活, 易于使用和试验</td></tr><tr class="even"><td>IronPython</td><td>以. NET和Mono实现的Python</td><td>面向NET和ECMA CLI的Python实现</td></tr><tr class="odd"><td>ZhPy</td><td>只是把Python翻译了一遍而已</td><td>又称中蟒, 可以完全用中文编程. 但中蟒目前已经停止更新了.</td></tr></tbody></table><p>我们通常所说的Python是<strong>CPython</strong>, 👇Python官方页面提供的是CPython</p><figure><img alt="1565579206457" data-src="Python基础语法/1565579206457.png"><figcaption>1565579206457</figcaption></figure><h2 id="版本">版本</h2><p>Python这种语言有<strong>Python2</strong>和<strong>Python3</strong>两个版本, 两者语法有少许不同, 比如Python2和Python3中<code>print()</code>的使用有区别, Python2和Python3中<code>input()</code>接受的数据类型有区别等.</p><p>最新的Python2对大部分Python2, 3不同的语法做了兼容, 而在Python3对Python2的语法兼容性很差, 但是提供了一个叫<a href="https://docs.python.org/zh-cn/3.7/library/2to3.html" target="_blank" rel="noopener">2to3</a>的脚本帮助我们将Python2的程序转换为Python3的程序.</p><h2 id="哲学">哲学</h2><p><strong>万物皆对象</strong></p><p>python在设计初始是一种<strong>面向对象</strong>语言.</p><p>💡 面向对象是一种<strong>编程范式</strong></p><h2 id="数据类型">数据类型</h2><p>Python是一门<strong>动态类型</strong>语言</p><h3 id="类型注解">类型注解</h3><p>在Python3中有了一个新特性: <strong>类型注解</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><p>正如其名, 注解只是标注一下, 有了类型注解的程序和没有类型注解的程序运行起来没有区别, 但它能帮助程序员更好的发现问题, 也能让IDE提供更准确的代码补全和语法检查.</p><h3 id="类型检查">类型检查</h3><p>有时候为了保证程序的严谨性我们会检查一下变量是不是我们设想它应该是的类型, 这个时候我们用 <code>isinstance()</code></p><p>之所以不使用 <code>type()</code> 是因为 <code>type()</code> 不会认为子类是一种父类类型, 不考虑继承关系. 举例说明:</p><figure><img alt="1571027624789" data-src="Python基础语法/1571027624789.png"><figcaption>1571027624789</figcaption></figure><h3 id="不可变对象">不可变对象</h3><p>❗️ <strong>我们可以给不可变对象重新赋值, 但其内存地址会改变</strong>. 以下是体现给可变对象/不可变对象重新赋值时它们的内存地址变化的例子.</p><p>💡 <code>id()</code>能获取一个变量的内存地址</p><figure><img alt="1571022411897" data-src="Python基础语法/1571022411897.png"><figcaption>1571022411897</figcaption></figure><h4 id="number-数字">Number (数字)</h4><ul><li>int (整数)</li><li>long (长整数)</li><li>float (浮点数, 即小数)</li><li>bool (布尔值, 即 <code>True</code> 和 <code>False</code> )</li></ul><p>Python中的Number我认为是比较特殊的, 因为它<strong>在内存中占用的空间大小是变动</strong>的.(在CPython中是如此, 但不知道为什么在IronPython下不是)</p><p>💡 用<code>sys.getsizeof()</code>可以知道一个变量的占用的内存大小</p><figure><img alt="1571022628668" data-src="Python基础语法/1571022628668.png"><figcaption>1571022628668</figcaption></figure><h4 id="string-字符串">String (字符串)</h4><h4 id="tuple-元组">Tuple (元组)</h4><h3 id="可变对象">可变对象</h3><p>可变对象可能带来的危险举例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(l = [])</span>:</span></span><br><span class="line">    l.append(<span class="string">'add'</span>)</span><br><span class="line">    print(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc()</span><br></pre></td></tr></tbody></table></figure><h4 id="list-列表">List (列表)</h4><p>💡 <strong>string</strong>和<strong>tuple</strong>都是特殊的<strong>list</strong></p><h4 id="set-集合">Set (集合)</h4><h4 id="dictionary-字典">Dictionary (字典)</h4><p>👇 在网上偷的<strong>string, tuple, list, dictionary的突出区别比较</strong>.</p><table><thead><tr class="header"><th>名字</th><th>是否可变</th><th>是否可迭代</th><th>是否可切片</th><th>访问方式</th><th>写法举例</th></tr></thead><tbody><tr class="odd"><td>string</td><td>no</td><td>yes</td><td>yes</td><td>下标索引</td><td>“abcd”</td></tr><tr class="even"><td>tuple</td><td>no</td><td>yes</td><td>yes</td><td>下标索引</td><td>(‘a’,‘b’,‘c’,‘d’,‘abcd’)</td></tr><tr class="odd"><td>list</td><td>yes</td><td>yes</td><td>yes</td><td>下标索引</td><td>[‘a’,‘b’,‘c’,‘d’,‘abcd’]</td></tr><tr class="even"><td>dictionary</td><td>yes</td><td>yes</td><td>no</td><td>关键字索引</td><td>{‘1’:‘a’,‘2’:‘b’}</td></tr></tbody></table><h3 id="python中有关对象需要注意的问题">Python中有关对象需要注意的问题</h3><p>python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响引用的这个变量, 而不可变对象不会. 在向类传递参数时也是如此.</p><figure><img alt="1571033275137" data-src="Python基础语法/1571033275137.png"><figcaption>1571033275137</figcaption></figure><h2 id="基础语法">基础语法</h2><h3 id="python内置帮助文档">Python内置帮助文档</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help()</span><br></pre></td></tr></tbody></table></figure><p>调用<code>help()</code>后就会进入Python内置帮助文档, 然后输入想查的类名/函数名/属性名就可以看到对应的帮助文档.</p><p>:bulb: 要注意输入的只有名字, 不带括号什么的, 以及要看一个包里的函数文档时需要先引用该包. 比如如果想查看<strong>time.time()</strong>的帮助文档, 首先<code>import time</code>, 然后输入<code>help()</code>进入帮助文档, 然后输入<code>time.time</code>, 就会看到<strong>time.time()</strong>函数的帮助文档. 按一次<kbd>q</kbd>退出<strong>time.time()</strong>的文档, 再按一次<kbd>q</kbd>退出帮助文档返回交互式Python界面.</p><h3 id="注释">注释</h3><p>在Python中 <code>#</code> 开头的为注释</p><h4 id="特殊注释">特殊注释</h4><h5 id="shebang">shebang</h5><p>shenbang (hashbang) 指的是以 <code>#!</code> 开头的语句. Linux操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数. 因为在很多语言中以 <code>#</code> 开头的是注释, 所以不会影响程序.</p><h5 id="编码格式">编码格式</h5><p>有的python文件是这么开头的:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure><p>第一行是给<strong>Linux系统</strong>的程序加载器看的, 因此在Windows下不需要这句, 第二句是指定文件的编码格式为<strong>UTF-8</strong>, 避免文件中的<strong>非ASCII字符</strong>被识别为乱码.</p><h5 id="docstring">docstring</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(int x, int y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这里是docstring, 是特殊的注释, 能让IDE, 编辑器在鼠标移动到有docstring的函数, 类上时显示这段docstring</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = func(i)</span><br></pre></td></tr></tbody></table></figure><h3 id="条件语句及循环">条件语句及循环</h3><h4 id="if-elif-else">if, elif, else</h4><p>下面是按a &lt; 10, 10 &lt; a &lt; 20, 20 &lt; a &lt; 30, a &gt; 30分类的举例.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">20</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">30</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>另外有一种one liner会很喜欢的用法:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span> <span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p>上面这句与下面这句等效.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><h4 id="生成器-迭代器range">生成器 ·迭代器·range</h4><p>语法类似于<a href="#切片">切片</a></p><h3 id="推导式">推导式</h3><p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性.<strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持:</p><ul><li>列表推导式</li><li>字典推导式</li><li>集合推导式</li></ul><p>列表推导式的语法:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure><p>使用举例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><h3 id="切片">切片</h3><p>因为tuple, string其实都是特殊的列表, 所以列表, 字符串, 元组都可以进行切片.</p><p>语法: l_sliced = a[begin : end : step]</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">l_sliced = l[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure><p>在没有<strong>numpy</strong>库的情况下<strong>多维切片</strong>是通过推导式实现的:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">b = [a[i][:<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)]</span><br></pre></td></tr></tbody></table></figure><h3 id="函数">函数</h3><p>💡 要注意函数名后的 <code>()</code> 也是一种运算符, 称为<strong>函数调用运算符</strong>. 如果调用函数的时候不加()只会创建一个该函数的对象而不会调用它.</p><h4 id="定义函数">定义函数</h4><p>python中以 <code>def</code> 关键字定义函数, 结构如下:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数主体</span><br></pre></td></tr></tbody></table></figure><p>python中的函数可以有返回值也可以没有返回值</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.appeend(<span class="string">'add'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><h3 id="用字典来实现case">用字典来实现case</h3><p>示例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printDefault</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switch = {</span><br><span class="line">    <span class="number">1</span>: print1,</span><br><span class="line">    <span class="number">2</span>: print2,</span><br><span class="line">    <span class="string">'default'</span>: printDefault</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">case = int(input(<span class="string">'input: '</span>))</span><br><span class="line">switch[case <span class="keyword">if</span> (case <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)) <span class="keyword">else</span> <span class="string">'default'</span>]()</span><br></pre></td></tr></tbody></table></figure><h3 id="编码格式-1">编码格式</h3><p>字符串经过<strong>编码（encode）</strong> 就成为了一堆数据, 反过来, 数据经过<strong>解码（decode）</strong> 就变回我们认识的字符串.</p><figure><img alt="img" data-src="Python基础语法/encode_decode.png"><figcaption>img</figcaption></figure><p>指定文件编码格式为 <code>utf-8</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">💡</span> 如果不指定文件编码格式在有的Python2版本中无法识别中文, 即便是中文注释也会报错.</p><figure><img alt="Unicode Decoding and Encoding" data-src="Python基础语法/Unicode_Decoding_and_Encoding.png"><figcaption>Unicode Decoding and Encoding</figcaption></figure><p>Linux系统默认编码格式是<strong>UTF-8</strong>, 系统语言是简体中文时Windows10的编码格式是<strong>GB2312</strong> (也称GBK, 国标扩展, cp936)</p><p>在python中 <code>str</code> 类型数据都以Unicode码点格式储存, 因此直接打印字符串会看到字符为'开头</p><h3 id="基本读写">基本读写</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.write(<span class="string">"text"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br><span class="line">    f.write(<span class="string">"test"</span>)</span><br></pre></td></tr></tbody></table></figure><p>💡 <strong>使用with语句打开文件是最推荐的方式</strong>, 原因见<a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html" target="_blank" rel="noopener">这里</a></p><p>下表是open时要指定的读写模式的比较.</p><table><thead><tr class="header"><th>读写模式</th><th>是否可读</th><th>是否可写</th><th>文件指针位置</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>r</td><td>是</td><td>否</td><td>文件开头</td><td>读取文件, 如果文件不存在则报错</td></tr><tr class="even"><td>r+</td><td>是</td><td>是</td><td>文件开头</td><td>读取并写入文件, 如果文件不存在则报错</td></tr><tr class="odd"><td>w</td><td>否</td><td>是</td><td>文件开头</td><td>覆写原文件, 如果文件不存在则创建</td></tr><tr class="even"><td>w+</td><td>是</td><td>是</td><td>文件开头</td><td>读取并覆盖写原内容, 如果文件不存在则创建</td></tr><tr class="odd"><td>a</td><td>否</td><td>是</td><td>文件末尾</td><td>追加文件内容, 如果文件不存在则报错</td></tr><tr class="even"><td>a+</td><td>是</td><td>是</td><td>文件末尾</td><td>追加文件内容并且可读, 如果文件不存在则报错</td></tr></tbody></table><p>另外还有<code>b</code>模式, 以二进制打开, 允许我们对二进制文件进行编辑, <code>b</code>可以与其他模式组合使用, 比如 <code>rb</code></p><p>🔗 <a href="https://www.cnblogs.com/nulige/p/6128948.html" target="_blank" rel="noopener">python基础-文件读写'r' 和 'rb'区别</a></p><h2 id="脚本和普通程序的区别">脚本和普通程序的区别</h2><p>脚本这个词来源于戏剧, 能用于舞台演出的戏剧文本就称为<strong>脚本</strong>. 在编程中的脚本是解释执行的程序, 通常只用来做简单的处理, 做自动化处理</p><h2 id="解释器的使用技巧">解释器的使用技巧</h2><p>在解释器中交互式编程时要注意缩进不要错</p><h3 id="清屏">清屏</h3><p>python解释器本身没有清屏命令, 只能通过调用命令行的清屏命令来达到效果</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># Windows下</span></span><br><span class="line">os.system(<span class="string">'cls'</span>)</span><br><span class="line"><span class="comment"># Linux下</span></span><br><span class="line">os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="代码风格">代码风格</h2><p>我推荐遵从<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a>. 当然一行一行看完这个规范不是一件令人愉快的事, 最简单的时刻遵守PEP8的方式是在代码工具里安一个<strong>代码风格检查器</strong> (linter). 检查你的代码是否符合PEP8的linter是<a href="http://pycodestyle.pycqa.org/en/latest/intro.html" target="_blank" rel="noopener">pycodestyle</a></p><p>💡 在VSC中可以在设置中搜索<strong>python.linting.pycodestyle</strong>, 勾选<strong>Pycodestyle Enabled</strong>, 这样在VSC中编写Python代码时使用的linter就是pycodestyle啦</p><figure><img alt="1571142193232" data-src="Python基础语法/1571142193232.png"><figcaption>1571142193232</figcaption></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux终端呈现彩色输出</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/</id>
    <published>2019-09-11T18:35:48.000Z</published>
    <updated>2020-03-20T15:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: <strong>让特定类型的输出显示为特定的颜色</strong>!</p><a id="more"></a><p>比如这样:</p><p style="color:purple">[MESSAGE] Turning left</p><p style="color:yellow">[DEBUG] target: 4</p><p style="color:red">[Error] target not found</p><p style="color:purple">[MESSAGE] Turning left</p><p style="color:purple">[MESSAGE] Diving</p><p style="color:green">[INFO] depth: 9m</p><p style="color:purple">[MESSAGE] Diving</p><p style="color:green">[INFO] depth: 10m</p><p style="color:purple">[MESSAGE] Forward</p><p style="color:purple">[MESSAGE] Turing right</p><p>能极大的增强终端信息的可读性!😆</p><p>这应该是Linux终端的特性, (我并不清楚是否兼容Windows命令行), shell, python, C++的彩色文字语法几乎是一样的.</p><h2 id="颜色表">颜色表</h2><p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" target="_blank" rel="noopener">维基的表</a></p><table><thead><tr class="header"><th>前景色 (字体颜色) 代码</th><th>背景色代码</th><th>颜色</th></tr></thead><tbody><tr class="odd"><td>30</td><td>40</td><td>黑色</td></tr><tr class="even"><td>31</td><td>41</td><td>紅色</td></tr><tr class="odd"><td>32</td><td>42</td><td>綠色</td></tr><tr class="even"><td>33</td><td>43</td><td>黃色</td></tr><tr class="odd"><td>34</td><td>44</td><td>藍色</td></tr><tr class="even"><td>35</td><td>45</td><td>紫紅色</td></tr><tr class="odd"><td>36</td><td>46</td><td>青藍色</td></tr><tr class="even"><td>37</td><td>47</td><td>白色</td></tr></tbody></table><h2 id="字体效果表">字体效果表</h2><table><thead><tr class="header"><th>代码</th><th>效果</th></tr></thead><tbody><tr class="odd"><td>0</td><td>默认</td></tr><tr class="even"><td>1</td><td>高亮(加粗)</td></tr><tr class="odd"><td>4</td><td>下划线</td></tr><tr class="even"><td>5</td><td>闪烁</td></tr><tr class="odd"><td>7</td><td>反色</td></tr><tr class="even"><td>8</td><td>不可见</td></tr></tbody></table><h2 id="常见问题">常见问题</h2><ul><li><a href="https://stackoverflow.com/a/55773513/10088906" target="_blank" rel="noopener">readline的提示符误将不可见字符认为可见</a></li></ul><h2 id="语法">语法</h2><h3 id="shell语法">shell语法</h3><p>举例:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "\e[31;43;1mError\!\e[0m"</span><br></pre></td></tr></tbody></table></figure><p>💡 如果上面这条命令不是彩色的, 执行<code>echo -e "\e[31;43;1mError\!\e[0m"</code></p><p>运行上面这条命令会输出一个黄底红色粗体字的"Error!". 前景色, 背景色和字体效果的代码没有先后顺序之分. 建议每个<code>\e[a;b;c</code>都接一个<code>\e[0m</code>将字体效果恢复默认, 不然后续输出还是带特殊效果的.</p><h3 id="python语法">python语法</h3><p>在<code>print()</code>中使用的示例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"\033[31;43;1mError!\033[0m"</span>)</span><br></pre></td></tr></tbody></table></figure><p>或者可以通过python执行shell命令:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">'echo "\e[31;43;1mError!\e[0m"'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="c语法">C++语法</h3><p>在C++中使用的语法和在python中是一样的:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[31;43;1m"</span> &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; <span class="string">"\033[0m"</span> &lt;&lt; <span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><p>一个小技巧是可以单独写一个<code>color_print.h</code>, 内容示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET   <span class="meta-string">"\033[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK   <span class="meta-string">"\033[30m"</span>      <span class="comment">/* Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED     <span class="meta-string">"\033[31m"</span>      <span class="comment">/* Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN   <span class="meta-string">"\033[32m"</span>      <span class="comment">/* Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW  <span class="meta-string">"\033[33m"</span>      <span class="comment">/* Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE    <span class="meta-string">"\033[34m"</span>      <span class="comment">/* Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGENTA <span class="meta-string">"\033[35m"</span>      <span class="comment">/* Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN    <span class="meta-string">"\033[36m"</span>      <span class="comment">/* Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE   <span class="meta-string">"\033[37m"</span>      <span class="comment">/* White */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLACK   <span class="meta-string">"\033[1m\033[30m"</span>      <span class="comment">/* Bold Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDRED     <span class="meta-string">"\033[1m\033[31m"</span>      <span class="comment">/* Bold Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDGREEN   <span class="meta-string">"\033[1m\033[32m"</span>      <span class="comment">/* Bold Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDYELLOW  <span class="meta-string">"\033[1m\033[33m"</span>      <span class="comment">/* Bold Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLUE    <span class="meta-string">"\033[1m\033[34m"</span>      <span class="comment">/* Bold Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDMAGENTA <span class="meta-string">"\033[1m\033[35m"</span>      <span class="comment">/* Bold Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDCYAN    <span class="meta-string">"\033[1m\033[36m"</span>      <span class="comment">/* Bold Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDWHITE   <span class="meta-string">"\033[1m\033[37m"</span>      <span class="comment">/* Bold White */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(color, context) std::cout &lt;&lt; color &lt;&lt; context &lt;&lt; RESET &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>然后在要显示彩色输出的cpp文件中引用这个头文件, 打印语句示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(BOLDRED, <span class="string">"Error!"</span>);</span><br></pre></td></tr></tbody></table></figure><p>因为是宏替换因此<code>context</code>字段其实可以随意填, 比如有一个变量<code>depth</code>, 用下面语句来打印深度是可以的:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(BOLDGREEN, <span class="string">"depth: "</span> &lt;&lt; depth &lt;&lt; <span class="string">"m"</span>)</span><br></pre></td></tr></tbody></table></figure><p>超好用!😆</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: &lt;strong&gt;让特定类型的输出显示为特定的颜色&lt;/strong&gt;!&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
</feed>
