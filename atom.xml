<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeoJhon.Song&#39;s Blog</title>
  
  <subtitle>欢迎来到我的博客!</subtitle>
  <link href="/zh-CN/atom.xml" rel="self"/>
  
  <link href="https://leojhonsong.github.io/zh-CN/"/>
  <updated>2019-10-10T19:08:58.522Z</updated>
  <id>https://leojhonsong.github.io/zh-CN/</id>
  
  <author>
    <name>LeoJhon.Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我开始用集成开发工具部署我的博客</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/10/05/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/10/05/我开始用集成开发工具部署我的博客/</id>
    <published>2019-10-05T21:34:39.000Z</published>
    <updated>2019-10-10T19:08:58.522Z</updated>
    
    <content type="html"><![CDATA[<p>这几天分别尝试了用<strong>Travis CI</strong>和<strong>GitHub Action</strong>部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢<strong>GitHub Action</strong>, 因为它就是Github的, 集成度更高. 而且<strong>Github Action</strong>支持的触发条件更多样一些.</p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天分别尝试了用&lt;strong&gt;Travis CI&lt;/strong&gt;和&lt;strong&gt;GitHub Action&lt;/strong&gt;部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢&lt;strong&gt;GitHub Action&lt;/strong&gt;, 因为它就是Github的, 集成度更高. 而且&lt;strong&gt;Github Action&lt;/strong&gt;支持的触发条件更多样一些.&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown安利&amp;Typora简要使用教程</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/23/Markdown安利-Typora简要使用教程/</id>
    <published>2019-09-23T06:45:31.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>在此我来安利一下<strong>Markdown</strong>和<strong>Typora</strong>.</p><a id="more"></a><h2 id="Markdown安利"><a href="#Markdown安利" class="headerlink" title="Markdown安利"></a>Markdown安利</h2><h3 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h3><p>Markdown是一门语言, 一门轻量级的<strong>标记语言</strong> (Markup Language). 有没有觉得这个词很眼熟? 是的, HTML全称<strong>HyperText Markup Language</strong>. Markdown和HTML同属于MarkupLanguage(Markdown是一门Markup Language是Markdown作者的恶趣味), 它们与C, Python等编程语言并不是一类东西. <strong>Markup</strong>这个词源自<strong>印刷业</strong>, 指的是在电子排版技术出现之前人们对印刷物内容的排版进行标记的方式. 比如一段文字应当是<strong>粗体</strong>, <em>斜体</em>,<u>有下划线</u>还是<del>有删除线</del>, 使用什么字体, 字体大小, 左页边距应当是多少, 一张图片该放在哪里, 多大等等…</p><p>💡 也就是说以前的人们在将原稿最终印刷出来前想知道会印成什么样基本靠脑补, 而现在我们称这个由标记语言文件得到最终效果的过程为<strong>渲染</strong> (render).</p><p>而之所以我们说Markdown是一门<strong>轻量级</strong>的标记语言是因为在Markdown的语法比HTML等标记语言要简洁太多😆</p><ul><li>一</li><li>二</li></ul><p>比如👆 上面这个列表的Markdown实现代码为</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>一</span><br><span class="line"><span class="bullet">- </span>二</span><br></pre></td></tr></tbody></table></figure><p>而HTML实现代码为</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但Markdown有时候也会让人觉得太过轻量级以至于缺少一些语法, 比如这个<u>下划线</u>其实是用HTML标签实现的. 好在你也可以在Markdown文件中写HTML, 如今的Markdown渲染工具基本都支持这个功能.</p><p>也是由于上面这个原因, 在Markdown作者们推出的<a href="https://commonmark.org/" target="_blank" rel="noopener"><strong>CommonMark</strong></a>的基础上有了添加了更多语法的各种Markdown超集, 比如GitHub发布的<a href="https://github.github.com/gfm/" target="_blank" rel="noopener"><strong>GitHub FlavoredMarkdown</strong></a>.</p><h3 id="Markdown应用广泛吗"><a href="#Markdown应用广泛吗" class="headerlink" title="Markdown应用广泛吗"></a>Markdown应用广泛吗</h3><p>实际上如今Markdown的使用相当广泛, 只要是支持所谓<strong>富文本</strong>的社区/论坛等, 比如说<strong>GitHub</strong>, <strong>知乎</strong>, <strong>Stack OverFlow</strong>, <strong>CSDN博客</strong>, <strong>Wikipedia</strong>都是使用的Markdown. 另外因为Markdown和HTML的转换十分容易, 目前大多个人博客都是编辑Markdown格式的文章再生成HTML页面, 比如我正在码的也是Markdown文件.</p><p>再有就是目前大多数项目根目录的<strong>README</strong>文档都是Markdown格式, 而在线查看项目代码时GitHub等代码托管网站都会自动将项目中所有Markdown文件渲染出来.</p><h3 id="为什么我们使用Markdown"><a href="#为什么我们使用Markdown" class="headerlink" title="为什么我们使用Markdown"></a>为什么我们使用Markdown</h3><p>以下是网上的一些总结和我个人的体会.</p><ol><li>Markdown的设计理念是易读易写, 因此<strong>即便不渲染Markdown文件的可读性也很高</strong>,这让没有Markdown渲染工具的人也能很好地阅读, 而如果要脑力渲染HTML, 一会就眼晕了.</li><li>这种格式能让文档很方便的排列为很简洁好看的排版, <strong>能让人专注于书写内容</strong>, 不必费神排版</li><li>支持代码按语言的语法高亮</li><li><strong>能很方便的进行版本管理</strong>. 在要进行版本管理的项目中的Word文件简直是毒瘤, 不操作一番的话版本管理工具比如git并不能识别word文件具体变化, 而使用纯文本的Markdown能让每次的更改被体现出来!</li><li><strong>占用空间小</strong> (可以想一想一个word文档的大小)</li><li><strong>能很容易地转为多种格式</strong>. Markdown和HTML是兄弟关系,因此Markdown文件能轻松转换成<strong>HTML</strong>文件格式以及HTML文件能轻易转换为的格式(<strong>PDF</strong>, <strong>jpg</strong>, <strong>Epub</strong>等)是显而易见的. 通过一些额外工具(比如<a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>)的帮助,Markdown文件还能一键转化为更多文件格式,比如<strong>LaTeX</strong>, <strong>Word</strong>,<strong>OpenOffice</strong>, <strong>Media Wiki</strong>等.</li><li>能方便的插入图片, 表格, 超链接等</li><li>兼容HTML语法, 因此我们想让页面显示成什么样就可以显示成什么样</li><li>可以兼容LaTeX语法, 可以很方便的显示复杂公式</li><li>还可以兼容<strong>Graphviz</strong>, <strong>Mermaid</strong>等流程图工具等等…</li></ol><h3 id="Markdown简明语法"><a href="#Markdown简明语法" class="headerlink" title="Markdown简明语法"></a>Markdown简明语法</h3><ul><li><p>一个标题以几个<code>#</code>开头, 空格后是文字. 以#的个数来表示第几级标题</p></li><li><p>以 - 开头接一个空格开始一个子弹列表, 以 1. 接空格开始一个有序列表</p></li><li><p>在要加粗的词两侧加 ** 来加粗. 如果要打出 ** 等特殊字符要在星号前加 \ 来转义 </p></li><li><p>在<strong>行内代码</strong>两侧加 ` .  注意这不是单引号, 在我键盘上在<kbd>Esc</kbd> 键下面. 当然这个不只是用来放行内代码的, 也可以放别的.</p></li><li><p>在代码块上下行加 ``` , 第一个```后写代码的语言.</p></li><li><p>在Typora这个软件里插入图片很容易, 直接<code>Ctrl V</code>粘贴就好了, 或者右键, 里面有插入图片的按键. 插入图片的markdown语法是</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">当图片失效时此处显示的文字</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>插入超链接的语法和插入图片的语法很像, 此处举例说明. 这是点击进入百度的链接👉 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></tbody></table></figure></li><li><p>表格用<code>|</code>分隔每个元素, 第一行是各列的名字, 第二行的 <code>|</code>间是<code>-</code>, 分隔列名和值. 以下是一个例子</p></li></ul><table><thead><tr><th>第一列</th><th>第二列</th><th>第三列</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td></tr></tbody></table><ul><li>更详细的语法说明在Typora内可以查看Typora自带的Markdown语法参考手册</li></ul><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569274096465.png" alt="1569274096465"></p><h2 id="Typora安利"><a href="#Typora安利" class="headerlink" title="Typora安利"></a>Typora安利</h2><p>那么用什么软件来写Markdown呢? 认准<a href="https://typora.io/#download" target="_blank" rel="noopener"><strong>Typora</strong></a>!</p><p>Typora的优点多到我不想写 (不其实是单纯不想写了), 最突出的优点我觉得是它的<strong>颜值</strong>,以及<strong>能直接将图片粘贴到文件中</strong>.</p><h3 id="Typora快速入门"><a href="#Typora快速入门" class="headerlink" title="Typora快速入门"></a>Typora快速入门</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>在<strong>Themes</strong>一栏可以切换软件的主题</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569271897771.png" alt="1569271897771"></p><h4 id="大纲视图"><a href="#大纲视图" class="headerlink" title="大纲视图"></a>大纲视图</h4><p>可以按这个<strong>OutLine</strong>或者按左下角的小圆圈触发大纲视图, 点击大纲视图里的标题可以快速跳转.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272130639.png" alt="1569272130639"></p><h4 id="源代码视图"><a href="#源代码视图" class="headerlink" title="源代码视图"></a>源代码视图</h4><p>按左下角这个<kbd></kbd>可以切换到源代码视图</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272534032.png" alt="1569272534032"></p><h4 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h4><p>右下角这里可以选择进行拼写检查的语言或者关闭这个功能.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272445049.png" alt="1569272445049"></p><h4 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h4><p>按这个<strong>Preference</strong>可以进行更多偏好设置.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272312746.png" alt="1569272312746"></p><p>以下是我的推荐设置</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051240.png" alt=""></p><p>勾选<strong>对网路图片应用上述规则</strong>那直接粘贴从浏览器复制的图片时Typora会自动将该图片下载到这个指定文件夹. 建议开启插入时自动转义, 虽然这样会让中文 文件夹名变为乱码, 但这样无论文件夹名/文件名有多骚都不会出问题.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051232.png" alt=""></p><p>忽略单个换行让Typora遵循GFM: 单个换行不渲染为换行, 两个换行才渲染为换行</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051204.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在此我来安利一下&lt;strong&gt;Markdown&lt;/strong&gt;和&lt;strong&gt;Typora&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>意识到了我的中文有多差</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/13/意识到了我的中文有多差/</id>
    <published>2019-09-13T13:46:47.000Z</published>
    <updated>2019-10-10T19:08:58.498Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子别人给我分享了<a href="https://www.byvoid.com/" target="_blank" rel="noopener">这个博客</a>, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!</p><a id="more"></a><p>先不提这个博主喜爱音韵学, 单说同样是理工科出身的博主, 我的表达能力和思想深度比他差了太多.</p><p>通常在解释一段程序时我会想好一会来组织语言, <strong>将我使用这段代码的意图尽可能体现出来, 描述尽可能准确, 有条理</strong>. 我对此体会良多: 当我刚开始接触一个领域, 在网上看资料时常常无法确定我理解得对不对, 需要结合多篇文章才能确定. 这是因为<strong>作者们自身接触这些许久, 无意识的省略了一些话</strong>. 但我认为文章既然要写出来就应该能让所有人无障碍的看懂, 不然只给自己看的话何不就放到自己github仓库?</p><p><a href="https://akaedu.github.io/book/index.html" target="_blank" rel="noopener">Linux C编程一站式学习</a>和<a href="https://www.pyimagesearch.com" target="_blank" rel="noopener">pyimagesearch</a>的文章就让人觉得文章读起来很流畅很易懂, 不会浪费时间在理解文章上. 比如<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" target="_blank" rel="noopener">这篇文章</a>曾带我轻松完成了困扰了我好几天的如何在树莓派上安装OpenCV的问题. 这个问题现在当然不会像前年那样困扰我, 但能有这样一篇好懂的文章指导我迅速完成我当然是十分乐意的.</p><p>因此我总是试图让我的文章能达到同样水准. 但我发现这很难. 说来可笑, 很多时候我甚至不知道怎么样去描述我的操作🤦‍ 而让文章有条理同样不是一件容易的事. 我感觉这和写一篇议论文围绕一个中心套用总分总的文章结构就可以写不一样, 我总是喜欢把一个主题的东西一股脑放到一篇文章里, 但我发现一方面<strong>文章太长会让人失去读下去的兴趣</strong>, 另一方面<strong>什么东西都往一篇文章里放会让文章失其重点</strong>. 我又不是在写书, 不如将一个主题的内容再按照几个重点分成几篇文章. 可<strong>将一篇文章分割为主题更明确的多篇文章</strong>对我来说并不是易事…</p><p>至于说<strong>byvoid</strong>的文章有思想深度, 从<a href="https://www.byvoid.com/zht/blog/why-the-usa-is-so-boring-1" target="_blank" rel="noopener">这篇文章</a>可见一斑. 我也喜欢旅游, 并且因为我小时候见了许多很美的自然景观, 我更倾向于体验一处的文化. 到一处游览后能有像<strong>byvoid</strong>这种深度的心得正是我所想努力做到的. 但一是我的文笔不够好,二是我并没有做功课去研究旅游地的文化.</p><p>从<strong>byvoid</strong>的文章能体会到中文的魅力: 用得好了读起来十分流畅, 四字成语言简意赅地表达出了意思, 很多用以佐证的诗句更是回味无穷… 这只是我个人的体会, 我也知道很粗浅. 当然我并不后悔初高中没有投入大量精力背诵各种诗句, 品鉴各大文豪的文章: 体会不到这些的魅力时我背下来又有什么用呢?</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子别人给我分享了&lt;a href=&quot;https://www.byvoid.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个博客&lt;/a&gt;, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>更好的Shebang使用方式</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/12/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/12/更好的shebang使用方式/</id>
    <published>2019-09-12T16:57:25.000Z</published>
    <updated>2019-10-10T19:08:58.522Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统的脚本第一行我们通常用<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang</a>语句来指明解释器路径, 一方面有的脚本没有文件后缀名, 需要通过shebang语句指明系统才知道要用什么解释器运行. 另一方面有时候为了兼容性我们会指明使用标准位置的系统安装版本解释器.</p><p>但我发现有时候我们并不能确定使用者把我们需要类型的解释器装到了地方, 如果我们只想指出<strong>使用的解释器类型</strong>而不是具体路径, 可以使用<code>/usr/bin/env</code>命令. 比如如果我们想用Python3解释器执行一个脚本, 可以在第一行加:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br></pre></td></tr></tbody></table></figure><p><code>env</code>会调用用户<strong>$PATH</strong>中首先出现的解释器版本.</p><p>当然对于更复杂的情况更建议专门写一段程序来决定用哪个解释器.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux系统的脚本第一行我们通常用
&lt;a href=&quot;https://zh.wikipedia.org/wiki/Shebang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shebang&lt;/a&gt;语句来指明解释器路径, 一方面有的脚本没有文件后缀名,
      
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础语法</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/11/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/11/Python基础语法/</id>
    <published>2019-09-11T19:50:22.000Z</published>
    <updated>2019-10-10T19:08:58.494Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇</p><a id="more"></a><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><table><thead><tr><th>版本</th><th>实现方式</th><th>特点</th></tr></thead><tbody><tr><td>CPython</td><td>C语言写的Python</td><td>速度快</td></tr><tr><td>JPython</td><td>由Java编写的Python</td><td>可以直接调用Java的各种函数库</td></tr><tr><td>PyPy</td><td>由rPython编写的Python</td><td>更灵活, 易于使用和试验</td></tr><tr><td>IronPython</td><td>以. NET和Mono实现的Python</td><td>面向NET和ECMA CLI的Python实现</td></tr><tr><td>ZhPy</td><td>只是把Python翻译了一遍而已</td><td>又称中蟒, 可以完全用中文编程. 但中蟒目前已经停止更新了.</td></tr></tbody></table><p>我们通常所说的Python是<strong>CPython</strong>, 👇Python官方页面提供的是CPython</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1565579206457.png" alt="1565579206457"></p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Python这种语言有Python2和Python3两个版本, 两者语法有少许不同, 一般不能直接把另一个版本的程序拿来运行</p><h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p><strong>万物皆对象</strong></p><p>python在设计初始是一种<strong>面向对象</strong>语言.</p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">💡</span> 面向对象是一种<strong>编程范式</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python是一门<strong>动态类型</strong>语言</p><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>在Python3中有了新特性: <strong>类型注解</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><p>正如其名, 注解只是标注一下, 有了类型注解的程序和没有类型注解的程序运行起来没有区别, 但它能帮助程序员更好的发现问题, 也能让IDE提供更准确的代码补全和语法检查.</p><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>有时候为了保证程序的严谨性我们会检查一下变量是不是我们设想它应该是的类型, 这个时候我们用 <code>isinstance()</code></p><p>之所以不使用 <code>type()</code> 是因为 <code>type()</code> 不会认为子类是一种父类类型, 不考虑继承关系. 举例说明:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> isinstance(i, int)</span><br><span class="line"><span class="keyword">print</span> isinstance(A(), A)</span><br><span class="line"><span class="keyword">print</span> type(A()) == A</span><br><span class="line"><span class="keyword">print</span> isinstance(B(), A)</span><br><span class="line"><span class="keyword">print</span> type(B()) == A</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取变量内存地址</span></span><br><span class="line">id(变量名)</span><br><span class="line"><span class="comment"># 得到变量类型</span></span><br><span class="line">type(变量名)</span><br><span class="line"><span class="comment"># 得到变量的内存大小</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getsizeof(变量名)</span><br></pre></td></tr></tbody></table></figure><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><h4 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number (数字)"></a>Number (数字)</h4><ul><li>int (整数)</li><li>long (长整数)</li><li>float (浮点数, 即小数)</li><li>bool (布尔值, 即 <code>True</code> 和 <code>False</code> )</li></ul><p>Python中的Number我认为是比较特殊的, 因为它<strong>在内存中占用的空间大小是变动</strong>的.(在CPython中是如此, 但不知道为什么在IronPython下不是)String (字符串)</p><h4 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple (元组)"></a>Tuple (元组)</h4><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 我们可以给不可变对象重新赋值, 但其内存地址会改变. 以下是体现给可变对象/不可变对象重新赋值时它们的内存地址变化的代码.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3</span></span><br><span class="line">y = x</span><br><span class="line"><span class="keyword">print</span> id(x), id(y)</span><br><span class="line">y = <span class="number">4</span></span><br><span class="line"><span class="keyword">print</span> id(x), id(y)</span><br><span class="line"><span class="keyword">print</span> x, y</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line"><span class="keyword">print</span> id(a), id(b)</span><br><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> id(a), id(b)</span><br><span class="line"><span class="keyword">print</span> a, b</span><br></pre></td></tr></tbody></table></figure><h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List (列表)"></a>List (列表)</h4><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set (集合)"></a>Set (集合)</h4><h4 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary (字典)"></a>Dictionary (字典)</h4><p>可变对象可能带来的危险举例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(l = [])</span>:</span></span><br><span class="line">    l.append(<span class="string">'add'</span>)</span><br><span class="line">    print(l)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myfunc([1, 2, 3])</span><br><span class="line">myfunc([1, 2, 3])</span><br><span class="line">myfunc()</span><br></pre></td></tr></tbody></table></figure><p>python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响引用的这个变量, 而不可变对象不会. 在向类传递参数时也是如此.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line">l1x = l1</span><br><span class="line">l1x[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">print(l1)</span><br><span class="line">l1x = l1.copy()</span><br><span class="line">l1x[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(l1)</span><br><span class="line">l2x = l2.copy()</span><br><span class="line">l2x[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'a'</span></span><br><span class="line">print(l2)</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l2x = copy.deepcopy(l2)</span><br><span class="line">l2x[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'b'</span></span><br><span class="line">print(l2)</span><br></pre></td></tr></tbody></table></figure><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help()</span><br></pre></td></tr></tbody></table></figure><p>按 <code>q</code> 退出帮助文档</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在Python中 <code>#</code> 开头的为注释</p><h4 id="特殊注释"><a href="#特殊注释" class="headerlink" title="特殊注释"></a>特殊注释</h4><h6 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h6><p>shenbang, hashbang指的是以 <code>#!</code> 开头的语句. Linux操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数. 因为在很多语言中以 <code>#</code> 开头的是注释, 所以不会影响程序.</p><p>有的python文件是这么开头的:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure><p>第一行是给Linux系统的程序加载器看的, 因此在Windows下不需要这句, 第二句是指定文件的编码格式为<strong>UTF-8</strong>, 避免出现乱码</p><h6 id="docstring"><a href="#docstring" class="headerlink" title="docstring"></a>docstring</h6><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(int x, int y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这里是docstring, 是特殊的注释, 能让IDE, 编辑器在鼠标移动到有docstring的函数, 类上时显示这段docstring</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = func(i)</span><br></pre></td></tr></tbody></table></figure><h3 id="条件语句及循环"><a href="#条件语句及循环" class="headerlink" title="条件语句及循环"></a>条件语句及循环</h3><h4 id="if-elif"><a href="#if-elif" class="headerlink" title="if elif"></a>if elif</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt;<span class="number">3</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">2</span> <span class="keyword">if</span> (<span class="number">2</span> &gt; <span class="number">3</span>) <span class="keyword">else</span> <span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="生成器-·迭代器·range"><a href="#生成器-·迭代器·range" class="headerlink" title="生成器 ·迭代器·range"></a>生成器 ·迭代器·range</h4><p>语法类似于切片</p><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性.<strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持:</p><ul><li>列表推导式</li><li>字典推导式</li><li>集合推导式</li></ul><p>列表推导式的语法:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure><p>使用举例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">l = [a[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))]</span><br><span class="line"></span><br><span class="line">h = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    h.append(a[i][<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="矩阵处理"><a href="#矩阵处理" class="headerlink" title="矩阵处理"></a>矩阵处理</h3><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>因为tuple, 字符串其实都是特殊的列表, 列表, 字符串, 元组都可以进行切片.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">b = a[begin:end:step]</span><br></pre></td></tr></tbody></table></figure><p>在没有<strong>numpy</strong>库的情况下<strong>多维切片</strong>是通过推导式实现的:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">b = [a[i][:<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)]</span><br></pre></td></tr></tbody></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>:bulb: 要注意函数名后的 <code>()</code> 也是一种运算符, 称为函数调用运算符. 如果调用函数的时候不加()只会创建一个该函数的对象而不会调用它.</p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>python中以 <code>def</code> 关键字定义函数, 结构如下:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数主体</span><br></pre></td></tr></tbody></table></figure><p>python中的函数可以有返回值也可以没有返回值</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.appeend(<span class="string">'add'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><h3 id="用字典来实现case"><a href="#用字典来实现case" class="headerlink" title="用字典来实现case"></a>用字典来实现case</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printdefault</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic = {</span><br><span class="line">    <span class="string">'a'</span>: print1,</span><br><span class="line">    <span class="string">'b'</span>: print2,</span><br><span class="line"><span class="string">'default'</span>: printdefault}</span><br><span class="line"></span><br><span class="line">i = input(<span class="string">'输入: '</span>)</span><br><span class="line">main = dic[i <span class="keyword">if</span> (i != <span class="string">'a'</span> <span class="keyword">or</span> i != <span class="string">'b'</span>) <span class="keyword">else</span> <span class="string">'default'</span>]</span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>字符串经过<strong>编码（encode）</strong> 就成为了一堆数据, 反过来, 数据经过<strong>解码（decode）</strong> 就变回我们认识的字符串.</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/encode_decode.png" alt="img"></p><p>指定文件编码格式为 <code>utf-8</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">💡</span> 如果不指定文件编码格式在有的Python2版本中无法识别中文, 即便是中文注释也会报错.</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Unicode_Decoding_and_Encoding.png" alt="Unicode Decoding and Encoding"></p><p>Linux系统默认编码格式是<strong>UTF-8</strong>, 系统语言是简体中文时Windows10的编码格式是<strong>GB2312</strong> (也称GBK, 国标扩展, cp936)</p><p>在python中 <code>str</code> 类型数据都以Unicode码点格式储存, 因此直接打印字符串会看到字符为’\u’开头</p><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.write(<span class="string">"text"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure><p><code>r</code> 是普通模式, <code>r+</code> 是读写, <code>w</code> 是覆盖写入模式, <code>w+</code> 是覆盖读写, <code>a</code> 是追加模式, <code>a+</code> 是追加读写, b是以二进制方式打开</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write()</span><br><span class="line">    f.read()</span><br><span class="line">    f.readlines()</span><br><span class="line">    f.readline()</span><br></pre></td></tr></tbody></table></figure><h2 id="脚本和普通程序的区别"><a href="#脚本和普通程序的区别" class="headerlink" title="脚本和普通程序的区别"></a>脚本和普通程序的区别</h2><p>脚本这个词来源于戏剧, 能用于舞台演出的戏剧文本就称为脚本. 在编程中的脚本是解释执行的程序, 通常只用来做简单的处理, 起辅助作用</p><h2 id="解释器的使用技巧"><a href="#解释器的使用技巧" class="headerlink" title="解释器的使用技巧"></a>解释器的使用技巧</h2><p>在解释器中交互式编程时要注意缩进不要错</p><h3 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h3><p>python解释器本身没有清屏命令, 只能通过调用命令行的清屏命令来达到效果</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># Windows下</span></span><br><span class="line">os.system(<span class="string">'cls'</span>)</span><br><span class="line"><span class="comment"># Linux下</span></span><br><span class="line">os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><ul><li>在除了函数调用符的运算符两侧加空格</li><li>注释时在 <code>#</code> 后写个空格再写注释内容</li><li>行尾注释时先写两个空格再写注释</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://leojhonsong.github.io/zh-CN/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux终端呈现彩色输出</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/11/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/11/Linux终端呈现彩色输出/</id>
    <published>2019-09-11T18:35:48.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: <strong>让特定类型的输出显示为特定的颜色</strong>!</p><a id="more"></a><p>比如这样:</p><p style="color:purple">[MESSAGE] Turning left</p><p style="color:yellow">[DEBUG] target: 4</p><p style="color:red">[Error] target not found</p><p style="color:purple">[MESSAGE] Turning left</p><p style="color:purple">[MESSAGE] Diving</p><p style="color:green">[INFO] depth: 9m</p><p style="color:purple">[MESSAGE] Diving</p><p style="color:green">[INFO] depth: 10m</p><p style="color:purple">[MESSAGE] Forward</p><p style="color:purple">[MESSAGE] Turing right</p><p>能极大的增强终端信息的可读性!😆</p><p>这应该是Linux终端的特性, (我并不清楚是否兼容Windows命令行), shell, python, C++的彩色文字语法几乎是一样的.</p><h2 id="颜色表"><a href="#颜色表" class="headerlink" title="颜色表"></a>颜色表</h2><table><thead><tr><th>前景色 (字体颜色) 代码</th><th>背景色代码</th><th>颜色</th></tr></thead><tbody><tr><td>30</td><td>40</td><td>黑色</td></tr><tr><td>31</td><td>41</td><td>紅色</td></tr><tr><td>32</td><td>42</td><td>綠色</td></tr><tr><td>33</td><td>43</td><td>黃色</td></tr><tr><td>34</td><td>44</td><td>藍色</td></tr><tr><td>35</td><td>45</td><td>紫紅色</td></tr><tr><td>36</td><td>46</td><td>青藍色</td></tr><tr><td>37</td><td>47</td><td>白色</td></tr></tbody></table><h2 id="字体效果表"><a href="#字体效果表" class="headerlink" title="字体效果表"></a>字体效果表</h2><table><thead><tr><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>0</td><td>默认</td></tr><tr><td>1</td><td>高亮(加粗)</td></tr><tr><td>4</td><td>下划线</td></tr><tr><td>5</td><td>闪烁</td></tr><tr><td>7</td><td>反色</td></tr><tr><td>8</td><td>不可见</td></tr></tbody></table><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h3><p>举例:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "\e[31;43;1mError\!\e[0m"</span><br></pre></td></tr></tbody></table></figure><p>💡 如果上面这条命令不是彩色的, 执行<code>echo -e "\e[31;43;1mError\!\e[0m"</code></p><p>运行上面这条命令会输出一个黄底红色粗体字的”Error!”. 前景色, 背景色和字体效果的代码没有先后顺序之分. 建议每个<code>\e[a;b;c</code>都接一个<code>\e[0m</code>将字体效果恢复默认, 不然后续输出还是带特殊效果的.</p><h3 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h3><p>在<code>print()</code>中使用的示例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"\033[31;43;1mError!\033[0m"</span>)</span><br></pre></td></tr></tbody></table></figure><p>或者可以通过python执行shell命令:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">'echo "\e[31;43;1mError!\e[0m"'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h3><p>在C++中使用的语法和在python中是一样的:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[31;43;1m"</span> &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; <span class="string">"\033[0m"</span> &lt;&lt; <span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><p>一个小技巧是可以单独写一个<code>color_print.h</code>, 内容示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET   <span class="meta-string">"\033[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK   <span class="meta-string">"\033[30m"</span>      <span class="comment">/* Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED     <span class="meta-string">"\033[31m"</span>      <span class="comment">/* Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN   <span class="meta-string">"\033[32m"</span>      <span class="comment">/* Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW  <span class="meta-string">"\033[33m"</span>      <span class="comment">/* Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE    <span class="meta-string">"\033[34m"</span>      <span class="comment">/* Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGENTA <span class="meta-string">"\033[35m"</span>      <span class="comment">/* Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN    <span class="meta-string">"\033[36m"</span>      <span class="comment">/* Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE   <span class="meta-string">"\033[37m"</span>      <span class="comment">/* White */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLACK   <span class="meta-string">"\033[1m\033[30m"</span>      <span class="comment">/* Bold Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDRED     <span class="meta-string">"\033[1m\033[31m"</span>      <span class="comment">/* Bold Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDGREEN   <span class="meta-string">"\033[1m\033[32m"</span>      <span class="comment">/* Bold Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDYELLOW  <span class="meta-string">"\033[1m\033[33m"</span>      <span class="comment">/* Bold Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLUE    <span class="meta-string">"\033[1m\033[34m"</span>      <span class="comment">/* Bold Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDMAGENTA <span class="meta-string">"\033[1m\033[35m"</span>      <span class="comment">/* Bold Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDCYAN    <span class="meta-string">"\033[1m\033[36m"</span>      <span class="comment">/* Bold Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDWHITE   <span class="meta-string">"\033[1m\033[37m"</span>      <span class="comment">/* Bold White */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(color, context) std::cout &lt;&lt; color &lt;&lt; context &lt;&lt; RESET &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>然后在要显示彩色输出的cpp文件中引用这个头文件, 打印语句示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(BOLDRED, <span class="string">"Error!"</span>);</span><br></pre></td></tr></tbody></table></figure><p>因为是宏替换因此<code>context</code>字段其实可以随意填, 比如有一个变量<code>depth</code>, 用下面语句来打印深度是可以的:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(BOLDGREEN, <span class="string">"depth: "</span> &lt;&lt; depth &lt;&lt; <span class="string">"m"</span>)</span><br></pre></td></tr></tbody></table></figure><p>超好用!😆</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: &lt;strong&gt;让特定类型的输出显示为特定的颜色&lt;/strong&gt;!&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>我将Shell换为了zsh</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/02/%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/02/我将shell换为了zsh/</id>
    <published>2019-09-02T01:22:25.000Z</published>
    <updated>2019-10-10T19:08:58.498Z</updated>
    
    <content type="html"><![CDATA[<p>我把shell从<strong>bash</strong>换到<strong>zsh</strong>了. 原本我是根本没动过换shell的念头的, 但因为这段时间用的笔记本被别人装好了zsh, 我就将就着用了, 谁知真香…</p><a id="more"></a><p>不得不说zsh比bash确实好了许多:</p><ul><li>补全智能了太多! 比如切换路径时的补全不必区分大小写, 比如会根据历史命令给出建议, 比如如果命令里有<code>$(pwd)</code>这样的取值操作, 按一下<kbd>Tab</kbd>zsh会将其补全为对应的值.</li><li>支持一次输入多行命令再执行. 不像bash只能一行一行运行, 如果其中有命令是需要输入确认的, 那么下一条命令就会被当做这条命令的确认用输入中, 然后就会报错 🤷</li><li>Powerlevel9k这个主题很好看很强大, 能显示出包括<strong>git状态</strong>, <strong>当前Python环境</strong>,<strong>命令执行时间</strong>, <strong>后台任务数量</strong>, <strong>当前时间</strong>在内的许多有用信息</li><li>zsh有许多很有用的插件</li></ul><p>总之我要到zsh去了, bash再见👋</p><p>下面是部分功能的展示</p><p><img src="%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/screencast.gif" alt=""></p><p>下面我大致说一下我的zsh配置</p><ul><li>zsh配置管理工具: <a href="https://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh</a></li><li>zsh插件管理工具: <a href="https://github.com/zsh-users/antigen" target="_blank" rel="noopener">Antigen</a></li><li>zsh主题: <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">Nerd-Fonts</a>字体(具体来说是<a href="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/DejaVuSansMono" target="_blank" rel="noopener">DejaVuSansMono Nerd</a>)的<a href="https://github.com/Powerlevel9k/powerlevel9k" target="_blank" rel="noopener">Powerlevel9k</a>主题</li></ul><p>以下是我的<code>~/.zshrc</code>中部分代码.</p><p>有关Powerlevel9k:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POWERLEVEL9K_MODE='nerdfont-complete'</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND="black"</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND="blue"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON="echo   $(whoami) "</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_BACKGROUND="purple"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_FOREGROUND="white"</span><br><span class="line">POWERLEVEL9K_ANACONDA_BACKGROUND="chartreuse3"</span><br><span class="line">POWERLEVEL9K_ANACONDA_LEFT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_DIR_HOME_BACKGROUND='123'</span><br><span class="line">POWERLEVEL9K_DIR_HOME_SUBFOLDER_BACKGROUND='123'</span><br><span class="line"><span class="meta">#</span><span class="bash"> POWERLEVEL9K_DIR_ETC_BACKGROUND=<span class="string">'123'</span></span></span><br><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(custom_os_icon ssh anaconda root_indicator dir dir_writable vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(command_execution_time status background_jobs time)</span><br><span class="line">ZSH_THEME="powerlevel9k/powerlevel9k"</span><br></pre></td></tr></tbody></table></figure><p>有关zsh插件:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Which plugins would you like to load?</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Standard plugins can be found <span class="keyword">in</span> ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">source ~/Desktop/backup/zsh/antigen.zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the oh-my-zsh<span class="string">'s library.</span></span></span><br><span class="line">antigen use oh-my-zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Bundles from the default repo (robbyrussell<span class="string">'s oh-my-zsh).</span></span></span><br><span class="line">antigen bundle git</span><br><span class="line">antigen bundle pip</span><br><span class="line">antigen bundle command-not-found</span><br><span class="line"><span class="meta">#</span><span class="bash"> custom plugins</span></span><br><span class="line">antigen bundle zsh-users/zsh-syntax-highlighting</span><br><span class="line">antigen bundle zsh-users/zsh-autosuggestions</span><br><span class="line">antigen bundle sobolevn/wakatime-zsh-plugin</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the theme.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> antigen theme powerlevel9k/powerlevel9k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell Antigen that you<span class="string">'re done.</span></span></span><br><span class="line">antigen apply</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我把shell从&lt;strong&gt;bash&lt;/strong&gt;换到&lt;strong&gt;zsh&lt;/strong&gt;了. 原本我是根本没动过换shell的念头的, 但因为这段时间用的笔记本被别人装好了zsh, 我就将就着用了, 谁知真香…&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/11/C-学习笔记/</id>
    <published>2019-08-11T03:25:19.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>… <a href="https://leojhonsong.github.io/zh-CN/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">前几天刚说最近没有用C的需求</a>我就开始要写C++了 🤦</p><p>TODO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;… &lt;a href=&quot;https://leojhonsong.github.io/zh-CN/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&quot;&gt;前几天刚说最近没有用C的需求&lt;/a&gt;我就开始要写C++了 🤦&lt;
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://leojhonsong.github.io/zh-CN/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>初学Socket通信</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/07/%E5%88%9D%E5%AD%A6socket%E9%80%9A%E4%BF%A1/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/07/初学socket通信/</id>
    <published>2019-08-07T08:14:26.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>记大二暑假北航实习</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/05/%E8%AE%B0%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E5%8C%97%E8%88%AA%E5%AE%9E%E4%B9%A0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/05/记大二暑假北航实习/</id>
    <published>2019-08-05T14:25:46.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>这个暑假我来到了北航<a href="http://softrobotics.buaa.edu.cn/peoples/peoples_ch/index.htm" target="_blank" rel="noopener">仿生软体机器人实验室</a>学习, 收获颇多.结实了一群有趣的人, 得到了一些答案, 看到了更明确的方向, 坚定了我研究软体机器人的信念💪</p><a id="more"></a><p>如今我愈发觉得玄幻小说里一种很玄的情节其实很现实: <strong>历练总是能有些机缘!</strong></p><p>有些事情在事前真的无法预测, 比如在我这次前往北京学习一个半月之前, 我是完全想不到我能有什么收获的, 而最终的收获多到一两句说不清. <strong>如果在家仔细思考, 总会觉得一个半月那样短, 去了又能怎样?</strong> 再引用一句玄幻小说里的话:</p><blockquote><p>我辈修士, 当与天争命!</p></blockquote><p>事实证明, 只要自己主动抓住各种机会一个半月并不那样短暂.</p><p>这一个半月我干了许多事: 我浇筑了一套软体臂, 软体爪, 我试着帮实验室的学长解决实验面临的困难, 我每天站着巨久调试了半个月机器人, 我随实验室的队伍到大连参加了一个难度很高的比赛, 我在大连每天白嫖各种海鲜, 我和在中科院中关村学生公寓的室友相处不错还一块深夜吃了烧烤, 我给好几人上了家教课, 我经常和在北京的亲属玩,我, 我试图减肥并失败🤦‍</p><h2 id="关于学习收获"><a href="#关于学习收获" class="headerlink" title="关于学习收获"></a>关于学习收获</h2><h3 id="在实验室的体会"><a href="#在实验室的体会" class="headerlink" title="在实验室的体会"></a>在实验室的体会</h3><p>实际上在前往文老师的实验室前我并没有真正接触到软体机器人: 只能自己看看资料算什么? 但我也很无奈啊, 想做的实验材料就动辄几千, 而花销小的实验一般是真-实验室阶段,我一时半会研究不出什么名堂. 更何况我在电子科大并没有找到相关团队. 而到文老师实验室这段时间我不仅是更正了一些对软体机器人的理解, 更是对科研有了一些概念.</p><p>很幸运的是实验室所有人人都很好, 我很快就融入其中, 也有幸和几位学长探讨了他们的工作. 谢博士的废寝忘食令我记忆犹新. 好几次谢博因为想解决问题而晚去吃饭. 谢博也很虚心, 因为并不是电气专业出身, 实验遇到电气方面问题还拉我一起研究. 辉哥则和我聊了很多过来人的经验, 他建议说在国外科研更加自由, 能支持更基础的研究方向, 杂事更少, 老师和学生的关系更像合作伙伴, 而最后如果能留在国外就不用按国内五年一个职位的累死累活竞争等等. 结对调试机器人的同样来自四川的陈学长则和我分享了许多学习经验, 在我看来他的学习经历实在是一次逆袭. 而见到文老师前我同样没想到是这样一位爱夸人的总是在笑的老师. 这一个半月我更多的时间是和刘学长在一起, 他也教了我很多, 比如如何浇筑(我一个学电气的是完全没做过这种事的), 而来实验室前的许多疑问我也从他那得到了解答.</p><p>亲身站在实验室里我更直观的体会到了软体机器人是怎样的一个领域. 虽然刘学长觉得软体机器人现在发展趋势缓下来了, 但我觉得这个领域仍在萌芽阶段. 从我了解到的成果和在实验室近距离看学长们的工作来看, 除了软体抓手现在已经商业化了其他成果仍离走出实验室差很远, 有些甚至只是证明了一些结构的潜力, 说白了目前基本是空架子. 就比如实验室花了好几万买的液态金属打印机, 不光墨水贵, 还经常不出墨, 出墨也不够理想, 和谢博一起做实验的袁学长说某些方面甚至可能比不上以前手工浇筑的效果. 不过最近清华大学刚研发出了类似喷墨打印机原理的液态金属打印方式, 看论文效果很不错, 期待能尽早推出产品.目前的成果之所以离投入应用还远一方面是因为目前的软体机器人因为使用的驱动方式, 能提供的驱动力普遍很小, 基本没有应用场景, 另一方面是因为目前软体机器人的控制基本是黑暗一片, 就算是一段较早出现的软体臂也没有一个称得上很好的闭环控制方法. 而针对非结构性环境的软体机器人如果连闭环都做不到还有何用? 虽然目前也有好几项人来控制, 机器人负责在人类很难触及的环境 (比如人体内, 十分狭窄的缝隙, 20m深的海底) 执行的成果, 但我认为自主始终是趋势.</p><p>另外一点在实验室学到的, 觉得很有意思的是如何记<strong>组会记录</strong>. 首先记肯定是要记的,不然如果讨论的不是自己在参与的项目时岂不是在浪费时间? 我认为组会本就是集思广益大家相互交流经验的地方 (这点在我们组里也很明显, 每个人讲完自己的项目进度后老师会问大家的看法和建议), 因此如果在组会中只注意讲好自己的项目就本末倒置了. 记组会记录一方面帮助自己整理思路, 看看能给正在讲的同学什么帮助, 另一方面讲大家的经验记录下来,这样以后自己遇到类似问题就能有突破口, 另外老师有时候也会给一些写论文方面的指导,也值得记录. 我觉得记组会记录最好用OneNote这种手写的电子档, 自由度高, 适合写写画画整理思路, 电子档也更利于保存.</p><h3 id="对C-的体会"><a href="#对C-的体会" class="headerlink" title="对C++的体会"></a>对C++的体会</h3><p>再有就是我学习C++的速度还是令我觉得值得表扬的😆 实际上在这个暑假之前我是不会C++的,顶多是大一上的时候学了最基础的C. 我是这个暑假开始时从学长那里继承了本紫色的**算法竞赛入门经典<strong>巩固了下C语言, 了解了一些C++. 而到了实验室先是照着网上的模板写了个C++的TCP server, 然后和中科院的学长一起负责ROV的控制代码 (纯C++). 说实话一方面是大一上扎实的C基础帮了大忙 (我明明每一科都能很好地应用可我就是考不好真的好气), 另一方面则是我浏览器程序员的特长: 上网查资料发挥了巨大作用😁 这真的是现学现卖.好在学长把核心代码都写好了, 我就写了写语法很简单的控制流程什么的. 期间也因为不熟悉C++遇到了很多奇葩问题, 比如就因为在</strong>多线程C++程序**中用错了计时函数导致了计时不准, 程序崩溃等各种迷之错误… 反正一波C++速成后我对C++的印象极差, 标准库很落后, 坑很多, 语法很啰嗦 (和我最爱的Python比), 环境配置也比Python开发麻烦等等…</p><p>以后我自己写程序用到C/C++顶多是要求算力部分用C/C++来加速, 或者用到的工具只有C/C++接口时.其他部分全部用Python糊!</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后想发表一番感慨: 虽然这只是我的大二暑假, 但实际上我在高三暑假就决定了以后研究机器人, 为此学习了许多, 做着各种各样的准备. 比如我学习了Python, 也针对机器人中很常用到的机器学习和CV分别做了一个小项目 (<a href="https://github.com/LeoJhonSong/SVM-Learning-Sample" target="_blank" rel="noopener">我的机器学习小项目</a>, <a href="https://github.com/LeoJhonSong/Fingertip-Drawboard" target="_blank" rel="noopener">我的CV小项目</a>)来学习了解, 比如我查阅了许多软体机器人的文献, 也曾自己试着<a href="https://leojhonsong.github.io/zh-CN/2018/12/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/">用仿真软件仿真软体机器人</a>,以及即便曾经的我<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/为什么我用Linux而不是Windows/">曾找各种理由来说服自己用Linux</a> (当然后来就离不开Linux了)… 总之我曾努力学习过的东西都确实地派上了用场, 我感到自己的努力没有白费💪 我会再接再厉!</p><h2 id="关于家教"><a href="#关于家教" class="headerlink" title="关于家教"></a>关于家教</h2><p>另外我在北京这段时间在一个叫<strong>易教网</strong>的平台接了几份家教的工作. 经过了这一段时间的体验我觉得当家教是一件既有趣又促进自己学习还赚钱的事.</p><h2 id="关于北京"><a href="#关于北京" class="headerlink" title="关于北京"></a>关于北京</h2><p>第一次在北京待一个半月, 见识到了首都的另一面. 以前我是个京黑, 这次在北京的体验改变了我的印象, 让我变成了真*京黑😁 是的印象一点也没有变好! 或者说见到了好的一面,但也加深了负面印象.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个暑假我来到了北航&lt;a href=&quot;http://softrobotics.buaa.edu.cn/peoples/peoples_ch/index.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仿生软体机器人实验室&lt;/a&gt;学习, 收获颇多.
结实了一群有趣的人, 得到了一些答案, 看到了更明确的方向, 坚定了我研究软体机器人的信念💪&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB杂记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/05/MATLAB%E6%9D%82%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/05/MATLAB杂记/</id>
    <published>2019-08-05T14:25:20.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>再开学的课程就要用MATLAB了, 而且了解很多机械系唯一要求学的编程语言就是MATLAB, 我决定还是稍微了解下.</p><a id="more"></a><p>首先, <a href="https://www.zhihu.com/question/37824202/answer/767114071" target="_blank" rel="noopener">MATLAB到底是不是编程语言?</a></p><p>从<strong>TIOBE</strong>上有MATLAB而且MATLAB排名还不低可以看出MATLAB确实是一门编程语言, 但从上面链接可以看出MATLAB算是残疾的编程语言, 很多特性没有, 更多的是用来验证算法可行性.但我又想验证算法可行性为啥不用Python什么的? 然后我发现原本用Octave教深度学习的吴恩达现在用该用Python了 😁 而且因为商业使用MATLAB很贵, 速度也慢, 因此公司里基本没有用MATLAB的</p><p>因此我觉得MATLAB的优势主要就在:</p><ul><li>语法简单, 没有编程基础的工科生也能快速掌握</li><li>集成度特别高, 各种工具都能轻松快速配置好</li><li>能和多种语言交互, 编写界面简单</li><li>很多工具都有图形界面, 操作简单, 按按键就可以, 不用写那么多代码.</li></ul><p>🤦‍</p><p>行吧我就简单学学</p><h1 id="MATLAB软件个性化设置"><a href="#MATLAB软件个性化设置" class="headerlink" title="MATLAB软件个性化设置"></a>MATLAB软件个性化设置</h1><h2 id="设置初始工作文件夹"><a href="#设置初始工作文件夹" class="headerlink" title="设置初始工作文件夹"></a>设置初始工作文件夹</h2><p>使用HOME目录作为起始工作文件夹我觉得不是什么好事, 所以最好自己指定一个合适的目录. 我使用的是MATLAB默认的<code>userpath</code>, 即<strong>Documents/MATLAB</strong>文件夹. 一方面这个文件夹看着比较合理一方面MATLAB说<a href="https://ww2.mathworks.cn/help/matlab/matlab_env/matlab-startup-folder.html#bujzf43" target="_blank" rel="noopener">使用userpath作为初始工作文件夹有一定好处</a></p><p>Linux下设置MATLAB的初始工作文件夹方法和在Windows下改快捷方式的起始位置这种方法不一样, 要达到这个目的有两种方式:</p><ol><li>在终端输入 <code>matlab -useStartupFolderPref</code> 打开MATLAB, -useStartupFolderPref选项指定初始工作文件夹为在<strong>Preference</strong>中<strong>Initial working folder option</strong>的指定文件夹.</li><li>在终端输入 <code>matlab -sd [folder]</code> 打开MATLAB, -sd选项指定初始工作文件夹为[folder]文件夹.</li></ol><h2 id="更改编辑界面颜色主题"><a href="#更改编辑界面颜色主题" class="headerlink" title="更改编辑界面颜色主题"></a>更改编辑界面颜色主题</h2><p>在vim, VSC, VS, CLION, Pycharm等工具用惯了黑暗主题以后拿到啥都想先换个黑暗主题. 但是找了半天也只找到了设置编辑界面颜色主题的方式, 普通操作似乎并不能自定义丑陋的灰色工具栏.</p><p>最终我把界面变成了这样 👇</p><p><img src="MATLAB%E6%9D%82%E8%AE%B0/appearance.png" alt="界面"></p><ul><li>颜色主题是通过<a href="https://github.com/scottclowe/matlab-schemer" target="_blank" rel="noopener">MATLAB Schemer</a>里的脚本更换的, 一键更换好评👍 因为我比较喜欢糖果色的颜色主题然后又不喜欢注释是灰色 (不管在黑色背景还是白色背景里辨析度都很低), 于是选择的主题是<a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes#dark-steel" target="_blank" rel="noopener">DarkSteel</a></li><li>字体用的是<a href="https://github.com/powerline/fonts/tree/master/DejaVuSansMono" target="_blank" rel="noopener">DejaVu Sans Mono forPowerline</a>, 大小是11, 不过不知道为什么MATLAB显示无效果的字体看着很粗糙, 边缘锯齿状过于明显,效果设置为了 <strong>bold</strong>, 这回好多了!</li><li>布局改成了和我常用的vim, VSC差不多的布局: 资源管理器在左上, 细节信息在左下, 编辑窗口在右</li></ul><h1 id="MATLAB语法和工具"><a href="#MATLAB语法和工具" class="headerlink" title="MATLAB语法和工具"></a>MATLAB语法和工具</h1><h2 id="在终端运行"><a href="#在终端运行" class="headerlink" title="在终端运行"></a>在终端运行</h2><p>曾经我因为嫌MATLAB界面太丑又不能个性化想过在终端像用交互式Python一样用交互式MATLAB以及运行脚本. 我发现这是可行的:</p><p>在终端启动交互式MATLAB:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matlab -nojvm</span><br></pre></td></tr></tbody></table></figure><p><code>-nojvm</code>选项本身是<strong>不启动Java虚拟机</strong>的意思, 但因为Matlab的GUI都是用Java写的(听网上说的), 所以也有<code>-nosplash</code> (<strong>不显示启动画面</strong>), <code>-nodesktop</code>(<strong>不启动图形界面</strong>) 的功能. 另外因为没有启动jvm这样启动MATLAB十分迅速.</p><p>💡 要注意用<code>-nojvm</code>选项时会创建图形界面的命令会报错.</p><p>在终端运行MATLAB脚本:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matlab -batch [MATLAB_command]</span><br></pre></td></tr></tbody></table></figure><p><code>-batch</code>选项和<code>-r</code>选项的区别在于前者不会启动图形界面而后者会. 另外如果脚本中没有与图形界面有关的语句同样可以加上<code>-nojvm</code>选项.</p><p><strong>但是啊!</strong></p><p>我后来发现这样就<strong>本末倒置</strong>了! MATLAB的亮点我觉得一是所有变量都是全局变量, 能迅速可视化变量, 工具集成度非常高, 适合迅速验证各种算法, 二是社区非常完善, 提供了很多工具能轻松仿真很多模型.</p><p>因此只在终端的MATLAB是没有灵魂的MATLAB. <strong>如果终端里的MATLAB就能解决你的需求的话为什么不用Python?</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再开学的课程就要用MATLAB了, 而且了解很多机械系唯一要求学的编程语言就是MATLAB, 我决定还是稍微了解下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="MATLAB" scheme="https://leojhonsong.github.io/zh-CN/categories/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/07/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/07/12/C语言学习笔记/</id>
    <published>2019-07-12T08:22:42.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.</p><p>经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了… 虽然我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知新, 再次”速成”一下.</p><a id="more"></a><h1 id="语句与行"><a href="#语句与行" class="headerlink" title="语句与行"></a>语句与行</h1><p>C语言我感觉对格式要求蛮宽松的, 可以一行多个语句 (每个语句必须以<code>;</code>结尾), 也可以跨行写语句(在行末写<code>\</code>折行), 不像python对缩进都有严格要求.</p><p>🌟 代码风格的话我只认<strong>VS风</strong>, 就是Visual Studio格式化出来的样式. 是的我是<strong>大括号换行派</strong>!</p><p>💡 要注意的是预编译指令必须一行不能写多个语句, 但可以折行.</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>有两种方式</p><h2 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h2><p>👇这种注释可以跨行写, 也可以在行内写</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="comment">/*comment*/</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*comment</span></span><br><span class="line"><span class="comment">comment</span></span><br><span class="line"><span class="comment">comment*/</span></span><br></pre></td></tr></tbody></table></figure><p>💡值得一提的是只要出现 <strong>/*</strong> 就会被识别为注释的开始, 如果想把y除z指向的内存的值赋给x写成下面这样是不行的.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y<span class="comment">/*z</span></span><br></pre></td></tr></tbody></table></figure><p>但这个问题也很好解决, 用空格或括号就能解决.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y / *z</span><br><span class="line">x = y/(*z)</span><br></pre></td></tr></tbody></table></figure><h2 id="不推荐的方式"><a href="#不推荐的方式" class="headerlink" title="不推荐的方式"></a>不推荐的方式</h2><p>这样只能单行注释</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code  <span class="comment">// comment</span></span><br></pre></td></tr></tbody></table></figure><p>❗️要注意这种注释方式是借鉴自C++, 在C99中才被标准化, 而目前使用最广泛的是C89标准,也就是说不使用是比较保险的.</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>C语言对内存的操作似乎很多, 也很注重内存管理.</p><p>C语言为内存的分配和管理提供了几个函数. 这些函数可以在 &lt;stdlib.h&gt; 头文件中找到.</p><p><strong>void *malloc(size_t size)</strong> 分配一块<code>size</code>大小的内存</p><p><strong>void *calloc(size_t num, size_t size)</strong> 分配一块储存了一个<code>num</code>长, 每个元素<code>size</code>字节的内存并将所有位初始化为0</p><p><strong>void *realloc(void *ptr, size_t size)</strong> 重新分配内存, 把内存扩展到 newsize</p><p><strong>void free(void *ptr)</strong> 释放<code>ptr</code>所指向的内存</p><p>💡 malloc是memory allocate, realloc是reallocate, calloc不知道是啥.</p><h1 id="段与栈与堆"><a href="#段与栈与堆" class="headerlink" title="段与栈与堆"></a>段与栈与堆</h1><p><strong>段</strong> (segmentation)是指二进制可执行文件内的区域,所有某种特定类型信息被保存在里面.可以用<code>size</code>命令得到可执行文件中各个段的大小. <strong>正文段</strong> (Text Segment)用于储存指令, <strong>数据段</strong> (Data Segment)用于储存已初始化的全局变量, <strong>BSS段</strong> (BSSSegment)用于储存未赋值的全局变量所需的空间.</p><p><strong>调用栈</strong>并不储存在可执行文件中,而是在运行时创建.调用栈所在的段称为堆栈段(StackSegment). 和其他段一样, 堆栈段也有自己的大小, 不能被越界访问, 否则就会出现段错误(Segmentation Fault). 这种情况叫<strong>栈溢出</strong>.</p><p>栈空间有多大和操作系统相关. 在Linux中, 栈大小是由系统命令<code>ulimit</code>指定的, 例如<code>ulimit -a</code>显示当前栈大小, 而<code>ulimit -s 32768</code>将把栈大小指定为32MB. 但在Windows中, 栈大小是储存在可执行文件中的. 使用gcc可以这样指定可执行文件的栈大小: <code>gcc-Wl,--stack=16777216</code>, 这样栈大小就变为16MB</p><p>💡 栈溢出不一定是递归调用过多导致的, 也可能是局部变量太大. 因此<strong>较大的数组建议储存为全局变量</strong>.</p><p><strong>栈</strong>是由编译器在需要时分配的, 不需要时自动清除的变量存储区. 里面的变量通常是局部变量, 函数参数等. <strong>堆</strong>是由<code>malloc()</code>函数分配的内存块,内存释放由程序员手动控制, 在C语言由<code>free()</code>完成.</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>较大的数组时应在main函数之外声明.</p><p><code>memset(a, 0, sizeof(a))</code>能方便地把数组a清零,它在<strong>string.h</strong>中定义.</p><p>用strcpy(a, b), strcmp(a, b), strcat(a, b)来执行“赋值”、“比较”和“连接”操作, 在<strong>string.h</strong>中定义</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言中的字符串是以“\0”结尾的字符数组</p><p>不同操作系统的回车换行符是不一致的. Windows是“\r”和“\n”两个字符,Linux是“\n”,而MacOS是“\r”. 如果在Windows下读取Windows文件, fgetc和getchar会把“\r””吃掉”, 只剩下“\n”; 但如果要在Linux下读取同样一个文件, 它们会忠实地先读取“\r”, 然后才是“\n”.</p><p>很有意思的一个小问题: “5”, ‘5’ 和 5 有什么区别?<br>“5”是一个字符串, ‘5’是一个字符常量, 5是一个数字常量</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>用int* a声明的变量a是指向int型变量的指针. 赋值a = &amp;b的含义是把变量b的地址存放在指针a中, 表达式<em>a代表a指向的变量, 既可以放在赋值符号的左边(左值), 也可以放在右边(右值) 注意: <em>a是指“a指向的变量”, 而不仅是“a指向的变量所拥有的值”. 理解这一点相当重要. 例如, *a = *a + 1就是让a指向的变量自增1. 甚至可以把它写成(</em>a)++. 注意不要写成<em>a++, 因为<code>++</code>运算符的优先级高于取内容运算符 `</em>`, 实际上会被解释成</em>(a++).</p><h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><ul><li>一个指针变量加/减一个整数是将该指针变量的原值(是一个地址)和它指向的变量所占用的内存单元字节数相加或相减.</li><li>两个指针变量间可以做减法, 但前提是这两个指针是指向同一个数组的元素. 两指针变量差是两个指针之间的元素个数</li><li>如果两指针变量指向同一数组的元素, 他们可以进行比较运算. 另外所有指针都可以和NULL进行相等/不想等比较.</li></ul><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></tbody></table></figure><p>宏名一般为大写, 以下划线连接单词.</p><p>看了网上资料我感觉在C中宏定义主要是以下作用</p><h3 id="增加代码抽象性"><a href="#增加代码抽象性" class="headerlink" title="增加代码抽象性"></a>增加代码抽象性</h3><p>用宏定义替代magic number, 或者嵌入式中一些寄存器的位操作, 一方面增强代码可读性(不像魔数让人不明所以, 而寄存器的位操作也很不直观), 一方面增强代码可移植性 (比如从一种单片机移植到另一种单片机, 只需更改宏定义即可)</p><h3 id="防止重复定义"><a href="#防止重复定义" class="headerlink" title="防止重复定义"></a>防止重复定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXXX</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>在头文件里用这样的语句来防止头文件被重复引用. 有一些头文件被重复引用会增加编译器工作, 降低编译效率, 而有一些头文件被重复引用会引起冲突 (比如如果头文件里定义了全局变量, 会发生重复定义错误).</p><h3 id="控制代码编译"><a href="#控制代码编译" class="headerlink" title="控制代码编译"></a>控制代码编译</h3><p>通过Makefile控制编译选项.</p><p>还能像轮子哥<a href="https://www.zhihu.com/question/22608939/answer/21963056" target="_blank" rel="noopener">这样</a>当模板用.</p><p>❗️虽然宏定义的好处不少, 但除了以上情况尽量少用尽量不用宏定义, 因为这会让开发者看到的代码与编译器看到的代码不同, 容易导致想不到的问题.</p><h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><p>调试时重点关注两方面: <strong>当前行的跳转</strong>, <strong>变量的变化</strong></p><p>循环结构程序设计中最常见的两个问题: <strong>算术运算溢出</strong>, <strong>程序效率低下</strong></p><p>变量在未赋值之前的值是不确定的.</p><h1 id="gcc与gdb命令简记"><a href="#gcc与gdb命令简记" class="headerlink" title="gcc与gdb命令简记"></a>gcc与gdb命令简记</h1><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>常用选项:</p><table><thead><tr><th>name_of_option</th><th>我猜的全名</th><th>含义</th></tr></thead><tbody><tr><td>-o [filename]</td><td>output</td><td>指定输出文件名</td></tr><tr><td>-g</td><td>gdb</td><td>生成调试用的符号表</td></tr><tr><td>-Wall</td><td>warning all</td><td>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros.</td></tr><tr><td>-lm</td><td>link math.h</td><td>链接math.h. C++编译器会自动链接, 但C的代码使用了math.h却不启动这个选项很可能出错</td></tr><tr><td>-ansi</td><td>ANSI</td><td>检查代码是否符合ANSI标准 (常与-Wpedantic连用)</td></tr><tr><td>-Wpedantic</td><td>warning pedantic</td><td>Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any -std option used.</td></tr><tr><td>-O1, -O2, -O3</td><td>optimize</td><td>开启速度优化. 开启后编译出的程序比直接编译出的程序快, -O2比-O1快, -O3比-O2快, 但为了避免优化误解代码含义, 在算法比赛中推荐-O2. 当然如果程序十分规范就没有这种担心.</td></tr><tr><td>-DXX</td><td>define XX</td><td>在编译时定义XX符号 (此处XX是随意什么大写单词的意思), 位于#ifdef XX和#endif中间的语句会被编译</td></tr></tbody></table><h3 id="gcc与g"><a href="#gcc与g" class="headerlink" title="gcc与g++"></a>gcc与g++</h3><p><code>gcc</code>到底能不能编译C++程序?</p><p>在某种程度上<code>gcc</code>和<code>g++</code>都可以编译 <strong>.cpp</strong> 后缀的程序, 但是<code>gcc</code>命令不能自动和C++程序使用的库链接. <code>gcc</code>把后缀为 <strong>.c</strong> 的当作是C程序,而<code>g++</code>将其当作C++程序.两者都会将后缀为 <strong>.cpp</strong> 的程序视作C++程序, 要注意虽然C++是C的超集,但是两者对语法的要求是有区别的, C++的语法规则更加严谨一些. 编译阶段, <code>g++</code>会调用<code>gcc</code>,因为<code>gcc</code>命令不能自动链接C＋＋库, 所以通常用<code>g++</code>来完成链接, 统一起见,干脆编译和链接统统用g++了, 这就给人一种错觉, 好像cpp程序只能用g++似的.</p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>💡执行gdb时加选项<code>-q</code> (quiet)可以去掉进入gdb开头的废话.</p><p>常用命令:</p><table><thead><tr><th>命令</th><th>全名</th><th>含义</th></tr></thead><tbody><tr><td>l</td><td>list</td><td>列出十行代码. 但可以通过<code>set listsize</code>来更改显示多少行, 用<code>show listsize</code>能查看listsize. l后可以接行号, 函数名</td></tr><tr><td>r</td><td>run</td><td>开始运行程序</td></tr><tr><td>b</td><td>break</td><td>设置断点, b后接行号或函数名</td></tr><tr><td>c</td><td>continue</td><td>继续运行. 要注意在断点处停下后用c继续而不是r</td></tr><tr><td>n</td><td>next</td><td>下一行</td></tr><tr><td>s</td><td>step</td><td>与n的区别是n会执行完本行语句, 而有函数调用时s会停在函数内</td></tr><tr><td>u</td><td>until</td><td>执行到指定行号或者指定函数的开头</td></tr><tr><td>i</td><td>info</td><td>显示各种信息. 如i b显示所有断点,i disp显示display,而i lo显示所有局部变量</td></tr><tr><td>disp</td><td>display</td><td>把一个表达式设置为display, 当程序每次停下来时都会显示其值</td></tr><tr><td>cl</td><td>clear</td><td>取消断点, 和b的格式相同. 如果该位置有多个断点, 将同时取消</td></tr><tr><td>cond</td><td>condition</td><td>用来设置条件断点</td></tr><tr><td>ig</td><td>ignore</td><td>设置记次断点, count次以前不停止</td></tr><tr><td>wa</td><td>watch point</td><td>watch a(简写为wa a)可以在变量a修改时停下,并显示出修改前后的变量值</td></tr><tr><td>aw</td><td>all watch point</td><td>读写时都停下</td></tr><tr><td>rw</td><td>read watch point</td><td>被读取时停下</td></tr><tr><td>q</td><td>quit</td><td>退出gdb</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.&lt;/p&gt;
&lt;p&gt;经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了… 虽然我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知新, 再次”速成”一下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://leojhonsong.github.io/zh-CN/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Vim使用杂记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/07/10/vim%E4%BD%BF%E7%94%A8%E6%9D%82%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/07/10/vim使用杂记/</id>
    <published>2019-07-10T07:58:14.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>使用vim开发也有半年多啦, 不过配置vim也是个漫长的过程. 记录一下常用快捷键和用法和配置过程.</p><a id="more"></a><p>🌟首先放上我的<a href="https://github.com/LeoJhonSong/vimrc" target="_blank" rel="noopener">vimrc链接</a></p><p>在vim中, 多文件编辑主要涉及三个概念: <strong>窗口</strong>, <strong>标签页</strong>, <strong>缓冲区</strong></p><p>相关参考:</p><p>🔗 <a href="https://harttle.land/2015/11/14/vim-window.html" target="_blank" rel="noopener">Vim 多文件编辑：窗口</a><br>🔗 <a href="https://harttle.land/2015/11/12/vim-tabpage.html" target="_blank" rel="noopener">Vim 多文件编辑：标签页</a><br>🔗 <a href="https://harttle.land/2015/11/17/vim-buffer.html" target="_blank" rel="noopener">Vim 多文件编辑：缓冲区</a></p><p>❗️没有特别说明本文中的代码都是放在 <code>.vimrc</code> 中的.</p><h1 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h1><h2 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h2><p><kbd>Ctrl f</kbd> 下翻一页<br><kbd>Ctrl b</kbd> 上翻一页<br><kbd>Ctrl d</kbd> 下翻半页<br><kbd>Ctrl u</kbd> 上翻半页</p><h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><p>原本展开代码和折叠代码是绑定在了 <code>zo</code> (z open) 和 <code>zc</code> (z close), 不过我重新映射到了空格键, normal模式下按一次展开, 再按一次折叠, 感觉更方便一些.</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;space&gt;</span> @=((<span class="built_in">foldclosed</span>(<span class="built_in">line</span>(<span class="string">'.'</span>)) &lt; <span class="number">0</span>) ? <span class="string">'zc'</span> : <span class="string">'zo'</span>)<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>另外 <code>zn</code> 为全部展开, <code>zN</code> 为全部折叠.</p><h2 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h2><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> spell</span><br><span class="line"><span class="keyword">set</span> spellfile=~/.<span class="keyword">vim</span>/spell/<span class="keyword">en</span>.utf-<span class="number">8</span>.<span class="built_in">add</span></span><br></pre></td></tr></tbody></table></figure><p>按 <code>]s</code> 跳往下一错误拼写, <code>[s</code> 往前跳.</p><p>按 <code>zg</code> 将当前光标所在单词记录到字典 (指出当前word 是 good word), <code>zw</code> 将当前单词从字典删除 (指出当前word为wrong word)</p><p>vim允许同时使用多个字典, 通过输入 <code>:set spellfile+=path/to/dic/en.utf-8.add</code> 来添加, 但要注意这个文件后缀名一定是 <strong>.[encoding].add</strong></p><p>这之后你可以输入 <code>set spellfile?</code> 来查看当前在使用哪些字典, 要将单词添加到第一个字典就按 <code>1zg</code> , 添加到第二个就按 <code>2zg</code> . 很好的一点是spellfile这个变量只在当前缓冲区有效, 即每个文件可以使用不同的spellfile值. 这给保存单词到当前工作区带来了可能. 因此我设置了一个快捷键:</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;C-z&gt;</span> :<span class="keyword">exe</span> <span class="string">"setlocal spellfile+="</span> . <span class="symbol">&lt;C-r&gt;</span>=<span class="built_in">shellescape</span>(<span class="built_in">fnamemodify</span>(<span class="string">"en.utf-8.add"</span>, <span class="string">":p"</span>), <span class="number">1</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样每次按<kbd>Ctrl , z</kbd>就会添加一个当前文件所在文件夹的字典到spellfile</p><h1 id="调整窗口"><a href="#调整窗口" class="headerlink" title="调整窗口"></a>调整窗口</h1><p>💡 <kbd>Ctrl w</kbd> 开头的都是与窗口有关的快捷键, w指window</p><h2 id="在窗口间移动"><a href="#在窗口间移动" class="headerlink" title="在窗口间移动"></a>在窗口间移动</h2><p><kbd>Ctrl w</kbd> 接 hjkl上下左右在各窗口间移动光标<br><kbd>Ctrl w t</kbd> 移动光标至最左上窗口<br><kbd>Ctrl w b</kbd> 移动光标至最右下窗口</p><h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>宽度调整:</p><p><kbd>Ctrl w [n] &gt;</kbd> 右移边界<br><kbd>Ctrl w [n] &lt;</kbd> 左移边界</p><p>💡默认增减1个字符宽度, 可以在Ctrl w和+/-间加数字来指定增减宽度. 不是最右边的窗口调整的是右边界, 最右边的窗口调整的是左边界.</p><p>高度调整:</p><p><kbd>Ctrl w [n] +</kbd> 增加高度<br><kbd>Ctrl w [n] -</kbd> 减小高度</p><p>通过设置以下几个键映射我可以十分方便地调整窗口大小</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F2&gt;</span> <span class="symbol">&lt;C-w&gt;</span>+</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F3&gt;</span> <span class="symbol">&lt;C-w&gt;</span>-</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F4&gt;</span> <span class="symbol">&lt;C-w&gt;</span>&lt;</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F5&gt;</span> <span class="symbol">&lt;C-w&gt;</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="调整位置"><a href="#调整位置" class="headerlink" title="调整位置"></a>调整位置</h2><p><kbd>Ctrl w</kbd> 接HJKL移动窗口至最上下左右并且宽度或高度为最大.<kbd>Ctrl w r</kbd> 顺时针移动窗口<br><kbd>Ctrl w R</kbd> 逆时针移动窗口</p><h1 id="键映射"><a href="#键映射" class="headerlink" title="键映射"></a>键映射</h1><p>vim是能够进行高度个性化的编辑器, 因此每个人肯定都会添加一些自己顺手的快捷键, 因为我是从VSCode转来vim的, 因此我的快捷键设置一定程度上参考了VSC的快捷键设置. 用以在 <strong>.vimrc</strong> 中设定快捷键的命令有好几个, 我的vimrc里比较常用的是 <code>nnoremap</code> 和 <code>map</code> . 以下是我常用的命令及其含义.</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>:noremap</td><td>nonrecursive map, 不可递归的映射</td></tr><tr><td>:nnoremap</td><td>normal nonrecursive map, 只在normal模式有效的noremap</td></tr><tr><td>:inoremap</td><td>insert nonrecursive map, 只在insert模式有效的noremap</td></tr><tr><td>:vnoremap</td><td>visual nonrecursive map, 只在visual模式有效的noremap</td></tr><tr><td>:map</td><td>可递归的映射</td></tr><tr><td>:nmap</td><td>normal map, 只在normal模式有效的map</td></tr></tbody></table><p>以下是各种映射命令对应有效的模式. 具体解释可以在vim里用 <code>:help</code> 命令查看.</p><p>💡顺带一提是可以把<a href="https://www.liuhaolin.com/vim/272.html" target="_blank" rel="noopener">vim的帮助文档设为中文</a>的</p><table><thead><tr><th>命令</th><th>模式</th></tr></thead><tbody><tr><td>:map   :noremap  :unmap</td><td>Normal, Visual, Select, Operator-pending</td></tr><tr><td>:nmap  :nnoremap :nunmap</td><td>Normal</td></tr><tr><td>:vmap  :vnoremap :vunmap</td><td>Visual and Select</td></tr><tr><td>:smap  :snoremap :sunmap</td><td>Select</td></tr><tr><td>:xmap  :xnoremap :xunmap</td><td>Visual</td></tr><tr><td>:omap  :onoremap :ounmap</td><td>Operator-pending</td></tr><tr><td>:map!  :noremap! :unmap!</td><td>Insert and Command-line</td></tr><tr><td>:imap  :inoremap :iunmap</td><td>Insert</td></tr><tr><td>:lmap  :lnoremap :lunmap</td><td>Insert, Command-line, Lang-Arg</td></tr><tr><td>:cmap  :cnoremap :cunmap</td><td>Command-line</td></tr><tr><td>:tmap  :tnoremap :tunmap</td><td>Terminal-Job</td></tr></tbody></table><p>💡 关于应当避免使用 <code>map</code> 的具体原因可以参考<a href="http://learnvimscriptthehardway.stevelosh.com/chapters/05.html#nonrecursive-mapping" target="_blank" rel="noopener">这里</a></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h2><p>我用<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug</a>来管理我的vim插件, 使用很简单, 写法可以参照我的vimrc. 每次要下载插件时在vim中输入 <code>:PlugInstall</code> 即可. 超好用😆</p><h2 id="NERDtree"><a href="#NERDtree" class="headerlink" title="NERDtree"></a>NERDtree</h2><p>NERDtree是一个不错的文件资源管理器, 体验和VSC的explorer差不多. 觉得每次输<code>:NERDTreeToggle</code> 太麻烦的话可以键绑定一下:</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;C-e&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>我绑定到了<kbd>Ctrl , e</kbd>, 和本来想绑的VSC里的<kbd>Ctrl shift e</kbd>不同. 因为在终端中<kbd>Ctrlshift 字母</kbd>和<kbd>Ctrl 字母</kbd>的输出没有区别.</p><p>以下是几个我比较常用的NREDtree命令</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>C</td><td>切换NERDtree根目录到光标所在文件夹</td></tr><tr><td>R</td><td>刷新根目录</td></tr><tr><td>r</td><td>刷新光标所在目录</td></tr><tr><td>s</td><td>水平分屏打开</td></tr><tr><td>i</td><td>竖直分屏打开</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用vim开发也有半年多啦, 不过配置vim也是个漫长的过程. 记录一下常用快捷键和用法和配置过程.&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://leojhonsong.github.io/zh-CN/categories/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的小技巧</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/07/03/Python%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/07/03/Python中的小技巧/</id>
    <published>2019-07-03T14:23:43.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>俺也记不住语法, 在这里记录一下常见语句.</p><a id="more"></a><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查看自带的帮助文档"><a href="#查看自带的帮助文档" class="headerlink" title="查看自带的帮助文档"></a>查看自带的帮助文档</h2><p>用<code>help()</code>函数, 以<code>q</code>退出.</p><p>❗️ 使用help(module_name)时首先需要import该模块</p><h2 id="查看当前python解释器路径"><a href="#查看当前python解释器路径" class="headerlink" title="查看当前python解释器路径"></a>查看当前python解释器路径</h2><p>有时候写程序会发现莫名其妙的bug比如找不到某库, 路径不对等, 可能是因为用错了解释器. 用下面语句可以查看当前解释器的路径:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.executable</span><br></pre></td></tr></tbody></table></figure><h2 id="在python解释器里清屏"><a href="#在python解释器里清屏" class="headerlink" title="在python解释器里清屏"></a>在python解释器里清屏</h2><p>搜了一下python里似乎没有很简短的清屏命令, 要用命令只能用类似以下这种:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">a = os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure><p>💡 这是在Linux下清屏的命令, 在Windows要用<code>os.system('cls')</code></p><p>💡 将这条命令赋值给一个变量是为了窗口顶部不出现一个0. 你可以单独输入<code>os.system('clear')</code>试试</p><p>但如果你是在<strong>Bash</strong>中打开的python可以用 <code>Ctrl + L</code>, 这是Bash的清屏快捷键.</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="生成等差数列"><a href="#生成等差数列" class="headerlink" title="生成等差数列"></a>生成等差数列</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(begin, end, step))</span><br></pre></td></tr></tbody></table></figure><h2 id="生成任意指定列表"><a href="#生成任意指定列表" class="headerlink" title="生成任意指定列表"></a>生成任意指定列表</h2><h3 id="利用列表推导式"><a href="#利用列表推导式" class="headerlink" title="利用列表推导式"></a>利用列表推导式</h3><p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性. <strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3中都有支持:</p><ul><li>列表(list)推导式</li><li>字典(dict)推导式</li><li>集合(set)推导式</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure><p>e.g.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><h3 id="利用lambda函数"><a href="#利用lambda函数" class="headerlink" title="利用lambda函数"></a>利用lambda函数</h3><p>lambda函数在python, C++, Java等语言中都有, 我理解的作用主要有三:</p><ul><li>少写几个字</li><li>能将一个”函数”以参数的形式传入另一个函数, ❗️注意此处普通函数能被传递并不是什么稀罕事, 更重要的是类似<a href="https://www.zhihu.com/question/20125256/answer/29733906" target="_blank" rel="noopener">这里</a>提到的”伪函数”</li><li>避免污染命名空间, 需要一个函数但不知道命什么名时用lambda函数</li></ul><p>lambda函数主要用在filter(), map(), reduce()中</p><p>💡 在python3中<code>reduce()</code>从内建函数中移除了, 被移到了functools模块中</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = [<span class="number">2</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">22</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, foo)</span><br><span class="line">[<span class="number">18</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">27</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x * <span class="number">2</span> + <span class="number">10</span>, foo)</span><br><span class="line">[<span class="number">14</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">54</span>, <span class="number">44</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">64</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> reduce(<span class="keyword">lambda</span> x, y: x + y, foo)</span><br><span class="line"><span class="number">139</span></span><br></pre></td></tr></tbody></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="由列表生成字典"><a href="#由列表生成字典" class="headerlink" title="由列表生成字典"></a>由列表生成字典</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">c = dict(zip(a, b))</span><br></pre></td></tr></tbody></table></figure><h2 id="对字典按值排序"><a href="#对字典按值排序" class="headerlink" title="对字典按值排序"></a>对字典按值排序</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = {<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>: <span class="number">5</span>, <span class="string">'d'</span>:<span class="number">4</span>, <span class="string">'e'</span>:<span class="number">3</span>}</span><br><span class="line"></span><br><span class="line">sorted(d.items(), key=<span class="keyword">lambda</span> i: i[<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><blockquote><p>sorted(iterable, /, *, key=None, reverse=False)</p><p>Return a new list containing all items from the iterable in ascending order.</p><p>A custom key function can be supplied to customize the sort order, and thereverse flag can be set to request the result in descending order.</p></blockquote><p>即<code>iterable</code>处放一个可迭代的对象, <code>key</code>处放自定义函数来选取比较的参数, <code>reverse</code>处设定是否反向</p><p><code>d.items()</code>返回可遍历的(键, 值) 元组数组, <code>key=lambda i: i[1]</code>即此处参与比较的参数是d的值</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俺也记不住语法, 在这里记录一下常见语句.&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Python" scheme="https://leojhonsong.github.io/zh-CN/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>有关人工智能的一点思考</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/06/21/%E6%9C%89%E5%85%B3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/06/21/有关人工智能的一点思考/</id>
    <published>2019-06-21T14:47:27.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>以下为个人看法, 可能有误</p><a id="more"></a><p>突然思考了一下<strong>什么是人工智能?</strong></p><blockquote><p>从学科角度讲, 人工智能是一门研究 <strong>模拟, 延伸, 扩展人类智能</strong> 的学科</p></blockquote><blockquote><p>人工智能是在机器上实现的人类智能</p></blockquote><p>这两条是我比较认可的对人工智能的描述. 可以看出<code>人工智能</code>是相对于<code>人类智能</code>的一个概念, 理解起来既简单又困难. 要说简单, 人工智能可以很直观的理解为<strong>人为制造的人类智能</strong>, 要说难, 人们至今仍在探索<strong>什么是人类智能</strong>. 这是一个极其抽象的哲学概念.实际上试图制造人工智能正是人们探索人类智能的途径之一: 能知道如何制造出一个智能了, 我们也就基本摸清什么是人类智能了.</p><p>目前人工智能的实现有三种研究方法:</p><ul><li><strong>功能模拟</strong>: 符号主义, 认为人工智能源自数理逻辑, 以及人类智能的基本单元是符号, 认知的过程是符号表示下符号运算的过程.</li><li><strong>结构模拟</strong>: 连接主义, 认为人工智能源自仿生学, 特别是人脑模型的研究, 主要模拟神经元生理机制.</li><li><strong>行为模拟</strong>: 控制论主义, 认为人工智能源自控制论, 原理是控制论及激励-响应控制系统.</li></ul><p>回顾了一番后我终于理清了之前一直不太懂的 <strong>人工智能, 机器学习, 深度学习的关系</strong>:</p><p><code>人工智能</code>是人们提出的一个理想化的概念, 在得出人类智能的定义前谁也没法说出到底什么是人工智能, 到底某机器是否具备人工智能. <code>机器学习</code>是人们以制造人工智能为目标造出的各种具有部分智能的东西, 而<code>深度学习</code>是其中从仿生角度出发的研究.</p><p>💡很有意思的是智能另有一个含义: <strong>能对环境作出反馈</strong>. 比如智能材料, 狭义的智能机器人等.</p><p>这次思考总结后我认为图灵测试并不能<strong>绝对</strong>判定一个东西是否具有人类智能.</p><p>一方面<strong>中文房间</strong>实验是很有力的反驳. 也许有人认为这个实验所假设的完美的指导书是不存在的, 是理想化的, 但实际上图灵测试也是这样的东西, 能够完美检测被测试者是否具有智能的测试是不存在的. 我们只需要足够大的”指导书”就能够应付图灵测试. 参考无穷大的数学定义: <strong>假设我们以M来衡量一个图灵测试的测试范围, 对任意给定M测试范围的图灵测试, 我们总能写出这样的”指导书”X: X让机器在当前图灵测试内表现得像一个人</strong>.</p><p>另一方面是因为我认为人们目前对人类智能的认知是不够的. 打个比方: 牛顿得出三条牛顿定律, 被人们奉为铁律, 后来相对论推翻了它, 牛顿定律变为了只在低速情况下适用. 但相对论又是绝对正确的吗? 目前它还没被推翻. 而我们对智能的判别甚至还停留在以经验来判断的阶段. (这里又存在一个哲学问题了: 存在绝对的真理吗? 这里我们暂且不讨论.) 也许我们可以说图灵测试在当前对人类智能的认知水平下可以作为是否具有智能的标准, 但它是那样的简陋, 早晚是要被取代的.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下为个人看法, 可能有误&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器人案例学习</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/06/09/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/06/09/机器人案例学习/</id>
    <published>2019-06-09T18:03:33.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>正如我在 <a href="https://leojhonsong.github.io/zh-CN/about/">about</a> 中提到的, <strong>我立志为软体机器人领域贡献一份力</strong>, 那就先从积累开始吧. 在此记录我觉得很精妙的机器人,或可以用于机器人的”东西”, 参考学习💪</p><a id="more"></a><p>TODO</p><h1 id="Cassie家族"><a href="#Cassie家族" class="headerlink" title="Cassie家族"></a>Cassie家族</h1><h1 id="BDC家族"><a href="#BDC家族" class="headerlink" title="BDC家族"></a>BDC家族</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如我在 &lt;a href=&quot;https://leojhonsong.github.io/zh-CN/about/&quot;&gt;about&lt;/a&gt; 中提到的, &lt;strong&gt;我立志为软体机器人领域贡献一份力&lt;/strong&gt;, 那就先从积累开始吧. 在此记录我觉得很精妙的机器人,
或可以用于机器人的”东西”, 参考学习💪&lt;/p&gt;
    
    </summary>
    
    
      <category term="Robotics" scheme="https://leojhonsong.github.io/zh-CN/categories/Robotics/"/>
    
    
  </entry>
  
  <entry>
    <title>当我安利软体机器人时我在谈什么</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/06/09/%E5%BD%93%E6%88%91%E5%AE%89%E5%88%A9%E8%BD%AF%E4%BD%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%97%B6%E6%88%91%E5%9C%A8%E8%B0%88%E4%BB%80%E4%B9%88/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/06/09/当我安利软体机器人时我在谈什么/</id>
    <published>2019-06-09T18:02:47.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>从小我就喜欢仿生机器人. 我敬畏着各种精妙的仿生设计和它们的设计者, 渴望着有朝一日我也能参与这样的工作. 当我看到波士顿动力的Atlas的仿生腿部结构时, 我就在想: 我们能不能造出人造人呢? 那时的我并没有想很多, 并不会去想这样浩大的工程的性价比, 并没有意识到背后的伦理问题, 只是出于一种探索, 好奇. 我也曾听到一句很有趣的话:</p><blockquote><p>“在一项技术成熟前不要谈论他的价值”</p></blockquote><p>法拉第在回答一位贵族夫人对发电机的用处的质疑时就反问到: “婴儿能做什么呢?”. 最近很火的<a href="https://www.bilibili.com/video/av54737593?from=search&amp;seid=16639379942704237214" target="_blank" rel="noopener">何同学对5G的看法</a>也发人深省. 在他提醒后我才想起注意到有许多技术 (比如有款机器人的无线控制对传输速度要求很高, 4G无法满足)依赖于5G. 5G必将给我们的生活带来现在的我们无法想象的改变.</p><p>而<strong>软体机器人</strong>也必然是这样值得我们期待的技术.</p><a id="more"></a><p>我接触到的第一个软体机器人是<a href="https://journals.sagepub.com/doi/full/10.1177/1553350617745953" target="_blank" rel="noopener">一个集成在da Vinci内窥镜操作臂上的手术系统</a>. 它的灵活, 精准震撼了我.</p><!-- TODO --><p>📺 <a href="https://youtu.be/AI7M-JTC6_w" target="_blank" rel="noopener">这个视频</a><strong>感性地</strong>介绍了一些软体机器人能解决的需求, 实际应用, 研究方向.</p><!-- TODO --><blockquote><p>刚体机器人基本由电机控制, 需要精准控制, 对这些刚性机器人的运用倾向于<strong>专业化与精确化</strong>, 它们很难表现出<strong>高度可变形能力与对复杂环境的适应性</strong>. 随着机器人运用领域继续扩大, 医疗保健、复杂地形勘探等特殊领域对机器人提出了更加严苛的要求.</p></blockquote><p>🔗 <a href="https://zhuanlan.zhihu.com/p/30700859" target="_blank" rel="noopener">这篇文章</a>源自文力老师的报告, 讲到了软体机器人的定义, 发展历程, 发展趋势分析, 也有文老师举例从产生灵感到实现一个软体机器人的简述.</p><blockquote><p>所以从2011年到2017年, 这七年的时间内, 软体机器人从单一的材料过渡到了多材料, 再到了智能材料, 最后有可能到生物材料, 这是一个发展的趋势. 所以从这个趋势结合起来讲，未来的发展方向一定是它<strong>结合驱动、传感、变刚度、多功能的复合材料, 以及添加软体机器人的控制方法</strong>. 目前控制方法这一块是比较欠缺的, 这是一个学术或者是创新方面的一个主要的发展趋势.</p></blockquote><p>(此处有个值得一提的概念: <strong>智能</strong>. 我目前的理解是: <strong>能与环境交互, 作出反馈</strong>)</p><p>目前主要的应用方向有:</p><ol><li>抓持作业</li><li>医疗康复 (比如康复训练或助力)</li><li>复杂环境勘探</li><li>微创外科手术</li></ol><p>当然我相信随着探究会逐渐发现更多的, 令人震惊的应用前景.</p><p>而软体机器人崛起的同时刚体机器人并不会退出舞台, 在工业等机器人提供主要生产力的环境它们是无可替代的, 软体机器人目前还无法输出很大的力矩, 并且我认为他们不必具备这种能力, 软体机器人和刚体机器人是<strong>互补的</strong>而非哪个一定更优于哪个.</p><p>这太酷了!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从小我就喜欢仿生机器人. 我敬畏着各种精妙的仿生设计和它们的设计者, 渴望着有朝一日我也能参与这样的工作. 当我看到波士顿动力的Atlas的仿生腿部结构时, 我就在想: 我们能不能造出人造人呢? 那时的我并没有想很多, 并不会去想这样浩大的工程的性价比, 并没有意识到背后的伦理问题, 只是出于一种探索, 好奇. 我也曾听到一句很有趣的话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“在一项技术成熟前不要谈论他的价值”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;法拉第在回答一位贵族夫人对发电机的用处的质疑时就反问到: “婴儿能做什么呢?”. 最近很火的&lt;a href=&quot;https://www.bilibili.com/video/av54737593?from=search&amp;amp;seid=16639379942704237214&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;何同学对5G的看法&lt;/a&gt;
也发人深省. 在他提醒后我才想起注意到有许多技术 (比如有款机器人的无线控制对传输速度要求很高, 4G无法满足)依赖于5G. 5G必将给我们的生活带来现在的我们无法想象的改变.&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;软体机器人&lt;/strong&gt;也必然是这样值得我们期待的技术.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Robotics" scheme="https://leojhonsong.github.io/zh-CN/categories/Robotics/"/>
    
      <category term="Soft Robotics" scheme="https://leojhonsong.github.io/zh-CN/categories/Robotics/Soft-Robotics/"/>
    
    
  </entry>
  
  <entry>
    <title>有关字符集与编码</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/05/29/%E6%9C%89%E5%85%B3%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/05/29/有关字符集与编码/</id>
    <published>2019-05-29T10:24:23.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>当我在解决<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81">Linux下解压zip文件的问题</a>时发现编码方面的问题还蛮多的, 在此记录.</p><a id="more"></a><h1 id="Windows下编码方式的坑"><a href="#Windows下编码方式的坑" class="headerlink" title="Windows下编码方式的坑"></a>Windows下编码方式的坑</h1><p>🔗 <a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">知乎-Windows记事本的ANSI, Unicode, UTF-8这三种编码模式有什么区别？</a></p><p>🔗 <a href="https://www.zhihu.com/question/20167122" target="_blank" rel="noopener">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个</a></p><ul><li>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码</li><li>所谓的「Unicode」指的是带有 BOM 的小端序 UTF-16</li><li>所谓的「UTF-8」指的是带 BOM 的 UTF-8</li></ul><p>之前一直听说Windows自带的记事本不要用, 会自动在文件开头加一个东西, 导致一些地方显示该文件开头有一个 “?” , 一直不知道是多了个啥, 原来是UTF-8/UTF-16编码的文件会在文件开头多一个BOM. <strong>UTF-8与带BOM的UTF-8的区别在于带BOM的UTF-8文件开头有U+FEFF.</strong> 微软使用带BOM的UTF-8的目的是将UTF-8与ASCII等编码方式区分开, 但这就导致了在很多时候UTF-8默认是不带BOM时文件读取有误.</p><h1 id="GBK不是一种编码格式"><a href="#GBK不是一种编码格式" class="headerlink" title="GBK不是一种编码格式"></a>GBK不是一种编码格式</h1><p>GBK并不是一种编码格式, 而是一个字符集. 我觉得很low的是GBK的全称是 <strong>Guojia BiaozhunKuozhan</strong> 🤦‍…low得不要不要的. 不过也可以理解, 毕竟这三个字母是从”国标”的首拼发展来的.</p><h2 id="自整理的中文字符集发展史"><a href="#自整理的中文字符集发展史" class="headerlink" title="自整理的中文字符集发展史"></a>自整理的中文字符集发展史</h2><p>以下是我整理的中文字符集发展史:</p><ul><li>最开始中国国家标准化管理委员会发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D79E19D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB/T2312-1980</code></a> (<strong>GB</strong>为<strong>国标</strong>首拼, <strong>T</strong>是<strong>推</strong>, 指推广,非强制性的标准), 包括了<strong>6763</strong>个常用汉字, 发布以后许多有汉字的语言也采用了这个字符集. 但这个字符集很不够, 缺少很多生僻字, 繁体字, 对日本, 韩国汉字收录也很不全.</li><li>微软根据GB2312做出了<code>cp936</code> (code page936), 字符集方案为GB2312, 编码方案为<strong>EUC-CN</strong>.</li><li>1993年<strong>Unicode1.1</strong>发布后国标委抄过来发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D7860AD3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 13000.1-1993</code></a>.</li><li>这时微软利用<strong>cp936</strong>中收录GB2312-1980后未使用完的码位收录了GB13000.1-1993的全部字符,这样既兼容了GB2312又添加了许多字符. 这个新版本cp936最早实现于<strong>Windows95简体中文版</strong>.这之后微软又陆陆续续给cp936加了几个字符. 直到2002年<a href="https://www.iana.org/assignments/charset-reg/GBK" target="_blank" rel="noopener">IANA将cp936的字符集注册为<code>GBK</code></a>. GBK共收录<strong>21886</strong>个汉字和图形符号.</li><li>再后来因为字符还是不全 (比如emoji什么的)以及其他原因发布了<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D79585D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 18030-2000</code></a>, 在Windows的对应代码页为<code>cp54936</code>. 但值得一提的是尽管2000年就有了新标准, 但Windows系统的系统语言为简体中文时的默认代码页仍为<strong>cp936</strong>. 原因可以参考<a href="https://linux.cn/article-1213-1.html" target="_blank" rel="noopener">这里</a>. 文章大意: 微软划水, 国家也没上心.</li><li>最近的一版标准字符集是<a href="http://www.std.gov.cn/gb/search/gbDetailed?id=71F772D800B5D3A7E05397BE0A0AB82A" target="_blank" rel="noopener"><code>GB 18030-2005</code></a>. 但这个好像有点复杂, 我并没有太看懂, 反正和之前的几个标准很不同. 怎么个不一样可以参考<a href="https://zhuanlan.zhihu.com/p/31643128" target="_blank" rel="noopener">这里</a>.</li></ul><h1 id="Unicode与UTF-8是不同层面的东西"><a href="#Unicode与UTF-8是不同层面的东西" class="headerlink" title="Unicode与UTF-8是不同层面的东西"></a>Unicode与UTF-8是不同层面的东西</h1><p>我曾经以为Unicode是一种编码格式, 就像UTF-8是一种编码格式, 但后来我发现这两者根本是不同层面上的东西.</p><h2 id="Unicode与UCS"><a href="#Unicode与UCS" class="headerlink" title="Unicode与UCS"></a>Unicode与UCS</h2><h3 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h3><p>与<strong>Unicode</strong> (统一码) 同一层面的概念是<strong>UCS</strong> (Universal Character Set, 通用字符集).UCS和Unicode分别由<strong>ISO</strong> (国际标准化组织) 和<strong>一帮软件制造商</strong> (Xerox, 苹果等成立了个统一码联盟) 先后发起. 后来他们才合并工作. 实际上两者是差不多的玩意. 我并不相信统一码联盟在成立时不知道ISO已经在开发UCS了(UCS项目启动比Unicode早<strong>4年</strong>), 而在这样的情况下还要开发Unicode, 个人认为是商业原因.直到现在这仍然是两个独立的项目, 但项目进度同步且两个组织都宣称要和对方<strong>保持兼容</strong>. 个人觉得很蠢🤷‍</p><h3 id="两者差异"><a href="#两者差异" class="headerlink" title="两者差异"></a>两者差异</h3><p>硬要说的话其实Unicode与UCS有一些细节不同.</p><p>比如ISO/IEC 10646-1使用四种不同风格的变体来显示简体中文, 繁体中文, 日语, 韩语汉字, 但Unicode2.0中只有简体中文的变体. 因此有过日本人无法接受Unicode的说法. (现在应该是没这问题了)</p><p>应该还有小区别吧? 其他区别我不知道, 也懒得找了😁</p><h2 id="现代编码模型"><a href="#现代编码模型" class="headerlink" title="现代编码模型"></a>现代编码模型</h2><p>Unicode是一套有些复杂的编码系统, 并不是单纯一个字符集方案或是一个编码方案, 而是构建出了一个<strong>现代编码模型</strong>. (这段话对UCS同理)</p><p>这个模型分五层:</p><ul><li>抽象字符集(Abstract character repertoire)</li><li>编码字符集(Coded Character Set)</li><li>字符编码方式(Character Encoding Form)</li><li>字符编码方案(Character Encoding Scheme)</li><li>传输编码语法(Transfer Encoding Syntax)</li></ul><p>按我的理解: 抽象字符集是一个抽象字符的<strong>集合</strong>, 不关注字形, 更关注字意. 比如钟和鐘的抽象字符是同一个, 而编码字符集是一个<strong>映射</strong>, 规定把一个抽象字符映射到哪个<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84#%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">字符平面</a>, 哪个<strong>码点</strong>. 但这并不是一一映射, 为了兼容或者有的字 (比如CJK字) 可能有多个变体. 字符编码方式又称为”storage format”, 我猜这是因为这一层<strong>将码点编码成码元</strong>(这里的编码方式就是<strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat,包括UTF-8, UTF-16, UTF-32等方法), 而码元正是每次从文件中读取到的字符的格式.</p><p>Unicode编码模型详细阐述可以参考<a href="https://zhuanlan.zhihu.com/p/27026033" target="_blank" rel="noopener">这里</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我在解决&lt;a href=&quot;https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81&quot;&gt;Linux下解压zip文件的问题&lt;/a&gt;时发现编码方面的问题还蛮多的, 在此记录.&lt;/p&gt;
    
    </summary>
    
    
      <category term="编码" scheme="https://leojhonsong.github.io/zh-CN/categories/%E7%BC%96%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Verilog杂记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/05/21/Verilog%E6%9D%82%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/05/21/Verilog杂记/</id>
    <published>2019-05-21T15:15:54.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<p>Verilog学习笔记.</p><p>这学期上了数字电路课, 从最开始的了解每个逻辑门的物理工作原理到学习每个组合电路, 时序电路元件是如何由逻辑门构成的, 再到后来跟着指导书设计出了很简易的8位CPU, 我个人是觉得很震撼的. 这也让我小时候的一个问题得到了解答: 集成电路这么复杂的东西真的是人能设计出来的吗? 其实我一直是知道答案的,这些小黑块既不可能是土里长出来的也不可能是从什么动物身上割下来的. 我只是一直不敢想象这么复杂而精妙的东西 (即便是一根充电线里的小巧电路也不是那时的我能弄清的). 最近我稍微体会到了那群伟大的工程师们是如何设计出了那样精密的芯片的: 不断积累基本模块. 实际上从最开始的黑底白字的电脑系统到现在繁华多样的炫酷系统, 也是很令人震撼的变化. 虽然大佬可能会觉得这些很简单, 但我仍认为该对这些技术保持敬畏之心.</p><a id="more"></a><h1 id="Quartus与Modelsim的安装"><a href="#Quartus与Modelsim的安装" class="headerlink" title="Quartus与Modelsim的安装"></a>Quartus与Modelsim的安装</h1><p>🔗 <a href="https://blog.csdn.net/weixin_38071135/article/details/82531594" target="_blank" rel="noopener">quartus16.1和modelsim-altera for linux的安装</a><br>🔗 <a href="https://coldnew.github.io/ce6f7a0a/" target="_blank" rel="noopener">DE2-115 開發紀錄: 在 Linux 下使用 ModelSim</a></p><p>参考上面两个链接 (后者算是对前者的补充)我成功在Ubuntu1804下安装了Quartus和Modelsim. 因为我懒得注册论坛帐号, 我并没有使用第一个链接中提供的破解文件, 而是使用了<a href="https://tsuhuai.wordpress.com/2015/02/17/altera-quartus-crack-for-linux-version/" target="_blank" rel="noopener">这里</a>提供的15.0版的crack. 我装的也是15.0版的Quartus和Modelsim, 但问题和解决方法是一样的.</p><p>⭐️后来我发现Linux下用<a href="http://www.geda-project.org/" target="_blank" rel="noopener">gEDA</a>这个项目应该体验也很不错.其中用<strong>icarus</strong>综合, 编译verilog代码, 用<strong>gscheme</strong>生成原理图, 用<strong>gtkwave</strong>看仿真波形图.</p><h1 id="verilog开发流程"><a href="#verilog开发流程" class="headerlink" title="verilog开发流程"></a>verilog开发流程</h1><p>🔗<a href="https://copyfuture.com/blogs-details/83fc5f52af0e6c318e3c5cfa5baf2ac0" target="_blank" rel="noopener">Verilog代码和FPGA硬件的映射关系</a> 这里通过一个例子清晰的展示了Verilog代码是怎样一步步映射到FPGA的基本逻辑单元的👍</p><h2 id="编写代码实现功能"><a href="#编写代码实现功能" class="headerlink" title="编写代码实现功能"></a>编写代码实现功能</h2><h2 id="验证功能-仿真"><a href="#验证功能-仿真" class="headerlink" title="验证功能(仿真)"></a>验证功能(仿真)</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><p>综合是把RTL级别的, 抽象层次较高的硬件代码综合成抽象层次较低的电路网表, 是一个具体优化+映射的过程,能够对应到门级逻辑.</p><h3 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h3><p>把综合后的具体数字逻辑映射到指定型号的FPGA器件中去, 包括选择哪一些基本逻辑单元 (主要包含LUT和寄存器单元) 以及布局布线等.</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载是将整个编译过程完成的可下载二进制信息通过下载线从计算机端传递到FPGA开发板端, 并完成FPGA内部电路的具体配置(LUT中的存储信息以及连接线的连接开关设置等等), 形成具有相应功能的功能电路.</p><h1 id="代码风格与语法纪要"><a href="#代码风格与语法纪要" class="headerlink" title="代码风格与语法纪要"></a>代码风格与语法纪要</h1><h2 id="有关模块"><a href="#有关模块" class="headerlink" title="有关模块"></a>有关模块</h2><p>🔗 <a href="http://jason0214.lofter.com/post/30cbe4_12a8f72" target="_blank" rel="noopener">关于Verilog的模块思想和模块的引用</a></p><blockquote><p>Verilog的开发应是<strong>自顶向下</strong>的，<strong>模块化</strong>的.</p></blockquote><p>一个系统由总设计师先进行系统描述(Spec), 将系统划分为若干模块, 编写模块模型(一般为行为级), 仿真验证后, 再把这些模块分配给下一层的设计师, 由他们完成模块的具体设计, 而总设计师负责各模块的接口定义.</p><blockquote><p>链接引用模块端口时, 注意括号内的是当前模块的端口, 括号外的是引用模块的端口.</p></blockquote><p>❗️一开始我看到Verilog中模块就像面向对象中的类一样, 调用模块也神似类的实例化, 曾以为其中有面向对象的思想, 后来发现我太想当然了: 面向对象的三大特征 (封装, 继承, 多态) 它只满足了封装, 显然不能算面向对象. 硬要说的话verilog包含了<strong>面向对象</strong>的思想, 而面向过程的程序设计方法正是:“自顶向下, 逐步求精”. 当然, <strong>要时刻牢记Verilog是一门硬件语言</strong>.</p><p>一个模块可以采用以下方式描述设计:</p><ul><li>数据流方式</li><li>行为方式</li><li>结构方式</li><li>混合</li></ul><h2 id="有关always"><a href="#有关always" class="headerlink" title="有关always"></a>有关always</h2><p><code>always</code>实际上就是循环关键字, 而<code>always @()</code>则是条件循环关键字.</p><p>always块的讲究很多:</p><ol><li><p>写在括号内的称<strong>敏感事件列表</strong>, 当这些事件 (电平信号变化或者出现边沿信号) 发生时触发这个块. 一个敏感事件列表中不能同时包含电平敏感事件和边沿敏感事件. <strong>电平敏感事件意味着这是一个描述组合逻辑的always块</strong> (我们也可以在描述组合逻辑的always块的敏感事件列表中填<code>*</code>来让综合器根据always块内容来自动添加敏感事件), <strong>边沿敏感事件意味着这是一个描述时序逻辑的always块</strong>.</p></li><li><p><strong>尽量只使用主时钟 (clk, rst) 作为always块的边沿敏感事件</strong>, 避免出错. 如果有其他信号边沿触发的事件可以通过<a href="https://blog.csdn.net/phenixyf/article/details/46364193" target="_blank" rel="noopener">这里</a>提到的clk周期延时法将边沿触发转换为电平触发.</p></li><li><p><strong>不要将同一信号的上升沿敏感事件和下降沿包含在同一敏感事件列表</strong>, 因为它们可以合为一个电平敏感事件.</p></li><li><p><strong>尽量不要在多个always块中给同一变量赋值</strong>, 这样容易产生竞争冒险 (所有always块同时运行),且无法综合. 如果一个变量的值与两个always块都有关且这两个always块无法合并, 可以参考<a href="https://blog.csdn.net/gududeyhc/article/details/8795202" target="_blank" rel="noopener">这种方法</a>. 另外也可以考虑用两个always块的敏感事件生成一组新的敏感事件 (参考第二条).</p></li><li><p><strong>一个always块中不能混用阻塞赋值 (=) 和非阻塞赋值 (&lt;=)</strong>, 在描述组合逻辑的always块中使用<code>=</code>, 在描述时序逻辑的always块中使用<code>&lt;=</code>.</p></li><li><p><strong>always块中的条件语句要与敏感事件相对应.</strong> 比如以下两段代码前者是错误的, 后者是正确的.</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rst)</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!rst)</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="关于default"><a href="#关于default" class="headerlink" title="关于default"></a>关于default</h2><p>在写case块时发现所有示例里都写出了default这种情况, 无论情况是否完备. 这让我有了两个问题:</p><ul><li>为什么一定要有default这种情况?</li><li>default情况该给变量赋什么值?</li></ul><h3 id="为什么一定要有default这种情况"><a href="#为什么一定要有default这种情况" class="headerlink" title="为什么一定要有default这种情况"></a>为什么一定要有default这种情况</h3><p>一些参考资料:</p><p>🔗<a href="https://blog.csdn.net/wordwarwordwar/article/details/80299636" target="_blank" rel="noopener">FPGA 和ASIC开发的区别</a></p><p>🔗<a href="https://www.eetoday.com/application/control/201806/1537.html" target="_blank" rel="noopener">当ASIC和FPGA之间的界限日益模糊，FPGA跟ASIC还有啥区别</a></p><p>🔗<a href="https://www.zhihu.com/question/20555065/answer/20357525" target="_blank" rel="noopener">知乎-请问：FPGA,PLD,CPLD,PLC,DSP什么区别？看他们的定义觉着都是可编程的逻辑器件</a></p><p>🔗<a href="https://forums.xilinx.com/t5/%E7%BB%BC%E5%90%88%E8%AE%A8%E8%AE%BA/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%AF%9B%E5%88%BA%E7%8E%B0%E8%B1%A1/td-p/295029" target="_blank" rel="noopener">组合逻辑设计中的毛刺现象</a></p><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">🔗</span><a href="https://blog.csdn.net/surgeddd/article/details/4683657" target="_blank" rel="noopener">锁存器、触发器、寄存器和缓冲器的区别</a></p><ol><li><p>避免产生Latch.</p><blockquote><p>latch是一种对脉冲电平敏感的存储单元路径，可以在特定输入脉冲作用下改变电平</p></blockquote><p>由这个描述我们可以看出<strong>在if-else结构和case结构中很容易产生latch</strong>: 当遇到在当前情况没有赋值的变量或遇到没有定义的情况时需要沿用上一时刻的值, 因此我们需要一个<strong>存储上一时刻状态的器件</strong>,并且是电平触发的 (if-else和case的判断条件都是电平), 这就是为什么latch会出现. 在<a href="https://blog.csdn.net/u012923751/article/details/79475568?comment_content=%E6%84%9F%E8%B0%A2%21&amp;comment_replyId=&amp;article_id=79475568&amp;comment_userId=&amp;commentId=" target="_blank" rel="noopener">这篇文章</a>有控制语句产生latch的实例, 在<a href="https://zhuanlan.zhihu.com/p/34408492" target="_blank" rel="noopener">这篇文章</a>中有latch产生原因的详细讨论.</p><p>❗️ 值得注意的是, 即便if-else结构或者case结构完整了也并不能保证不会产生latch, 只是避免了因这种情况产生的latch.</p><p>至于为什么要避免产生latch, 因为此处产生的latch容易产生毛刺.</p><p>❗️ 此处的Latch特指PLD中的latch. 因为latch在实现同一功能时需要的门比用FF实现少, 在ASIC开发中latch使用较多 (ASIC的设计中可以保证latch信号的质量). 而由于PLD芯片中的基本单元是查找表和触发器, 没有标准的latch单元, 因此FGPA中的latch更耗资源, 也容易产生毛刺. 并不是所有latch都容易产生毛刺.</p></li><li><p>方便调试</p><p>如果default对应的情况是不应当出现的情况, 在仿真时可以将default情况下的变量赋值为不定态X,方便看出问题.</p></li><li><p>这已经是一种代码规范, 最好养成严谨的习惯, 避免出错.</p></li></ol><h3 id="default情况下该赋什么值"><a href="#default情况下该赋什么值" class="headerlink" title="default情况下该赋什么值"></a>default情况下该赋什么值</h3><p>如果default对应的情况不应当出现, 在仿真时将变量都赋值为不定态X, 方便看出错误 (在Modelsim里不定态的信号会显示为红色), 在实际应用时全部置零 (复位态).</p><h2 id="关于wire和reg"><a href="#关于wire和reg" class="headerlink" title="关于wire和reg"></a>关于wire和reg</h2><p>🔗<a href="https://www.zhihu.com/question/21021718/answer/17195122" target="_blank" rel="noopener">知乎-Verilog 中定义信号为什么要区分 wire 和 reg 两种类型？-屯屯屯屯的回答</a></p><p>🔗<a href="https://www.zhihu.com/question/21021718/answer/28802850https://www.zhihu.com/question/21021718" target="_blank" rel="noopener">知乎-Verilog 中定义信号为什么要区分 wire 和 reg 两种类型？-BruceX的回答</a></p><p>🔗<a href="https://link.zhihu.com/?target=http%3A//inst.eecs.berkeley.edu/~cs150/Documents/Nets.pdf" target="_blank" rel="noopener">UC Berkley讲义-Verilog: wire VS. reg</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Verilog学习笔记.&lt;/p&gt;
&lt;p&gt;这学期上了数字电路课, 从最开始的了解每个逻辑门的物理工作原理到学习每个组合电路, 时序电路元件是如何由逻辑门构成的, 再到后来跟着指导书设计出了很简易的8位CPU, 我个人是觉得很震撼的. 这也让我小时候的一个问题得到了解答: 集成电路这么复杂的东西真的是人能设计出来的吗? 其实我一直是知道答案的,
这些小黑块既不可能是土里长出来的也不可能是从什么动物身上割下来的. 我只是一直不敢想象这么复杂而精妙的东西 (即便是一根充电线里的小巧电路也不是那时的我能弄清的). 最近我稍微体会到了那群伟大的工程师们是如何设计出了那样精密的芯片的: 不断积累基本模块. 实际上从最开始的黑底白字的电脑系统到现在繁华多样的炫酷系统, 也是很令人震撼的变化. 虽然大佬可能会觉得这些很简单, 但我仍认为该对这些技术保持敬畏之心.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Verilog" scheme="https://leojhonsong.github.io/zh-CN/categories/Verilog/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么我用Linux而不是Windows</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/05/17/为什么我用Linux而不是Windows/</id>
    <published>2019-05-17T06:48:06.000Z</published>
    <updated>2019-10-10T19:08:58.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>又过了一段时间, 我觉得对于这个问题我已经不在需要去想那么多理由来说服自己了. 在习惯了在Linux开发后我再在Windows试着做点小东西便发现这一切比起在Linux下来得束手束脚得多. 没有强大而美观的终端, 无法只通过编辑配置文件就轻松对软件进行配置, 无法一个命令改变文件权限, 系统语言为中文时的默认编码格式为cp936有时候也会给开发带来麻烦… 更别说windows没有强大的包管理工具…总之<strong>一切Windows防止普通用户误操作的措施让开发者变得十分拘束</strong>.</p><p><strong>WSL也不顶用</strong>. 我也一度十分推崇WSL, 但体验了一天不到我就果断删除了. <strong>我连自己环境都没配出来!</strong> 目前的WSL还bug很多, 比如我的终端字体根本不能正确显示 (这很重要好吧), 比如在Windows系统和WSL同时对一个文件进行了操作似乎会造成文件权限问题, 再比如我在Ubuntu1804的WSL中执行<code>sudo apt install pip</code>结果报错了… (这个问题并不只有我一个人遇到)</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然上大学前我是完全没听说过Linux的 (不是Linux不nb是我太菜), 但进大学后身边人人都说他好, 我也就早早地开始接触它. 从最开始在Win10上在虚拟机里装了Ubuntu16.04摸了几把, 到发现双系统爆炸好装就顺手装上了Ubuntu18.04体验, 到现在思考为什么我要用Linux, 思考要不要试试Ubuntu之外的Linux系统, 感觉自己对Linux还是有了一定的了解.</p><p>在我刚装了双系统时就有同学问我Linux到底咋好, 我当时也没太体会出, 就一气胡说, 什么”没有毒瘤360”啊, “不像Windows下乱七八糟的软件有各种开机加载项, 我这快坏掉的电脑运行Linux系统开机快”啊 (当时我的硬盘刚出现<a href="https://leojhonsong.github.io/zh-CN/%E6%88%91%E6%89%93%E7%AE%97%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86/">要爆炸的迹象</a>),总之我当时也说不上Linux哪里好到值得我不用Windows和它的Office套装.</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>因此当最近我再次想起这个问题时我进行了一番搜索:</p><ul><li>首先我搜了Linux和Windows的比较, 发现其实问题并不是”Linux比Windows好在哪”而是”Linux和Windows哪个好?”</li></ul><p>🔗<a href="https://www.zhihu.com/question/24439007/answer/27872778?utm_source=qq&amp;utm_medium=social&amp;utm_oi=575568675688419328" target="_blank" rel="noopener">知乎话题-微软的 Web 服务器为何能屹立不倒？</a></p><p>🔗<a href="https://www.michaelhorowitz.com/Linux.vs.Windows.php" target="_blank" rel="noopener">LINUX vs WINDOWS</a></p><ul><li>然后我想到了解Linux和Windows的起源来发现他们设计理念, 运行方式的差异.</li></ul><p>🔗<a href="https://www.bbsmax.com/A/mo5kVo2JwR/" target="_blank" rel="noopener">操作系统Unix、Windows、Mac OS、Linux的故事</a></p><p>🔗<a href="https://linux.cn/article-3789-1.html" target="_blank" rel="noopener">一段关于 Unix 与 Linux 的暗黑史</a></p><p>我顺便搜了一下Linux在电影行业的应用</p><p>🔗<a href="https://blog.csdn.net/neo_liukun/article/details/6787507" target="_blank" rel="noopener">Linux与电影制作</a></p><ul><li>还有些杂乱的</li></ul><p>🔗<a href="https://www.jianshu.com/p/71158a9c8d03" target="_blank" rel="noopener">浏览黑暗网络的操作系统：Windows，Mac还是Linux？</a></p><p>🔗<a href="https://en.wikipedia.org/wiki/Comparison_of_operating_systems" target="_blank" rel="noopener">Comparison of operating systems</a></p><p>🔗<a href="https://meta.stackexchange.com/questions/10369/which-tools-and-technologies-are-used-to-build-the-stack-exchange-network" target="_blank" rel="noopener">What tools and technologies are used to build the Stack Exchange Network?</a></p><p>🔗<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=Netperf-Windows-Linux" target="_blank" rel="noopener">Some Windows Server 2016 vs. Linux Network Benchmarks</a></p><p>🔗<a href="https://www.zhihu.com/question/19818863" target="_blank" rel="noopener">京东用 .NET 架构的原因是什么？</a></p><p>🔗<a href="https://www.zhihu.com/question/50117613/answer/119798303" target="_blank" rel="noopener">如何评价微软的 UI 设计？</a></p><h1 id="信息整理"><a href="#信息整理" class="headerlink" title="信息整理"></a>信息整理</h1><p>我们可以发现虽然Linux是在服务器领域发家的, 但现在Windows也在服务器领域占领了不小的份额. 并且在某些领域比起Linux反而Windows更受青睐. 很有意思的是在银行业Unix因为稳定性被使用, 而Windows因为能提供因为Windows系统的原因出现的损失提供补偿而被使用, Linux看起来在银行业倒是没几家使用的样子.</p><p>实际上Linux和Windows在各方面的性能上并无什么差异, 让人们决定到底选择Linux还是Windows的因素我觉得可以<strong>主要</strong>可以分<strong>服务器领域</strong>和<strong>个人电脑领域</strong>两个方面来讨论.</p><h2 id="服务器领域"><a href="#服务器领域" class="headerlink" title="服务器领域"></a>服务器领域</h2><p>服务器都是公司在使用, 而公司是一定要赚钱的 (就算是非营利组织也是要靠钱来维持的), 因此很多决定因素都和💰有关.</p><p>因为是公司用的服务器, 因此很容易受到攻击, 另外因为很可能保存有公司重要资料因此要有公司内部人员来管理, 开发. 然后我们就看到: <strong>中小型IT企业普遍选择Windows, 而大型IT企业更倾向于选择Linux.</strong></p><p>❗️</p><ul><li>此处仅讨论IT领域, 因为其他领域我没了解到那么多, 并且讨论价值没那么大, 比如文学界的数据库服务器我不认为会使用Linux系统</li><li>此处的中小型公司指有一定技术水准的程序员的数量较少, 反之大型公司指技术实力雄厚的, 比如BAT</li></ul><p>中小型IT企业更青睐Windows是因为:</p><ol><li>Window<strong>s学习成本相对低</strong>, 甚至微软能提供良好的技术支持.</li><li>使用Linux看似省下了Windows激活码的钱, 但却需要大量资金来养一批有实力的技术人员在公司里才能达到或者超过使用来自微软的服务的体验 (紧急情况处理, 技术支持, 损失赔偿等), 对人手不够的公司来说Windows是个很好的选择. 就比如 Stack Exchange这公司, 还是很nb吧, 但人家的服务器一直在Windows平台使用微软的方案, 因为这公司一共就一百多人, 还分散在世界各地. 他们很明显没有足够的人手去搞骚东西, 而微软的服务很好地解决了他们的烦恼: 俺们就是想<strong>省心</strong>.</li><li>有许多银行也会使用Windows, 因为<strong>微软能为损失背锅</strong>. 另外不算各巨头公司的魔改的话Windows系统的<strong>安全性很高</strong>, 毕竟他的源码是闭源的, 更不容易被人发现0day漏洞, 而微软的事故响应也很快, 比开源社区修bug不知快到哪去了. 经常有人认为Linux系统公布了源码, 那各位大牛肯定早把它修补得差不多了, 但事实并非如此, Linux也有许多漏洞, SUSE就曾爆出过重大漏洞. 而与Linux有血缘的Unix则是因为在贝尔实验室已经经历了十数年的打熬, 才能做到如今的稳定性.</li></ol><p>而大型公司则是相反, 因为技术雄厚因此更愿意用Linux这样的开源系统, 甚至基于Linux魔改. 比如Google就糊了<em>Goobuntu</em>, <em>gLinux</em>内部使用. 这些公司有钱有人, 那当然是选择高度定制化, 自己能完全把控的系统. 而没人会去魔改Windows拿来用, 那太骚了.</p><h2 id="个人电脑领域"><a href="#个人电脑领域" class="headerlink" title="个人电脑领域"></a>个人电脑领域</h2><p>以下的观点就主观一些了, 毕竟本文标题是 “我为什么用Linux” 😁</p><p>其实在PC端Windows各方面都有着很不俗的表现, 抛开游戏方面不谈 (这方面当然是Windows更合适, 但我是不打游戏的).</p><p>比如<strong>办公方面</strong>吊打Linux: Word, PPT, Excel, OneNote为首的Office套件实在好用, 虽然这些软件在Linux上可以访问网页版, 但经我测试有许多有用功能网页版并不具备. (OneDrive现在能在Linux很好的使用了倒是一大喜事) 无论WPS还是LibreOffice都存在很严重的图文串位问题. 至于Latex在Linux平台体验并没有和Windows平台有什么区别.</p><p>再比如<strong>驱动方面</strong>, Windows确实比Linux做得好不少, 驱动比Linux全很多 (就比如很多电脑刚装了Linux会有显卡, 网卡, 蓝牙等各种各样驱动问题而且解决起来没有在Windows那么容易). 甚至很多做硬件相关的企业都用Windows. 很多设备只做了Windows平台的驱动, 但我是没听说过只做了Linux平台驱动的设备.</p><p>而在<strong>美观程度</strong>方面个人认为只要想做, Linux桌面可以做到高度个性化, 因此可以很美观, 不像在Windows即便你觉得什么东西丑爆了你也只能按照Windows的规矩来个性化. 即便自己配置觉得麻烦也可以直接偷别人的配置. 比如我打算以后按<a href="https://www.zhihu.com/question/26031045/answer/356288402" target="_blank" rel="noopener">这个样子</a>折腾一番, 实在炫酷.</p><p>但要说到<strong>开发方面</strong>我认为Linux是比Windows好的选择. 无赖一点的解释: 既然以后在IT界很有可能需要用Linux, Linux学习成本又不低, 那何不早些接触Linux? 在微软实习的学长说他觉得那里的人人均会Linux. 曾经看到说我们身周的设备90%以上用的系统都是Linux (虽然我觉得有点过了但反正极多, 而Windows IoT才起步). 在和目标平台相同的平台上开发能提高发现问题的可能性. 另外Linux上没有Windows上那么多针对普通用户设置的开关, 不会还需要自己开启IIS之类. 而且Linux不使用 <code>\\</code> 作为文件夹名称分割符, 感觉没那么容易混乱. 再有Windows自带的Windows Defender过于烦人, 默认设置甚至会实时扫描所有进程, 占用很多内存. 然后Linux文件以<code>LF</code>为换行符, 而Windows以<code>CLRF</code>为换行符, 因此到了Linux强迫症表示Git提交时再也看不到将文件从CRLF转到LF的提示了😁. Linux的好处太多啦, 还有环境好配, 命令行比图形界面更能让人提高效率等…</p><p>而还有一点超脱以上所有并且十分重要的原因: <strong>生态</strong>.</p><p>如果你要使用的工具, 祖传代码, 社区已有的成果, 公司生态等逼着你用Linux, 你又能有什么办法.</p><hr><p>我又发现了Windows可以diss的地方: 编码方式.</p><p>实例参见<a href="https://leojhonsong.github.io/zh-CN/Linux%E6%9D%82%E8%AE%B0/#%E8%A7%A3%E5%8E%8B%20-zip%20%E5%8E%8B%E7%BC%A9%E5%8C%85%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA%E4%B9%B1%E7%A0%81">这里</a>. 这里有详细的吐槽 🔗<a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">知乎-Windows记事本的ANSI, Unicode, UTF-8这三种编码模式有什么区别？-梁海的回答</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h1&gt;&lt;p&gt;又过了一段时间, 我觉得对于这个问题我已经不在需要去想那么多理由来说服自己了. 在习惯了在Linux开发后我再在Windows试着做点小东西便发现这一切比起在Linux下来得束手束脚得多. 没有强大而美观的终端, 无法只通过编辑配置文件就轻松对软件进行配置, 无法一个命令改变文件权限, 系统语言为中文时的默认编码格式为cp936有时候也会给开发带来麻烦… 更别说windows没有强大的包管理工具…总之&lt;strong&gt;一切Windows防止普通用户误操作的措施让开发者变得十分拘束&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WSL也不顶用&lt;/strong&gt;. 我也一度十分推崇WSL, 但体验了一天不到我就果断删除了. &lt;strong&gt;我连自己环境都没配出来!&lt;/strong&gt; 目前的WSL还bug很多, 比如我的终端字体根本不能正确显示 (这很重要好吧), 比如在Windows系统和WSL同时对一个文件进行了操作似乎会造成文件权限问题, 再比如我在Ubuntu1804的WSL中执行&lt;code&gt;sudo apt install pip&lt;/code&gt;结果报错了… (这个问题并不只有我一个人遇到)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/Linux/"/>
    
    
  </entry>
  
</feed>
