<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeoJhon.Song&#39;s Blog</title>
  
  <subtitle>欢迎来到我的博客!</subtitle>
  <link href="/zh-CN/atom.xml" rel="self"/>
  
  <link href="https://leojhonsong.github.io/zh-CN/"/>
  <updated>2021-01-10T17:48:00.000Z</updated>
  <id>https://leojhonsong.github.io/zh-CN/</id>
  
  <author>
    <name>LeoJhon.Song</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初级急救员笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2021/01/21/%E5%88%9D%E7%BA%A7%E6%80%A5%E6%95%91%E5%91%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2021/01/21/%E5%88%9D%E7%BA%A7%E6%80%A5%E6%95%91%E5%91%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-20T17:43:00.000Z</published>
    <updated>2021-01-10T17:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近假期了, 把十八岁暑假去参加的初级急救员培训笔记拿出来写在这里好了. 望指正.</p><a id="more"></a><h2 id="关于红十字会的初级急救员培训"><a href="#关于红十字会的初级急救员培训" class="headerlink" title="关于红十字会的初级急救员培训"></a>关于红十字会的初级急救员培训</h2><h3 id="为什么要学急救"><a href="#为什么要学急救" class="headerlink" title="为什么要学急救"></a>为什么要学急救</h3><p>学急救对普通人来说并不是一件小题大做的事情, 所谓初级急救员培训, 一共只有16小时 (两天), 我当时报名所想要达到的目的也仅是在遇到突发情况时不至于茫然无措. 摘抄一段成都红会的课程介绍页面的话:</p><blockquote><p>通过现场初级急救知识的学习和实践, 使受训人员掌握基本救护理论和实践操作技能, 在遇到突发事件或意外伤害时能自救互救, 以减轻痛苦、减少伤残, 为挽救生命争取宝贵时间</p></blockquote><p>实际上这样的”突发事件或意外伤害”发生在身边, 甚至亲友身上的几率<strong>并不小</strong>. 实际上我已经有过<strong>两次</strong>我在场时亲人发生突发事件的经历了. 正是第一次遇到这种情况时的无助让我在高中结束时思考假期做什么第一个想到了学急救培训. 但即便我认真地做了笔记, 也不时地关注一些急救信息, 我第二次面临这样的情况时仍然完全没法沉着冷静. 虽然做了些调整体位, 等救护车等力所能及的事情, 但是我内心仍然是茫然无助的. 毕竟只是普通人, 又只学了些急救的皮毛, 非常容易遇到没有头绪的情况 (甚至可能因为经验太少而产生误判). 因此遇到突发事件我的经验是:</p><p><strong>第一要务是给120打电话, 说明情况并寻求帮助</strong></p><p>这是否意味着自己就没有学急救的意义了呢? 学习急救知识对于普通人来说仍然是十分必要的, 因为急救讲究争分夺秒, 在救护车赶来前, 如果我们能做一些应急措施, 那将是非常有意义的. 但是如果我们毫无相关常识, 比如不知道复苏体位到底是怎样的, 不知道心肺复苏的要点, 那么即便有120在旁电话指导我们仍然很难做出有效的应对措施. 身边人的健康是非常重要的事情, 学一学成本不大, 但价值极高 👍</p><h3 id="报名渠道"><a href="#报名渠道" class="headerlink" title="报名渠道"></a>报名渠道</h3><p>在各地的红十字会官网上应当就能搜到报名方式.</p><p>🔗 <a href="http://www.scredcross.org.cn/htm/detail_6355.html" target="_blank" rel="noopener">四川红会的课程介绍</a> 🔗 <a href="http://www.chengduredcross.cn/list_wjpx.asp?ClassID=020501" target="_blank" rel="noopener">成都红会初级急救员培训报名渠道</a></p><p>这个培训要收个两百多的报名费, 但也不算贵, 毕竟会发一个培训用创伤训练包 👍 (说起来培训的氛围非常好, 老师特别亲和)</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>💡 这里有一份<a href="./初级急救员笔记/2011年国际急救与复苏指南.pdf">2011年国际急救与复苏指南</a>和<a href="./初级急救员笔记/日常急救手册.pdf">日常急救手册</a>可供下载. 以下几个板块是急救培训老师着重讲的部分, 其实在前面这本急救与复苏指南里还有好一些内容.</p><p>❗这里会涉及到许多没有实际操作过就无法把握要点的技术, 这只是一份<strong>笔记</strong>.</p><h3 id="心肺复苏"><a href="#心肺复苏" class="headerlink" title="心肺复苏"></a>心肺复苏</h3><h4 id="判断是否进行心肺复苏"><a href="#判断是否进行心肺复苏" class="headerlink" title="判断是否进行心肺复苏"></a>判断是否进行心肺复苏</h4><p>虽然人人都知道有个叫心肺复苏的技术能救命, 但实际上实施心肺复苏有一定的条件, 盲目进行心肺复苏反而容易出问题. 下面便是判断是否进行心肺复苏的流程.</p><p><img src="./%E5%88%9D%E7%BA%A7%E6%80%A5%E6%95%91%E5%91%98%E7%AC%94%E8%AE%B0/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%BF%9B%E8%A1%8C%E5%BF%83%E8%82%BA%E5%A4%8D%E8%8B%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.svg?50" alt="判断是否进行心肺复苏流程图"></p><h5 id="确认现场环境安全"><a href="#确认现场环境安全" class="headerlink" title="确认现场环境安全"></a>确认现场环境安全</h5><p>举例:</p><ul><li>关闭受损汽车的发动机, 拉下手刹</li><li>在抢救触电者前切断电源</li><li>远离危险地带 (比如易塌墙)</li><li>远离有毒有害气体 (比如开窗通风)</li></ul><p>❗尽量不要移动伤员</p><h5 id="做好自我防护措施"><a href="#做好自我防护措施" class="headerlink" title="做好自我防护措施"></a>做好自我防护措施</h5><p>随意接触伤员有一定可能染上病, 以下是一些可能的, 对彼此都有防护作用的措施:</p><ul><li>处理伤口前洗手, 尽量戴手套. 如果没有手套的话塑料袋也可以.</li><li>戴口罩</li><li>处理大量出血的外伤时戴防护镜</li><li>做人工呼吸时隔一层布或纸</li></ul><h5 id="判断有无意识"><a href="#判断有无意识" class="headerlink" title="判断有无意识"></a>判断有无意识</h5><p>要判断有无意识, 对于成人, 拍打双肩, 在耳边大声呼唤; 对于婴儿, 拍打足底. 可以给予”睁开眼睛”, “动动手指”这样的简单指令.</p><p>如伤病员无反应:</p><ol><li>向周围人表明急救员身份</li><li><strong>指定</strong>一个人拨打120</li><li>寻求他人帮助 (比如寻找AED)</li><li>向他人问明伤员情况, 如是否有内出血/骨折/脊柱损失等. (周围人也许就知道)</li></ol><p>如伤病员有反应:</p><ol><li>表明急救员身份</li><li>心理安慰</li><li><strong>视情况</strong>拨打120</li><li>帮助调整伤员体位, 排除气道异物, 打开气道</li></ol><h5 id="判断有无呼吸"><a href="#判断有无呼吸" class="headerlink" title="判断有无呼吸"></a>判断有无呼吸</h5><h3 id="气道异物梗阻"><a href="#气道异物梗阻" class="headerlink" title="气道异物梗阻"></a>气道异物梗阻</h3><h3 id="创伤"><a href="#创伤" class="headerlink" title="创伤"></a>创伤</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近假期了, 把十八岁暑假去参加的初级急救员培训笔记拿出来写在这里好了. 望指正.&lt;/p&gt;
    
    </summary>
    
    
      <category term="健康" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%81%A5%E5%BA%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>HPV与宫颈癌小知识</title>
    <link href="https://leojhonsong.github.io/zh-CN/2021/01/11/HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://leojhonsong.github.io/zh-CN/2021/01/11/HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2021-01-10T17:30:00.000Z</published>
    <updated>2021-01-10T17:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>帮人查HPV疫苗的信息整理了一份资料出来, 就分享一下好了. ❗ 注意以下信息为截止2020年12月的信息.</p><a id="more"></a><h2 id="HPV"><a href="#HPV" class="headerlink" title="HPV"></a>HPV</h2><p>HPV (human papilloma virus), 即<strong>人类乳头状瘤病毒</strong>. 和乳头没有关系, 是大部分类型得了会长出乳头状的瘤 (即疣, 皮肤上的粗糙, 坚硬颗粒), 有近200种类型. <strong>不论是一般身体部位或生殖器的皮肤, 只要有鳞状上皮, 就可以被人类乳突病毒感染的, 但每种HPV通常只能感染特定区域皮肤.</strong></p><h3 id="较常见HPV与疣的种类"><a href="#较常见HPV与疣的种类" class="headerlink" title="较常见HPV与疣的种类"></a>较常见HPV与疣的种类</h3><p>❗ 大多数时候感染后没有任何临床症状, 也就是说连下面这些疣都不会有. 而出现了疣的话大致可以分以下几种情况.</p><table><thead><tr><th>疣类型</th><th>说明</th><th>HPV类型</th><th>危害程度</th></tr></thead><tbody><tr><td>普通疣 (瘊子)</td><td>有着粗糙的表面, 通常发生在手及脚部, 但亦有可能在身体其他区域发生</td><td>2, 4 (最常见), 1, 3, 26, 29, 57</td><td>良性</td></tr><tr><td>扁平疣</td><td>扁平而光滑的疣, 呈现肉色, 可能一长就是许多个；最常发生在头、脸、颈部、手、手肘及膝盖</td><td>3, 10, 28</td><td>良性</td></tr><tr><td>丝状疣</td><td>呈螺丝或者指头状, 在颈部, 脸部, 尤其是嘴唇以及眼皮周围上发生, 常见于中老年, 孕妇等 (因为抵抗力下降). <strong>注意与皮赘区别</strong></td><td>1, 2, 4, 7, 26, 27, 28, 29</td><td>良性</td></tr><tr><td>跖疣</td><td>发生在足底部. <strong>注意与鸡眼, 老茧区别</strong></td><td>1 (最常见), 2, 3, 4, 27, 28, 58</td><td>良性</td></tr><tr><td>肛门生殖器疣 (尖锐湿疣)</td><td>长在肛门/生殖器附近. <strong>注意与珍珠疹, 假性湿疣区别</strong></td><td><strong>6, 11</strong> (90%), 13, 40, 42, 43, 44, 54, 61, 72, 81, 89</td><td>低危</td></tr><tr><td>(癌和子宫颈细胞化生不良)</td><td>与癌症有关, 特别是子宫颈癌, 并且还可能会导致一些外阴, 阴道, 阴茎, 肛门和口咽的癌. 男性也可能感染</td><td><strong>16, 18</strong> (70%宫颈癌, 90%肛门癌, 很大比例阴道癌), <strong>31, 33, 45, 52, 58</strong>(20%宫颈癌), 35, 39, 59</td><td>高危</td></tr></tbody></table><p>💡 高危/低危根据致癌性划分. 无论是高危类型的HPV还是低危类型的HPV, <strong>目前都没有明确有效的抗病毒治疗手段</strong>, 只能治疗HPV导致的病变</p><p>💡 <strong>由此可见只有四十余种HPV通过性行为传播且有危害性, 大部分HPV性质和脚气类似, 并非性传播</strong> (但是能通过疫苗预防的几种HPV确实只有与性相关的几种)</p><p>💡 从整体上看, 我国的感染型别与国际以及亚洲地区其他国家略有差异, 在细胞学正常人群中, 全球范围内最常见的HPV型别依次是 HPV 16/52/31/53, 而在我国排名前四的型别依次是HPV 16/18/58/52. <strong>除了广泛流行的 HPV 16/18 型, HPV 58/52 型在中国宫颈癌中占比为 14.7%, 明显高于全球占比  7.4%</strong>.</p><p>80%感染的HPV会在6-24个月内会被身体的免疫系统自动清除, 医学上称为<strong>一过性感染</strong>.</p><h3 id="感染HPV的常见途径"><a href="#感染HPV的常见途径" class="headerlink" title="感染HPV的常见途径"></a>感染HPV的常见途径</h3><ol start="2"><li>间接接触传播 (共用拖鞋, 共用毛巾, 共用剃须刀, 公用马桶, 私人衣物等)</li><li>性传播</li><li>母婴传播</li><li>医源性感染</li></ol><h2 id="宫颈癌"><a href="#宫颈癌" class="headerlink" title="宫颈癌"></a>宫颈癌</h2><p>到目前为止, 宫颈癌是人类唯一一个找到病因且可预防的癌症种类. 中国女性 HPV 感染率按年龄呈[双峰] 分布：第一个高峰在[17-24 岁], 第二个高峰在[40-44 岁].</p><p>宫颈癌与hpv关联: 只有少数高危型的 HPV 持续感染才会有一定几率引发宫颈癌, 通常情况下持续感染经过 10-20 年的自然演化发展, 才可能会发展成为宫颈癌.</p><h3 id="中国《子宫颈癌综合防控指南》提出的三级预防策略"><a href="#中国《子宫颈癌综合防控指南》提出的三级预防策略" class="headerlink" title="中国《子宫颈癌综合防控指南》提出的三级预防策略"></a>中国《子宫颈癌综合防控指南》提出的三级预防策略</h3><ol><li><strong>一级预防 (治未病)</strong>: 开展健康教育和接种 HPV 预防性疫苗</li><li><strong>二级预防 (治初病)</strong>: 对所有适龄妇女定期开展宫颈癌筛查</li><li><strong>三级预防 (治已病)</strong>: 根据宫颈癌的临床分期, 开展适宜的手术、放疗、化疗及姑息疗法</li></ol><p>🌟 筛查比hpv疫苗重要得多</p><p><img src="HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/screening.jpg" alt="图片"></p><h2 id="HPV疫苗"><a href="#HPV疫苗" class="headerlink" title="HPV疫苗"></a>HPV疫苗</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>以L1蛋白外壳模拟HPV病毒, 本身不是病毒, 不会造成感染</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li><p>预防大部分有致癌风险的HPV</p></li><li><p><strong>感染过HPV也仍有接种价值</strong>: HPV感染或由此引发的宫颈病变治愈后, 进行HPV疫苗接种可以减少疾病的复发率. 理论上认为, 人体自然感染HPV后, 抵抗病毒的体系是细胞免疫, 主要在宫颈局部起作用, 产生的抗体水平很低, 不足以对抗病毒的再次进攻. 而疫苗是肌肉注射, 会引发人体产生强烈有效的免疫反应, 产生的抗体的滴度是自然感染的40倍以上, 这样就可以防止病毒的感染.</p></li></ul><h3 id="接种条件及方式"><a href="#接种条件及方式" class="headerlink" title="接种条件及方式"></a>接种条件及方式</h3><ul><li>对疫苗活性成分 (L1蛋白) 或任何辅料成分有超敏反应者禁用</li><li>目前大陆没有开放男性接种HPV疫苗 (国外可以)</li><li>肌肉注射 (首选上臂三角肌), 每次0.5ml</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/types.png" alt="image-20210109163343942"></p><p>共二, 四, 九价三种HPV疫苗, “价”指疫苗能预防的HPV亚种数. 目前全世界只有葛兰素史克 (英国), 默沙东 (美国), 万泰沧海 (中国) 三家能生产HPV疫苗, 其中四价, 九价疫苗目前只有默沙东能生产.</p><h3 id="性价比"><a href="#性价比" class="headerlink" title="性价比"></a>性价比</h3><p><strong>万泰沧海二价 &gt; GSK二价 &gt; 默沙东九价 &gt; 默沙东四价</strong></p><ul><li><p>万泰沧海疫苗价格低的原因在于研发原理带来的低成本. 默沙东疫苗基于酒酿酵母表达体系, GSK 疫苗基于<strong>昆虫细胞</strong>表达系统, 万泰沧海疫苗基于<strong>大肠杆菌</strong>表达体系.</p></li><li><p>万泰对16/18型保护效力高于进口疫苗, 且不良反应小</p></li><li><p>四价只比二价多了对尖锐湿疣的预防, 但是尖锐湿疣看网上信息意思基本是良性的, 因此不如九价性价比高</p></li><li><p>国内目前都是自费接种, 因此其实大部分人还是选择等九价. 不过可能出现打完一针后缺货的情况.</p></li><li><p>打过了二价或四价, 也可以再接种九价, 不过要等完成接种的一年后才可以, 而且有点亏</p></li></ul><h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>打疫苗要按周期, 一共打三次. 可以比建议时间晚几天, 但最好不要提前打. 这是为了产生最多的抗体. 提前打浪费. <strong>一年内完成三针产生的抗体量都是够的</strong>.</p><h3 id="保护能力持续时间"><a href="#保护能力持续时间" class="headerlink" title="保护能力持续时间"></a>保护能力持续时间</h3><p>尚不清楚, 目前可以确保是10年以上. (因为这个疫苗一共出现才十多年)</p><h3 id="年龄限制"><a href="#年龄限制" class="headerlink" title="年龄限制"></a>年龄限制</h3><p>九价建议注射年龄是16~26岁, 指第一针需要在26岁半前接种, 27岁前完成三针. 之所以国内对默沙东九价疫苗限制年龄段比国外窄是因为国内的默沙东九价疫苗临床数据目前只做了16-26岁女性的  (同时也有疫苗资源紧张的原因).也因为同样原因大陆没有开放男性接种HPV疫苗.</p><h3 id="供应量"><a href="#供应量" class="headerlink" title="供应量"></a>供应量</h3><p>九价供应短缺原因:</p><ul><li>国内缺口大: 国家统计局最新数据显示, 九价HPV疫苗的适龄人群 (16-26岁) 约<strong>1.2亿</strong>. 而按照智飞生物2019年九价HPV疫苗批签发量332.4万计算, 能够接种到该疫苗的人数还<strong>不足总数的1%</strong>. (按照10%的核心人群渗透率算)</li><li>九价国内审批只用了八天, 默沙东产量预估不足, 并且增加产能决心不强烈</li><li>目前国外很多市场已经淘汰二价, 四价疫苗, 以售卖九价疫苗为主.</li></ul><p>现状:</p><ul><li><p>目前只有默沙东一家生产九价疫苗. 2023年默沙东新生产线将投产.</p></li><li><p>截至2020年7月国内HPV疫苗研发概况👇 (可以看到甚至十一, 十四价HPV疫苗也已经开始研发了), 但是我看网上消息的意思, 直到2026年估计不会有国产九价疫苗上市 🤦‍♂ ️</p></li></ul><p><img src="HPV%E4%B8%8E%E5%AE%AB%E9%A2%88%E7%99%8C%E5%B0%8F%E7%9F%A5%E8%AF%86/outline.jpeg" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;帮人查HPV疫苗的信息整理了一份资料出来, 就分享一下好了. ❗ 注意以下信息为截止2020年12月的信息.&lt;/p&gt;
    
    </summary>
    
    
      <category term="健康" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%81%A5%E5%BA%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>笔记本电脑性能提升/选购指南</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/05/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/05/08/%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87-%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</id>
    <published>2020-05-08T07:26:17.000Z</published>
    <updated>2020-05-08T07:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>自去年三月多开始有意识了解电脑配件至今已有一年多, 对这些乱七八糟的了解多了许多, 整理一下我对<strong>笔记本</strong>性能提升的经验以及选购指南. 因为我很了解在不了解这些时听到这些陌生概念的望而畏怯以及半信半疑, 我尽量解释得小白些.</p><p>❗️ 因为我自己没有台式机所以这里只谈笔记本相关.</p><a id="more"></a><h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><p>不同于台式机里什么配件都可以换,  比如很多笔记本的CPU, 显卡是焊死在主板上的. 即便你的笔记本支持更换这两样, 这也不是容易事. 因为笔记本的散热是精打细算设计好的, 更换了更好的CPU或者显卡通常以为着更大的发热量, 很容易导致过热然后出奇奇怪怪的问题.</p><p>因此为了提升笔记本性能常见的操作是<strong>更换硬盘和内存</strong>.</p><h3 id="更换硬盘"><a href="#更换硬盘" class="headerlink" title="更换硬盘"></a>更换硬盘</h3><h3 id="更换内存"><a href="#更换内存" class="headerlink" title="更换内存"></a>更换内存</h3><h2 id="选购指南"><a href="#选购指南" class="headerlink" title="选购指南"></a>选购指南</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自去年三月多开始有意识了解电脑配件至今已有一年多, 对这些乱七八糟的了解多了许多, 整理一下我对&lt;strong&gt;笔记本&lt;/strong&gt;性能提升的经验以及选购指南. 因为我很了解在不了解这些时听到这些陌生概念的望而畏怯以及半信半疑, 我尽量解释得小白些.&lt;/p&gt;
&lt;p&gt;❗️ 因为我自己没有台式机所以这里只谈笔记本相关.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="硬件" scheme="https://leojhonsong.github.io/zh-CN/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年4月12日 Vim经验分享</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/04/20/2020%E5%B9%B44%E6%9C%8812%E6%97%A5vim%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/04/20/2020%E5%B9%B44%E6%9C%8812%E6%97%A5vim%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2020-04-20T09:01:34.000Z</published>
    <updated>2020-04-20T09:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><span></span></p><a id="more"></a><p>最近在<a href="https://uestc-msc.github.io/" target="_blank" rel="noopener">电子科大微软学生俱乐部</a>做了一次vim经验分享, 下面是当时的录像. 这个录像是用zoom的会议录制功能得到的. 顺带一提zoom是有Linux平台的目前为止体验最好的视频会议软件, zoom录制的会议视频似乎本身就会进行压缩, 不像用其他软件得到的会议录制我还要自己压缩一下. zoom要是再有网页端就更好了😆</p><iframe src="//player.bilibili.com/player.html?aid=710237273&amp;bvid=BV18Q4y1K744&amp;cid=177852832&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>然后因为当时准备得有些仓促导致有几个地方演示得不充分有的地方说串了, 所以我补全了幻灯片. 👇下面这个就是我的幻灯片, 使用<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">Markdown Preview Enhanced</a>制作的markdown幻灯片. 屏幕gif录制工具为<a href="https://github.com/phw/peek" target="_blank" rel="noopener">peek</a>, 键盘按键可视化工具为<a href="https://gitlab.com/screenkey/screenkey" target="_blank" rel="noopener">screenkey</a></p><div style="width:100%; padding-bottom:56.25%; position:relative;">  <iframe src="https://leojhonsong.github.io/vim-share/vim.html" style="width:94%; height:94%; position:absolute; transform: translate(3%,3%); box-shadow: 0 0 6px 7px black;"></iframe></div><p>🔗 你也可以点击<a href="https://leojhonsong.github.io/vim-share/vim.html">这个链接</a>全屏观看. 这个幻灯片的源代码在<a href="https://github.com/LeoJhonSong/vim-share/blob/master/vim.md" target="_blank" rel="noopener">这里</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="编辑器" scheme="https://leojhonsong.github.io/zh-CN/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="vim" scheme="https://leojhonsong.github.io/zh-CN/categories/%E7%BC%96%E8%BE%91%E5%99%A8/vim/"/>
    
    
  </entry>
  
  <entry>
    <title>单硬盘三系统安装记录</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/04/04/%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/04/04/%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-04T07:04:15.000Z</published>
    <updated>2020-04-27T02:46:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一下我在同一个SSD里同时安装Ubuntu, Windows, macOS三个系统并以GRUB作为开机引导的经验. 说实话过程并不复杂.</p><a id="more"></a><p>也不知道最近自己时间都浪费哪里去了😑 3月7号弄好的东西现在才得以闲下来记录一番. 先秀一张GRUB界面😏</p><p><img src="%E5%8D%95%E7%A1%AC%E7%9B%98%E4%B8%89%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/grub.jpg" alt=""></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>说说我的心路历程😏</p><p>直到上大学我都对电脑了解甚少, <strong>只知道有Windows系统</strong>, 并不知道还可以有其他系统, 更别说在这之上的骚操作了😂 上大学后<strong>我逐渐熟悉了Windows系统</strong>并且喜欢上了这个很有现代感的系统. 但随着我对编程的学习逐渐深入, 以及我为了尽早熟悉机器人相关知识而想要了解Linux系统, 在听人介绍后我费了些力气<strong>在虚拟机里装上了Ubuntu16.04</strong>, 不过那时候了解的还是太少, 只是跟着网上的教程将这个东西装好了, 没什么收获. 装好后因为那时也没什么夸张到要开虚拟机在Ubuntu里编程的项目, 所以就体验了几下就束之高阁了. 毕竟那时对于编程, 甚至查找资料的经验都太少了, 只看到一些令人头大的辣鸡资料, 因此并没能学到什么.</p><p>大一下的时候我选了一门叫智能嵌入式的课, 其中有个课题是要编写一个能手势识别的程序并移植到树莓派上. 因此我就买了一个树莓派3b+. 不过那时懵懂的我对于怎么给一个SD卡安装系统手足无措, 就在网上搜资料给树莓派依次装了Ubuntu Mate, ArchLinux, 最后才是Raspbian😂 (我记得Mate是因为我当时没有找到arm架构的国内源就抛弃了, 而ArchLinux我就根本没装上…) 费劲心力我最后总算是把那个课题做完了, 但一方面我写得很差, 再加上树莓派3b+对图像处理的性能很一般, 所以我的手势识别程序移植到树莓派后十分卡顿😅 那是我<strong>第一次将程序移植到Linux平台, 也是第一次接触Linux嵌入式</strong></p><p>后来在一个实验室学习时接触到了ROS, 而那时Ubuntu18.04已经较为成熟了, 我就安装了个Ubuntu18.04的虚拟机在里面跟着刷了一遍ROS基础教程, 这回算是<strong>对Ubuntu的基本使用比较了解了</strong>. 不过那时其实并完全不了解ROS的最大作用是什么, 只是知道很牛逼, 跟着教程做了一遍, 没多久就忘了, 只是了解到有那么些概念😁 那时我以为Linux系统也就那样, 我在虚拟机体验到的就是它的全部了. 因此那时有同学和我讨论装Linux虚拟机好还是Windows, Linux双系统好时, 我的想法就是这系统又没那么便利, 误操作带来的危险性又那么大, 当然是装在虚拟机好.</p><p>而我装Windows, Ubuntu双系统的契机应该是<a href="/zh-CN/2019/03/30/我打算换电脑了/">我电脑的机械硬盘开始老化</a>, 速度变得极慢. 那应该是我大二下刚开学的时候, 我实在忍受不了在机械硬盘运行本身就很耗资源的Windows系统了, 而那时我的编程活动也开始多起来, 再加上我偶然得知Ubuntu能识别到已经存在的Windows系统并傻瓜式安装, 我就给自己<strong>装了个Windows, Ubuntu双系统</strong>. 不久后我的机械硬盘彻底不行了就买个一个1T的SSD. 不过换了硬盘后我也还是装的双系统, 因为我<strong>逐渐尝到了Linux系统的甜头</strong>.</p><blockquote><p>我在<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%94%A8Linux%E8%80%8C%E4%B8%8D%E6%98%AFWindows/">另一篇文章</a>写了自己对Linux和Windows的对比</p></blockquote><p>而随着我逐渐熟悉Ubuntu, 我开始像大多数Linux用户那样折腾自己的配置, 美化环境😏 期间也尝试了挺多东西, 到现在也形成了自己的使用习惯. 不过很尴尬的是在美化方面, 我经常看到这个好康的在Linux没有但macOS有的字眼. 所以<strong>我开始眼馋macOS</strong>. 不过那时我也就是眼馋, 因为我对比了一番, 发现macOS从接口, 生态等角度都不太适合做嵌入式开发就没有想过安一个试试. (我也在VMware里折腾过macOS虚拟机, 但和Ubuntu虚拟机一样装了没多久就删了)</p><p>而直到最近, 我看到了很详细的黑苹果安装教程, 加上我一个同学根据那份教程成功安上了黑苹果, 我也蠢蠢欲动了. 毕竟疫情期间闲着也是闲着+都用双系统了再多一个也不多. 于是我折腾一番<strong>给单硬盘安装了三个系统</strong>😁</p><p>P.S. 第一次体验macOS的本土包一开始连怎么删除文件都没搞懂, 还是现查的😅 使用逻辑与Windows/Linux差得真的太多了! 甚至因为别扭一度弃用了几天. 不过光是macOS下终端的美观程度就把俺勾回来了🤤</p><p>之前也看到网上有人装三系统的文章, 但基本都用了些杂牌子工具一通瞎操作… 所以我分享一下自己较为<strong>清爽</strong>的安装方法.</p><p>❗️ 我的电脑是真的一点不矫情, 安装很顺利, 不保证你的电脑上同样的不会出幺蛾子.</p><h2 id="关于镜像烧录"><a href="#关于镜像烧录" class="headerlink" title="关于镜像烧录"></a>关于镜像烧录</h2><h3 id="镜像烧录工具"><a href="#镜像烧录工具" class="headerlink" title="镜像烧录工具"></a>镜像烧录工具</h3><p>镜像烧录工具是唯一需要的第三方工具了. 这里给出两个我推荐的镜像烧录工具.</p><ul><li><a href="https://rufus.ie/" target="_blank" rel="noopener">Rufus</a> 这是一个干净而强大的镜像烧录工具, 我还<strong>没遇到过它不能烧录的镜像</strong>, 操作简单的同时也提供了一定的可自定义选项. 问题在于它只有Windows端和macOS端, <strong>没有Linux端</strong></li><li><a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">balenaEtcher</a> 这个工具是<strong>全平台</strong>的, 这点很棒, 但是它的问题是它<strong>无法烧录Windows镜像</strong>.</li></ul><h3 id="推荐的镜像烧录顺序"><a href="#推荐的镜像烧录顺序" class="headerlink" title="推荐的镜像烧录顺序"></a>推荐的镜像烧录顺序</h3><p>我推荐的镜像烧录顺序:</p><ol><li><p>将三个系统镜像都放到移动硬盘里, 提前下好balenaEthcer的便携版Linux客户端, Rufus便携版也都放在移动硬盘里. 这样有需要我同时插上硬盘和一个U盘, 无需安装烧录工具就可以烧录系统.</p><p>❗️balenaEtcher网站直连下载速度有些慢, 建议在有翻墙工具的时候就翻墙下好 (如果你本来就没有当我没说😁)</p></li><li><p>在Windows下用<strong>Rufus</strong>提前烧录好<strong>Windows安装盘</strong>备用.</p></li><li><p>在Ubuntu下用<strong>balenaEtcher</strong>烧录了<strong>macOS安装盘</strong>然后安装macOS, 然后用之前准备的Windows安装盘安装Windows. (此处为什么会在Ubuntu操作会在<a href="#更改EFI分区文件">后文</a>说明)</p></li><li><p>在Windows下把刚才的macOS安装盘或者Windows安装盘随便哪个用<strong>Rufus</strong>重新烧录成<strong>Ubuntu安装盘</strong>, 安装Ubuntu.</p></li><li><p>没了</p></li></ol><p>💡 也就是说推荐准备<strong>两个</strong>U盘. 如果你没有两个U盘那你可以跳过第二步, 然后只要保证身边有另外一台Windows电脑就好了.</p><p>烧录一个镜像大致十分钟, 而安装每个系统平均下来十五分钟, 因此全过程<strong>一个多小时</strong>就能搞定.</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>我安装系统的顺序是:</p><ol><li>macOS10.15.4</li><li>Windows10</li><li>Ubuntu18.04</li></ol><p>之所以是先安装macOS是因为看网上都说<strong>macOS要求EFI分区不小于200MB</strong>, 否则在安装时会提示无法安装. 然后我搜了搜EFI分区扩容, 似乎并没什么清爽的办法. 因此时刻准备着重装系统的我判定<strong>还是直接格式化硬盘来得清爽</strong>. 然后在安装的时候先安装macOS那它自己就会处理好这个事情, 不需要我担心😁</p><p>(不过我把三个系统都装完这个EFI分区也才用了120MB, 也不知道它要那么大干嘛)</p><p>而最后才安装Ubuntu是基于两方面考虑:</p><ol><li>如果先装Ubuntu就意味着得给Windows系统留下一定空间. 那么就需要在安装Ubuntu过程中”Installation Type”这一页选择<code>Something else</code>来<strong>自己给Linux系统分区</strong> (如果不选这种方式, 另外两种方式都会使用硬盘剩余的所有空间). 然而麻烦的是你不光需要给Ubuntu系统分一个主分区, 你还需要讲这个主分区分成几个逻辑分区, 而且每个逻辑分区的大小有一定的讲究. 我目前没有研究过这里的门道并且我对Ubuntu安装程序帮我规划的各个分区的大小没有不满. 因此我决定不去管这种事, <strong>我选择最后来安装Ubuntu, 让安装程序用我给它剩下的空间自己看着办</strong>😏</li><li>Ubuntu安装程序能识别电脑里已经安装的Windows系统 (识别不到我的黑苹果系统), 并<strong>自动处理好与Windows系统共存的配置</strong>, 将Windows添加到GRUB引导项中. 因为我的主力系统是Ubuntu而且我也很喜欢使用GRUB作为开机引导程序, 因此这帮我省了一些事.</li></ol><h3 id="macOS安装"><a href="#macOS安装" class="headerlink" title="macOS安装"></a>macOS安装</h3><p>我使用的黑苹果镜像是<a href="https://blog.daliansky.net/macOS-Catalina-10.15.4-19E266-Release-version-with-Clover-5107-original-image-Double-EFI-Version-UEFI-and-MBR.html" target="_blank" rel="noopener">在这个文章最后的百度云链接</a></p><p>❗️ 我安装完之后才从使用苹果系统的同学们那得知macOS10.15, 也就是Catalina目前bug还比较多, 外观上和10.14也没什么区别, 因此建议安装macOS<strong>10.14</strong>, 而不是10.15.</p><p>这个镜像很棒的一点是它不止包含一个macOS系统安装程序, <strong>还有一个Windows PE</strong>, 也就是一个可以从U盘启动的专门魔改过, 用于修复系统的Windows系统. 这个Windows PE中包含了大多数你在网上教你修复系统发中文教程中提到的各种看起来有点不靠谱的工具 😂</p><p>我安装macOS使用的是<a href="https://blog.daliansky.net/MacOS-installation-tutorial-XiaoMi-Pro-installation-process-records.html" target="_blank" rel="noopener">这个教程</a>. 跟着一步步操作就可以了. 安装好后发现有驱动问题等先放着不管, 把三个系统都装好再来看上面那个镜像的链接里提供的问题解决方案好了, 不然容易心情变得焦躁的 🤗</p><h4 id="更改EFI分区文件"><a href="#更改EFI分区文件" class="headerlink" title="更改EFI分区文件"></a>更改EFI分区文件</h4><p>看到网上说装黑苹果最重要的就是要有对应自己电脑型号的EFI文件, 过了这一关就八九不离十了.</p><p><a href="https://github.com/daliansky/Hackintosh#%E9%BB%91%E8%8B%B9%E6%9E%9C%E9%95%BF%E6%9C%9F%E7%BB%B4%E6%8A%A4%E6%9C%BA%E5%9E%8B%E6%95%B4%E7%90%86-by-%E6%88%91%E6%84%8F" target="_blank" rel="noopener">这里</a>是一份黑苹果爱好者们提供了EFI分区文件的笔记本和台式机的型号列表, 也有他们自己的安装过程分享. 我使用的是其中的<a href="https://github.com/YGQ8988/dell-3568" target="_blank" rel="noopener">Dell Inspiron 3568</a></p><p>💡 在安装前我也曾担心后续两个系统的安装会不会破坏已经安装好的macOS的EFI文件, 实验表明他们是互不干扰的, 不会看对方不顺眼就删掉对方 😏</p><h4 id="网卡问题"><a href="#网卡问题" class="headerlink" title="网卡问题"></a>网卡问题</h4><p>这似乎是在实体机安装黑苹果一定会有的问题, 有人是直接买了一个苹果能识别的网卡换上, 而我懒一点, 我买了一个有macOS驱动的外置网卡, Comfast的<strong>CF-811 AC</strong>, 很小一个, 不贵, 速度也很不错. macOS在使用这个外置网卡时不会认为在使用WiFi, 而是认为是接入了一个以太网. 唯一缺点是我还没有搞清如何让使用这样外置网卡的macOS连接上星巴克WiFi这样需要等它弹出登录页面才能用的公共WiFi–并不会有什么页面弹出 😓</p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>Windows的官方镜像可以在<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">I Tell You</a>的操作系统一栏找到, 而激活码在淘宝就可以买到, 只是需要一些搜索技巧 😏</p><p>在安装系统的第一步就会要你选择安装在哪里, 在此时创建一个想要的大小的分区选中就可以进行安装了. 因为我的硬盘是1TSSD, 所以我分了一个274G的分区给Windows, 绰绰有余. 如果我真用满了也意味着我该重装了.</p><h4 id="System-Reserved分区"><a href="#System-Reserved分区" class="headerlink" title="System Reserved分区"></a>System Reserved分区</h4><p>当你安好Windows系统后会发现在给Windows划分的分区前后多了两个分区, 一个叫<strong>System Reserved</strong>, 一个叫<strong>Microsoft Windows Recovery Environment</strong>如果你断定自己不会用到安装在硬盘的Windows系统的恢复模式 (实际上Windows安装盘的恢复模式或者Windows PE盘可能会是你遇到麻烦时的更好选择), 那么<strong>Microsoft Windows Recovery Environment</strong>这个分区可以随便删. 而<strong>System Reserved</strong>这个分区<strong>绝对不能随便删, 最好是别动</strong>. 血泪教训啊! 一次我看这分区不爽一气之下删掉了, 然后就因为缺少文件而无法启动Windows了…</p><p>🔗 <a href="https://www.zhihu.com/question/60154583" target="_blank" rel="noopener">Windows的System Reserved分区是什么以及能否删除</a></p><p>我找到了这个<a href="http://www.uefi.org/sites/default/files/resources/UEFI-Plugfest-WindowsBootEnvironment.pdf" target="_blank" rel="noopener">Windows Boot Environment - Murali Ravirala (Microsoft)</a>, 里面讲述了Windows系统的启动过程, 提到了这个分区的作用.</p><p>总结下来意思就是<strong>System Reserved</strong>这个分区不能随便删, 要删还要不会出错操作很麻烦, 因此就别动它了 🤦‍♂</p><p>💡 值得一提的是Windows现在有了<strong>开发人员模式</strong>, 开启这个模式后在Windows开发的体验会好很多, 不会经常弄出些乱七八糟的错误.</p><h3 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h3><p>Ubuntu系统的安装就跟着<a href="https://ubuntu.com/tutorials/tutorial-install-ubuntu-desktop#1-overview" target="_blank" rel="noopener">官网安装教程</a>来是最简洁正确的. 唯一需要注意的是在官网教程第六步时, 因为之前安装了Windows系统, Ubuntu安装程序会检测到已安装的Windows系统, 并给出一个<strong>Install Ubuntu alongside Windows 10</strong>的选项. 选择这个是这种情况下最简单的安装方式. 另外选择这个的话Ubuntu安装程序会自动把Windows系统加入到GRUB中, 属实舒服.</p><p><strong>系统安装就全部完成了!</strong> 🎉</p><h2 id="GRUB配置及开机美化"><a href="#GRUB配置及开机美化" class="headerlink" title="GRUB配置及开机美化"></a>GRUB配置及开机美化</h2><p>然后是我在这次重装前一直不确定的事: 是否能把macOS引导项也加入GRUB? 经过我的尝试答案是可以!</p><p>在网上搜索后我知道了怎么样来配置GRUB的引导项, 其实真心不难.</p><h3 id="引导项设置"><a href="#引导项设置" class="headerlink" title="引导项设置"></a>引导项设置</h3><p>第一步是进入<code>/etc/grub.d/</code>, 添加/编辑引导项. ❗️ 建议在先备份这个路径下的文件, 等确认改动成功了再删除备份也不迟.</p><p>在我的这个路径下有这样一些文件. 是的这里甚至有一个README 😂</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00_header</span><br><span class="line">05_debian_theme</span><br><span class="line">10_linux</span><br><span class="line">20_linux_xen</span><br><span class="line">20_memtest86+</span><br><span class="line">30_os-prober</span><br><span class="line">30_uefi-firmware</span><br><span class="line">40_custom</span><br><span class="line">41_custom</span><br><span class="line">README</span><br></pre></td></tr></tbody></table></figure><p>这个README的内容是这样的:</p><blockquote><p>All executable files in this directory are processed in shell expansion order.</p><p> 00_<em>: Reserved for 00_header.<br> 10_</em>: Native boot entries.<br> 20_*: Third party apps (e.g. memtest86+).  </p><p>The number namespace in-between is configurable by system installer and/oradministrator.  For example, you can add an entry to boot another OS as01_otheros, 11_otheros, etc, depending on the position you want it to occupy inthe menu; and then adjust the default setting via /etc/default/grub.</p></blockquote><p>也就是说:</p><ul><li><strong>00_</strong>开头的是为<code>00_header</code>这个文件保留的, <strong>10_</strong>开头的是系统自带的引导项, 这个稍后解释. <strong>20_</strong>开头的是一些第三方软件的东西, 比如<code>20_memtest86+</code>是一个叫memtest86+的内存测试软件 (虽然不知道是干啥的).</li><li>除了上面这三个前缀的文件名是可以自由改动的, 要把数字改成多少取决于你想让这个文件代表的引导项出现代GRUB引导菜单的第几个. (这个文件的顺序看起来就是最后生成出的<code>/boot/grub/grub.cfg</code>这个文件里引导项的顺序)</li><li>这些文件写好之后在<code>/etc/default/grub</code>这个文件可以调一调设置.</li></ul><p>一个引导项文件的写法示例 (也就是我的macOS的引导项文件):</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">exec tail -n +3 $0</span><br><span class="line"># This file provides an easy way to add custom menu entries.  Simply type the</span><br><span class="line"># menu entries you want to add after this comment.  Be careful not to change</span><br><span class="line"># the 'exec tail' line above.</span><br><span class="line"></span><br><span class="line">menuentry 'macOS Catalina 10.15.3' --class macosx {</span><br><span class="line">    insmod part_gpt</span><br><span class="line">    insmod fat</span><br><span class="line">    search --no-floppy --fs-uuid --set=root 67E3-17ED</span><br><span class="line">    chainloader /EFI/CLOVER/CLOVERX64.efi</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中前5行是<code>40_custom</code>中给出的注释, 我就抄过来了. 然后由<code>menuentry</code>起头声明一个引导项. 然后<code>--class</code>用来设置这个引导项的类型, 直观来说就是在GRUB界面里图标的名字. 此处的类型为<strong>macosx</strong>, 也就是说在我使用的GRUB主题的<code>icons</code>文件夹中有同名 (除了后缀名) 图标的话到时候这个引导项在GRUB界面里的文字前面的图标就是这个叫<code>macosx.png</code>的图标.</p><p>在这个引导项大括号里的内容是和在GRUB命令行进入一个系统需要输入的命令是一样的, 我感觉算是一种脚本? 我也不太懂, 只能说说大概理解:</p><ul><li>第一行指定硬盘分区表的格式</li><li>第二行指定文件系统</li><li>第三行指定在uuid为<strong>67E3-17ED</strong>的分区搜索引导项的启动文件</li><li>第四行指定这个引导项使用的启动文件 (因为黑苹果实际是有Clover启动的, 因此macOS引导项的指定启动文件为Clover的启动文件)</li></ul><p>💡 其中<code>insmod</code>是<strong>ins</strong>ert <strong>mod</strong>e的缩写.</p><h3 id="Grub-tone"><a href="#Grub-tone" class="headerlink" title="Grub tone"></a>Grub tone</h3><p>在<code>etc/default/grub</code>这个文件里可以进行的设置有<code>GRUB_CMDLINE_LINUX_DEFAULT</code>, 这个在显卡不兼容时常用到的设置, 也有<code>GRUB_THEME</code>这个设置GRUB图形界面的主题的, 甚至可以通过<code>GRUB_INIT_TUNE</code>可以设置开机彩铃 😂</p><p>GRUB tone的值是什么意思以及可以看<a href="https://breadmaker.github.io/grub-tune-tester/" target="_blank" rel="noopener">GRUB_INIT_TUNE tester</a>, 这里也提供了一些好听的铃声. 我用过这个超级马里奥音效:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_INIT_TUNE="1750 523 1 392 1 523 1 659 1 784 1 1047 1 784 1 415 1 523 1 622 1 831 1 622 1 831 1 1046 1 1244 1 1661 1 1244 1 466 1 587 1 698 1 932 1 1175 1 1397 1 1865 1 1397 1"</span><br></pre></td></tr></tbody></table></figure><p>但是这个音效声音大小无法调节, 只能是最大声, 真的很大声那种😏 所以虽然很好玩, 我后来还是取消了这个设置.</p><h3 id="最后微调"><a href="#最后微调" class="headerlink" title="最后微调"></a>最后微调</h3><p>调整完上面两个后运行<code>update-grub</code>来更新<code>/boot/grub/grub.cfg</code>. 最后可以到<code>/boot/grub/grub.cfg</code>进行最后微调 (如果需要的话).</p><h3 id="开机美化"><a href="#开机美化" class="headerlink" title="开机美化"></a>开机美化</h3><p>Ubuntu开机过程中一共有三处可以美化:</p><ul><li>GRUB theme</li><li><a href="https://wiki.archlinux.org/index.php/plymouth" target="_blank" rel="noopener">Plymouth</a> theme</li><li><a href="https://wiki.archlinux.org/index.php/GDM" target="_blank" rel="noopener">GDM</a> theme</li></ul><p>我的GRUB主题是<a href="https://www.gnome-look.org/p/1009533/" target="_blank" rel="noopener">Aurora Penguinis GRUB2 Theme</a>, Plymouth主题是<a href="https://www.gnome-look.org/p/1009239/" target="_blank" rel="noopener">Aurora Penguinis Plymouth 2 Theme</a>. 而Gnome能使用的GDM主题我没看到什么我中意的, 就自行改动了一下<code>/usr/share/gnome-shell/theme/ubuntu.css</code>里的样式, 给登录界面加了个背景图片.</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#lockDialogGroup</span> {</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#2c001e</span> <span class="built_in">url</span>(file:///home/leo/Pictures/login-screen/custom.jpg);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-position</span>: center; }</span><br></pre></td></tr></tbody></table></figure><h2 id="关于启动"><a href="#关于启动" class="headerlink" title="关于启动"></a>关于启动</h2><p>最后放上几个在搜索资料过程中看到的好资料:</p><ul><li><a href="https://help.ubuntu.com/community/Installation?_ga=2.230386906.774703488.1586350910-773002345.1585209571" target="_blank" rel="noopener">Ubuntu系统安装教程考古</a> 在<strong>Either Shrink the Windows C: Drive to Make Room for Linux OR Turn off Windows Updating</strong>这部分可以找到有人遇到的Windows系统更新却破坏了Ubuntu系统是怎么回事. (也很明显我这不会出现这问题)</li><li><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">阮一峰-计算机是如何启动的？</a> 在这里可以看到启动为什么叫<strong>boot</strong>, 也可以对启动过程中发生了什么有个大概了解.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一下我在同一个SSD里同时安装Ubuntu, Windows, macOS三个系统并以GRUB作为开机引导的经验. 说实话过程并不复杂.&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
      <category term="macOS" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/macOS/"/>
    
      <category term="启动" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%90%AF%E5%8A%A8/"/>
    
      <category term="GRUB" scheme="https://leojhonsong.github.io/zh-CN/categories/%E5%90%AF%E5%8A%A8/GRUB/"/>
    
    
  </entry>
  
  <entry>
    <title>Graphviz简要语法</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/03/12/Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/03/12/Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/</id>
    <published>2020-03-11T19:46:33.000Z</published>
    <updated>2020-04-04T06:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://emden.github.io/" target="_blank" rel="noopener">Graphviz</a>是一个很强大的<strong>图形可视化工具</strong>. 它使用<strong>DOT</strong>语言来描述图形, 但它并不单纯是个绘图软件, 而是能接入程序, 进行函数调用流程, 决策树, 数据结构, 日志系统等图形关系生成, 而且可以是<strong>交互式</strong>的 (不过我暂时没研究过所以不太了解). 暂且不提这些扩展功能, graphviz的语法允许我们仅通过文字描述能绘制出样式极其丰富的图形, 这大大方便了对图形的改动的跟踪.</p><a id="more"></a><h2 id="有关官方文档"><a href="#有关官方文档" class="headerlink" title="有关官方文档"></a>有关官方文档</h2><p>graphviz.org这个网站也不知道是不是停止维护了, 所有除了指向其他人的项目的链接都是无效链接了… 我在上面放的graphviz的官网链接是<a href="https://gitlab.com/graphviz/graphviz" target="_blank" rel="noopener">graphviz的GitLab repo</a>提供的地址. (实际上我觉得这个项目对文档的维护<strong>很烂</strong>, 描述得很不清楚, 有些地方甚至有错误. 这也是为什么我要自己总结一篇常用语法).</p><p>官方给出的有助于编写DOT文件的文档我觉得就这几个:</p><ul><li><a href="https://emden.github.io/_pages/doc/info/lang.html" target="_blank" rel="noopener">DOT语言概述</a></li><li><a href="https://emden.github.io/_pages/doc/info/attrs.html" target="_blank" rel="noopener">节点, 边线, 图形的属性列表</a></li><li><a href="https://emden.github.io/_pages/doc/info/shapes.html" target="_blank" rel="noopener">节点的三种形状设定方式及节点的样式详解</a> (此处又不得不吐槽graphviz开发组的文档组织真的差)</li><li><a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">箭头的头部形状参数详解</a></li><li><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">graphviz中可用颜色及颜色主题列表</a></li></ul><p>但其实给我帮助最大的是<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener"><strong>被graphviz开发组嫌弃的旧版文档 (dot布局版)</strong></a></p><p>❗️ 因为我最常使用的是<strong>dot</strong>布局所以此处涉及的内容大部分为dot布局下的情况.</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>还是先来个Hello World 😏</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph G{</span><br><span class="line">    Hello -&gt; World;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/helloworld.svg?20" alt=""></p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>因为graphviz许多概念解释起来会套娃, 要理解概念A要先理解概念B, 要理解概念B则需要先知道什么是概念A 🤤 因此这里先放上一些常用属性来快速入门.</p><p>🌟 不明白到底如何使用属性的话点<a href="#属性">这里</a>快速跳转后文的实例.</p><table><thead><tr><th>用途</th><th>属性名</th><th>可选值</th><th>作用对象</th><th>备注</th></tr></thead><tbody><tr><td>轮廓颜色</td><td><code>color</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>节点, 边线, 簇</td><td></td></tr><tr><td>填充颜色</td><td><code>bgcolor</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>簇, 图</td><td><code>fillcolor</code>会覆盖<code>bgcolor</code></td></tr><tr><td>填充颜色</td><td><code>fillcolor</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>节点, 边线, 簇</td><td>需要与<code>style=filled</code>一起使用. 如果设置了<code>style=filled</code>但没有设置<code>fillcolor</code>那么<code>color</code>的值将被同时用于轮廓和填充</td></tr><tr><td>字体颜色</td><td><code>fontcolor</code></td><td><a href="https://emden.github.io/_pages/doc/info/colors.html" target="_blank" rel="noopener">可用颜色及颜色主题列表</a></td><td>节点, 边线, 簇, 图</td><td></td></tr><tr><td>箭头方向</td><td><code>dir</code></td><td>“forward”, “back”, “both”, “none”</td><td>边线</td><td>正向/反向/双向/无箭头</td></tr><tr><td>箭头形状</td><td><code>arrowhead</code> <code>arrortail</code></td><td>见备注</td><td>边线</td><td>graphviz提供了极其丰富的箭头形状值, 常用值参见<a href="https://emden.github.io/_pages/doc/info/attrs.html#k:arrowType" target="_blank" rel="noopener">这里</a>, 箭头形状值的完整说明见<a href="https://emden.github.io/_pages/doc/info/arrows.html" target="_blank" rel="noopener">这里</a></td></tr><tr><td>样式</td><td><code>style</code></td><td><a href="https://emden.github.io/_pages/doc/info/attrs.html#k:style" target="_blank" rel="noopener">各对象样式说明</a></td><td>节点, 边线, 簇, 图</td><td>emmm这个style很难准确地翻译为中文, 因为这个属性被很笼统地赋予了四种对象…总的来说是在描述这个对象长什么样, 是虚线的还是加粗的又或是点点的</td></tr><tr><td>边线风格</td><td><code>splines</code></td><td>none, line, polyline, curved, ortho, spline</td><td>图</td><td>不显示边线/线段 (false)/线段 (true)/弧线/直角折线/常规. 到底什么样详见<a href="https://emden.github.io/_pages/doc/info/attrs.html#d:splines" target="_blank" rel="noopener">splines说明</a> emmmm我感觉<strong>polyline</strong>和<strong>spline</strong>并没有区别…再次吐槽graphviz开发组的混乱逻辑 😩</td></tr><tr><td>label水平对齐方式</td><td><code>labeljust</code></td><td>“l”, “r”</td><td>图, 簇</td><td>“l”就是和图/簇的左边界对齐, “r”就是和图/簇的右边界对齐. 如果父级显性设置了这一属性, 子图会继承这一属性. <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span> 实际上还有一个可选值, 就是不设置这个属性, 那么label就会居中对齐.</td></tr><tr><td>label垂直对齐方式</td><td><code>labelloc</code></td><td>“t”, “b”, “c”</td><td>节点, 图, 簇</td><td>对于图和簇只有”t”和”b”是可用的, 即标签只能设置在图/簇的顶部或者底部. 如果父级显性设置了这一属性, 子图会继承这一属性. 而对于一个节点, 只有当它的高度大于label这个属性才是可用的.</td></tr><tr><td>节点排布方向</td><td>rankdir</td><td>TB, BT, LR, RL</td><td>图</td><td>从上到下/从下到上/从左到右/从右到左</td></tr></tbody></table><h3 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout (布局)"></a>Layout (布局)</h3><p>💡 graphviz有一点不好的是节点在画布上的位置是<strong>由算法决定</strong>的, 不能<strong>完全</strong>自己设定, 因此有时候无法让图变得那么美观.</p><p>graphviz提供了多种<strong>用于排布节点, 边线箭头头部, 边线标签位置</strong>的布局算法.</p><p>因为了解graphviz的布局算法有助于我们更好的布局, 此处简单翻译一下<a href="https://emden.github.io/_pages/pdf/dotguide.pdf" target="_blank" rel="noopener">被现在graphviz开发组嫌弃的旧版文档 (dot布局版)</a>描述的<strong>dot布局</strong>的图形绘制主要的四步:</p><ol><li><p>通过反转一些边线的指向来打破输入图形 (我猜这个输入图形说的是.dot文件) 中出现的所有循环 (因为dot布局算法是基于非循环图形的)</p></li><li><p>给各节点赋予不同的等级 (<code>rank</code>). (比如在一个top-to-bottom方向的图中等级决定了节点的纵坐标) 连接跨度超过一个等级的节点的边线会被分割成一串”虚拟”节点以及单位长度的边线</p><p>💡 后文会提及对节点的rank是可以进行一些设置的.</p></li><li><p>给同等级的节点排序, 避免绘图时出现边线的交叉 (估计只是减少交叉?)</p></li><li><p>在让边线尽可能短的情况下设定节点的横坐标, 然后绘制边线 (同样是假设是top-to-bottom方向的图)</p></li></ol><p>下面给出一些主要布局算法的简单说明和图例.</p><p>💡 以下布局的图例除了最后一个都来自<a href="https://emden.github.io/gallery/" target="_blank" rel="noopener">graphviz-gallary</a></p><h4 id="dot"><a href="#dot" class="headerlink" title="dot"></a>dot</h4><p>用于绘制<strong>有向图</strong>, 他的布局算法原理上面已经说了, 特点是绘制出的图<strong>很有层次</strong>.</p><p>❗️ 注意dot布局和DOT语言不是一个东西.</p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/cluster.png?20" alt="img"></p><h4 id="neato"><a href="#neato" class="headerlink" title="neato"></a>neato</h4><p>用于绘制<strong>无向图</strong>. neato布局算法的原理是构建一个虚拟物理模型并不断对其迭代最终得到一个<strong>最低总能量排布</strong> (low-energy configuration). 这个虚拟物理模型具体指的是在每个节点间放置一个<strong>理想弹簧</strong>, 这样得到的布局通常很合理. (在统计学中这种算法也被称作<strong>多维缩放</strong>). neato布局很适合用于<strong>通信网络</strong>及<strong>计算机程序</strong>的绘制.</p><p>💡 当图较大 (超过100个节点)时就该考虑换成fdp或者sfdp布局了</p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/ER.png?30" alt="在这里插入图片描述"></p><h4 id="fdp"><a href="#fdp" class="headerlink" title="fdp"></a>fdp</h4><p>同样是基于弹簧模型. 区别在于fdp算法的迭代是在试图减小节点间弹簧的力的大小而不是弹簧能量大小.</p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/fdpclust.png?40" alt="在这里插入图片描述"></p><h4 id="sfdp"><a href="#sfdp" class="headerlink" title="sfdp"></a>sfdp</h4><p>为大规模图而生的多尺度版fdp</p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/JGD_BIBD@bibd_17_3.gif?40" alt="在这里插入图片描述"></p><p>上面这个图得自🔗 <a href="http://yifanhu.net/GALLERY/GRAPHS/index.html" target="_blank" rel="noopener">A Gallery of Large Graphs</a>. 这个网站还有<strong>很多</strong>很壮观的图😳</p><h4 id="twopi"><a href="#twopi" class="headerlink" title="twopi"></a>twopi</h4><p>径向布局.</p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/twopi2.png?50" alt="在这里插入图片描述"></p><h4 id="circo"><a href="#circo" class="headerlink" title="circo"></a>circo</h4><p>圆形布局. 很适合有许多环路结构的图, 比如电信网络.</p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/circo.png?30" alt="在这里插入图片描述"></p><h3 id="有关三种主要描述对象"><a href="#有关三种主要描述对象" class="headerlink" title="有关三种主要描述对象"></a>有关三种主要描述对象</h3><p>DOT语言主要描述三种对象: <strong>graph</strong>, <strong>node</strong>, <strong>edge</strong>. 这里分别翻译为<strong>图</strong>, <strong>节点</strong>, <strong>边线</strong>. 每一种对象有各自可以设置的一组属性.</p><h4 id="Graph-图"><a href="#Graph-图" class="headerlink" title="Graph (图)"></a>Graph (图)</h4><p>最外层的graph (main graph)可以被设定为<strong>有向图</strong><code>digraph</code>(directed graph)或是<strong>无向图</strong><code>graph</code>(undirected graph). main graph内可以用<code>subgraph</code>来定义一个节点和边线的集合. 也可以通过设定最外层图为<code>strict digraph</code>或者<code>strict graph</code>来禁用<strong>multi-edges</strong>. 也就是说<code>strict digraph</code>会让有向图中一个指向节点和一个被指向节点间只能有一条边线 (不过反过来还可以有一条, 也就是两节点间最多两条边线), <code>strict graph</code>则会让无向图中两节点间只能有一条边线.</p><p>最外层的图又称top-level graph, root graph (反正开发组文档都没能统一这东西的叫法). 图可以有子图 (subgraph), 子图会继承父级的显式设置的大部分属性. 有一种特殊的子图被称为<a href="#Cluster-簇"><strong>簇</strong></a>.</p><h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node (节点)"></a>Node (节点)</h4><p>一个节点会<strong>在第一次在DOT文件中出现时被创建</strong>.</p><h4 id="Edge-边线"><a href="#Edge-边线" class="headerlink" title="Edge (边线)"></a>Edge (边线)</h4><p>一条边线会在几个节点被用<code>-&gt;</code>边线操作符连接时被创建.</p><p>💡 <strong>在graphviz中可以直接用中文作为节点名.</strong></p><h3 id="Label-标签"><a href="#Label-标签" class="headerlink" title="Label (标签)"></a>Label (标签)</h3><p>如果你想要显示的标签中有空格, 那通过把节点名用<code>""</code>括起来可以实现, 当然显式声明标签内容是更好的选择. 而<strong>如果你想让一些节点显示相同的标签那就必须显式声明节点的标签了</strong>, 因为节点名不能重复.</p><p>💡 label中可以使用转义字符比如<code>\n</code>来实现多行标签.</p><h4 id="HTML-like-Label"><a href="#HTML-like-Label" class="headerlink" title="HTML-like Label"></a>HTML-like Label</h4><p>为了能提供更丰富的样式, dot布局支持使用HTML语法的HTML-like标签 (看了下似乎其他布局不支持这种东西).</p><p>具体可用语法格式参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 总结下来就是目前支持以下几种类HTML元素:</p><ul><li>斜体 &lt;i&gt;</li><li>粗体 &lt;b&gt;</li><li>下划线 &lt;u&gt;</li><li>上划线 &lt;o&gt;</li><li>删除线 &lt;s&gt;</li><li>下角标 &lt;sub&gt;</li><li>上角标 &lt;sup&gt;</li><li>指定字体 &lt;font&gt;</li><li>换行符 &lt;br /&gt;</li><li>表格 &lt;table&gt; &lt;tr&gt; &lt;td&gt;</li><li>图片 &lt;img&gt;</li><li>水平/竖直分割线 &lt;hr&gt; &lt;vr&gt;</li></ul><p>❗️ 要注意这种类HTML标签只是<strong>借鉴自HTML</strong>, 和HTML元素并不完全一样, 因此<strong>并不支持html中其他写法和属性</strong>. 再比如HTML中是没有上面这个<code>&lt;vr&gt;</code>tag的😅</p><p>不得不说类HTML标签确实极大地提升了灵活性, 让我们能写出奇形怪状的节点形状, 能在标签中嵌入图片等, 详情参见<a href="https://emden.github.io/_pages/doc/info/shapes.html#html" target="_blank" rel="noopener">graphviz官方文档-HTML-Like Labels</a>. 不过这东西写起来确实麻烦一些…</p><blockquote><p>一个展示类HTML标签能带来的丰富样式的例子</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">  rankdir=LR</span><br><span class="line">  node [shape=plaintext]</span><br><span class="line">  a [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD ROWSPAN="3" BGCOLOR="yellow"&gt;class&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD PORT="here" BGCOLOR="lightblue"&gt;qualifier&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  b [shape=ellipse style=filled</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE BGCOLOR="bisque"&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="3"&gt;elephant&lt;/TD&gt;</span><br><span class="line">          &lt;TD ROWSPAN="2" BGCOLOR="chartreuse" VALIGN="bottom" ALIGN="right"&gt;two&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" ROWSPAN="2"&gt;</span><br><span class="line">            &lt;TABLE BGCOLOR="grey"&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;corn&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD BGCOLOR="yellow"&gt;c&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">              &lt;TR&gt; &lt;TD&gt;f&lt;/TD&gt; &lt;/TR&gt;</span><br><span class="line">            &lt;/TABLE&gt;</span><br><span class="line">          &lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="white"&gt;penguin&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD COLSPAN="2" BORDER="4" ALIGN="right" PORT="there"&gt;4&lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">  c [</span><br><span class="line">    label=&lt;long line 1&lt;BR/&gt;line 2&lt;BR ALIGN="LEFT"/&gt;line 3&lt;BR ALIGN="RIGHT"/&gt;&gt;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  subgraph { rank=same b c }</span><br><span class="line">  a:here -&gt; b:there [dir=both arrowtail=diamond]</span><br><span class="line">  c -&gt; b</span><br><span class="line">  d [shape=triangle]</span><br><span class="line">  d -&gt; c [</span><br><span class="line">    label=&lt;</span><br><span class="line">      &lt;TABLE&gt;</span><br><span class="line">        &lt;TR&gt;</span><br><span class="line">          &lt;TD BGCOLOR="red" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">          &lt;TD&gt;Edge labels&lt;BR/&gt;also&lt;/TD&gt;</span><br><span class="line">          &lt;TD BGCOLOR="blue" WIDTH="10"&gt; &lt;/TD&gt;</span><br><span class="line">        &lt;/TR&gt;</span><br><span class="line">      &lt;/TABLE&gt;</span><br><span class="line">    &gt;</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/html-like_label.svg?60" alt=""></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是通过<code>name=value</code>形式来设置的. 节点与边线的属性需要放在<code>[]</code>方括号中.</p><blockquote><p>一个展示属性写法以及属性能做些什么的例子</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    size ="4,4"; //设置图形尺寸为4英寸长宽</span><br><span class="line">    方形节点 [shape=box];  /*这是一种注释写法*/</span><br><span class="line">    方形节点 -&gt; 上面是加粗线 [style=bold];</span><br><span class="line">    上面是加粗线 -&gt; 和下面的对比;</span><br><span class="line">    方形节点 -&gt; 上面是虚线 [style=dotted];</span><br><span class="line">    方形节点 -&gt; 重量更大导致垂直指下的节点[weight=4];</span><br><span class="line">    "和下面的对比" -&gt; { make_string; 上面是有标签的红线}  //可以一次连接多个节点</span><br><span class="line">    上面是虚线 -&gt; make_string;</span><br><span class="line">    edge [color=red];  // 这是另一种注释写法</span><br><span class="line">    方形节点 -&gt; 上面是有标签的红线 [label="100 times"];</span><br><span class="line">    make_string [label="多行\n标签"];</span><br><span class="line">    node [shape=box,style=filled,color=".7 .3 1.0"];</span><br><span class="line">    和下面的对比 -&gt; 在节点默认属性改变后才创建的节点;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/attr.svg" alt=""></p><h4 id="常用属性的默认值"><a href="#常用属性的默认值" class="headerlink" title="常用属性的默认值"></a>常用属性的默认值</h4><p><strong>图</strong>的默认属性:</p><ul><li>labeljust=”c”</li><li>labelloc=”b” (簇的默认值为”t”)</li><li>clusterrank=”local”</li><li>compound=false</li><li>rankdir=TB</li></ul><p><strong>节点</strong>的默认属性是:</p><ul><li>shape=ellipse</li><li>width=0.75</li><li>height=0.5</li><li>标签为节点名</li><li>labelloc=”c”</li></ul><h3 id="Cluster-簇"><a href="#Cluster-簇" class="headerlink" title="Cluster (簇)"></a>Cluster (簇)</h3><p>簇是一种会将属于这个子图的元素都<strong>框在一个长方形里</strong>的特殊子图. 如果一个子图的名字以<strong>cluster</strong>开头那么这个子图就会被认为是一个簇 (这个判定方式好暴力😅). 但是如果在根图中设置了<code>clusterrank=none</code>那么簇这种特殊的子图会被禁用.</p><p>这里我又要来吐槽graphviz开发组了! 看看他们是怎么<a href="https://emden.github.io/_pages/doc/info/attrs.html#a:clusterrank" target="_blank" rel="noopener">说明clusterrank这个属性</a>的:</p><blockquote><p>the modes “global” and “none” <strong>appear</strong> to be identical, both turning off the special cluster processing.</p></blockquote><p>为什么官方开发组都在用这种表推测的语气啊… 🙃这也太迷惑了</p><p>如果根图中设置了<code>compound=true</code>, 那么dot布局允许用边线连接节点和簇的边框. 这是通过设置边线的<code>lhead</code>和<code>ltail</code>属性来实现的. 这样以来, 虽然边线仍然是从一个节点指向另一个节点的, 但是设置了<code>lhead</code>或者<code>ltail</code>的一侧<strong>会看起来像是被簇的边框盖住了</strong>.</p><blockquote><p>一个使用簇, 并且有连接节点与簇的边线的例子</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    compound=true;</span><br><span class="line">    subgraph cluster0 {</span><br><span class="line">        a -&gt; b;</span><br><span class="line">        a -&gt; c;</span><br><span class="line">        b -&gt; d;</span><br><span class="line">        c -&gt; d;</span><br><span class="line">    }</span><br><span class="line">    subgraph cluster1 {</span><br><span class="line">        e -&gt; g;</span><br><span class="line">        e -&gt; f;</span><br><span class="line">    }</span><br><span class="line">    b -&gt; f [lhead=cluster1];</span><br><span class="line">    d -&gt; e;</span><br><span class="line">    c -&gt; g [ltail=cluster0,lhead=cluster1];</span><br><span class="line">    c -&gt; e [ltail=cluster0];</span><br><span class="line">    d -&gt; h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/cluster.svg?20" alt=""></p><h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><p>以下是几条我认为<strong>用来提示图的美观程度</strong>的语法.</p><h3 id="优化布局"><a href="#优化布局" class="headerlink" title="优化布局"></a>优化布局</h3><p>知道了上面提到的<a href="#Layout-布局">布局的原理</a>我们就可以进行一些更个性化的布局, 比如设置<code>rankdir</code>可以设置节点的排布方向, 默认为<strong>TB</strong>, top to bottom, 也就是从上到下. 可选值有<strong>TB</strong>, <strong>BT</strong>, <strong>LR</strong>, <strong>RL</strong>.</p><p>再比如设置节点的<code>rank</code>属性我们可以改变节点的布局. <code>rank</code>的可选值有: <strong>same</strong>, <strong>min</strong>, <strong>source</strong>, <strong>max</strong>, <strong>sink</strong>.</p><blockquote><p>一个展示设置rank属性能达到什么效果的例子 (代码和图形都截自旧版文档, 因为代码没给全我也懒得写, 就这么放着吧👍)</p></blockquote><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/image-20200313010630547.png?60" alt="image-20200313010630547"></p><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/image-20200313010749024.png?80" alt="image-20200313010749024"></p><h3 id="Node-Port-节点端口"><a href="#Node-Port-节点端口" class="headerlink" title="Node Port (节点端口)"></a>Node Port (节点端口)</h3><p>Graphviz提供了节点端口来指定边线应连接到节点的什么位置. 这提供了更高的个性化. 当没有被指定节点端口时边线是指向节点中心并在节点边界处被截断的.</p><p>一共有两种节点端口:</p><ul><li>基于方位的8个端口: n,ne, e, se, s, sw, w, nw</li><li>基<code>record</code>结构的端口: <code>shape=record</code>的节点可以以记录结构来定义端口. 而因为有&lt;TABLE&gt;元素的<a href="#html-like-label">HTML-like标签</a>与可以作为<code>shape=record</code>的扩展甚至替代品, 每个&lt;TD&gt;元素的<strong>PORT</strong>属性也都提供了一个到该单元格的端口名.</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">    node [shape = box]</span><br><span class="line">    node0:n -&gt; node1:n [label = "n"]</span><br><span class="line">    node2:ne -&gt; node3:ne [label = "ne"]</span><br><span class="line">    node4:e -&gt; node5:e [label = "e"]</span><br><span class="line">    node6:se -&gt; node7:se [label = "se"]</span><br><span class="line">    node8:s -&gt; node9:s [label = "s"]</span><br><span class="line">    node10:sw -&gt; node11:sw [label = "sw"]</span><br><span class="line">    node12:w -&gt; node13:w [label = "w"]</span><br><span class="line">    node14:nw -&gt; node15:nw [label = "nw"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="Graphviz%E7%AE%80%E8%A6%81%E8%AF%AD%E6%B3%95/node_port.svg" alt=""></p><h3 id="Concentrators-边线合并"><a href="#Concentrators-边线合并" class="headerlink" title="Concentrators (边线合并)"></a>Concentrators (边线合并)</h3><p>在根图中设置<code>concentrate=true</code>将允许边线融合来避免图变得一团乱麻.</p><p>边线合并的条件是:</p><ul><li>他们的方向相同</li><li>他们有相同的起点或终点</li><li>他们的长度大于1</li></ul><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="VSC的dot语言支持插件"><a href="#VSC的dot语言支持插件" class="headerlink" title="VSC的dot语言支持插件"></a>VSC的dot语言支持插件</h3><p>我最喜欢的画graphviz图的工具是VSC里的<a href="https://marketplace.visualstudio.com/items?itemName=joaompinto.vscode-graphviz" target="_blank" rel="noopener">Graphviz(dot)语言支持插件</a>, 是的它<strong>只支持dot布局</strong>. 虽然也可以用graph来声明顶层图, 但绘制出来的仍然是有向图🤦‍♂ 不过无伤大雅, 我基本只画dot布局的图.</p><p>VSC里也有提供直接在markdown文档中渲染graphviz的dot布局图的插件, 不过我觉得这样的兼容性太低, 没有这个插件的人只会看到一串代码, 因此我选择的是一个能提供<strong>DOT语法高亮</strong>, 能提供<strong>自动刷新</strong>的预览图, <strong>能生成svg图</strong>的插件. 只要把这个svg插入markdown就能在文档看到graphviz图了, 而每次更改图片后只需要覆盖原本的svg即可更新md文档中的图, 也很方便的👍</p><h3 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h3><p>也有很多在线网站提供在线绘制graphviz图的服务, 上网一搜就有, 不过我感觉做得都半斤八两, 体验不算好, 我认为只能拿来救急用, 因此也不给出推荐了.</p><p>💡 实际上有些工具绘制出的图都有细微风格差异, 你可以挨个体验出一个最喜欢的风格的工具.</p><p>不过比较有意思的是这个<a href="https://sketchviz.com/new" target="_blank" rel="noopener">sketchviz</a>, 绘制出的是<strong>手绘风</strong>的图.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://emden.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Graphviz&lt;/a&gt;是一个很强大的&lt;strong&gt;图形可视化工具&lt;/strong&gt;. 它使用&lt;strong&gt;DOT&lt;/strong&gt;语言来描述图形, 但它并不单纯是个绘图软件, 而是能接入程序, 进行函数调用流程, 决策树, 数据结构, 日志系统等图形关系生成, 而且可以是&lt;strong&gt;交互式&lt;/strong&gt;的 (不过我暂时没研究过所以不太了解). 暂且不提这些扩展功能, graphviz的语法允许我们仅通过文字描述能绘制出样式极其丰富的图形, 这大大方便了对图形的改动的跟踪.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Graphviz" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/Graphviz/"/>
    
    
  </entry>
  
  <entry>
    <title>广受好评的机器人相关 (数学/物理/控制/计算机类) 网课列表</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/02/22/%E5%B9%BF%E5%8F%97%E5%A5%BD%E8%AF%84%E7%9A%84%E6%95%B0%E5%AD%A6-IT%E7%B1%BB%E7%BD%91%E8%AF%BE%E5%88%97%E8%A1%A8/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/02/22/%E5%B9%BF%E5%8F%97%E5%A5%BD%E8%AF%84%E7%9A%84%E6%95%B0%E5%AD%A6-IT%E7%B1%BB%E7%BD%91%E8%AF%BE%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-22T08:18:42.000Z</published>
    <updated>2020-02-22T08:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近很多国内学校因为疫情开始在网上上课, 不过我们学校的网课体验很差… 网络问题暂且不说, 既然都是网课何不去学习那些广受好评的版本? 列出一些广受好评的课程链接, 希望能帮到一些同样在被迫害的同学们 (也方便我以后极速复习) 💩</p><a id="more"></a><p>❗️ 好的学习资料有很多, 种类也很多 (网课, 书, 网站, 习题集, 项目…) 为了避免内容太过杂乱此处只讨论网课.</p><p>P.S. 我觉得网课的好处是有老师的讲解十分易懂, 同时通过倍速播放可以极速学习 😏</p><p>💡 为达到最好效果, 我的做法是把网课视频都下载下来, 在vlc中<strong>设置播放时显示当前文件名及时间</strong>并倍速播放. 到关键点, 或者想要记笔记的地方就暂停并截屏保存到一个文件夹 (截屏软件推荐)</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="MIT-线性代数"><a href="#MIT-线性代数" class="headerlink" title="MIT-线性代数"></a>MIT-线性代数</h3><p>特点: 教授的粉笔巨大无比 😂</p><p>相较于国内老师从行列式入手, 这门课<strong>从几何空间的角度更加直观揭示线代的内核</strong>.</p><p>🔗<a href="https://www.bilibili.com/video/BV1zx411g7gq" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">网易公开课链接</a></p><h3 id="MIT-概率论"><a href="#MIT-概率论" class="headerlink" title="MIT-概率论"></a>MIT-概率论</h3><p>🔗<a href="https://www.bilibili.com/video/BV19s41167TE" target="_blank" rel="noopener">b站链接</a></p><h3 id="张宇考研-数学-微积分-线性代数-概率论"><a href="#张宇考研-数学-微积分-线性代数-概率论" class="headerlink" title="张宇考研-数学 (微积分, 线性代数, 概率论)"></a>张宇考研-数学 (微积分, 线性代数, 概率论)</h3><p>🔗<a href="https://www.youtube.com/watch?v=ghNtuabD6Ss&amp;list=PLRMOX8QaZK8z4yLzXRkiPO38R911V7TQE" target="_blank" rel="noopener">YouTube链接</a></p><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2><h3 id="北航-理论力学"><a href="#北航-理论力学" class="headerlink" title="北航-理论力学"></a>北航-理论力学</h3><p>王琪老师讲得特别贴合实际, 有许多很生动的例子 👍</p><p>🔗<a href="https://www.bilibili.com/video/BV1k7411T7QU" target="_blank" rel="noopener">b站链接</a></p><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="MIT-信号与系统"><a href="#MIT-信号与系统" class="headerlink" title="MIT-信号与系统"></a>MIT-信号与系统</h3><p><strong>奥本海姆亲授版!</strong> 相信国内大部分学信号与系统这门课的同学的课本都是奥本海姆编写的. 虽然这个是二十多年前录制的课程了, 演示时使用的是很古老的覆盖片和只有绿色荧光的电脑屏幕, 但是奥本海姆教授讲解得十分清晰, 处理信号的核心思想贯穿始终, 让人学得十分系统性.</p><p>🔗<a href="https://www.bilibili.com/video/BV1xy4y167DD" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/free?pid=M8AROL7GG&amp;mid=M8AROOU9F" target="_blank" rel="noopener">网易公开课链接</a></p><h3 id="MIT-数字信号处理"><a href="#MIT-数字信号处理" class="headerlink" title="MIT-数字信号处理"></a>MIT-数字信号处理</h3><p>认准奥本海姆教授 👍</p><p>🔗<a href="https://www.bilibili.com/video/BV1uk4y1R771" target="_blank" rel="noopener">b站链接</a></p><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><h3 id="MIT-计算机科学及编程导论"><a href="#MIT-计算机科学及编程导论" class="headerlink" title="MIT-计算机科学及编程导论"></a>MIT-计算机科学及编程导论</h3><p>这门课主要针对<strong>从未接触过计算机科学或编程的人</strong>. 基于<strong>python</strong>讲解了基础的程序编写, 调试, 算法, 数据结构, 面向对象等内容, 比起知识的深度更注重知识的广度 (内容较为简单).</p><p>🔗<a href="https://www.bilibili.com/video/BV1m4411U7gs" target="_blank" rel="noopener">b站链接</a> 🔗<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fbianchengdaolun.html" target="_blank" rel="noopener">网易公开课链接</a></p><h3 id="翁恺-C语言程序设计"><a href="#翁恺-C语言程序设计" class="headerlink" title="翁恺-C语言程序设计"></a>翁恺-C语言程序设计</h3><p>C语言入门课.</p><p>🔗<a href="https://www.bilibili.com/video/BV1sJ411E7St" target="_blank" rel="noopener">b站链接</a> 🔗<a href="https://www.icourse163.org/course/ZJU-9001" target="_blank" rel="noopener">中国大学MOOC链接</a></p><h3 id="清华-数据结构与算法"><a href="#清华-数据结构与算法" class="headerlink" title="清华-数据结构与算法"></a>清华-数据结构与算法</h3><p>🔗<a href="https://www.bilibili.com/video/BV1jt4y117KR" target="_blank" rel="noopener">b站链接</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近很多国内学校因为疫情开始在网上上课, 不过我们学校的网课体验很差… 网络问题暂且不说, 既然都是网课何不去学习那些广受好评的版本? 列出一些广受好评的课程链接, 希望能帮到一些同样在被迫害的同学们 (也方便我以后极速复习) 💩&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>文件命名规则总结</title>
    <link href="https://leojhonsong.github.io/zh-CN/2020/02/06/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
    <id>https://leojhonsong.github.io/zh-CN/2020/02/06/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-06T07:34:23.000Z</published>
    <updated>2020-02-06T07:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果待处理文件的文件名中含有一些特殊字符, 有许多程序会因为考虑不完善 (或者说程序员偷懒) 而出现识别不到文件, 文件处理出错, 结果不符合意图, 甚至程序崩溃的问题. 而为了方便自己偷懒, 我总结了一些命名文件的规则.</p><a id="more"></a><p>💡 我并不是说文件名命名必须遵循这些准则, 只是在程序设计/输入不够严谨 (也就是想偷懒的情况下) 这样的命名准则是最不容易导致错误的👍</p><h2 id="文件名中只应该包含数字-字母-汉字-下划线-连字符-句点"><a href="#文件名中只应该包含数字-字母-汉字-下划线-连字符-句点" class="headerlink" title="文件名中只应该包含数字, 字母, 汉字, 下划线, 连字符, 句点"></a>文件名中只应该包含数字, 字母, 汉字, 下划线, 连字符, 句点</h2><p>许多特殊字符会让程序出错, 下面举几个例子:</p><ul><li><code>文件名里 有空格.jpg</code> 这样的文件名很可能让程序以为要处理的文件的名字是<code>文件名里</code>, 因而找不到文件或者处理了错误的文件. 而<code>有空格.jpg</code>会被当成无效参数, 多余字符.</li><li><code>文件名里/有左斜杠.avi</code> 这样的文件名在很多程序里会被认为是一个名为<code>文件名里</code>的文件夹下的<code>有左斜杠.avi</code>文件, 因此可能得到<strong>没有<code>文件名里</code>这个文件夹</strong>的报错</li><li><code>文件名里(有)括号.gif</code> 比如在markdown文档中用<code>![](文件名里(有)括号.gif)</code>来引用这个gif, 在有的markdown渲染器会被渲染为<strong>)括号.gif</strong>. 因为前一个)被认为是markdown引用图片的<code>![]()</code>语法的结束符了.</li><li>在一些较老的程序中汉字也算是一种特殊字符. 比如在python2中如果不特意注意编码格式转换问题的话中文很容易被读取为乱码. 当然现在的程序大多是兼容汉字的. (Python2在已经终止维护了🕯)</li></ul><blockquote><p>空格用下划线代替, 其他字符用连字符代替</p></blockquote><p>如果你原本想要包含这些特殊字符在文件名中来表达一些逻辑关系, 我的做法是用_来代替空格, 用-来代替其他字符.</p><h2 id="当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字-并且位数不足的用0在左侧占位"><a href="#当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字-并且位数不足的用0在左侧占位" class="headerlink" title="当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位"></a>当文件名包含有排序意图的数字时应当用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</h2><p>曾经我很困惑下面这两种情况的文件夹排序为什么不是从小到大的, 后来我发现前者是因为文件系统<strong>不把汉字数字作为排序用的数字</strong> (有意思的是我Ubuntu系统和Windows系统里图一情况排序不一样), 后一个是因为文件系统是<strong>逐字比较</strong>而不是把一串数字作为一个数 (windows系统和Ubuntu系统排序图2情况时都能正常排序)</p><blockquote><p>图一 Ubuntu系统下含汉字数字文件名排序</p></blockquote><p><img src="%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/image-20200207181027438.png" alt=""></p><blockquote><p>图二 百度云里含数字文件名排序</p></blockquote><p><img src="%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/Screenshot_20200207_181843.jpg" alt=""></p><p>因此如果想在文件名中包含有排序功能的数字, 或者表达顺序之意时应当<strong>用阿拉伯数字而不是汉字, 并且位数不足的用0在左侧占位</strong>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果待处理文件的文件名中含有一些特殊字符, 有许多程序会因为考虑不完善 (或者说程序员偷懒) 而出现识别不到文件, 文件处理出错, 结果不符合意图, 甚至程序崩溃的问题. 而为了方便自己偷懒, 我总结了一些命名文件的规则.&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>我开始用集成开发工具部署我的博客</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/10/06/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/10/06/%E6%88%91%E5%BC%80%E5%A7%8B%E7%94%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-10-05T21:34:39.000Z</published>
    <updated>2019-10-29T21:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天分别尝试了用<strong>Travis CI</strong>和<strong>GitHub Action</strong>部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢<strong>GitHub Action</strong>, 因为它就是Github的, 集成度更高. 而且<strong>Github Action</strong>支持的触发条件更多样一些.</p><a id="more"></a><p>先分别放上我使用Travis和GitHub Action时的配置文件</p><p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/blob/02ce864f1cbe09d82c0dfe6f617b36737344d41e/.travis.yml" target="_blank" rel="noopener">Travis配置文件</a></p><p>🔗 <a href="https://github.com/LeoJhonSong/LeoJhonSong.github.io/tree/Root/.github/workflows" target="_blank" rel="noopener">GitHub Action配置文件</a></p><h2 id="GitHub-Action的缺点"><a href="#GitHub-Action的缺点" class="headerlink" title="GitHub Action的缺点"></a>GitHub Action的缺点</h2><p>可以看出Travis要更<strong>成熟</strong>一些, 提供了一些很方便的功能, 比如要添加ssh known hosts, travis只需要</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">addons:</span></span><br><span class="line">  <span class="attr">ssh_known_hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">github.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ssh.github.com</span></span><br></pre></td></tr></tbody></table></figure><p>而在GitHub Action中需要</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">login</span> <span class="string">ssh</span> <span class="string">and</span> <span class="string">git</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">~/.ssh</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">-e</span> <span class="string">"Host github.com\nStrictHostKeyChecking no\nIdentityFile ~/.ssh/id_rsa_github_action"</span> <span class="string">&gt;</span> <span class="string">~/.ssh/config</span></span><br></pre></td></tr></tbody></table></figure><p>看起来GitHub Action的配置更短, 但这句是强行不验证github.com的服务器, 并没有Travis中的配置直观, 合理.</p><p>另外GitHub Action暂时还不支持<strong>缓存</strong>, 照<a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts" target="_blank" rel="noopener">这个样子</a>即便实现了也是很别扭的东西… 我觉得缓存还是一个很重要的功能. 一个最简单的例子: 没有缓存的public文件夹导致刚换到GitHub Action时我的每篇博客<strong>更新时间与我的最后一次上传时间相同</strong> (hexo通过对比source文件夹和public文件夹的时间戳来判断更新时间). 目前我是通过将master分支下载到public文件夹来蛮力解决的.</p><h2 id="GitHub-Action的优点"><a href="#GitHub-Action的优点" class="headerlink" title="GitHub Action的优点"></a>GitHub Action的优点</h2><p>当然GitHub Action的优点也是明显的, 比如我的代码的<strong>托管平台和持续集成平台合二为一</strong>, 不说管理起来方便了多少至少内心通达了😆</p><p>另外GitHub Action的支持的触发条件更加丰富, 比如用下面代码可以指定只有<code>Root</code>分支有推送且有<strong>source/en</strong>文件夹以外的文件变动时才运行. 换句话说只有配置文件或者中文博客内容发生变动时才运行.</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Root</span></span><br><span class="line">    <span class="attr">paths-ignore:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'source/en/**'</span></span><br></pre></td></tr></tbody></table></figure><p>在<a href="https://docs.travis-ci.com/user/conditional-builds-stages-jobs/" target="_blank" rel="noopener">Travis的文档</a>中我并没有看到可以这么操作.</p><p>再有就是GitHub Action支持一个项目有<strong>多个</strong>workflow, 比如我的博客就同时在运行两个工作流: 一个生成并部署中文博客, 一个生成并部署英文博客. 这是一个十分吸引人的功能! 并且GitHub正试图将workflow打造成能<strong>轻松分享, 引用</strong>的东西, 这能极大减少人们写这些繁琐低级的配置文件的时间. 实际上GitHub已经<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">初步成功了</a>. 在我的配置中就引用了两个GitHub官方发布的action.</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">8.10</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="number">8.10</span><span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>目前来说GitHub Action体验着很不错!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天分别尝试了用&lt;strong&gt;Travis CI&lt;/strong&gt;和&lt;strong&gt;GitHub Action&lt;/strong&gt;部署博客. 集成开发确实十分方便, 让人可以专注于写作, 而且对本地环境依赖性更小了 (在线写作也是可以的). 两者比较下来我更喜欢&lt;strong&gt;GitHub Action&lt;/strong&gt;, 因为它就是Github的, 集成度更高. 而且&lt;strong&gt;Github Action&lt;/strong&gt;支持的触发条件更多样一些.&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="CI/CD" scheme="https://leojhonsong.github.io/zh-CN/categories/CI-CD/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown安利&amp;Typora简要使用教程</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/23/Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2019-09-23T06:45:31.000Z</published>
    <updated>2020-03-16T16:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在此我来安利一下<strong>Markdown</strong>和<strong>Typora</strong>.</p><a id="more"></a><h2 id="Markdown安利"><a href="#Markdown安利" class="headerlink" title="Markdown安利"></a>Markdown安利</h2><h3 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h3><p>Markdown是一门语言, 一门轻量级的<strong>标记语言</strong> (Markup Language). 有没有觉得这个词很眼熟? 是的, HTML全称<strong>HyperText Markup Language</strong>. Markdown和HTML同属于MarkupLanguage(Markdown是一门Markup Language是Markdown作者的恶趣味), 它们与C, Python等编程语言并不是一类东西. <strong>Markup</strong>这个词源自<strong>印刷业</strong>, 指的是在电子排版技术出现之前人们对印刷物内容的排版进行标记的方式. 比如一段文字应当是<strong>粗体</strong>, <em>斜体</em>,<u>有下划线</u>还是<del>有删除线</del>, 使用什么字体, 字体大小, 左页边距应当是多少, 一张图片该放在哪里, 多大等等…</p><p>💡 也就是说以前的人们在将原稿最终印刷出来前想知道会印成什么样基本靠脑补, 而现在我们称这个由标记语言文件得到最终效果的过程为<strong>渲染</strong> (render).</p><p>而之所以我们说Markdown是一门<strong>轻量级</strong>的标记语言是因为在Markdown的语法比HTML等标记语言要简洁太多😆</p><ul><li>一</li><li>二</li></ul><p>比如👆 上面这个列表的Markdown实现代码为</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>一</span><br><span class="line"><span class="bullet">- </span>二</span><br></pre></td></tr></tbody></table></figure><p>而HTML实现代码为</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>但Markdown有时候也会让人觉得太过轻量级以至于缺少一些语法, 比如这个<u>下划线</u>其实是用HTML标签实现的. 好在你也可以在Markdown文件中写HTML, 如今的Markdown渲染工具基本都支持这个功能.</p><p>也是由于上面这个原因, 在Markdown作者们推出的<a href="https://commonmark.org/" target="_blank" rel="noopener"><strong>CommonMark</strong></a>的基础上有了添加了更多语法的各种Markdown超集, 比如GitHub发布的<a href="https://github.github.com/gfm/" target="_blank" rel="noopener"><strong>GitHub FlavoredMarkdown</strong></a>.</p><h3 id="Markdown应用广泛吗"><a href="#Markdown应用广泛吗" class="headerlink" title="Markdown应用广泛吗"></a>Markdown应用广泛吗</h3><p>实际上如今Markdown的使用相当广泛, 只要是支持所谓<strong>富文本</strong>的社区/论坛等, 比如说<strong>GitHub</strong>, <strong>知乎</strong>, <strong>Stack OverFlow</strong>, <strong>CSDN博客</strong>, <strong>Wikipedia</strong>都是使用的Markdown. 另外因为Markdown和HTML的转换十分容易, 目前大多个人博客都是编辑Markdown格式的文章再生成HTML页面, 比如我正在码的也是Markdown文件.</p><p>再有就是目前大多数项目根目录的<strong>README</strong>文档都是Markdown格式, 而在线查看项目代码时GitHub等代码托管网站都会自动将项目中所有Markdown文件渲染出来.</p><h3 id="为什么我们使用Markdown"><a href="#为什么我们使用Markdown" class="headerlink" title="为什么我们使用Markdown"></a>为什么我们使用Markdown</h3><p>以下是网上的一些总结和我个人的体会.</p><ol><li>Markdown的设计理念是易读易写, 因此<strong>即便不渲染Markdown文件的可读性也很高</strong>,这让没有Markdown渲染工具的人也能很好地阅读, 而如果要脑力渲染HTML, 一会就眼晕了.</li><li>这种格式能让文档很方便的排列为很简洁好看的排版, <strong>能让人专注于书写内容</strong>, 不必费神排版</li><li>支持代码按语言的语法高亮</li><li><strong>能很方便的进行版本管理</strong>. 在要进行版本管理的项目中的Word文件简直是毒瘤, 不操作一番的话版本管理工具比如git并不能识别word文件具体变化, 而使用纯文本的Markdown能让每次的更改被体现出来!</li><li><strong>占用空间小</strong> (可以想一想一个word文档的大小)</li><li><strong>能很容易地转为多种格式</strong>. Markdown和HTML是兄弟关系,因此Markdown文件能轻松转换成<strong>HTML</strong>文件格式以及HTML文件能轻易转换为的格式(<strong>PDF</strong>, <strong>jpg</strong>, <strong>Epub</strong>等)是显而易见的. 通过一些额外工具(比如<a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>)的帮助,Markdown文件还能一键转化为更多文件格式,比如<strong>LaTeX</strong>, <strong>Word</strong>,<strong>OpenOffice</strong>, <strong>Media Wiki</strong>等.</li><li>能方便的插入图片, 表格, 超链接等</li><li>兼容HTML语法, 因此我们想让页面显示成什么样就可以显示成什么样</li><li>可以兼容LaTeX语法, 可以很方便的显示复杂公式</li><li>还可以兼容<strong>Graphviz</strong>, <strong>Mermaid</strong>等流程图工具等等…</li></ol><h3 id="Markdown简明语法"><a href="#Markdown简明语法" class="headerlink" title="Markdown简明语法"></a>Markdown简明语法</h3><ul><li><p>一个标题以几个<code>#</code>开头, 空格后是文字. 以#的个数来表示第几级标题</p></li><li><p>以 - 开头接一个空格开始一个子弹列表, 以 1. 接空格开始一个有序列表</p></li><li><p>在要加粗的词两侧加 ** 来加粗. 如果要打出 ** 等特殊字符要在星号前加 \ 来转义 </p></li><li><p>在<strong>行内代码</strong>两侧加 ` .  注意这不是单引号, 在我键盘上在<kbd>Esc</kbd> 键下面. 当然这个不只是用来放行内代码的, 也可以放别的.</p></li><li><p>在代码块上下行加 ``` , 第一个```后写代码的语言.</p></li><li><p>在Typora这个软件里插入图片很容易, 直接<code>Ctrl V</code>粘贴就好了, 或者右键, 里面有插入图片的按键. 插入图片的markdown语法是</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">当图片失效时此处显示的文字</span>](<span class="link">图片地址</span>)</span><br></pre></td></tr></tbody></table></figure></li><li><p>插入超链接的语法和插入图片的语法很像, 此处举例说明. 这是点击进入百度的链接👉 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></tbody></table></figure></li><li><p>表格用<code>|</code>分隔每个元素, 第一行是各列的名字, 第二行的 <code>|</code>间是<code>-</code>, 分隔列名和值. 以下是一个例子</p></li></ul><table><thead><tr><th>第一列</th><th>第二列</th><th>第三列</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td></tr></tbody></table><ul><li>更详细的语法说明在Typora内可以查看Typora自带的Markdown语法参考手册</li></ul><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569274096465.png" alt="1569274096465"></p><h2 id="Typora安利"><a href="#Typora安利" class="headerlink" title="Typora安利"></a>Typora安利</h2><p>那么用什么软件来写Markdown呢? 认准<a href="https://typora.io/#download" target="_blank" rel="noopener"><strong>Typora</strong></a>!</p><p>Typora的优点多到我不想写 (不其实是单纯不想写了), 最突出的优点我觉得是它的<strong>颜值</strong>,以及<strong>能直接将图片粘贴到文件中</strong>.</p><h3 id="Typora快速入门"><a href="#Typora快速入门" class="headerlink" title="Typora快速入门"></a>Typora快速入门</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>在<strong>Themes</strong>一栏可以切换软件的主题</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569271897771.png" alt="1569271897771"></p><h4 id="大纲视图"><a href="#大纲视图" class="headerlink" title="大纲视图"></a>大纲视图</h4><p>可以按这个<strong>OutLine</strong>或者按左下角的小圆圈触发大纲视图, 点击大纲视图里的标题可以快速跳转.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272130639.png" alt="1569272130639"></p><h4 id="源代码视图"><a href="#源代码视图" class="headerlink" title="源代码视图"></a>源代码视图</h4><p>按左下角这个<kbd>&lt;/&gt;</kbd>可以切换到源代码视图</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272534032.png" alt="1569272534032"></p><h4 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h4><p>右下角这里可以选择进行拼写检查的语言或者关闭这个功能.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272445049.png" alt="1569272445049"></p><h4 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h4><p>按这个<strong>Preference</strong>可以进行更多偏好设置.</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1569272312746.png" alt="1569272312746"></p><p>以下是我的推荐设置</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051240.png" alt=""></p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20200227124912356.png" alt="image-20200227124912356"></p><p>勾选<strong>对网络图片应用上述规则</strong>那直接粘贴从浏览器复制的图片时Typora会自动将该图片下载到这个指定文件夹.</p><p>忽略单个换行让Typora遵循GFM: 单个换行不渲染为换行, 两个换行才渲染为换行</p><p><img src="Markdown%E5%AE%89%E5%88%A9-Typora%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/TIM%E5%9B%BE%E7%89%8720190924051204.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在此我来安利一下&lt;strong&gt;Markdown&lt;/strong&gt;和&lt;strong&gt;Typora&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Markdown" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/Markdown/"/>
    
    
  </entry>
  
  <entry>
    <title>意识到了我的中文有多差</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%84%8F%E8%AF%86%E5%88%B0%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AD%E6%96%87%E6%9C%89%E5%A4%9A%E5%B7%AE/</id>
    <published>2019-09-13T13:46:47.000Z</published>
    <updated>2019-09-13T13:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子别人给我分享了<a href="https://www.byvoid.com/" target="_blank" rel="noopener">这个博客</a>, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!</p><a id="more"></a><p>先不提这个博主喜爱音韵学, 单说同样是理工科出身的博主, 我的表达能力和思想深度比他差了太多.</p><p>通常在解释一段程序时我会想好一会来组织语言, <strong>将我使用这段代码的意图尽可能体现出来, 描述尽可能准确, 有条理</strong>. 我对此体会良多: 当我刚开始接触一个领域, 在网上看资料时常常无法确定我理解得对不对, 需要结合多篇文章才能确定. 这是因为<strong>作者们自身接触这些许久, 无意识的省略了一些话</strong>. 但我认为文章既然要写出来就应该能让所有人无障碍的看懂, 不然只给自己看的话何不就放到自己github仓库?</p><p><a href="https://akaedu.github.io/book/index.html" target="_blank" rel="noopener">Linux C编程一站式学习</a>和<a href="https://www.pyimagesearch.com" target="_blank" rel="noopener">pyimagesearch</a>的文章就让人觉得文章读起来很流畅很易懂, 不会浪费时间在理解文章上. 比如<a href="https://www.pyimagesearch.com/2016/04/18/install-guide-raspberry-pi-3-raspbian-jessie-opencv-3/" target="_blank" rel="noopener">这篇文章</a>曾带我轻松完成了困扰了我好几天的如何在树莓派上安装OpenCV的问题. 这个问题现在当然不会像前年那样困扰我, 但能有这样一篇好懂的文章指导我迅速完成我当然是十分乐意的.</p><p>因此我总是试图让我的文章能达到同样水准. 但我发现这很难. 说来可笑, 很多时候我甚至不知道怎么样去描述我的操作🤦‍ 而让文章有条理同样不是一件容易的事. 我感觉这和写一篇议论文围绕一个中心套用总分总的文章结构就可以写不一样, 我总是喜欢把一个主题的东西一股脑放到一篇文章里, 但我发现一方面<strong>文章太长会让人失去读下去的兴趣</strong>, 另一方面<strong>什么东西都往一篇文章里放会让文章失其重点</strong>. 我又不是在写书, 不如将一个主题的内容再按照几个重点分成几篇文章. 可<strong>将一篇文章分割为主题更明确的多篇文章</strong>对我来说并不是易事…</p><p>至于说<strong>byvoid</strong>的文章有思想深度, 从<a href="https://www.byvoid.com/zht/blog/why-the-usa-is-so-boring-1" target="_blank" rel="noopener">这篇文章</a>可见一斑. 我也喜欢旅游, 并且因为我小时候见了许多很美的自然景观, 我更倾向于体验一处的文化. 到一处游览后能有像<strong>byvoid</strong>这种深度的心得正是我所想努力做到的. 但一是我的文笔不够好,二是我并没有做功课去研究旅游地的文化.</p><p>从<strong>byvoid</strong>的文章能体会到中文的魅力: 用得好了读起来十分流畅, 四字成语言简意赅地表达出了意思, 很多用以佐证的诗句更是回味无穷… 这只是我个人的体会, 我也知道很粗浅. 当然我并不后悔初高中没有投入大量精力背诵各种诗句, 品鉴各大文豪的文章: 体会不到这些的魅力时我背下来又有什么用呢?</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子别人给我分享了&lt;a href=&quot;https://www.byvoid.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个博客&lt;/a&gt;, 看了以后我意识到自己语文学得太不到家了, 实在对不起初高中语文老师!&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://leojhonsong.github.io/zh-CN/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>更好的Shebang使用方式</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/13/%E6%9B%B4%E5%A5%BD%E7%9A%84shebang%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2019-09-12T16:57:25.000Z</published>
    <updated>2019-09-13T09:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux系统的脚本第一行我们通常用<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener">shebang</a>语句来指明解释器路径, 一方面有的脚本没有文件后缀名, 需要通过shebang语句指明系统才知道要用什么解释器运行. 另一方面有时候为了兼容性我们会指明使用标准位置的系统安装版本解释器.</p><p>但我发现有时候我们并不能确定使用者把我们需要类型的解释器装到了地方, 如果我们只想指出<strong>使用的解释器类型</strong>而不是具体路径, 可以使用<code>/usr/bin/env</code>命令. 比如如果我们想用Python3解释器执行一个脚本, 可以在第一行加:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br></pre></td></tr></tbody></table></figure><p><code>env</code>会调用用户<strong>$PATH</strong>中首先出现的解释器版本.</p><p>当然对于更复杂的情况更建议专门写一段程序来决定用哪个解释器.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Linux系统的脚本第一行我们通常用
&lt;a href=&quot;https://zh.wikipedia.org/wiki/Shebang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shebang&lt;/a&gt;语句来指明解释器路径, 一方面有的脚本没有文件后缀名,
      
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础语法</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/12/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/12/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2019-09-11T19:50:22.000Z</published>
    <updated>2020-03-17T04:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇</p><a id="more"></a><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><table><thead><tr><th>版本</th><th>实现方式</th><th>特点</th></tr></thead><tbody><tr><td>CPython</td><td>C语言写的Python</td><td>速度快</td></tr><tr><td>JPython</td><td>由Java编写的Python</td><td>可以直接调用Java的各种函数库</td></tr><tr><td>PyPy</td><td>由rPython编写的Python</td><td>更灵活, 易于使用和试验</td></tr><tr><td>IronPython</td><td>以. NET和Mono实现的Python</td><td>面向NET和ECMA CLI的Python实现</td></tr><tr><td>ZhPy</td><td>只是把Python翻译了一遍而已</td><td>又称中蟒, 可以完全用中文编程. 但中蟒目前已经停止更新了.</td></tr></tbody></table><p>我们通常所说的Python是<strong>CPython</strong>, 👇Python官方页面提供的是CPython</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1565579206457.png" alt="1565579206457"></p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Python这种语言有<strong>Python2</strong>和<strong>Python3</strong>两个版本, 两者语法有少许不同, 比如Python2和Python3中<code>print()</code>的使用有区别, Python2和Python3中<code>input()</code>接受的数据类型有区别等.</p><p>最新的Python2对大部分Python2, 3不同的语法做了兼容, 而在Python3对Python2的语法兼容性很差, 但是提供了一个叫<a href="https://docs.python.org/zh-cn/3.7/library/2to3.html" target="_blank" rel="noopener">2to3</a>的脚本帮助我们将Python2的程序转换为Python3的程序.</p><h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p><strong>万物皆对象</strong></p><p>python在设计初始是一种<strong>面向对象</strong>语言.</p><p>💡 面向对象是一种<strong>编程范式</strong></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Python是一门<strong>动态类型</strong>语言</p><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>在Python3中有了一个新特性: <strong>类型注解</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><p>正如其名, 注解只是标注一下, 有了类型注解的程序和没有类型注解的程序运行起来没有区别, 但它能帮助程序员更好的发现问题, 也能让IDE提供更准确的代码补全和语法检查.</p><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>有时候为了保证程序的严谨性我们会检查一下变量是不是我们设想它应该是的类型, 这个时候我们用 <code>isinstance()</code></p><p>之所以不使用 <code>type()</code> 是因为 <code>type()</code> 不会认为子类是一种父类类型, 不考虑继承关系. 举例说明:</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571027624789.png" alt="1571027624789"></p><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>❗️ <strong>我们可以给不可变对象重新赋值, 但其内存地址会改变</strong>. 以下是体现给可变对象/不可变对象重新赋值时它们的内存地址变化的例子.</p><p>💡 <code>id()</code>能获取一个变量的内存地址</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571022411897.png" alt="1571022411897"></p><h4 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number (数字)"></a>Number (数字)</h4><ul><li>int (整数)</li><li>long (长整数)</li><li>float (浮点数, 即小数)</li><li>bool (布尔值, 即 <code>True</code> 和 <code>False</code> )</li></ul><p>Python中的Number我认为是比较特殊的, 因为它<strong>在内存中占用的空间大小是变动</strong>的.(在CPython中是如此, 但不知道为什么在IronPython下不是)</p><p>💡 用<code>sys.getsizeof()</code>可以知道一个变量的占用的内存大小</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571022628668.png" alt="1571022628668"></p><h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String (字符串)"></a>String (字符串)</h4><h4 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple (元组)"></a>Tuple (元组)</h4><h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>可变对象可能带来的危险举例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(l = [])</span>:</span></span><br><span class="line">    l.append(<span class="string">'add'</span>)</span><br><span class="line">    print(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">myfunc()</span><br></pre></td></tr></tbody></table></figure><h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List (列表)"></a>List (列表)</h4><p>💡 <strong>string</strong>和<strong>tuple</strong>都是特殊的<strong>list</strong></p><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set (集合)"></a>Set (集合)</h4><h4 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary (字典)"></a>Dictionary (字典)</h4><p>👇 在网上偷的<strong>string, tuple, list, dictionary的突出区别比较</strong>.</p><table><thead><tr><th>名字</th><th>是否可变</th><th>是否可迭代</th><th>是否可切片</th><th>访问方式</th><th>写法举例</th></tr></thead><tbody><tr><td>string</td><td>no</td><td>yes</td><td>yes</td><td>下标索引</td><td>“abcd”</td></tr><tr><td>tuple</td><td>no</td><td>yes</td><td>yes</td><td>下标索引</td><td>(‘a’,‘b’,‘c’,‘d’,‘abcd’)</td></tr><tr><td>list</td><td>yes</td><td>yes</td><td>yes</td><td>下标索引</td><td>[‘a’,‘b’,‘c’,‘d’,‘abcd’]</td></tr><tr><td>dictionary</td><td>yes</td><td>yes</td><td>no</td><td>关键字索引</td><td>{‘1’:‘a’,‘2’:‘b’}</td></tr></tbody></table><h3 id="Python中有关对象需要注意的问题"><a href="#Python中有关对象需要注意的问题" class="headerlink" title="Python中有关对象需要注意的问题"></a>Python中有关对象需要注意的问题</h3><p>python中向函数传递参数只是<strong>引用传递</strong>: 如果参数为可变对象, 在函数中变化会影响引用的这个变量, 而不可变对象不会. 在向类传递参数时也是如此.</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571033275137.png" alt="1571033275137"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="Python内置帮助文档"><a href="#Python内置帮助文档" class="headerlink" title="Python内置帮助文档"></a>Python内置帮助文档</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help()</span><br></pre></td></tr></tbody></table></figure><p>调用<code>help()</code>后就会进入Python内置帮助文档, 然后输入想查的类名/函数名/属性名就可以看到对应的帮助文档.</p><p>:bulb: 要注意输入的只有名字, 不带括号什么的, 以及要看一个包里的函数文档时需要先引用该包. 比如如果想查看<strong>time.time()</strong>的帮助文档, 首先<code>import time</code>, 然后输入<code>help()</code>进入帮助文档, 然后输入<code>time.time</code>, 就会看到<strong>time.time()</strong>函数的帮助文档. 按一次<kbd>q</kbd>退出<strong>time.time()</strong>的文档, 再按一次<kbd>q</kbd>退出帮助文档返回交互式Python界面.</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在Python中 <code>#</code> 开头的为注释</p><h4 id="特殊注释"><a href="#特殊注释" class="headerlink" title="特殊注释"></a>特殊注释</h4><h5 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h5><p>shenbang (hashbang) 指的是以 <code>#!</code> 开头的语句. Linux操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数. 因为在很多语言中以 <code>#</code> 开头的是注释, 所以不会影响程序.</p><h5 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h5><p>有的python文件是这么开头的:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure><p>第一行是给<strong>Linux系统</strong>的程序加载器看的, 因此在Windows下不需要这句, 第二句是指定文件的编码格式为<strong>UTF-8</strong>, 避免文件中的<strong>非ASCII字符</strong>被识别为乱码.</p><h5 id="docstring"><a href="#docstring" class="headerlink" title="docstring"></a>docstring</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(int x, int y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这里是docstring, 是特殊的注释, 能让IDE, 编辑器在鼠标移动到有docstring的函数, 类上时显示这段docstring</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = func(i)</span><br></pre></td></tr></tbody></table></figure><h3 id="条件语句及循环"><a href="#条件语句及循环" class="headerlink" title="条件语句及循环"></a>条件语句及循环</h3><h4 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if, elif, else"></a>if, elif, else</h4><p>下面是按a &lt; 10, 10 &lt; a &lt; 20, 20 &lt; a &lt; 30, a &gt; 30分类的举例.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">20</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> a &lt; <span class="number">30</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>另外有一种one liner会很喜欢的用法:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span> <span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p>上面这句与下面这句等效.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span> &gt; <span class="number">3</span>:</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><h4 id="生成器-·迭代器·range"><a href="#生成器-·迭代器·range" class="headerlink" title="生成器 ·迭代器·range"></a>生成器 ·迭代器·range</h4><p>语法类似于<a href="#切片">切片</a></p><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><p><strong>推导式comprehensions</strong>（又称解析式）, 是Python的一种独有特性.<strong>推导式是可以从一个数据序列构建另一个新的数据序列的结构体</strong>. 换句话说能从一组数据中求出满足条件的新数据, 比如a, b两个等长列表中都为偶数的项的乘积. 共有三种推导式, 在Python2和3 中都有支持:</p><ul><li>列表推导式</li><li>字典推导式</li><li>集合推导式</li></ul><p>列表推导式的语法:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [output_expression <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> expression]</span><br></pre></td></tr></tbody></table></figure><p>使用举例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">names = [<span class="string">'Bob'</span>,<span class="string">'Tom'</span>,<span class="string">'alice'</span>,<span class="string">'Jerry'</span>,<span class="string">'Wendy'</span>,<span class="string">'Smith'</span>]</span><br><span class="line">LONG_NAMES = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> len(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">a = [x*y <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> x &gt; <span class="number">2</span> <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> y &lt; <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>因为tuple, string其实都是特殊的列表, 所以列表, 字符串, 元组都可以进行切片.</p><p>语法: l_sliced = a[begin : end : step]</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">l_sliced = l[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure><p>在没有<strong>numpy</strong>库的情况下<strong>多维切片</strong>是通过推导式实现的:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">b = [a[i][:<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>)]</span><br></pre></td></tr></tbody></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>💡 要注意函数名后的 <code>()</code> 也是一种运算符, 称为<strong>函数调用运算符</strong>. 如果调用函数的时候不加()只会创建一个该函数的对象而不会调用它.</p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>python中以 <code>def</code> 关键字定义函数, 结构如下:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(参数列表)</span>:</span></span><br><span class="line">    函数主体</span><br></pre></td></tr></tbody></table></figure><p>python中的函数可以有返回值也可以没有返回值</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(l)</span>:</span></span><br><span class="line">    l.appeend(<span class="string">'add'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></tbody></table></figure><h3 id="用字典来实现case"><a href="#用字典来实现case" class="headerlink" title="用字典来实现case"></a>用字典来实现case</h3><p>示例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'111'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'222'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printdefault</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic = {</span><br><span class="line">    <span class="string">'a'</span>: print1,</span><br><span class="line">    <span class="string">'b'</span>: print2,</span><br><span class="line"><span class="string">'default'</span>: printdefault}</span><br><span class="line"></span><br><span class="line">i = input(<span class="string">'input: '</span>)</span><br><span class="line">main = dic[i <span class="keyword">if</span> (i != <span class="string">'a'</span> <span class="keyword">or</span> i != <span class="string">'b'</span>) <span class="keyword">else</span> <span class="string">'default'</span>]</span><br><span class="line">main()</span><br></pre></td></tr></tbody></table></figure><h3 id="编码格式-1"><a href="#编码格式-1" class="headerlink" title="编码格式"></a>编码格式</h3><p>字符串经过<strong>编码（encode）</strong> 就成为了一堆数据, 反过来, 数据经过<strong>解码（decode）</strong> 就变回我们认识的字符串.</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/encode_decode.png" alt="img"></p><p>指定文件编码格式为 <code>utf-8</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8">💡</span> 如果不指定文件编码格式在有的Python2版本中无法识别中文, 即便是中文注释也会报错.</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Unicode_Decoding_and_Encoding.png" alt="Unicode Decoding and Encoding"></p><p>Linux系统默认编码格式是<strong>UTF-8</strong>, 系统语言是简体中文时Windows10的编码格式是<strong>GB2312</strong> (也称GBK, 国标扩展, cp936)</p><p>在python中 <code>str</code> 类型数据都以Unicode码点格式储存, 因此直接打印字符串会看到字符为’\u’开头</p><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">f.read()</span><br><span class="line">f.write(<span class="string">"text"</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.read()</span><br><span class="line">    f.write(<span class="string">"test"</span>)</span><br></pre></td></tr></tbody></table></figure><p>💡 <strong>使用with语句打开文件是最推荐的方式</strong>, 原因见<a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html" target="_blank" rel="noopener">这里</a></p><p>下表是open时要指定的读写模式的比较.</p><table><thead><tr><th>读写模式</th><th>是否可读</th><th>是否可写</th><th>文件指针位置</th><th>作用</th></tr></thead><tbody><tr><td>r</td><td>是</td><td>否</td><td>文件开头</td><td>读取文件, 如果文件不存在则报错</td></tr><tr><td>r+</td><td>是</td><td>是</td><td>文件开头</td><td>读取并写入文件, 如果文件不存在则报错</td></tr><tr><td>w</td><td>否</td><td>是</td><td>文件开头</td><td>覆写原文件, 如果文件不存在则创建</td></tr><tr><td>w+</td><td>是</td><td>是</td><td>文件开头</td><td>读取并覆盖写原内容, 如果文件不存在则创建</td></tr><tr><td>a</td><td>否</td><td>是</td><td>文件末尾</td><td>追加文件内容, 如果文件不存在则报错</td></tr><tr><td>a+</td><td>是</td><td>是</td><td>文件末尾</td><td>追加文件内容并且可读, 如果文件不存在则报错</td></tr></tbody></table><p>另外还有<code>b</code>模式, 以二进制打开, 允许我们对二进制文件进行编辑, <code>b</code>可以与其他模式组合使用, 比如<code>rb</code></p><p>🔗 <a href="https://www.cnblogs.com/nulige/p/6128948.html" target="_blank" rel="noopener">python基础-文件读写’r’ 和 ‘rb’区别</a></p><h2 id="脚本和普通程序的区别"><a href="#脚本和普通程序的区别" class="headerlink" title="脚本和普通程序的区别"></a>脚本和普通程序的区别</h2><p>脚本这个词来源于戏剧, 能用于舞台演出的戏剧文本就称为<strong>脚本</strong>. 在编程中的脚本是解释执行的程序, 通常只用来做简单的处理, 做自动化处理</p><h2 id="解释器的使用技巧"><a href="#解释器的使用技巧" class="headerlink" title="解释器的使用技巧"></a>解释器的使用技巧</h2><p>在解释器中交互式编程时要注意缩进不要错</p><h3 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h3><p>python解释器本身没有清屏命令, 只能通过调用命令行的清屏命令来达到效果</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># Windows下</span></span><br><span class="line">os.system(<span class="string">'cls'</span>)</span><br><span class="line"><span class="comment"># Linux下</span></span><br><span class="line">os.system(<span class="string">'clear'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>我推荐遵从<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a>. 当然一行一行看完这个规范不是一件令人愉快的事, 最简单的时刻遵守PEP8的方式是在代码工具里安一个<strong>代码风格检查器</strong> (linter).检查你的代码是否符合PEP8的linter是<a href="http://pycodestyle.pycqa.org/en/latest/intro.html" target="_blank" rel="noopener">pycodestyle</a></p><p>💡 在VSC中可以在设置中搜索<strong>python.linting.pycodestyle</strong>, 勾选<strong>Pycodestyle Enabled</strong>, 这样在VSC中编写Python代码时使用的linter就是pycodestyle啦</p><p><img src="Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1571142193232.png" alt="1571142193232"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子带学弟学妹们入门Python时自己整理的一些觉得初学者需要知道的Python知识. 我本身既不是计算机专业的也说不出自己对Python还是挺了解的这样的话, 说实话心里还是有一点忐忑. 如有错误欢迎指出🙇&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Python" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux终端呈现彩色输出</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/12/Linux%E7%BB%88%E7%AB%AF%E5%91%88%E7%8E%B0%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/</id>
    <published>2019-09-11T18:35:48.000Z</published>
    <updated>2020-03-20T15:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: <strong>让特定类型的输出显示为特定的颜色</strong>!</p><a id="more"></a><p>比如这样:</p><p style="color:purple">[MESSAGE] Turning left</p><p style="color:yellow">[DEBUG] target: 4</p><p style="color:red">[Error] target not found</p><p style="color:purple">[MESSAGE] Turning left</p><p style="color:purple">[MESSAGE] Diving</p><p style="color:green">[INFO] depth: 9m</p><p style="color:purple">[MESSAGE] Diving</p><p style="color:green">[INFO] depth: 10m</p><p style="color:purple">[MESSAGE] Forward</p><p style="color:purple">[MESSAGE] Turing right</p><p>能极大的增强终端信息的可读性!😆</p><p>这应该是Linux终端的特性, (我并不清楚是否兼容Windows命令行), shell, python, C++的彩色文字语法几乎是一样的.</p><h2 id="颜色表"><a href="#颜色表" class="headerlink" title="颜色表"></a>颜色表</h2><table><thead><tr><th>前景色 (字体颜色) 代码</th><th>背景色代码</th><th>颜色</th></tr></thead><tbody><tr><td>30</td><td>40</td><td>黑色</td></tr><tr><td>31</td><td>41</td><td>紅色</td></tr><tr><td>32</td><td>42</td><td>綠色</td></tr><tr><td>33</td><td>43</td><td>黃色</td></tr><tr><td>34</td><td>44</td><td>藍色</td></tr><tr><td>35</td><td>45</td><td>紫紅色</td></tr><tr><td>36</td><td>46</td><td>青藍色</td></tr><tr><td>37</td><td>47</td><td>白色</td></tr></tbody></table><h2 id="字体效果表"><a href="#字体效果表" class="headerlink" title="字体效果表"></a>字体效果表</h2><table><thead><tr><th>代码</th><th>效果</th></tr></thead><tbody><tr><td>0</td><td>默认</td></tr><tr><td>1</td><td>高亮(加粗)</td></tr><tr><td>4</td><td>下划线</td></tr><tr><td>5</td><td>闪烁</td></tr><tr><td>7</td><td>反色</td></tr><tr><td>8</td><td>不可见</td></tr></tbody></table><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h3><p>举例:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "\e[31;43;1mError\!\e[0m"</span><br></pre></td></tr></tbody></table></figure><p>💡 如果上面这条命令不是彩色的, 执行<code>echo -e "\e[31;43;1mError\!\e[0m"</code></p><p>运行上面这条命令会输出一个黄底红色粗体字的”Error!”. 前景色, 背景色和字体效果的代码没有先后顺序之分. 建议每个<code>\e[a;b;c</code>都接一个<code>\e[0m</code>将字体效果恢复默认, 不然后续输出还是带特殊效果的.</p><h3 id="python语法"><a href="#python语法" class="headerlink" title="python语法"></a>python语法</h3><p>在<code>print()</code>中使用的示例:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"\033[31;43;1mError!\033[0m"</span>)</span><br></pre></td></tr></tbody></table></figure><p>或者可以通过python执行shell命令:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">'echo "\e[31;43;1mError!\e[0m"'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h3><p>在C++中使用的语法和在python中是一样的:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">cout</span> &lt;&lt; <span class="string">"\033[31;43;1m"</span> &lt;&lt; <span class="string">"Error!"</span> &lt;&lt; <span class="string">"\033[0m"</span> &lt;&lt; <span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><p>一个小技巧是可以单独写一个<code>color_print.h</code>, 内容示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RESET   <span class="meta-string">"\033[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK   <span class="meta-string">"\033[30m"</span>      <span class="comment">/* Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED     <span class="meta-string">"\033[31m"</span>      <span class="comment">/* Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN   <span class="meta-string">"\033[32m"</span>      <span class="comment">/* Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YELLOW  <span class="meta-string">"\033[33m"</span>      <span class="comment">/* Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE    <span class="meta-string">"\033[34m"</span>      <span class="comment">/* Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGENTA <span class="meta-string">"\033[35m"</span>      <span class="comment">/* Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYAN    <span class="meta-string">"\033[36m"</span>      <span class="comment">/* Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE   <span class="meta-string">"\033[37m"</span>      <span class="comment">/* White */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLACK   <span class="meta-string">"\033[1m\033[30m"</span>      <span class="comment">/* Bold Black */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDRED     <span class="meta-string">"\033[1m\033[31m"</span>      <span class="comment">/* Bold Red */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDGREEN   <span class="meta-string">"\033[1m\033[32m"</span>      <span class="comment">/* Bold Green */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDYELLOW  <span class="meta-string">"\033[1m\033[33m"</span>      <span class="comment">/* Bold Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDBLUE    <span class="meta-string">"\033[1m\033[34m"</span>      <span class="comment">/* Bold Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDMAGENTA <span class="meta-string">"\033[1m\033[35m"</span>      <span class="comment">/* Bold Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDCYAN    <span class="meta-string">"\033[1m\033[36m"</span>      <span class="comment">/* Bold Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOLDWHITE   <span class="meta-string">"\033[1m\033[37m"</span>      <span class="comment">/* Bold White */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> print(color, context) std::cout &lt;&lt; color &lt;&lt; context &lt;&lt; RESET &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>然后在要显示彩色输出的cpp文件中引用这个头文件, 打印语句示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(BOLDRED, <span class="string">"Error!"</span>);</span><br></pre></td></tr></tbody></table></figure><p>因为是宏替换因此<code>context</code>字段其实可以随意填, 比如有一个变量<code>depth</code>, 用下面语句来打印深度是可以的:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(BOLDGREEN, <span class="string">"depth: "</span> &lt;&lt; depth &lt;&lt; <span class="string">"m"</span>)</span><br></pre></td></tr></tbody></table></figure><p>超好用!😆</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写的程序会在终端给出大量输出, 如果都是黑底白字那这一大堆字刷刷刷往上冒一会就能把人看眼晕, 但我发现了一个很实用而简单的技巧: &lt;strong&gt;让特定类型的输出显示为特定的颜色&lt;/strong&gt;!&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="操作系统， Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C-Linux/"/>
    
      <category term="调试" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%B0%83%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>我将Shell换为了zsh</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/09/02/%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/09/02/%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/</id>
    <published>2019-09-02T01:22:25.000Z</published>
    <updated>2019-10-02T18:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我把shell从<strong>bash</strong>换到<strong>zsh</strong>了. 原本我是根本没动过换shell的念头的, 但因为这段时间用的笔记本被别人装好了zsh, 我就将就着用了, 谁知真香…</p><a id="more"></a><p>不得不说zsh比bash确实好了许多:</p><ul><li>补全智能了太多! 比如切换路径时的补全不必区分大小写, 比如会根据历史命令给出建议, 比如如果命令里有<code>$(pwd)</code>这样的取值操作, 按一下<kbd>Tab</kbd>zsh会将其补全为对应的值.</li><li>支持一次输入多行命令再执行. 不像bash只能一行一行运行, 如果其中有命令是需要输入确认的, 那么下一条命令就会被当做这条命令的确认用输入中, 然后就会报错 🤷</li><li>Powerlevel9k这个主题很好看很强大, 能显示出包括<strong>git状态</strong>, <strong>当前Python环境</strong>,<strong>命令执行时间</strong>, <strong>后台任务数量</strong>, <strong>当前时间</strong>在内的许多有用信息</li><li>zsh有许多很有用的插件</li></ul><p>总之我要到zsh去了, bash再见👋</p><p>下面是部分功能的展示</p><p><img src="%E6%88%91%E5%B0%86shell%E6%8D%A2%E4%B8%BA%E4%BA%86zsh/screencast.gif" alt=""></p><p>下面我大致说一下我的zsh配置</p><ul><li>zsh配置管理工具: <a href="https://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh</a></li><li>zsh插件管理工具: <a href="https://github.com/zsh-users/antigen" target="_blank" rel="noopener">Antigen</a></li><li>zsh主题: <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener">Nerd-Fonts</a>字体(具体来说是<a href="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/DejaVuSansMono" target="_blank" rel="noopener">DejaVuSansMono Nerd</a>)的<a href="https://github.com/Powerlevel9k/powerlevel9k" target="_blank" rel="noopener">Powerlevel9k</a>主题</li></ul><p>以下是我的<code>~/.zshrc</code>中部分代码.</p><p>有关Powerlevel9k:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POWERLEVEL9K_MODE='nerdfont-complete'</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND="black"</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND="blue"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON="echo   $(whoami) "</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_BACKGROUND="purple"</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_FOREGROUND="white"</span><br><span class="line">POWERLEVEL9K_ANACONDA_BACKGROUND="chartreuse3"</span><br><span class="line">POWERLEVEL9K_ANACONDA_LEFT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER=""</span><br><span class="line">POWERLEVEL9K_DIR_HOME_BACKGROUND='123'</span><br><span class="line">POWERLEVEL9K_DIR_HOME_SUBFOLDER_BACKGROUND='123'</span><br><span class="line"><span class="meta">#</span><span class="bash"> POWERLEVEL9K_DIR_ETC_BACKGROUND=<span class="string">'123'</span></span></span><br><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(custom_os_icon ssh anaconda root_indicator dir dir_writable vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(command_execution_time status background_jobs time)</span><br><span class="line">ZSH_THEME="powerlevel9k/powerlevel9k"</span><br></pre></td></tr></tbody></table></figure><p>有关zsh插件:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Which plugins would you like to load?</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Standard plugins can be found <span class="keyword">in</span> ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">source ~/Desktop/backup/zsh/antigen.zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the oh-my-zsh<span class="string">'s library.</span></span></span><br><span class="line">antigen use oh-my-zsh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Bundles from the default repo (robbyrussell<span class="string">'s oh-my-zsh).</span></span></span><br><span class="line">antigen bundle git</span><br><span class="line">antigen bundle pip</span><br><span class="line">antigen bundle command-not-found</span><br><span class="line"><span class="meta">#</span><span class="bash"> custom plugins</span></span><br><span class="line">antigen bundle zsh-users/zsh-syntax-highlighting</span><br><span class="line">antigen bundle zsh-users/zsh-autosuggestions</span><br><span class="line">antigen bundle sobolevn/wakatime-zsh-plugin</span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the theme.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> antigen theme powerlevel9k/powerlevel9k</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell Antigen that you<span class="string">'re done.</span></span></span><br><span class="line">antigen apply</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我把shell从&lt;strong&gt;bash&lt;/strong&gt;换到&lt;strong&gt;zsh&lt;/strong&gt;了. 原本我是根本没动过换shell的念头的, 但因为这段时间用的笔记本被别人装好了zsh, 我就将就着用了, 谁知真香…&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件配置" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    
      <category term="操作系统" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/11/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-08-11T03:25:19.000Z</published>
    <updated>2020-03-16T16:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>… 前几天刚说最近没有用C的需求我就开始要写C++了 🤦</p><p>TODO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;… 前几天刚说最近没有用C的需求我就开始要写C++了 🤦&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
    
      
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C/C++" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>初学Socket通信</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/07/%E5%88%9D%E5%AD%A6socket%E9%80%9A%E4%BF%A1/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/07/%E5%88%9D%E5%AD%A6socket%E9%80%9A%E4%BF%A1/</id>
    <published>2019-08-07T08:14:26.000Z</published>
    <updated>2019-08-07T08:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>记大二暑假北航实习</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/05/%E8%AE%B0%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E5%8C%97%E8%88%AA%E5%AE%9E%E4%B9%A0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/05/%E8%AE%B0%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E5%8C%97%E8%88%AA%E5%AE%9E%E4%B9%A0/</id>
    <published>2019-08-05T14:25:46.000Z</published>
    <updated>2019-10-08T03:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个暑假我来到了北航<a href="http://softrobotics.buaa.edu.cn/peoples/peoples_ch/index.htm" target="_blank" rel="noopener">仿生软体机器人实验室</a>学习, 收获颇多.结实了一群有趣的人, 得到了一些答案, 看到了更明确的方向, 坚定了我研究软体机器人的信念💪</p><a id="more"></a><p>如今我愈发觉得玄幻小说里一种很玄的情节其实很现实: <strong>历练总是能有些机缘!</strong></p><p>有些事情在事前真的无法预测, 比如在我这次前往北京学习一个半月之前, 我是完全想不到我能有什么收获的, 而最终的收获多到一两句说不清. <strong>如果在家仔细思考, 总会觉得一个半月那样短, 去了又能怎样?</strong> 再引用一句玄幻小说里的话:</p><blockquote><p>我辈修士, 当与天争命!</p></blockquote><p>事实证明, 只要自己主动抓住各种机会一个半月并不那样短暂.</p><p>这一个半月我干了许多事: 我浇筑了一套软体臂, 软体爪, 我试着帮实验室的学长解决实验面临的困难, 我每天站着巨久调试了半个月机器人, 我随实验室的队伍到大连参加了一个难度很高的比赛, 我在大连每天白嫖各种海鲜, 我和在中科院中关村学生公寓的室友相处不错还一块深夜吃了烧烤, 我给好几人上了家教课, 我经常和在北京的亲属玩,我, 我试图减肥并失败🤦‍</p><h2 id="关于学习收获"><a href="#关于学习收获" class="headerlink" title="关于学习收获"></a>关于学习收获</h2><h3 id="在实验室的体会"><a href="#在实验室的体会" class="headerlink" title="在实验室的体会"></a>在实验室的体会</h3><p>实际上在前往文老师的实验室前我并没有真正接触到软体机器人: 只能自己看看资料算什么? 但我也很无奈啊, 想做的实验材料就动辄几千, 而花销小的实验一般是真-实验室阶段,我一时半会研究不出什么名堂. 更何况我在电子科大并没有找到相关团队. 而到文老师实验室这段时间我不仅是更正了一些对软体机器人的理解, 更是对科研有了一些概念.</p><p>很幸运的是实验室所有人人都很好, 我很快就融入其中, 也有幸和几位学长探讨了他们的工作. 谢博士的废寝忘食令我记忆犹新. 好几次谢博因为想解决问题而晚去吃饭. 谢博也很虚心, 因为并不是电气专业出身, 实验遇到电气方面问题还拉我一起研究. 辉哥则和我聊了很多过来人的经验, 他建议说在国外科研更加自由, 能支持更基础的研究方向, 杂事更少, 老师和学生的关系更像合作伙伴, 而最后如果能留在国外就不用按国内五年一个职位的累死累活竞争等等. 结对调试机器人的同样来自四川的陈学长则和我分享了许多学习经验, 在我看来他的学习经历实在是一次逆袭. 而见到文老师前我同样没想到是这样一位爱夸人的总是在笑的老师. 这一个半月我更多的时间是和刘学长在一起, 他也教了我很多, 比如如何浇筑(我一个学电气的是完全没做过这种事的), 而来实验室前的许多疑问我也从他那得到了解答.</p><p>亲身站在实验室里我更直观的体会到了软体机器人是怎样的一个领域. 虽然刘学长觉得软体机器人现在发展趋势缓下来了, 但我觉得这个领域仍在萌芽阶段. 从我了解到的成果和在实验室近距离看学长们的工作来看, 除了软体抓手现在已经商业化了其他成果仍离走出实验室差很远, 有些甚至只是证明了一些结构的潜力, 说白了目前基本是空架子. 就比如实验室花了好几万买的液态金属打印机, 不光墨水贵, 还经常不出墨, 出墨也不够理想, 和谢博一起做实验的袁学长说某些方面甚至可能比不上以前手工浇筑的效果. 不过最近清华大学刚研发出了类似喷墨打印机原理的液态金属打印方式, 看论文效果很不错, 期待能尽早推出产品.目前的成果之所以离投入应用还远一方面是因为目前的软体机器人因为使用的驱动方式, 能提供的驱动力普遍很小, 基本没有应用场景, 另一方面是因为目前软体机器人的控制基本是黑暗一片, 就算是一段较早出现的软体臂也没有一个称得上很好的闭环控制方法. 而针对非结构性环境的软体机器人如果连闭环都做不到还有何用? 虽然目前也有好几项人来控制, 机器人负责在人类很难触及的环境 (比如人体内, 十分狭窄的缝隙, 20m深的海底) 执行的成果, 但我认为自主始终是趋势.</p><p>另外一点在实验室学到的, 觉得很有意思的是如何记<strong>组会记录</strong>. 首先记肯定是要记的,不然如果讨论的不是自己在参与的项目时岂不是在浪费时间? 我认为组会本就是集思广益大家相互交流经验的地方 (这点在我们组里也很明显, 每个人讲完自己的项目进度后老师会问大家的看法和建议), 因此如果在组会中只注意讲好自己的项目就本末倒置了. 记组会记录一方面帮助自己整理思路, 看看能给正在讲的同学什么帮助, 另一方面讲大家的经验记录下来,这样以后自己遇到类似问题就能有突破口, 另外老师有时候也会给一些写论文方面的指导,也值得记录. 我觉得记组会记录最好用OneNote这种手写的电子档, 自由度高, 适合写写画画整理思路, 电子档也更利于保存.</p><h3 id="对C-的体会"><a href="#对C-的体会" class="headerlink" title="对C++的体会"></a>对C++的体会</h3><p>再有就是我学习C++的速度还是令我觉得值得表扬的😆 实际上在这个暑假之前我是不会C++的,顶多是大一上的时候学了最基础的C. 我是这个暑假开始时从学长那里继承了本紫色的**算法竞赛入门经典<strong>巩固了下C语言, 了解了一些C++. 而到了实验室先是照着网上的模板写了个C++的TCP server, 然后和中科院的学长一起负责ROV的控制代码 (纯C++). 说实话一方面是大一上扎实的C基础帮了大忙 (我明明每一科都能很好地应用可我就是考不好真的好气), 另一方面则是我浏览器程序员的特长: 上网查资料发挥了巨大作用😁 这真的是现学现卖.好在学长把核心代码都写好了, 我就写了写语法很简单的控制流程什么的. 期间也因为不熟悉C++遇到了很多奇葩问题, 比如就因为在</strong>多线程C++程序**中用错了计时函数导致了计时不准, 程序崩溃等各种迷之错误… 反正一波C++速成后我对C++的印象极差, 标准库很落后, 坑很多, 语法很啰嗦 (和我最爱的Python比), 环境配置也比Python开发麻烦等等…</p><p>以后我自己写程序用到C/C++顶多是要求算力部分用C/C++来加速, 或者用到的工具只有C/C++接口时.其他部分全部用Python糊!</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后想发表一番感慨: 虽然这只是我的大二暑假, 但实际上我在高三暑假就决定了以后研究机器人, 为此学习了许多, 做着各种各样的准备. 比如我学习了Python, 也针对机器人中很常用到的机器学习和CV分别做了一个小项目 (<a href="https://github.com/LeoJhonSong/SVM-Learning-Sample" target="_blank" rel="noopener">我的机器学习小项目</a>, <a href="https://github.com/LeoJhonSong/Fingertip-Drawboard" target="_blank" rel="noopener">我的CV小项目</a>)来学习了解, 比如我查阅了许多软体机器人的文献, 也曾自己试着<a href="https://leojhonsong.github.io/zh-CN/2018/12/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Win10%E4%B8%8B%E5%AE%89%E8%A3%85SOFA%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E5%B9%B6%E5%8A%A0%E8%A3%85SoftRobots%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BB%8F%E5%8E%86/">用仿真软件仿真软体机器人</a>,以及即便曾经的我<a href="https://leojhonsong.github.io/zh-CN/2019/05/17/为什么我用Linux而不是Windows/">曾找各种理由来说服自己用Linux</a> (当然后来就离不开Linux了)… 总之我曾努力学习过的东西都确实地派上了用场, 我感到自己的努力没有白费💪 我会再接再厉!</p><h2 id="关于家教"><a href="#关于家教" class="headerlink" title="关于家教"></a>关于家教</h2><p>另外我在北京这段时间在一个叫<strong>易教网</strong>的平台接了几份家教的工作. 经过了这一段时间的体验我觉得当家教是一件既有趣又促进自己学习还赚钱的事.</p><h2 id="关于北京"><a href="#关于北京" class="headerlink" title="关于北京"></a>关于北京</h2><p>第一次在北京待一个半月, 见识到了首都的另一面. 以前我是个京黑, 这次在北京的体验改变了我的印象, 让我变成了真*京黑😁 是的印象一点也没有变好! 或者说见到了好的一面,但也加深了负面印象.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个暑假我来到了北航&lt;a href=&quot;http://softrobotics.buaa.edu.cn/peoples/peoples_ch/index.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仿生软体机器人实验室&lt;/a&gt;学习, 收获颇多.
结实了一群有趣的人, 得到了一些答案, 看到了更明确的方向, 坚定了我研究软体机器人的信念💪&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://leojhonsong.github.io/zh-CN/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>MATLAB杂记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/08/05/MATLAB%E6%9D%82%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/08/05/MATLAB%E6%9D%82%E8%AE%B0/</id>
    <published>2019-08-05T14:25:20.000Z</published>
    <updated>2020-03-16T16:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>再开学的课程就要用MATLAB了, 而且了解很多机械系唯一要求学的编程语言就是MATLAB, 我决定还是稍微了解下.</p><a id="more"></a><p>首先, <a href="https://www.zhihu.com/question/37824202/answer/767114071" target="_blank" rel="noopener">MATLAB到底是不是编程语言?</a></p><p>从<strong>TIOBE</strong>上有MATLAB而且MATLAB排名还不低可以看出MATLAB确实是一门编程语言, 但从上面链接可以看出MATLAB算是<strong>残疾</strong>的编程语言, 很多特性没有, 更多的是<strong>用来验证算法可行性</strong>.但我又想验证算法可行性为啥不用Python什么的, 语法也不麻烦呀? 然后我发现原本用<strong>Octave</strong>教深度学习的吴恩达现在改用<strong>Python</strong>了 😁</p><p>💡 (这条是后来补的) 但其实随着使用我发现在<strong>矩阵计算方面</strong>MATLAB的语法还是比python简单很多.</p><p>因此我觉得MATLAB的优势主要就在:</p><ul><li>语法简单, 没有编程基础的工科生也能快速掌握, 尤其计算方面的语法比Python简单太多</li><li>集成度特别高, 各种工具都能轻松快速配置好</li><li>能和多种语言交互, 编写界面简单</li><li>很多工具都有图形界面, 操作简单, 按按键就可以, 不用写那么多代码.</li></ul><p>总而言之, 虽然缺点多多, MATLAB还是很值得一学的</p><h1 id="MATLAB软件个性化设置"><a href="#MATLAB软件个性化设置" class="headerlink" title="MATLAB软件个性化设置"></a>MATLAB软件个性化设置</h1><h2 id="设置初始工作文件夹"><a href="#设置初始工作文件夹" class="headerlink" title="设置初始工作文件夹"></a>设置初始工作文件夹</h2><p>使用HOME目录作为起始工作文件夹我觉得不是什么好事, 所以最好自己指定一个合适的目录. 我使用的是MATLAB默认的<code>userpath</code>, 即<strong>Documents/MATLAB</strong>文件夹. 一方面这个文件夹看着比较合理, 一方面MATLAB说<a href="https://ww2.mathworks.cn/help/matlab/matlab_env/matlab-startup-folder.html#bujzf43" target="_blank" rel="noopener">使用userpath作为初始工作文件夹有一定好处</a>.</p><p>Linux下设置MATLAB的初始工作文件夹方法和在Windows下改快捷方式的起始位置这种方法不一样, 要达到这个目的有两种方式:</p><ol><li>在终端输入 <code>matlab -useStartupFolderPref</code> 打开MATLAB. -useStartupFolderPref选项指定初始工作文件夹为在<strong>Preference</strong>中<strong>Initial working folder option</strong>的指定文件夹.</li><li>在终端输入 <code>matlab -sd [folder]</code> 打开MATLAB. -sd选项指定初始工作文件夹为[folder]文件夹.</li></ol><h2 id="更改编辑界面颜色主题"><a href="#更改编辑界面颜色主题" class="headerlink" title="更改编辑界面颜色主题"></a>更改编辑界面颜色主题</h2><p>在vim, VSC, VS, CLION, Pycharm等工具用惯了黑暗主题以后拿到啥都想先换个黑暗主题. 但是找了半天也只找到了设置编辑界面颜色主题的方式, 普通操作似乎并不能自定义丑陋的灰色工具栏.</p><p>最终我把界面变成了这样 👇</p><p><img src="MATLAB%E6%9D%82%E8%AE%B0/appearance.png" alt="界面"></p><ul><li>颜色主题是通过<a href="https://github.com/scottclowe/matlab-schemer" target="_blank" rel="noopener">MATLAB Schemer</a>里的脚本更换的, 一键更换好评👍 因为我比较喜欢糖果色的颜色主题然后又不喜欢注释是灰色 (不管在黑色背景还是白色背景里辨析度都很低), 于是选择的主题是<a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes#dark-steel" target="_blank" rel="noopener">Dark Steel</a>.</li><li>字体用的是<a href="https://github.com/powerline/fonts/tree/master/DejaVuSansMono" target="_blank" rel="noopener">DejaVu Sans Mono for Powerline</a>, 大小是11, 不过不知道为什么MATLAB显示不带效果的字体看着很粗糙, <strong>边缘锯齿状过于明显</strong>, 效果设置为了 <strong>bold</strong>, 这回好多了!</li><li>布局改成了和我常用的vim, VSC差不多的布局: 资源管理器在左上, 细节信息在左下, 编辑窗口在右</li></ul><h1 id="MATLAB语法和工具"><a href="#MATLAB语法和工具" class="headerlink" title="MATLAB语法和工具"></a>MATLAB语法和工具</h1><h2 id="在终端运行"><a href="#在终端运行" class="headerlink" title="在终端运行"></a>在终端运行</h2><p>曾经我因为嫌MATLAB界面太丑又不能个性化想过在终端像用交互式Python一样用交互式MATLAB以及运行脚本. 我发现这是可行的:</p><p>在终端启动交互式MATLAB:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matlab -nojvm</span><br></pre></td></tr></tbody></table></figure><p><code>-nojvm</code>选项本身是<strong>不启动Java虚拟机</strong>的意思, 但因为Matlab的GUI都是用Java写的(听网上说的), 所以也有<code>-nosplash</code> (<strong>不显示启动画面</strong>), <code>-nodesktop</code>(<strong>不启动图形界面</strong>) 的功能. 另外因为没有启动jvm这样启动MATLAB十分迅速.</p><p>💡 要注意用<code>-nojvm</code>选项时会创建图形界面的命令会报错.</p><p>在终端运行MATLAB脚本:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matlab -batch [MATLAB_command]</span><br></pre></td></tr></tbody></table></figure><p><code>-batch</code>选项和<code>-r</code>选项的区别在于前者不会启动图形界面而后者会. 另外如果脚本中没有与图形界面有关的语句同样可以加上<code>-nojvm</code>选项.</p><p><strong>但是啊!</strong></p><p>我后来发现这样就<strong>本末倒置</strong>了! MATLAB的亮点我觉得一是所有变量都是全局变量, 能迅速可视化变量, 工具集成度非常高, 适合迅速验证各种算法, 二是社区非常完善, 提供了很多工具能轻松仿真很多模型.</p><p>因此只在终端的MATLAB是没有灵魂的MATLAB. <strong>如果终端里的MATLAB就能解决你的需求的话为什么不用Python?</strong> 🤤</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再开学的课程就要用MATLAB了, 而且了解很多机械系唯一要求学的编程语言就是MATLAB, 我决定还是稍微了解下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂记" scheme="https://leojhonsong.github.io/zh-CN/categories/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="MATLAB" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/MATLAB/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="https://leojhonsong.github.io/zh-CN/2019/07/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://leojhonsong.github.io/zh-CN/2019/07/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-07-12T08:22:42.000Z</published>
    <updated>2020-03-16T16:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.</p><p>经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了… 虽然我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知新, 再次”速成”一下.</p><a id="more"></a><h1 id="语句与行"><a href="#语句与行" class="headerlink" title="语句与行"></a>语句与行</h1><p>C语言我感觉对格式要求蛮宽松的, 可以一行多个语句 (每个语句必须以<code>;</code>结尾), 也可以跨行写语句(在行末写<code>\</code>折行), 不像python对缩进都有严格要求.</p><p>🌟 代码风格的话我只认<strong>VS风</strong>, 就是Visual Studio格式化出来的样式. 是的我是<strong>大括号换行派</strong>!</p><p>💡 要注意的是预编译指令必须一行不能写多个语句, 但可以折行.</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>有两种方式</p><h2 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a>推荐的方式</h2><p>👇这种注释可以跨行写, 也可以在行内写</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="comment">/*comment*/</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*comment</span></span><br><span class="line"><span class="comment">comment</span></span><br><span class="line"><span class="comment">comment*/</span></span><br></pre></td></tr></tbody></table></figure><p>💡值得一提的是只要出现 <strong>/*</strong> 就会被识别为注释的开始, 如果想把y除z指向的内存的值赋给x写成下面这样是不行的.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y<span class="comment">/*z</span></span><br></pre></td></tr></tbody></table></figure><p>但这个问题也很好解决, 用空格或括号就能解决.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y / *z</span><br><span class="line">x = y/(*z)</span><br></pre></td></tr></tbody></table></figure><h2 id="不推荐的方式"><a href="#不推荐的方式" class="headerlink" title="不推荐的方式"></a>不推荐的方式</h2><p>这样只能单行注释</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code  <span class="comment">// comment</span></span><br></pre></td></tr></tbody></table></figure><p>❗️要注意这种注释方式是借鉴自C++, 在C99中才被标准化, 而目前使用最广泛的是C89标准,也就是说不使用是比较保险的.</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>C语言对内存的操作似乎很多, 也很注重内存管理.</p><p>C语言为内存的分配和管理提供了几个函数. 这些函数可以在 &lt;stdlib.h&gt; 头文件中找到.</p><p><strong>void *malloc(size_t size)</strong> 分配一块<code>size</code>大小的内存</p><p><strong>void *calloc(size_t num, size_t size)</strong> 分配一块储存了一个<code>num</code>长, 每个元素<code>size</code>字节的内存并将所有位初始化为0</p><p><strong>void *realloc(void *ptr, size_t size)</strong> 重新分配内存, 把内存扩展到 newsize</p><p><strong>void free(void *ptr)</strong> 释放<code>ptr</code>所指向的内存</p><p>💡 malloc是memory allocate, realloc是reallocate, calloc不知道是啥.</p><h1 id="段与栈与堆"><a href="#段与栈与堆" class="headerlink" title="段与栈与堆"></a>段与栈与堆</h1><p><strong>段</strong> (segmentation)是指二进制可执行文件内的区域,所有某种特定类型信息被保存在里面.可以用<code>size</code>命令得到可执行文件中各个段的大小. <strong>正文段</strong> (Text Segment)用于储存指令, <strong>数据段</strong> (Data Segment)用于储存已初始化的全局变量, <strong>BSS段</strong> (BSSSegment)用于储存未赋值的全局变量所需的空间.</p><p><strong>调用栈</strong>并不储存在可执行文件中,而是在运行时创建.调用栈所在的段称为堆栈段(StackSegment). 和其他段一样, 堆栈段也有自己的大小, 不能被越界访问, 否则就会出现段错误(Segmentation Fault). 这种情况叫<strong>栈溢出</strong>.</p><p>栈空间有多大和操作系统相关. 在Linux中, 栈大小是由系统命令<code>ulimit</code>指定的, 例如<code>ulimit -a</code>显示当前栈大小, 而<code>ulimit -s 32768</code>将把栈大小指定为32MB. 但在Windows中, 栈大小是储存在可执行文件中的. 使用gcc可以这样指定可执行文件的栈大小: <code>gcc-Wl,--stack=16777216</code>, 这样栈大小就变为16MB</p><p>💡 栈溢出不一定是递归调用过多导致的, 也可能是局部变量太大. 因此<strong>较大的数组建议储存为全局变量</strong>.</p><p><strong>栈</strong>是由编译器在需要时分配的, 不需要时自动清除的变量存储区. 里面的变量通常是局部变量, 函数参数等. <strong>堆</strong>是由<code>malloc()</code>函数分配的内存块,内存释放由程序员手动控制, 在C语言由<code>free()</code>完成.</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>较大的数组时应在main函数之外声明.</p><p><code>memset(a, 0, sizeof(a))</code>能方便地把数组a清零,它在<strong>string.h</strong>中定义.</p><p>用strcpy(a, b), strcmp(a, b), strcat(a, b)来执行“赋值”、“比较”和“连接”操作, 在<strong>string.h</strong>中定义</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言中的字符串是以“\0”结尾的字符数组</p><p>不同操作系统的回车换行符是不一致的. Windows是“\r”和“\n”两个字符,Linux是“\n”,而MacOS是“\r”. 如果在Windows下读取Windows文件, fgetc和getchar会把“\r””吃掉”, 只剩下“\n”; 但如果要在Linux下读取同样一个文件, 它们会忠实地先读取“\r”, 然后才是“\n”.</p><p>很有意思的一个小问题: “5”, ‘5’ 和 5 有什么区别?<br>“5”是一个字符串, ‘5’是一个字符常量, 5是一个数字常量</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>用int* a声明的变量a是指向int型变量的指针. 赋值a = &amp;b的含义是把变量b的地址存放在指针a中, 表达式<em>a代表a指向的变量, 既可以放在赋值符号的左边(左值), 也可以放在右边(右值) 注意: <em>a是指“a指向的变量”, 而不仅是“a指向的变量所拥有的值”. 理解这一点相当重要. 例如, *a = *a + 1就是让a指向的变量自增1. 甚至可以把它写成(</em>a)++. 注意不要写成<em>a++, 因为<code>++</code>运算符的优先级高于取内容运算符 `</em>`, 实际上会被解释成</em>(a++).</p><h2 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h2><ul><li>一个指针变量加/减一个整数是将该指针变量的原值(是一个地址)和它指向的变量所占用的内存单元字节数相加或相减.</li><li>两个指针变量间可以做减法, 但前提是这两个指针是指向同一个数组的元素. 两指针变量差是两个指针之间的元素个数</li><li>如果两指针变量指向同一数组的元素, 他们可以进行比较运算. 另外所有指针都可以和NULL进行相等/不想等比较.</li></ul><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></tbody></table></figure><p>宏名一般为大写, 以下划线连接单词.</p><p>看了网上资料我感觉在C中宏定义主要是以下作用</p><h3 id="增加代码抽象性"><a href="#增加代码抽象性" class="headerlink" title="增加代码抽象性"></a>增加代码抽象性</h3><p>用宏定义替代magic number, 或者嵌入式中一些寄存器的位操作, 一方面增强代码可读性(不像魔数让人不明所以, 而寄存器的位操作也很不直观), 一方面增强代码可移植性 (比如从一种单片机移植到另一种单片机, 只需更改宏定义即可)</p><h3 id="防止重复定义"><a href="#防止重复定义" class="headerlink" title="防止重复定义"></a>防止重复定义</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXXX</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>在头文件里用这样的语句来防止头文件被重复引用. 有一些头文件被重复引用会增加编译器工作, 降低编译效率, 而有一些头文件被重复引用会引起冲突 (比如如果头文件里定义了全局变量, 会发生重复定义错误).</p><h3 id="控制代码编译"><a href="#控制代码编译" class="headerlink" title="控制代码编译"></a>控制代码编译</h3><p>通过Makefile控制编译选项.</p><p>还能像轮子哥<a href="https://www.zhihu.com/question/22608939/answer/21963056" target="_blank" rel="noopener">这样</a>当模板用.</p><p>❗️虽然宏定义的好处不少, 但除了以上情况尽量少用尽量不用宏定义, 因为这会让开发者看到的代码与编译器看到的代码不同, 容易导致想不到的问题.</p><h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><p>调试时重点关注两方面: <strong>当前行的跳转</strong>, <strong>变量的变化</strong></p><p>循环结构程序设计中最常见的两个问题: <strong>算术运算溢出</strong>, <strong>程序效率低下</strong></p><p>变量在未赋值之前的值是不确定的.</p><h1 id="gcc与gdb命令简记"><a href="#gcc与gdb命令简记" class="headerlink" title="gcc与gdb命令简记"></a>gcc与gdb命令简记</h1><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>常用选项:</p><table><thead><tr><th>name_of_option</th><th>我猜的全名</th><th>含义</th></tr></thead><tbody><tr><td>-o [filename]</td><td>output</td><td>指定输出文件名</td></tr><tr><td>-g</td><td>gdb</td><td>生成调试用的符号表</td></tr><tr><td>-Wall</td><td>warning all</td><td>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros.</td></tr><tr><td>-lm</td><td>link math.h</td><td>链接math.h. C++编译器会自动链接, 但C的代码使用了math.h却不启动这个选项很可能出错</td></tr><tr><td>-ansi</td><td>ANSI</td><td>检查代码是否符合ANSI标准 (常与-Wpedantic连用)</td></tr><tr><td>-Wpedantic</td><td>warning pedantic</td><td>Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any -std option used.</td></tr><tr><td>-O1, -O2, -O3</td><td>optimize</td><td>开启速度优化. 开启后编译出的程序比直接编译出的程序快, -O2比-O1快, -O3比-O2快, 但为了避免优化误解代码含义, 在算法比赛中推荐-O2. 当然如果程序十分规范就没有这种担心.</td></tr><tr><td>-DXX</td><td>define XX</td><td>在编译时定义XX符号 (此处XX是随意什么大写单词的意思), 位于#ifdef XX和#endif中间的语句会被编译</td></tr></tbody></table><h3 id="gcc与g"><a href="#gcc与g" class="headerlink" title="gcc与g++"></a>gcc与g++</h3><p><code>gcc</code>到底能不能编译C++程序?</p><p>在某种程度上<code>gcc</code>和<code>g++</code>都可以编译 <strong>.cpp</strong> 后缀的程序, 但是<code>gcc</code>命令不能自动和C++程序使用的库链接. <code>gcc</code>把后缀为 <strong>.c</strong> 的当作是C程序,而<code>g++</code>将其当作C++程序.两者都会将后缀为 <strong>.cpp</strong> 的程序视作C++程序, 要注意虽然C++是C的超集,但是两者对语法的要求是有区别的, C++的语法规则更加严谨一些. 编译阶段, <code>g++</code>会调用<code>gcc</code>,因为<code>gcc</code>命令不能自动链接C＋＋库, 所以通常用<code>g++</code>来完成链接, 统一起见,干脆编译和链接统统用g++了, 这就给人一种错觉, 好像cpp程序只能用g++似的.</p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>💡执行gdb时加选项<code>-q</code> (quiet)可以去掉进入gdb开头的废话.</p><p>常用命令:</p><table><thead><tr><th>命令</th><th>全名</th><th>含义</th></tr></thead><tbody><tr><td>l</td><td>list</td><td>列出十行代码. 但可以通过<code>set listsize</code>来更改显示多少行, 用<code>show listsize</code>能查看listsize. l后可以接行号, 函数名</td></tr><tr><td>r</td><td>run</td><td>开始运行程序</td></tr><tr><td>b</td><td>break</td><td>设置断点, b后接行号或函数名</td></tr><tr><td>c</td><td>continue</td><td>继续运行. 要注意在断点处停下后用c继续而不是r</td></tr><tr><td>n</td><td>next</td><td>下一行</td></tr><tr><td>s</td><td>step</td><td>与n的区别是n会执行完本行语句, 而有函数调用时s会停在函数内</td></tr><tr><td>u</td><td>until</td><td>执行到指定行号或者指定函数的开头</td></tr><tr><td>i</td><td>info</td><td>显示各种信息. 如i b显示所有断点,i disp显示display,而i lo显示所有局部变量</td></tr><tr><td>disp</td><td>display</td><td>把一个表达式设置为display, 当程序每次停下来时都会显示其值</td></tr><tr><td>cl</td><td>clear</td><td>取消断点, 和b的格式相同. 如果该位置有多个断点, 将同时取消</td></tr><tr><td>cond</td><td>condition</td><td>用来设置条件断点</td></tr><tr><td>ig</td><td>ignore</td><td>设置记次断点, count次以前不停止</td></tr><tr><td>wa</td><td>watch point</td><td>watch a(简写为wa a)可以在变量a修改时停下,并显示出修改前后的变量值</td></tr><tr><td>aw</td><td>all watch point</td><td>读写时都停下</td></tr><tr><td>rw</td><td>read watch point</td><td>被读取时停下</td></tr><tr><td>q</td><td>quit</td><td>退出gdb</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇是学习笔记, 因为我决定最近专门重新学习一下C语言.&lt;/p&gt;
&lt;p&gt;经常有人说自己入门C语言时觉得C语言很简单, 不到一个月就能入门, 但用久了会觉得C语言很难, 觉得自己还没有入门. 而我现在觉得当时速成的C语言已经全部不记得了… 虽然我目前并没有使用C的需求, 但总是看到各种C系代码, 一直头疼也不是办法, 不如温故而知新, 再次”速成”一下.&lt;/p&gt;
    
    </summary>
    
    
      <category term="语言" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C/C++" scheme="https://leojhonsong.github.io/zh-CN/categories/%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
  </entry>
  
</feed>
